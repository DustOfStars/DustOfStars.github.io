<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" integrity="sha256-jTIdiMuX/e3DGJUGwl3pKSxuc6YOuqtJYkM0bGQESA4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.10.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="SV Verilog对比， 数据类型、自定义类型、字符串类型、接口等">
<meta property="og:type" content="article">
<meta property="og:title" content="路科V0SV和Verilog的对比总结">
<meta property="og:url" content="http://example.com/2022/05/10/55/index.html">
<meta property="og:site_name" content="DustOfStars">
<meta property="og:description" content="SV Verilog对比， 数据类型、自定义类型、字符串类型、接口等">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/05/10/55/%E8%B7%AF%E7%A7%91.png">
<meta property="article:published_time" content="2022-05-10T13:05:55.000Z">
<meta property="article:modified_time" content="2022-05-10T13:05:55.000Z">
<meta property="article:author" content="Jia">
<meta property="article:tag" content="UVM">
<meta property="article:tag" content="System Verilog">
<meta property="article:tag" content="IC验证">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/05/10/55/%E8%B7%AF%E7%A7%91.png">


<link rel="canonical" href="http://example.com/2022/05/10/55/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2022/05/10/55/","path":"2022/05/10/55/","title":"路科V0SV和Verilog的对比总结"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>路科V0SV和Verilog的对比总结 | DustOfStars</title>
  




<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/love.js"></script>
<!-- 文章加密 -->
<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">DustOfStars</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">--jxw</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-github"><a href="https://github.com/DustOfStars" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>Github</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Verilog%EF%BC%9A"><span class="nav-number">1.</span> <span class="nav-text">Verilog：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B-veriables"><span class="nav-number">1.1.</span> <span class="nav-text">变量类型 veriables</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9B%E5%80%BC%E9%80%BB%E8%BE%91"><span class="nav-number">1.1.1.</span> <span class="nav-text">四值逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#0"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">0</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#X"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">X</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%94%A8%E6%9D%A5%E6%8D%95%E8%8E%B7%E8%AE%BE%E8%AE%A1%E9%94%99%E8%AF%AF%EF%BC%8C%E6%AF%94%E5%A6%82%E5%AF%84%E5%AD%98%E5%99%A8%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.1.1.3.1.</span> <span class="nav-text">用来捕获设计错误，比如寄存器未初始化</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Z"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">Z</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%94%A8%E6%9D%A5%E8%A1%A8%E7%A4%BA%E6%9C%AA%E8%BF%9E%E6%8E%A5%E6%88%96%E8%80%85%E4%B8%89%E6%80%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E9%80%BB%E8%BE%91"><span class="nav-number">1.1.1.4.1.</span> <span class="nav-text">用来表示未连接或者三态的设计逻辑</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reg"><span class="nav-number">1.1.2.</span> <span class="nav-text">reg</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E6%9D%A5%E6%8F%8F%E8%BF%B0-%E9%80%BB%E8%BE%91%EF%BC%8C-integer-%E7%94%A8%E6%9D%A5%E6%8F%8F%E8%BF%B0%E5%BE%AA%E7%8E%AF%E5%8F%98%E9%87%8F%E5%92%8C%E8%AE%A1%E7%AE%97"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">用来描述 逻辑， integer 用来描述循环变量和计算</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#reg%E5%B9%B6%E4%B8%8D%E4%B8%80%E5%AE%9A%E8%A6%81%E8%A2%AB%E7%BB%BC%E5%90%88%E4%B8%BAregister%EF%BC%8C%E5%AE%83%E5%8F%AA%E6%98%AF%E7%94%A8%E6%9D%A5%E4%B8%8E%E7%BA%BF%E7%BD%91%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%AF%B9%EF%BC%8C%E8%A1%A8%E7%A4%BA%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%98%E9%87%8F"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">reg并不一定要被综合为register，它只是用来与线网类型相对，表示存储数据的变量</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#integer"><span class="nav-number">1.1.3.</span> <span class="nav-text">integer</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%92%8Ctime%E7%B1%BB%E4%BC%BC%EF%BC%8C%E5%83%8F%E6%9C%89%E7%9B%B8%E5%90%8C%E4%BD%8D%E6%95%B0%E7%9A%84reg%E4%B8%80%E6%A0%B7%E8%BF%90%E8%BD%AC%EF%BC%8C"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">和time类似，像有相同位数的reg一样运转，</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#time"><span class="nav-number">1.1.4.</span> <span class="nav-text">time</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%92%8Crealtime%E7%B1%BB%E4%BC%BC%EF%BC%8C-%E7%94%A8%E6%9D%A5%E4%BF%9D%E5%AD%98%E6%B5%8B%E8%AF%95%E8%A3%85%E7%BD%AE%E7%9A%84%E4%BB%BF%E7%9C%9F%E6%97%B6%E9%97%B4"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">和realtime类似， 用来保存测试装置的仿真时间</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#real"><span class="nav-number">1.1.5.</span> <span class="nav-text">real</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B%E4%B8%AD%E4%BD%BF%E7%94%A8"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">在系统模型中使用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#realtime"><span class="nav-number">1.1.6.</span> <span class="nav-text">realtime</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%BF%9D%E5%AD%98%E5%9C%A8initial-always-task-function%E4%B8%AD%E8%B5%8B%E7%9A%84%E5%80%BC"><span class="nav-number">1.1.7.</span> <span class="nav-text">变量类型是保存在initial always task function中赋的值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AA%E8%83%BD%E7%94%A8-%E8%BF%87%E7%A8%8B%E8%B5%8B%E5%80%BC-%E6%9D%A5%E5%AE%8C%E6%88%90"><span class="nav-number">1.1.8.</span> <span class="nav-text">只能用 过程赋值 来完成</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%BD%91%E7%B1%BB%E5%9E%8B-nets"><span class="nav-number">1.2.</span> <span class="nav-text">线网类型 nets</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9B%E5%80%BC%E9%80%BB%E8%BE%91-1"><span class="nav-number">1.2.1.</span> <span class="nav-text">四值逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#0-1"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">0</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#X-1"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">X</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Z-1"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">Z</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#wire"><span class="nav-number">1.2.2.</span> <span class="nav-text">wire</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#wor"><span class="nav-number">1.2.3.</span> <span class="nav-text">wor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#wand"><span class="nav-number">1.2.4.</span> <span class="nav-text">wand</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E4%BA%8E%E5%BB%BA%E6%A8%A1%E8%BF%9E%E6%8E%A5%E7%BA%BF%E8%B7%AF%EF%BC%8C%E5%80%BC%E7%94%B1-%E7%BA%BF%E7%BD%91%E9%A9%B1%E5%8A%A8%E5%99%A8%E5%86%B3%E5%AE%9A"><span class="nav-number">1.2.5.</span> <span class="nav-text">用于建模连接线路，值由 线网驱动器决定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%BD%91%E9%A9%B1%E5%8A%A8%E5%99%A8%EF%BC%9A%E5%8F%AF%E4%BB%A5%E6%98%AF%E9%97%A8%E6%88%96%E8%80%85%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AE%9E%E4%BE%8B%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%98%AF%E8%BF%9E%E7%BB%AD%E8%B5%8B%E5%80%BC%E7%9A%84%E8%BE%93%E5%87%BA"><span class="nav-number">1.2.6.</span> <span class="nav-text">线网驱动器：可以是门或者模块的实例，也可以是连续赋值的输出</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SV"><span class="nav-number">2.</span> <span class="nav-text">SV :</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E4%BF%A1%E5%8F%B7"><span class="nav-number">2.1.</span> <span class="nav-text">硬件信号</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.1.1.</span> <span class="nav-text">类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%98%E9%87%8F-var"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">变量 var</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%BD%91%E7%B1%BB%E5%9E%8B-wire"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">线网类型 wire</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.1.2.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%9B%E5%80%BC%E9%80%BB%E8%BE%91-logic"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">四值逻辑 logic</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%94%A8%E6%9D%A5%E8%A1%A8%E7%A4%BA%E9%80%9A%E7%94%A8%E7%9A%84%E5%AD%98%E5%82%A8%E7%A1%AC%E4%BB%B6%E6%95%B0%E6%8D%AE"><span class="nav-number">2.1.2.1.1.</span> <span class="nav-text">用来表示通用的存储硬件数据</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%99%BD%E7%84%B6%E5%8F%AA%E8%A1%A8%E7%A4%BA%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%BD%86%E6%98%AF%E5%9C%A8%E5%A3%B0%E6%98%8E%E6%97%B6%EF%BC%8C%E4%BC%9A%E9%BB%98%E8%AE%A4%E8%A1%A8%E7%A4%BA%E4%B8%BA%E5%8F%98%E9%87%8Fvar%EF%BC%8C%E7%94%A8%E6%88%B7%E5%8F%AF%E4%BB%A5%E6%98%BE%E5%BC%8F%E5%A3%B0%E6%98%8E%E5%85%B6%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.1.2.1.2.</span> <span class="nav-text">虽然只表示数据类型，但是在声明时，会默认表示为变量var，用户可以显式声明其类型</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%80%BC%E9%80%BB%E8%BE%91-bit"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">二值逻辑 bit</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B8%AE%E5%8A%A9%E6%9B%B4%E9%AB%98%E7%BA%A7%E6%8A%BD%E8%B1%A1%E7%9A%84%E5%BB%BA%E6%A8%A1%EF%BC%8C%E6%AF%94%E5%A6%82%EF%BC%8C%E4%BA%8B%E5%8A%A1%E7%BA%A7%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.1.2.2.1.</span> <span class="nav-text">帮助更高级抽象的建模，比如，事务级模型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#bit%E7%B1%BB%E5%9E%8B%E9%BB%98%E8%AE%A4%E4%B9%9F%E6%98%AF%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%EF%BC%8C"><span class="nav-number">2.1.2.2.2.</span> <span class="nav-text">bit类型默认也是变量类型，</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8unsighed%E8%A1%A8%E7%A4%BA%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B%EF%BC%8C-%E6%AF%94%E5%A6%82-byte-unsigned"><span class="nav-number">2.1.2.2.3.</span> <span class="nav-text">可以使用unsighed表示无符号类型， 比如 byte unsigned</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.2.</span> <span class="nav-text">自定义类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8A%BF"><span class="nav-number">2.2.1.</span> <span class="nav-text">优势</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9B%B4%E5%B0%91%E7%9A%84%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%A4%BA%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">可以用更少的代码表示更多的功能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7%E6%9B%B4%E5%A5%BD"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">代码可读性更好</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%9A%E8%BF%87typedef%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">通过typedef创建用户自定义类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%9A%E8%BF%87enum%E5%88%9B%E5%BB%BA%E6%9E%9A%E4%B8%BE"><span class="nav-number">2.2.1.4.</span> <span class="nav-text">通过enum创建枚举</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%9A%E8%BF%87struct%E5%88%9B%E5%BB%BA%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.2.1.5.</span> <span class="nav-text">通过struct创建结构体类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Verilog%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E6%88%B7%E6%89%A9%E5%B1%95%E5%8F%98%E9%87%8F%E5%92%8C%E7%BA%BF%E7%BD%91%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.2.1.6.</span> <span class="nav-text">Verilog无法使用户扩展变量和线网类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SV%E6%8F%90%E4%BE%9B%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8%E6%88%B7%E6%9E%84%E5%BB%BA%E6%9B%B4%E9%AB%98%E5%B1%82%E6%AC%A1%E6%8A%BD%E8%B1%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.2.1.7.</span> <span class="nav-text">SV提供的自定义类型使用户构建更高层次抽象的数据类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AF%94%E5%A6%82%EF%BC%9A-typedef-int-unsigned-uint-uint-a-b"><span class="nav-number">2.2.1.8.</span> <span class="nav-text">比如： typedef int unsigned uint;  uint a, b;</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E8%88%AC%E5%AF%B9%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%8A%A0%E4%B8%AA-t%E5%90%8E%E7%BC%80"><span class="nav-number">2.2.1.9.</span> <span class="nav-text">一般对自定义类型加个_t后缀</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#enum%E6%9E%9A%E4%B8%BE"><span class="nav-number">2.2.2.</span> <span class="nav-text">enum枚举</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AF%8F%E4%B8%AA%E5%80%BC%E9%83%BD%E8%A6%81%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%90%8D%E5%AD%97%EF%BC%8C%E6%AF%94%E5%A6%82%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8BRGB"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">每个值都要一个用户自定义的名字，比如枚举类型RGB</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#enum-red-green-blue-RGB"><span class="nav-number">2.2.2.1.1.</span> <span class="nav-text">enum {red, green, blue} RGB;</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Verilog%E6%B2%A1%E6%9C%89%E6%9E%9A%E4%B8%BE%EF%BC%8C%E4%B8%BA%E4%BA%86%E6%8F%90%E4%BE%9B%E6%8F%8F%E8%BF%B0%E5%8F%98%E9%87%8F%E7%9A%84%E8%8C%83%E5%9B%B4%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0%E6%9D%A5%E8%A1%A8%E7%A4%BA%E5%8F%AF%E5%8F%96%E5%80%BC%E7%9A%84%E8%8C%83%E5%9B%B4%EF%BC%8C%E6%88%96%E8%80%85%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%AE%9A%E4%B9%89%E5%90%84%E4%B8%AA%E5%90%88%E6%B3%95%E5%80%BC%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">Verilog没有枚举，为了提供描述变量的范围，使用参数来表示可取值的范围，或者宏定义定义各个合法值的名称</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E5%80%BC"><span class="nav-number">2.2.2.3.</span> <span class="nav-text">定义枚举值</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E4%B8%BAint%EF%BC%8C32%E4%BD%8D%E4%BA%8C%E5%80%BC%E9%80%BB%E8%BE%91"><span class="nav-number">2.2.2.3.1.</span> <span class="nav-text">默认为int，32位二值逻辑</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%86%E6%98%AF%EF%BC%8CSV%E4%B9%9F%E5%85%81%E8%AE%B8%E6%8C%87%E6%98%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E6%AF%94%E5%A6%82%EF%BC%9A-enum-bit-TRUE-FALSE-Boolean-enum-logic-1-0-WAITE-LOAD-READY-state"><span class="nav-number">2.2.2.3.2.</span> <span class="nav-text">但是，SV也允许指明数据类型，比如： enum bit {TRUE, FALSE} Boolean;  enum logic [1:0] {WAITE, LOAD, READY} state;</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E8%A2%AB%E8%B5%8B%E5%80%BC%EF%BC%8C%E9%82%A3%E4%B9%88%E6%89%80%E8%B5%8B%E5%80%BC%E5%BA%94%E8%AF%A5%E5%9C%A8%E5%85%B6%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4%E5%86%85-enum-logic-2-0-WAITE-x3D-3%E2%80%99b001-Load-x3D-3%E2%80%99b010-READY-x3D-3%E2%80%99b100-state"><span class="nav-number">2.2.2.3.3.</span> <span class="nav-text">如果枚举类型被赋值，那么所赋值应该在其数据范围内   enum logic [2:0] {WAITE &#x3D; 3’b001, Load &#x3D; 3’b010, READY &#x3D; 3’b100} state;</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%9E%9A%E4%B8%BE%E5%8F%98%E9%87%8F%E6%98%AF%E5%9B%9B%E5%80%BC%E9%80%BB%E8%BE%91%EF%BC%8C%E9%82%A3%E4%B9%88%E8%B5%8B%E5%80%BC%E4%B8%BAX%E6%88%96%E8%80%85Z%E4%B9%9F%E6%98%AF%E5%90%88%E6%B3%95%E7%9A%84-enum-logic-ON-x3D-1%E2%80%99b1-OFF-x3D-1%E2%80%99bz-out"><span class="nav-number">2.2.2.3.4.</span> <span class="nav-text">如果枚举变量是四值逻辑，那么赋值为X或者Z也是合法的   enum logic {ON&#x3D;1’b1, OFF&#x3D;1’bz} out;</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.2.2.4.</span> <span class="nav-text">自定义枚举类型</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E6%B2%A1%E6%9C%89%E4%BC%B4%E9%9A%8Ftypedef%EF%BC%8C%E9%82%A3%E4%B9%88%E8%AF%A5%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%B8%AA%E5%8C%BF%E5%90%8D%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.2.2.4.1.</span> <span class="nav-text">如果枚举类型没有伴随typedef，那么该枚举类型是个匿名枚举类型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B0%86%E5%AE%83typedef%E4%B8%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E6%9D%A5%E5%A3%B0%E6%98%8E%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F%E6%88%96%E8%80%85%E7%BA%BF%E7%BD%91-typedef-enum-WAITE-LOAD-READY-state-t-state-t-state-next-state"><span class="nav-number">2.2.2.4.2.</span> <span class="nav-text">将它typedef为自定义类型，就可以用同一个枚举类型来声明多个变量或者线网    typedef enum {WAITE, LOAD, READY} state_t;   state_t state next_state;</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E8%B5%8B%E5%80%BC"><span class="nav-number">2.2.2.5.</span> <span class="nav-text">枚举类型赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E8%A6%81%E6%B1%82%E5%BE%88%E4%B8%A5%E6%A0%BC%EF%BC%8C-x3D-%E4%B8%A4%E7%AB%AF%E5%BF%85%E9%A1%BB%E6%98%AF%E7%9B%B8%E5%90%8C%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%EF%BC%9B"><span class="nav-number">2.2.2.5.1.</span> <span class="nav-text">赋值要求很严格，&#x3D;两端必须是相同的枚举类型；</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#struct-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">2.2.3.</span> <span class="nav-text">struct 结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E5%8A%BF-1"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">优势</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BB%8F%E5%B8%B8%E9%81%87%E5%88%B0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E9%80%BB%E8%BE%91%E7%9B%B8%E5%85%B3%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BF%A1%E5%8F%B7%E7%BB%84%EF%BC%8C%E6%AF%94%E5%A6%82%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%89%80%E6%9C%89%E6%8E%A7%E5%88%B6%E4%BF%A1%E5%8F%B7%EF%BC%8C%E6%88%96%E8%80%85%E5%9C%A8%E7%8A%B6%E6%80%81%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E6%89%80%E6%9C%89%E4%BF%A1%E5%8F%B7%EF%BC%8Cverilog%E4%B8%8D%E6%96%B9%E4%BE%BF"><span class="nav-number">2.2.3.1.1.</span> <span class="nav-text">经常遇到数据表示逻辑相关的数据信号组，比如总线协议的所有控制信号，或者在状态控制器中用到的所有信号，verilog不方便</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#SV%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%8C%E6%88%90%E5%91%98%E5%8F%AF%E4%BB%A5%E6%98%AF%E4%BB%BB%E6%84%8F%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%8C%85%E6%8B%AC%E8%87%AA%E5%AE%9A%E4%B9%89%E5%92%8C%E5%85%B6%E4%BB%96%E5%B8%B8%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.2.3.1.2.</span> <span class="nav-text">SV的结构体，成员可以是任意变量类型，包括自定义和其他常量类型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#struct"><span class="nav-number">2.2.3.1.3.</span> <span class="nav-text">struct {</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%98%AF%E5%8F%98%E9%87%8F%E7%9A%84%E5%90%88%E9%9B%86%EF%BC%8C%E6%89%80%E4%BB%A5%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%8F%98%E9%87%8F%E4%B8%80%E5%8F%AF%E4%BB%A5%E7%B4%A2%E5%BC%95%E5%88%B0%E5%85%B6%E5%86%85%E9%83%A8%EF%BC%8C%E7%94%A8-%E7%AC%A6%E5%8F%B7%EF%BC%8C%E5%92%8CC%E4%B8%80%E6%A0%B7"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">结构体是变量的合集，所以结构体的变量一可以索引到其内部，用.符号，和C一样</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E9%BB%98%E8%AE%A4%E4%B8%BA%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%EF%BC%8C%E7%94%A8%E6%88%B7%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%98%BE%E5%BC%8F%E5%A3%B0%E6%98%8E%E4%B8%BAvar%E6%88%96%E8%80%85wire"><span class="nav-number">2.2.3.3.</span> <span class="nav-text">结构体类型默认为变量类型，用户也可以显式声明为var或者wire</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B9%9F%E5%8F%AF%E4%BB%A5typedef%E4%B8%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%EF%BC%8C%E7%84%B6%E5%90%8E%E4%BD%BF%E7%94%A8"><span class="nav-number">2.2.3.4.</span> <span class="nav-text">结构体也可以typedef为自定义类型，然后使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E7%B4%A2%E5%BC%95%E5%88%B0%E6%88%90%E5%91%98%EF%BC%8C%E4%BE%9D%E6%AC%A1%E8%B5%8B%E5%80%BC"><span class="nav-number">2.2.3.5.</span> <span class="nav-text">可以通过索引到成员，依次赋值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B9%9F%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E5%88%86%E5%8F%B7%E2%80%99%E5%92%8C%E8%8A%B1%E6%8B%AC%E5%8F%B7-%E5%AE%9E%E7%8E%B0%E6%95%B4%E4%BD%93%E8%B5%8B%E5%80%BC"><span class="nav-number">2.2.3.6.</span> <span class="nav-text">也可以通过分号’和花括号{}实现整体赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#IW-x3D-%E2%80%98-100-3-8%E2%80%99hFF-0"><span class="nav-number">2.2.3.6.1.</span> <span class="nav-text">IW &#x3D; ‘{100, 3, 8’hFF, 0};</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.3.</span> <span class="nav-text">字符串类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8A%BF-2"><span class="nav-number">2.3.1.</span> <span class="nav-text">优势</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Verilog%E6%B2%A1%E6%9C%89string%EF%BC%8CSV%E5%BC%95%E5%85%A5string%E5%AE%B9%E7%BA%B3%E5%8F%AF%E5%8F%98%E9%95%BF%E5%BA%A6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">Verilog没有string，SV引入string容纳可变长度的字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#string%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83%E4%B8%BAbyte%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%8D%B3char"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">string类型的存储单元为byte类型，即char</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8string%E5%8F%98%E9%87%8F%E9%95%BF%E5%BA%A6%E4%B8%BAN%E6%97%B6%EF%BC%8C%E7%B4%A2%E5%BC%95%E6%98%AF0%E5%88%B0N-1"><span class="nav-number">2.3.1.3.</span> <span class="nav-text">在string变量长度为N时，索引是0到N-1</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%92%8CC%E7%9A%84%E5%B7%AE%E5%88%AB"><span class="nav-number">2.3.2.</span> <span class="nav-text">和C的差别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%93%E5%B0%BE%E6%B2%A1%E6%9C%89-0"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">字符串结尾没有\0</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%EF%BC%8C%E7%94%A8%E6%88%B7%E4%B8%8D%E9%9C%80%E8%A6%81%E6%8B%85%E5%BF%83%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">内存动态分配，用户不需要担心内存管理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8"><span class="nav-number">2.3.3.</span> <span class="nav-text">使用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#typedef-logic-15-0-r-t"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">typedef logic [15:0] r_t;</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">内置函数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#str-len-%E8%BF%94%E5%9B%9Estring%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="nav-number">2.3.3.2.1.</span> <span class="nav-text">str.len()   返回string的长度</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#str-putc-i-c-%E5%B0%86%E7%AC%ACi%E4%B8%AA%E5%AD%97%E7%AC%A6%E6%9B%BF%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6c%EF%BC%8C%E7%AD%89%E5%90%8C%E4%BA%8E-str-i-x3D-c"><span class="nav-number">2.3.3.2.2.</span> <span class="nav-text">str.putc(i, c)    将第i个字符替换为字符c，等同于 str[i] &#x3D; c</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#str-getc-i-%E8%BF%94%E5%9B%9E%E7%AC%ACi%E4%B8%AA%E5%AD%97%E7%AC%A6"><span class="nav-number">2.3.3.2.3.</span> <span class="nav-text">str.getc(i)    返回第i个字符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#str-substr-i-j-%E8%BF%94%E5%9B%9E%E7%AC%ACi%E4%B8%AA%E5%AD%97%E7%AC%A6%E5%88%B0%E7%AC%ACj%E4%B8%AA%E5%AD%97%E7%AC%A6"><span class="nav-number">2.3.3.2.4.</span> <span class="nav-text">str.substr(i, j)    返回第i个字符到第j个字符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8F%A6%E5%A4%96%EF%BC%8CSV%E6%9C%89%E5%85%B6%E4%BB%96%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0"><span class="nav-number">2.3.3.2.5.</span> <span class="nav-text">另外，SV有其他的系统函数</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.4.</span> <span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8A%BF-3"><span class="nav-number">2.4.1.</span> <span class="nav-text">优势</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Verilog%E9%80%9A%E8%BF%87%E6%A8%A1%E5%9D%97%E4%B9%8B%E9%97%B4%E7%9A%84%E7%AB%AF%E5%8F%A3%E8%BF%9E%E6%8E%A5%EF%BC%8C%E8%BF%9B%E8%A1%8C%E6%A8%A1%E5%9D%97%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%EF%BC%8C%E4%BD%86%E6%98%AF%E5%A4%A7%E5%9E%8B%E8%AE%BE%E8%AE%A1%EF%BC%8C%E7%AB%AF%E5%8F%A3%E8%BF%9E%E6%8E%A5%E5%BE%88%E5%AE%B9%E6%98%93%E5%87%BA%E9%94%99%EF%BC%8C%E6%89%80%E4%BB%A5%EF%BC%8CSV%E6%89%A9%E5%B1%95%E4%BA%86%E6%8E%A5%E5%8F%A3interface"><span class="nav-number">2.4.1.1.</span> <span class="nav-text">Verilog通过模块之间的端口连接，进行模块间的通信，但是大型设计，端口连接很容易出错，所以，SV扩展了接口interface</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E6%8F%90%E4%BE%9B%E4%BA%86%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%BA%A7%E5%BB%BA%E6%A8%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">2.4.1.2.</span> <span class="nav-text">接口提供了面向抽象级建模的方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E4%BB%A5%E7%AE%80%E5%8C%96%E5%BB%BA%E6%A8%A1%E5%92%8C%E9%AA%8C%E8%AF%81%E5%A4%A7%E5%9E%8B%E5%A4%8D%E6%9D%82%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.4.1.3.</span> <span class="nav-text">可以简化建模和验证大型复杂的设计</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%A4%E5%85%B6%E6%98%AF%E6%A0%87%E5%87%86%E6%80%BB%E7%BA%BF%E7%AB%AF%E5%8F%A3%EF%BC%8CVerilog%E9%9C%80%E8%A6%81%E5%9C%A8%E5%A4%9A%E4%B8%AA%E6%A8%A1%E5%9D%97%E9%87%8D%E5%A4%8D%E5%A3%B0%E6%98%8E%EF%BC%8C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E4%B9%9F%E6%98%AF%E5%A4%9A%E6%AC%A1%E5%AE%9A%E4%B9%89%EF%BC%8C%E5%8F%98%E6%9B%B4%E4%B9%8B%E5%90%8E%E7%9A%84%E6%9B%B4%E6%94%B9%E4%B9%9F%E5%BE%88%E9%BA%BB%E7%83%A6"><span class="nav-number">2.4.1.4.</span> <span class="nav-text">尤其是标准总线端口，Verilog需要在多个模块重复声明，通信协议也是多次定义，变更之后的更改也很麻烦</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%85%81%E8%AE%B8%E5%A4%9A%E4%B8%AA%E4%BF%A1%E5%8F%B7%E8%A2%AB%E6%95%B4%E5%90%88%E5%88%B0%E4%B8%80%E8%B5%B7%EF%BC%8C%E7%94%A8%E4%BA%8E%E8%A1%A8%E7%A4%BA%E5%8D%95%E4%B8%80%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%AB%AF%E5%8F%A3"><span class="nav-number">2.4.1.5.</span> <span class="nav-text">接口允许多个信号被整合到一起，用于表示单一的抽象端口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3%EF%BC%8C%E9%81%BF%E5%85%8D%E5%88%86%E6%95%A3%E7%AB%AF%E5%8F%A3%E4%BF%A1%E5%8F%B7%E8%BF%9E%E6%8E%A5"><span class="nav-number">2.4.1.6.</span> <span class="nav-text">多个模块可以使用同一个接口，避免分散端口信号连接</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AE%B9"><span class="nav-number">2.4.2.</span> <span class="nav-text">内容</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#interface-main-bus"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">interface main_bus;</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8D%E6%AD%A2%E5%8F%AF%E4%BB%A5%E5%8C%85%E5%90%AB-%E5%8F%98%E9%87%8F%E6%88%96%E8%80%85%E7%BA%BF%E7%BD%91%EF%BC%8C%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%B0%81%E8%A3%85%E6%A8%A1%E5%9D%97%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">接口不止可以包含 变量或者线网，还可以封装模块之间通信的协议</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%B5%8C%E5%85%A5%E4%B8%8E%E5%8D%8F%E8%AE%AE%E6%9C%89%E5%85%B3%E7%9A%84%E6%96%AD%E8%A8%80%E6%A3%80%E6%9F%A5%E3%80%81%E5%8A%9F%E8%83%BD%E8%A6%86%E7%9B%96%E7%8E%87%E6%94%B6%E9%9B%86%E7%AD%89%E6%A8%A1%E5%9D%97"><span class="nav-number">2.4.2.3.</span> <span class="nav-text">还可以嵌入与协议有关的断言检查、功能覆盖率收集等模块</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8D%E5%90%8C%E4%BA%8E%E6%A8%A1%E5%9D%97%E7%9A%84%E5%9C%B0%E6%96%B9%E5%9C%A8%E4%BA%8E%EF%BC%8C%E6%8E%A5%E5%8F%A3%E4%B8%8D%E5%85%81%E8%AE%B8%E5%8C%85%E5%90%AB%E8%AE%BE%E8%AE%A1%E5%B1%82%E6%AC%A1%EF%BC%8C%E5%8D%B3%E6%8E%A5%E5%8F%A3%E6%97%A0%E6%B3%95%E4%BE%8B%E5%8C%96%E6%A8%A1%E5%9D%97%EF%BC%8C%E4%BD%86%E6%98%AF%E6%8E%A5%E5%8F%A3%E5%8F%AF%E4%BB%A5%E4%BE%8B%E5%8C%96%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.4.2.4.</span> <span class="nav-text">接口不同于模块的地方在于，接口不允许包含设计层次，即接口无法例化模块，但是接口可以例化接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A3%B0%E6%98%8Emodport%EF%BC%8C%E6%9D%A5%E7%BA%A6%E6%9D%9F%E4%B8%8D%E5%90%8C%E6%A8%A1%E5%9D%97%E8%BF%9E%E6%8E%A5%E6%97%B6%E4%BF%A1%E5%8F%B7%E7%81%AF%E6%96%B9%E5%90%91"><span class="nav-number">2.4.2.5.</span> <span class="nav-text">可以在接口的声明modport，来约束不同模块连接时信号灯方向</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E"><span class="nav-number">2.4.3.</span> <span class="nav-text">声明</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E5%92%8C%E6%A8%A1%E5%9D%97%E5%AE%9A%E4%B9%89%E7%B1%BB%E4%BC%BC"><span class="nav-number">2.4.3.1.</span> <span class="nav-text">接口定义和模块定义类似</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%9C%89%E7%AB%AF%E5%8F%A3%EF%BC%8C%E4%BE%8B%E5%A6%82%E5%A4%96%E9%83%A8%E6%8E%A5%E5%85%A5%E7%9A%84%E6%97%B6%E9%92%9F%E6%88%96%E8%80%85%E5%A4%8D%E4%BD%8D%E4%BF%A1%E5%8F%B7%EF%BC%9B"><span class="nav-number">2.4.3.2.</span> <span class="nav-text">也可以有端口，例如外部接入的时钟或者复位信号；</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%E5%8C%96"><span class="nav-number">2.4.4.</span> <span class="nav-text">例化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BE%8B%E5%8C%96%E6%96%B9%E5%BC%8F%E5%92%8C%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BE%8B%E5%8C%96%E6%96%B9%E5%BC%8F%E4%B8%80%E8%87%B4"><span class="nav-number">2.4.4.1.</span> <span class="nav-text">接口的例化方式和模块的例化方式一致</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%A6%82%E6%9E%9C%E5%A3%B0%E6%98%8E%E4%B8%BAinput%E3%80%81output%E3%80%81inout%EF%BC%8C%E9%82%A3%E4%B9%88%E5%9C%A8%E4%BE%8B%E5%8C%96%E6%97%B6%E5%8F%AF%E4%BB%A5%E4%B8%8D%E8%BF%9E%E6%8E%A5"><span class="nav-number">2.4.4.2.</span> <span class="nav-text">模块的端口如果声明为input、output、inout，那么在例化时可以不连接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%A6%82%E6%9E%9C%E5%A3%B0%E6%98%8E%E4%B8%BAinterface%EF%BC%8C%E9%82%A3%E4%B9%88%E5%9C%A8%E4%BE%8B%E5%8C%96%E6%97%B6%E5%BF%85%E9%A1%BB%E8%BF%9E%E6%8E%A5%E5%88%B0%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E4%BE%8B%EF%BC%8C%E6%88%96%E8%80%85%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3%E7%AB%AF%E5%8F%A3"><span class="nav-number">2.4.4.3.</span> <span class="nav-text">模块的端口如果声明为interface，那么在例化时必须连接到一个接口的实例，或者另一个接口端口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E6%8B%A5%E6%9C%89%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%AB%AF%E5%8F%A3%EF%BC%8C%E9%82%A3%E4%B9%88%E7%B4%A2%E5%BC%95%E8%BF%99%E4%B8%AA%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%EF%BC%8C%E9%9C%80%E8%A6%81%E9%80%9A%E8%BF%87-%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%8C"><span class="nav-number">2.4.4.4.</span> <span class="nav-text">如果一个模块拥有一个接口类型的端口，那么索引这个接口中的信号，需要通过.操作符，</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#modport"><span class="nav-number">2.4.5.</span> <span class="nav-text">modport</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BA%BF%E7%BD%91%E4%BF%A1%E5%8F%B7%E6%88%96%E8%80%85%E5%8F%98%E9%87%8F%EF%BC%8C%E5%AF%B9%E4%BA%8E%E8%BF%9E%E6%8E%A5%E5%88%B0%E8%BF%99%E4%B8%AA%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%B8%8D%E5%90%8C%E6%A8%A1%E5%9D%97%E5%8F%AF%E8%83%BD%E6%9C%89%E4%B8%8D%E5%90%8C%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%90%91%EF%BC%8C%E6%89%80%E4%BB%A5%E5%BC%95%E5%85%A5modport%E8%A1%A8%E7%A4%BA%E4%B8%8D%E5%90%8C%E6%A8%A1%E5%9D%97%E7%9C%8B%E5%88%B0%E5%90%8C%E4%B8%80%E7%BB%84%E4%BF%A1%E5%8F%B7%E6%97%B6%E7%9A%84%E8%A7%86%E8%A7%92%E6%96%B9%E5%90%91"><span class="nav-number">2.4.5.1.</span> <span class="nav-text">接口的线网信号或者变量，对于连接到这个接口的不同模块可能有不同的连接方向，所以引入modport表示不同模块看到同一组信号时的视角方向</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%A3%B0%E6%98%8Emodport%EF%BC%8C%E9%9C%80%E8%A6%81%E6%8C%87%E5%90%8Dmodport%E4%B8%AD%E5%90%84%E4%B8%AA%E4%BF%A1%E5%8F%B7%E7%81%AF%E6%96%B9%E5%90%91"><span class="nav-number">2.4.5.2.</span> <span class="nav-text">在接口中声明modport，需要指名modport中各个信号灯方向</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BD%93%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%9C%A8%E4%BE%8B%E5%8C%96%E6%97%B6%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%80%89%E6%8B%A9%E8%BF%9E%E6%8E%A5%E5%88%B0interface%E7%AB%AF%E5%8F%A3%E4%B8%AD%E5%85%B7%E4%BD%93%E7%9A%84%E6%9F%90%E4%B8%80%E4%B8%AAmodport"><span class="nav-number">2.4.5.3.</span> <span class="nav-text">当一个模块在例化时，可以选择连接到interface端口中具体的某一个modport</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%99%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%8F%AF%E4%BB%A5%E9%99%8D%E4%BD%8E%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%90%91%E9%94%99%E8%AF%AF%E7%9A%84%E5%8F%AF%E8%83%BD%EF%BC%8C%E9%81%BF%E5%85%8D%E4%BF%A1%E5%8F%B7%E5%A4%9A%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">2.4.5.4.</span> <span class="nav-text">这种方式可以降低连接方向错误的可能，避免信号多驱动的情况</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#interface-chip-bus-%E2%80%A6"><span class="nav-number">2.4.5.5.</span> <span class="nav-text">interface chip_bus(…);</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8"><span class="nav-number">2.4.6.</span> <span class="nav-text">应用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%B0%86%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0%E5%92%8CDUT%E8%BF%9E%E6%8E%A5%E5%9C%A8%E4%B8%80%E8%B5%B7"><span class="nav-number">2.4.6.1.</span> <span class="nav-text">利用接口，可以将测试平台和DUT连接在一起</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">2.4.7.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%AF%B9%E4%BA%8E%E8%AE%BE%E8%AE%A1%E5%A4%8D%E7%94%A8%E5%BE%88%E6%9C%89%E5%88%A9"><span class="nav-number">2.4.7.1.</span> <span class="nav-text">接口对于设计复用很有利</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%87%8F%E5%B0%91%E4%BA%86%E6%A8%A1%E5%9D%97%E4%B9%8B%E9%97%B4%E9%94%99%E8%AF%AF%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8F%AF%E8%83%BD%E6%80%A7"><span class="nav-number">2.4.7.2.</span> <span class="nav-text">接口减少了模块之间错误连接的可能性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%B7%BB%E5%8A%A0%E4%BA%86%E6%96%B0%E7%9A%84%E4%BF%A1%E5%8F%B7%EF%BC%8C%E5%8F%AA%E9%9C%80%E8%A6%81%E5%9C%A8%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%A3%B0%E6%98%8E%EF%BC%8C%E4%B8%8D%E9%9C%80%E8%A6%81%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A8%A1%E5%9D%97%E4%B8%AD%E5%A3%B0%E6%98%8E"><span class="nav-number">2.4.7.3.</span> <span class="nav-text">如果添加了新的信号，只需要在接口中声明，不需要在每个模块中声明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%B1%E4%BA%8E%E6%8E%A5%E5%8F%A3%E5%8F%AF%E4%BB%A5%E5%B0%86%E6%9C%89%E5%85%B3%E4%BF%A1%E5%8F%B7%E9%83%BD%E9%9B%86%E5%90%88%E5%9C%A8%E4%B8%80%E8%B5%B7%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%9C%A8%E4%BD%BF%E7%94%A8%E8%BF%99%E4%BA%9B%E4%BF%A1%E5%8F%B7%E6%97%B6%EF%BC%8C%E9%9C%80%E8%A6%81%E6%B7%BB%E5%8A%A0%E6%8E%A5%E5%8F%A3%E5%AE%9E%E4%BE%8B%E5%90%8D"><span class="nav-number">2.4.7.4.</span> <span class="nav-text">由于接口可以将有关信号都集合在一起，可以在使用这些信号时，需要添加接口实例名</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E7%A7%8D%E6%8E%A5%E5%8F%A3%E5%BE%80%E5%BE%80%E5%B0%86%E6%9C%89%E5%85%B3%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%90%88%E5%9C%A8%E4%B8%80%E8%B5%B7%EF%BC%8C%E5%9B%A0%E6%AD%A4%EF%BC%8C%E5%AF%B9%E4%BA%8E%E6%8B%A5%E6%9C%89%E5%A4%9A%E7%BB%84%E4%B8%8D%E7%9B%B8%E5%85%B3%E4%BF%A1%E5%8F%B7%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%80%8C%E8%A8%80%EF%BC%8C%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3%E6%89%8D%E8%83%BD%E5%AE%8C%E6%88%90%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%9D%97%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="nav-number">2.4.7.5.</span> <span class="nav-text">一种接口往往将有关信号集合在一起，因此，对于拥有多组不相关信号的设计而言，需要多个接口才能完成与其他模块的连接</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9A"><span class="nav-number">2.5.</span> <span class="nav-text">其他注意点：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9B%E5%80%BC%E9%80%BB%E8%BE%91%EF%BC%8C%E6%AF%94%E5%A6%82reg%E3%80%81logic%E3%80%81integer%EF%BC%8C%E5%9C%A8%E4%BB%BF%E7%9C%9F%E5%BC%80%E5%A7%8B%E6%97%B6%E7%9A%84%E5%88%9D%E5%A7%8B%E5%80%BC%E4%B8%BAX"><span class="nav-number">2.5.1.</span> <span class="nav-text">四值逻辑，比如reg、logic、integer，在仿真开始时的初始值为X</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%80%BC%E9%80%BB%E8%BE%91bit%E5%9C%A8%E4%BB%BF%E7%9C%9F%E5%BC%80%E5%A7%8B%E7%9A%84%E5%88%9D%E5%80%BC%E4%B8%BA0"><span class="nav-number">2.5.2.</span> <span class="nav-text">二值逻辑bit在仿真开始的初值为0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%9B%9B%E5%80%BC%E9%80%BB%E8%BE%91%E5%92%8C%E4%BA%8C%E5%80%BC%E9%80%BB%E8%BE%91%E5%8F%91%E7%94%9F%E8%BD%AC%E6%8D%A2%EF%BC%8C%E5%88%99%E6%8A%8AX%E5%92%8CZ%E9%83%BD%E8%BD%AC%E4%B8%BA0"><span class="nav-number">2.5.3.</span> <span class="nav-text">如果四值逻辑和二值逻辑发生转换，则把X和Z都转为0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%80%BC%E9%80%BB%E8%BE%91%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E5%8F%AF%E7%BB%BC%E5%90%88%E7%94%B5%E8%B7%AF%EF%BC%8C%E4%BD%86%E6%98%AF%E7%94%B1%E4%BA%8E%E6%B2%A1%E6%9C%89X%E3%80%81Z%EF%BC%8C%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E4%BB%BF%E7%9C%9F%E8%A1%8C%E4%B8%BA%E5%92%8C%E7%BB%BC%E5%90%88%E7%94%B5%E8%B7%AF%E7%9A%84%E7%BB%93%E6%9E%9C%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">2.5.4.</span> <span class="nav-text">二值逻辑也可以实现可综合电路，但是由于没有X、Z，可能出现仿真行为和综合电路的结果不一致的情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SV%E4%B8%AD%E8%BF%98%E6%96%B0%E5%A2%9E%E4%BA%86void%E7%B1%BB%E5%9E%8B%EF%BC%8C%E7%94%A8%E4%BA%8E%E5%9C%A8%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E6%97%B6%E8%A1%A8%E7%A4%BA%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%8C%E5%90%8CC"><span class="nav-number">2.5.5.</span> <span class="nav-text">SV中还新增了void类型，用于在函数定义时表示无返回值，同C</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SV%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%BA%86shortreal%E8%A1%A8%E7%A4%BA32%E4%BD%8D%E5%8D%95%E7%B2%BE%E5%BA%A6%E6%B5%AE%E7%82%B9%E6%95%B0%EF%BC%8C%E5%90%8Cfloat%EF%BC%9B"><span class="nav-number">2.5.6.</span> <span class="nav-text">SV中添加了shortreal表示32位单精度浮点数，同float；</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jia</p>
  <div class="site-description" itemprop="description">Go ahead, and believe in yourself.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">73</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/DustOfStars" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;DustOfStars" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/10/55/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jia">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DustOfStars">
      <meta itemprop="description" content="Go ahead, and believe in yourself.">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="路科V0SV和Verilog的对比总结 | DustOfStars">
      <meta itemprop="description" content="SV Verilog对比， 数据类型、自定义类型、字符串类型、接口等">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          路科V0SV和Verilog的对比总结
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-10 21:05:55" itemprop="dateCreated datePublished" datetime="2022-05-10T21:05:55+08:00">2022-05-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%B7%AF%E7%A7%91V0/" itemprop="url" rel="index"><span itemprop="name">路科V0</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">SV Verilog对比， 数据类型、自定义类型、字符串类型、接口等</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><img src="/2022/05/10/55/%E8%B7%AF%E7%A7%91.png" alt="路科"></p>
<h2 id="Verilog："><a href="#Verilog：" class="headerlink" title="Verilog："></a>Verilog：</h2><h3 id="变量类型-veriables"><a href="#变量类型-veriables" class="headerlink" title="变量类型 veriables"></a>变量类型 veriables</h3><h4 id="四值逻辑"><a href="#四值逻辑" class="headerlink" title="四值逻辑"></a>四值逻辑</h4><h5 id="0"><a href="#0" class="headerlink" title="0"></a>0</h5><h5 id="1"><a href="#1" class="headerlink" title="1"></a>1</h5><h5 id="X"><a href="#X" class="headerlink" title="X"></a>X</h5><h6 id="用来捕获设计错误，比如寄存器未初始化"><a href="#用来捕获设计错误，比如寄存器未初始化" class="headerlink" title="用来捕获设计错误，比如寄存器未初始化"></a>用来捕获设计错误，比如寄存器未初始化</h6><h5 id="Z"><a href="#Z" class="headerlink" title="Z"></a>Z</h5><h6 id="用来表示未连接或者三态的设计逻辑"><a href="#用来表示未连接或者三态的设计逻辑" class="headerlink" title="用来表示未连接或者三态的设计逻辑"></a>用来表示未连接或者三态的设计逻辑</h6><p>但是在系统级或者事务级，Z和X很少使用</p>
<h4 id="reg"><a href="#reg" class="headerlink" title="reg"></a>reg</h4><h5 id="用来描述-逻辑，-integer-用来描述循环变量和计算"><a href="#用来描述-逻辑，-integer-用来描述循环变量和计算" class="headerlink" title="用来描述 逻辑， integer 用来描述循环变量和计算"></a>用来描述 逻辑， integer 用来描述循环变量和计算</h5><h5 id="reg并不一定要被综合为register，它只是用来与线网类型相对，表示存储数据的变量"><a href="#reg并不一定要被综合为register，它只是用来与线网类型相对，表示存储数据的变量" class="headerlink" title="reg并不一定要被综合为register，它只是用来与线网类型相对，表示存储数据的变量"></a>reg并不一定要被综合为register，它只是用来与线网类型相对，表示存储数据的变量</h5><h4 id="integer"><a href="#integer" class="headerlink" title="integer"></a>integer</h4><h5 id="和time类似，像有相同位数的reg一样运转，"><a href="#和time类似，像有相同位数的reg一样运转，" class="headerlink" title="和time类似，像有相同位数的reg一样运转，"></a>和time类似，像有相同位数的reg一样运转，</h5><p>表达式的integer值作为 有符号数 处理， reg 和 time 作为无符号数处理</p>
<h4 id="time"><a href="#time" class="headerlink" title="time"></a>time</h4><h5 id="和realtime类似，-用来保存测试装置的仿真时间"><a href="#和realtime类似，-用来保存测试装置的仿真时间" class="headerlink" title="和realtime类似， 用来保存测试装置的仿真时间"></a>和realtime类似， 用来保存测试装置的仿真时间</h5><h4 id="real"><a href="#real" class="headerlink" title="real"></a>real</h4><h5 id="在系统模型中使用"><a href="#在系统模型中使用" class="headerlink" title="在系统模型中使用"></a>在系统模型中使用</h5><h4 id="realtime"><a href="#realtime" class="headerlink" title="realtime"></a>realtime</h4><h4 id="变量类型是保存在initial-always-task-function中赋的值"><a href="#变量类型是保存在initial-always-task-function中赋的值" class="headerlink" title="变量类型是保存在initial always task function中赋的值"></a>变量类型是保存在initial always task function中赋的值</h4><h4 id="只能用-过程赋值-来完成"><a href="#只能用-过程赋值-来完成" class="headerlink" title="只能用 过程赋值 来完成"></a>只能用 过程赋值 来完成</h4><h3 id="线网类型-nets"><a href="#线网类型-nets" class="headerlink" title="线网类型 nets"></a>线网类型 nets</h3><h4 id="四值逻辑-1"><a href="#四值逻辑-1" class="headerlink" title="四值逻辑"></a>四值逻辑</h4><h5 id="0-1"><a href="#0-1" class="headerlink" title="0"></a>0</h5><h5 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h5><h5 id="X-1"><a href="#X-1" class="headerlink" title="X"></a>X</h5><h5 id="Z-1"><a href="#Z-1" class="headerlink" title="Z"></a>Z</h5><h4 id="wire"><a href="#wire" class="headerlink" title="wire"></a>wire</h4><h4 id="wor"><a href="#wor" class="headerlink" title="wor"></a>wor</h4><h4 id="wand"><a href="#wand" class="headerlink" title="wand"></a>wand</h4><h4 id="用于建模连接线路，值由-线网驱动器决定"><a href="#用于建模连接线路，值由-线网驱动器决定" class="headerlink" title="用于建模连接线路，值由 线网驱动器决定"></a>用于建模连接线路，值由 线网驱动器决定</h4><h4 id="线网驱动器：可以是门或者模块的实例，也可以是连续赋值的输出"><a href="#线网驱动器：可以是门或者模块的实例，也可以是连续赋值的输出" class="headerlink" title="线网驱动器：可以是门或者模块的实例，也可以是连续赋值的输出"></a>线网驱动器：可以是门或者模块的实例，也可以是连续赋值的输出</h4><h2 id="SV"><a href="#SV" class="headerlink" title="SV :"></a>SV :</h2><p> 在与C交互时，可以使用二值逻辑使接口参数更加简单，<br>因为构建验证驱动组件时，不关注硬件底层逻辑X，Z</p>
<h3 id="硬件信号"><a href="#硬件信号" class="headerlink" title="硬件信号"></a>硬件信号</h3><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><h5 id="变量-var"><a href="#变量-var" class="headerlink" title="变量 var"></a>变量 var</h5><h5 id="线网类型-wire"><a href="#线网类型-wire" class="headerlink" title="线网类型 wire"></a>线网类型 wire</h5><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><h5 id="四值逻辑-logic"><a href="#四值逻辑-logic" class="headerlink" title="四值逻辑 logic"></a>四值逻辑 logic</h5><p>构成的vector都是无符号类型</p>
<h6 id="用来表示通用的存储硬件数据"><a href="#用来表示通用的存储硬件数据" class="headerlink" title="用来表示通用的存储硬件数据"></a>用来表示通用的存储硬件数据</h6><p>####### logic resetN;    &#x2F;&#x2F; 1位宽的四值逻辑</p>
<p>####### logic  [63:0] data;     &#x2F;&#x2F; 64位宽的变量</p>
<p>####### logic [0:7} array [0:255];    &#x2F;&#x2F; 由8位向量元素构成的数组</p>
<h6 id="虽然只表示数据类型，但是在声明时，会默认表示为变量var，用户可以显式声明其类型"><a href="#虽然只表示数据类型，但是在声明时，会默认表示为变量var，用户可以显式声明其类型" class="headerlink" title="虽然只表示数据类型，但是在声明时，会默认表示为变量var，用户可以显式声明其类型"></a>虽然只表示数据类型，但是在声明时，会默认表示为变量var，用户可以显式声明其类型</h6><p>####### var logic [63:0] addr;    &#x2F;&#x2F; 64位宽的变量类型</p>
<p>####### wire logic [63:0] data;    &#x2F;&#x2F; 64位宽的线网类型</p>
<h5 id="二值逻辑-bit"><a href="#二值逻辑-bit" class="headerlink" title="二值逻辑 bit"></a>二值逻辑 bit</h5><h6 id="帮助更高级抽象的建模，比如，事务级模型"><a href="#帮助更高级抽象的建模，比如，事务级模型" class="headerlink" title="帮助更高级抽象的建模，比如，事务级模型"></a>帮助更高级抽象的建模，比如，事务级模型</h6><p>####### bit ： 1位二值逻辑变量</p>
<p>构成的vector是无符号类型</p>
<p>####### byte ： 8位二值逻辑，类似于C语言中的char</p>
<p>####### shortint ： 16位，类似short</p>
<p>####### int : 32位，类似int</p>
<p>####### longint : 64位，类似longlong</p>
<h6 id="bit类型默认也是变量类型，"><a href="#bit类型默认也是变量类型，" class="headerlink" title="bit类型默认也是变量类型，"></a>bit类型默认也是变量类型，</h6><p>除了bit的其他二值逻辑类型的verctor，默认都是有符号类型</p>
<h6 id="可以使用unsighed表示无符号类型，-比如-byte-unsigned"><a href="#可以使用unsighed表示无符号类型，-比如-byte-unsigned" class="headerlink" title="可以使用unsighed表示无符号类型， 比如 byte unsigned"></a>可以使用unsighed表示无符号类型， 比如 byte unsigned</h6><p>####### 表示的范围从[-128, 127]， 变为了[0, 255]</p>
<h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h3><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><h5 id="可以用更少的代码表示更多的功能"><a href="#可以用更少的代码表示更多的功能" class="headerlink" title="可以用更少的代码表示更多的功能"></a>可以用更少的代码表示更多的功能</h5><h5 id="代码可读性更好"><a href="#代码可读性更好" class="headerlink" title="代码可读性更好"></a>代码可读性更好</h5><h5 id="通过typedef创建用户自定义类型"><a href="#通过typedef创建用户自定义类型" class="headerlink" title="通过typedef创建用户自定义类型"></a>通过typedef创建用户自定义类型</h5><h5 id="通过enum创建枚举"><a href="#通过enum创建枚举" class="headerlink" title="通过enum创建枚举"></a>通过enum创建枚举</h5><h5 id="通过struct创建结构体类型"><a href="#通过struct创建结构体类型" class="headerlink" title="通过struct创建结构体类型"></a>通过struct创建结构体类型</h5><h5 id="Verilog无法使用户扩展变量和线网类型"><a href="#Verilog无法使用户扩展变量和线网类型" class="headerlink" title="Verilog无法使用户扩展变量和线网类型"></a>Verilog无法使用户扩展变量和线网类型</h5><h5 id="SV提供的自定义类型使用户构建更高层次抽象的数据类型"><a href="#SV提供的自定义类型使用户构建更高层次抽象的数据类型" class="headerlink" title="SV提供的自定义类型使用户构建更高层次抽象的数据类型"></a>SV提供的自定义类型使用户构建更高层次抽象的数据类型</h5><h5 id="比如：-typedef-int-unsigned-uint-uint-a-b"><a href="#比如：-typedef-int-unsigned-uint-uint-a-b" class="headerlink" title="比如： typedef int unsigned uint;  uint a, b;"></a>比如： typedef int unsigned uint;  uint a, b;</h5><h5 id="一般对自定义类型加个-t后缀"><a href="#一般对自定义类型加个-t后缀" class="headerlink" title="一般对自定义类型加个_t后缀"></a>一般对自定义类型加个_t后缀</h5><h4 id="enum枚举"><a href="#enum枚举" class="headerlink" title="enum枚举"></a>enum枚举</h4><h5 id="每个值都要一个用户自定义的名字，比如枚举类型RGB"><a href="#每个值都要一个用户自定义的名字，比如枚举类型RGB" class="headerlink" title="每个值都要一个用户自定义的名字，比如枚举类型RGB"></a>每个值都要一个用户自定义的名字，比如枚举类型RGB</h5><h6 id="enum-red-green-blue-RGB"><a href="#enum-red-green-blue-RGB" class="headerlink" title="enum {red, green, blue} RGB;"></a>enum {red, green, blue} RGB;</h6><h5 id="Verilog没有枚举，为了提供描述变量的范围，使用参数来表示可取值的范围，或者宏定义定义各个合法值的名称"><a href="#Verilog没有枚举，为了提供描述变量的范围，使用参数来表示可取值的范围，或者宏定义定义各个合法值的名称" class="headerlink" title="Verilog没有枚举，为了提供描述变量的范围，使用参数来表示可取值的范围，或者宏定义定义各个合法值的名称"></a>Verilog没有枚举，为了提供描述变量的范围，使用参数来表示可取值的范围，或者宏定义定义各个合法值的名称</h5><h5 id="定义枚举值"><a href="#定义枚举值" class="headerlink" title="定义枚举值"></a>定义枚举值</h5><h6 id="默认为int，32位二值逻辑"><a href="#默认为int，32位二值逻辑" class="headerlink" title="默认为int，32位二值逻辑"></a>默认为int，32位二值逻辑</h6><h6 id="但是，SV也允许指明数据类型，比如：-enum-bit-TRUE-FALSE-Boolean-enum-logic-1-0-WAITE-LOAD-READY-state"><a href="#但是，SV也允许指明数据类型，比如：-enum-bit-TRUE-FALSE-Boolean-enum-logic-1-0-WAITE-LOAD-READY-state" class="headerlink" title="但是，SV也允许指明数据类型，比如： enum bit {TRUE, FALSE} Boolean;  enum logic [1:0] {WAITE, LOAD, READY} state;"></a>但是，SV也允许指明数据类型，比如： enum bit {TRUE, FALSE} Boolean;  enum logic [1:0] {WAITE, LOAD, READY} state;</h6><h6 id="如果枚举类型被赋值，那么所赋值应该在其数据范围内-enum-logic-2-0-WAITE-x3D-3’b001-Load-x3D-3’b010-READY-x3D-3’b100-state"><a href="#如果枚举类型被赋值，那么所赋值应该在其数据范围内-enum-logic-2-0-WAITE-x3D-3’b001-Load-x3D-3’b010-READY-x3D-3’b100-state" class="headerlink" title="如果枚举类型被赋值，那么所赋值应该在其数据范围内   enum logic [2:0] {WAITE &#x3D; 3’b001, Load &#x3D; 3’b010, READY &#x3D; 3’b100} state;"></a>如果枚举类型被赋值，那么所赋值应该在其数据范围内   enum logic [2:0] {WAITE &#x3D; 3’b001, Load &#x3D; 3’b010, READY &#x3D; 3’b100} state;</h6><h6 id="如果枚举变量是四值逻辑，那么赋值为X或者Z也是合法的-enum-logic-ON-x3D-1’b1-OFF-x3D-1’bz-out"><a href="#如果枚举变量是四值逻辑，那么赋值为X或者Z也是合法的-enum-logic-ON-x3D-1’b1-OFF-x3D-1’bz-out" class="headerlink" title="如果枚举变量是四值逻辑，那么赋值为X或者Z也是合法的   enum logic {ON&#x3D;1’b1, OFF&#x3D;1’bz} out;"></a>如果枚举变量是四值逻辑，那么赋值为X或者Z也是合法的   enum logic {ON&#x3D;1’b1, OFF&#x3D;1’bz} out;</h6><h5 id="自定义枚举类型"><a href="#自定义枚举类型" class="headerlink" title="自定义枚举类型"></a>自定义枚举类型</h5><h6 id="如果枚举类型没有伴随typedef，那么该枚举类型是个匿名枚举类型"><a href="#如果枚举类型没有伴随typedef，那么该枚举类型是个匿名枚举类型" class="headerlink" title="如果枚举类型没有伴随typedef，那么该枚举类型是个匿名枚举类型"></a>如果枚举类型没有伴随typedef，那么该枚举类型是个匿名枚举类型</h6><h6 id="将它typedef为自定义类型，就可以用同一个枚举类型来声明多个变量或者线网-typedef-enum-WAITE-LOAD-READY-state-t-state-t-state-next-state"><a href="#将它typedef为自定义类型，就可以用同一个枚举类型来声明多个变量或者线网-typedef-enum-WAITE-LOAD-READY-state-t-state-t-state-next-state" class="headerlink" title="将它typedef为自定义类型，就可以用同一个枚举类型来声明多个变量或者线网    typedef enum {WAITE, LOAD, READY} state_t;   state_t state next_state;"></a>将它typedef为自定义类型，就可以用同一个枚举类型来声明多个变量或者线网    typedef enum {WAITE, LOAD, READY} state_t;   state_t state next_state;</h6><h5 id="枚举类型赋值"><a href="#枚举类型赋值" class="headerlink" title="枚举类型赋值"></a>枚举类型赋值</h5><h6 id="赋值要求很严格，-x3D-两端必须是相同的枚举类型；"><a href="#赋值要求很严格，-x3D-两端必须是相同的枚举类型；" class="headerlink" title="赋值要求很严格，&#x3D;两端必须是相同的枚举类型；"></a>赋值要求很严格，&#x3D;两端必须是相同的枚举类型；</h6><p>int foo; states_t state;<br>foo &#x3D; state + 1; &#x2F;&#x2F; 可以   <br>state &#x3D; foo +1; &#x2F;&#x2F; 不可以 <br>state &#x3D; states_t’(foo+1); &#x2F;&#x2F; 可以</p>
<p>state++; &#x2F;&#x2F;不可以<br>state&#x3D; state + 1; &#x2F;&#x2F;不可以<br>state &#x3D; states_t’(state+1);  &#x2F;&#x2F; 可以</p>
<h4 id="struct-结构体"><a href="#struct-结构体" class="headerlink" title="struct 结构体"></a>struct 结构体</h4><h5 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h5><h6 id="经常遇到数据表示逻辑相关的数据信号组，比如总线协议的所有控制信号，或者在状态控制器中用到的所有信号，verilog不方便"><a href="#经常遇到数据表示逻辑相关的数据信号组，比如总线协议的所有控制信号，或者在状态控制器中用到的所有信号，verilog不方便" class="headerlink" title="经常遇到数据表示逻辑相关的数据信号组，比如总线协议的所有控制信号，或者在状态控制器中用到的所有信号，verilog不方便"></a>经常遇到数据表示逻辑相关的数据信号组，比如总线协议的所有控制信号，或者在状态控制器中用到的所有信号，verilog不方便</h6><h6 id="SV的结构体，成员可以是任意变量类型，包括自定义和其他常量类型"><a href="#SV的结构体，成员可以是任意变量类型，包括自定义和其他常量类型" class="headerlink" title="SV的结构体，成员可以是任意变量类型，包括自定义和其他常量类型"></a>SV的结构体，成员可以是任意变量类型，包括自定义和其他常量类型</h6><h6 id="struct"><a href="#struct" class="headerlink" title="struct {"></a>struct {</h6><p>  int a,b;<br>  opcode_t opcode;<br>  logic [23:0] address;<br>  bit error;<br>} Instruction_Word;</p>
<h5 id="结构体是变量的合集，所以结构体的变量一可以索引到其内部，用-符号，和C一样"><a href="#结构体是变量的合集，所以结构体的变量一可以索引到其内部，用-符号，和C一样" class="headerlink" title="结构体是变量的合集，所以结构体的变量一可以索引到其内部，用.符号，和C一样"></a>结构体是变量的合集，所以结构体的变量一可以索引到其内部，用.符号，和C一样</h5><p>Instruction_Word.address &#x3D; 32’hF000001E;</p>
<h5 id="结构体类型默认为变量类型，用户也可以显式声明为var或者wire"><a href="#结构体类型默认为变量类型，用户也可以显式声明为var或者wire" class="headerlink" title="结构体类型默认为变量类型，用户也可以显式声明为var或者wire"></a>结构体类型默认为变量类型，用户也可以显式声明为var或者wire</h5><h5 id="结构体也可以typedef为自定义类型，然后使用"><a href="#结构体也可以typedef为自定义类型，然后使用" class="headerlink" title="结构体也可以typedef为自定义类型，然后使用"></a>结构体也可以typedef为自定义类型，然后使用</h5><p>typedef struct {<br>  …;<br>  …;<br>} instruction_word_t;<br>instruction_word_t IM;</p>
<h5 id="可以通过索引到成员，依次赋值"><a href="#可以通过索引到成员，依次赋值" class="headerlink" title="可以通过索引到成员，依次赋值"></a>可以通过索引到成员，依次赋值</h5><h5 id="也可以通过分号’和花括号-实现整体赋值"><a href="#也可以通过分号’和花括号-实现整体赋值" class="headerlink" title="也可以通过分号’和花括号{}实现整体赋值"></a>也可以通过分号’和花括号{}实现整体赋值</h5><h6 id="IW-x3D-‘-100-3-8’hFF-0"><a href="#IW-x3D-‘-100-3-8’hFF-0" class="headerlink" title="IW &#x3D; ‘{100, 3, 8’hFF, 0};"></a>IW &#x3D; ‘{100, 3, 8’hFF, 0};</h6><p>IW &#x3D; ‘{address:0, opcode:8’hFF, a:100, b:5};</p>
<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><h4 id="优势-2"><a href="#优势-2" class="headerlink" title="优势"></a>优势</h4><h5 id="Verilog没有string，SV引入string容纳可变长度的字符串"><a href="#Verilog没有string，SV引入string容纳可变长度的字符串" class="headerlink" title="Verilog没有string，SV引入string容纳可变长度的字符串"></a>Verilog没有string，SV引入string容纳可变长度的字符串</h5><h5 id="string类型的存储单元为byte类型，即char"><a href="#string类型的存储单元为byte类型，即char" class="headerlink" title="string类型的存储单元为byte类型，即char"></a>string类型的存储单元为byte类型，即char</h5><h5 id="在string变量长度为N时，索引是0到N-1"><a href="#在string变量长度为N时，索引是0到N-1" class="headerlink" title="在string变量长度为N时，索引是0到N-1"></a>在string变量长度为N时，索引是0到N-1</h5><h4 id="和C的差别"><a href="#和C的差别" class="headerlink" title="和C的差别"></a>和C的差别</h4><h5 id="字符串结尾没有-0"><a href="#字符串结尾没有-0" class="headerlink" title="字符串结尾没有\0"></a>字符串结尾没有\0</h5><h5 id="内存动态分配，用户不需要担心内存管理"><a href="#内存动态分配，用户不需要担心内存管理" class="headerlink" title="内存动态分配，用户不需要担心内存管理"></a>内存动态分配，用户不需要担心内存管理</h5><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="typedef-logic-15-0-r-t"><a href="#typedef-logic-15-0-r-t" class="headerlink" title="typedef logic [15:0] r_t;"></a>typedef logic [15:0] r_t;</h5><p>r_t r;<br>integer i &#x3D; 1;<br>string b &#x3D; “”;<br>string a &#x3D; {“Hi”, b};<br>r &#x3D; r_t’(a);<br>b &#x3D; string’(r);<br>b &#x3D; “Hi”;<br>b &#x3D; {5{“Hi”}};<br>a &#x3D; {i{“Hi”}};    &#x2F;&#x2F;可以，非常量复制<br>a &#x3D; {a, b};<br>a &#x3D; {“Hi”, b};<br>b &#x3D; {“Hi”, “”};<br>a[0] &#x3D; “h”;</p>
<h5 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h5><h6 id="str-len-返回string的长度"><a href="#str-len-返回string的长度" class="headerlink" title="str.len()   返回string的长度"></a>str.len()   返回string的长度</h6><h6 id="str-putc-i-c-将第i个字符替换为字符c，等同于-str-i-x3D-c"><a href="#str-putc-i-c-将第i个字符替换为字符c，等同于-str-i-x3D-c" class="headerlink" title="str.putc(i, c)    将第i个字符替换为字符c，等同于 str[i] &#x3D; c"></a>str.putc(i, c)    将第i个字符替换为字符c，等同于 str[i] &#x3D; c</h6><h6 id="str-getc-i-返回第i个字符"><a href="#str-getc-i-返回第i个字符" class="headerlink" title="str.getc(i)    返回第i个字符"></a>str.getc(i)    返回第i个字符</h6><h6 id="str-substr-i-j-返回第i个字符到第j个字符"><a href="#str-substr-i-j-返回第i个字符到第j个字符" class="headerlink" title="str.substr(i, j)    返回第i个字符到第j个字符"></a>str.substr(i, j)    返回第i个字符到第j个字符</h6><h6 id="另外，SV有其他的系统函数"><a href="#另外，SV有其他的系统函数" class="headerlink" title="另外，SV有其他的系统函数"></a>另外，SV有其他的系统函数</h6><p>####### $sformatf()   用来生成一个格式化的字符串</p>
<p>####### $display()    打印输出</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="优势-3"><a href="#优势-3" class="headerlink" title="优势"></a>优势</h4><h5 id="Verilog通过模块之间的端口连接，进行模块间的通信，但是大型设计，端口连接很容易出错，所以，SV扩展了接口interface"><a href="#Verilog通过模块之间的端口连接，进行模块间的通信，但是大型设计，端口连接很容易出错，所以，SV扩展了接口interface" class="headerlink" title="Verilog通过模块之间的端口连接，进行模块间的通信，但是大型设计，端口连接很容易出错，所以，SV扩展了接口interface"></a>Verilog通过模块之间的端口连接，进行模块间的通信，但是大型设计，端口连接很容易出错，所以，SV扩展了接口interface</h5><h5 id="接口提供了面向抽象级建模的方式"><a href="#接口提供了面向抽象级建模的方式" class="headerlink" title="接口提供了面向抽象级建模的方式"></a>接口提供了面向抽象级建模的方式</h5><h5 id="可以简化建模和验证大型复杂的设计"><a href="#可以简化建模和验证大型复杂的设计" class="headerlink" title="可以简化建模和验证大型复杂的设计"></a>可以简化建模和验证大型复杂的设计</h5><h5 id="尤其是标准总线端口，Verilog需要在多个模块重复声明，通信协议也是多次定义，变更之后的更改也很麻烦"><a href="#尤其是标准总线端口，Verilog需要在多个模块重复声明，通信协议也是多次定义，变更之后的更改也很麻烦" class="headerlink" title="尤其是标准总线端口，Verilog需要在多个模块重复声明，通信协议也是多次定义，变更之后的更改也很麻烦"></a>尤其是标准总线端口，Verilog需要在多个模块重复声明，通信协议也是多次定义，变更之后的更改也很麻烦</h5><h5 id="接口允许多个信号被整合到一起，用于表示单一的抽象端口"><a href="#接口允许多个信号被整合到一起，用于表示单一的抽象端口" class="headerlink" title="接口允许多个信号被整合到一起，用于表示单一的抽象端口"></a>接口允许多个信号被整合到一起，用于表示单一的抽象端口</h5><h5 id="多个模块可以使用同一个接口，避免分散端口信号连接"><a href="#多个模块可以使用同一个接口，避免分散端口信号连接" class="headerlink" title="多个模块可以使用同一个接口，避免分散端口信号连接"></a>多个模块可以使用同一个接口，避免分散端口信号连接</h5><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="interface-main-bus"><a href="#interface-main-bus" class="headerlink" title="interface main_bus;"></a>interface main_bus;</h5><p>   …;<br>   …;<br>endinterface</p>
<p>main_bus bus();   &#x2F;&#x2F; 接口实例</p>
<h5 id="接口不止可以包含-变量或者线网，还可以封装模块之间通信的协议"><a href="#接口不止可以包含-变量或者线网，还可以封装模块之间通信的协议" class="headerlink" title="接口不止可以包含 变量或者线网，还可以封装模块之间通信的协议"></a>接口不止可以包含 变量或者线网，还可以封装模块之间通信的协议</h5><h5 id="还可以嵌入与协议有关的断言检查、功能覆盖率收集等模块"><a href="#还可以嵌入与协议有关的断言检查、功能覆盖率收集等模块" class="headerlink" title="还可以嵌入与协议有关的断言检查、功能覆盖率收集等模块"></a>还可以嵌入与协议有关的断言检查、功能覆盖率收集等模块</h5><h5 id="接口不同于模块的地方在于，接口不允许包含设计层次，即接口无法例化模块，但是接口可以例化接口"><a href="#接口不同于模块的地方在于，接口不允许包含设计层次，即接口无法例化模块，但是接口可以例化接口" class="headerlink" title="接口不同于模块的地方在于，接口不允许包含设计层次，即接口无法例化模块，但是接口可以例化接口"></a>接口不同于模块的地方在于，接口不允许包含设计层次，即接口无法例化模块，但是接口可以例化接口</h5><h5 id="可以在接口的声明modport，来约束不同模块连接时信号灯方向"><a href="#可以在接口的声明modport，来约束不同模块连接时信号灯方向" class="headerlink" title="可以在接口的声明modport，来约束不同模块连接时信号灯方向"></a>可以在接口的声明modport，来约束不同模块连接时信号灯方向</h5><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><h5 id="接口定义和模块定义类似"><a href="#接口定义和模块定义类似" class="headerlink" title="接口定义和模块定义类似"></a>接口定义和模块定义类似</h5><h5 id="也可以有端口，例如外部接入的时钟或者复位信号；"><a href="#也可以有端口，例如外部接入的时钟或者复位信号；" class="headerlink" title="也可以有端口，例如外部接入的时钟或者复位信号；"></a>也可以有端口，例如外部接入的时钟或者复位信号；</h5><p>interface main_bus (input logic clock, resetN, test_mode);</p>
<h4 id="例化"><a href="#例化" class="headerlink" title="例化"></a>例化</h4><h5 id="接口的例化方式和模块的例化方式一致"><a href="#接口的例化方式和模块的例化方式一致" class="headerlink" title="接口的例化方式和模块的例化方式一致"></a>接口的例化方式和模块的例化方式一致</h5><h5 id="模块的端口如果声明为input、output、inout，那么在例化时可以不连接"><a href="#模块的端口如果声明为input、output、inout，那么在例化时可以不连接" class="headerlink" title="模块的端口如果声明为input、output、inout，那么在例化时可以不连接"></a>模块的端口如果声明为input、output、inout，那么在例化时可以不连接</h5><h5 id="模块的端口如果声明为interface，那么在例化时必须连接到一个接口的实例，或者另一个接口端口"><a href="#模块的端口如果声明为interface，那么在例化时必须连接到一个接口的实例，或者另一个接口端口" class="headerlink" title="模块的端口如果声明为interface，那么在例化时必须连接到一个接口的实例，或者另一个接口端口"></a>模块的端口如果声明为interface，那么在例化时必须连接到一个接口的实例，或者另一个接口端口</h5><h5 id="如果一个模块拥有一个接口类型的端口，那么索引这个接口中的信号，需要通过-操作符，"><a href="#如果一个模块拥有一个接口类型的端口，那么索引这个接口中的信号，需要通过-操作符，" class="headerlink" title="如果一个模块拥有一个接口类型的端口，那么索引这个接口中的信号，需要通过.操作符，"></a>如果一个模块拥有一个接口类型的端口，那么索引这个接口中的信号，需要通过.操作符，</h5><p>bus.resetN</p>
<h4 id="modport"><a href="#modport" class="headerlink" title="modport"></a>modport</h4><h5 id="接口的线网信号或者变量，对于连接到这个接口的不同模块可能有不同的连接方向，所以引入modport表示不同模块看到同一组信号时的视角方向"><a href="#接口的线网信号或者变量，对于连接到这个接口的不同模块可能有不同的连接方向，所以引入modport表示不同模块看到同一组信号时的视角方向" class="headerlink" title="接口的线网信号或者变量，对于连接到这个接口的不同模块可能有不同的连接方向，所以引入modport表示不同模块看到同一组信号时的视角方向"></a>接口的线网信号或者变量，对于连接到这个接口的不同模块可能有不同的连接方向，所以引入modport表示不同模块看到同一组信号时的视角方向</h5><h5 id="在接口中声明modport，需要指名modport中各个信号灯方向"><a href="#在接口中声明modport，需要指名modport中各个信号灯方向" class="headerlink" title="在接口中声明modport，需要指名modport中各个信号灯方向"></a>在接口中声明modport，需要指名modport中各个信号灯方向</h5><h5 id="当一个模块在例化时，可以选择连接到interface端口中具体的某一个modport"><a href="#当一个模块在例化时，可以选择连接到interface端口中具体的某一个modport" class="headerlink" title="当一个模块在例化时，可以选择连接到interface端口中具体的某一个modport"></a>当一个模块在例化时，可以选择连接到interface端口中具体的某一个modport</h5><h5 id="这种方式可以降低连接方向错误的可能，避免信号多驱动的情况"><a href="#这种方式可以降低连接方向错误的可能，避免信号多驱动的情况" class="headerlink" title="这种方式可以降低连接方向错误的可能，避免信号多驱动的情况"></a>这种方式可以降低连接方向错误的可能，避免信号多驱动的情况</h5><h5 id="interface-chip-bus-…"><a href="#interface-chip-bus-…" class="headerlink" title="interface chip_bus(…);"></a>interface chip_bus(…);</h5><pre><code>modport master(...);
</code></pre>
<p>   modport slave(…);<br>endinterface</p>
<p>module primary(interface pins); &#x2F;&#x2F;通用接口端口<br>…<br>endmodule</p>
<p>module secondary (chip_bus pins);   &#x2F;&#x2F; 特定接口端口<br>…<br>endmodule</p>
<p>module chip (…);<br>   chip_bus bus(..);    &#x2F;&#x2F; 接口实例<br>   primary i1 (bus.master);    &#x2F;&#x2F; 使用master modport方式<br>    secondary i2(bus.slave);   &#x2F;&#x2F; 使用slave modport方式<br>endmodule</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><h5 id="利用接口，可以将测试平台和DUT连接在一起"><a href="#利用接口，可以将测试平台和DUT连接在一起" class="headerlink" title="利用接口，可以将测试平台和DUT连接在一起"></a>利用接口，可以将测试平台和DUT连接在一起</h5><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h5 id="接口对于设计复用很有利"><a href="#接口对于设计复用很有利" class="headerlink" title="接口对于设计复用很有利"></a>接口对于设计复用很有利</h5><h5 id="接口减少了模块之间错误连接的可能性"><a href="#接口减少了模块之间错误连接的可能性" class="headerlink" title="接口减少了模块之间错误连接的可能性"></a>接口减少了模块之间错误连接的可能性</h5><h5 id="如果添加了新的信号，只需要在接口中声明，不需要在每个模块中声明"><a href="#如果添加了新的信号，只需要在接口中声明，不需要在每个模块中声明" class="headerlink" title="如果添加了新的信号，只需要在接口中声明，不需要在每个模块中声明"></a>如果添加了新的信号，只需要在接口中声明，不需要在每个模块中声明</h5><h5 id="由于接口可以将有关信号都集合在一起，可以在使用这些信号时，需要添加接口实例名"><a href="#由于接口可以将有关信号都集合在一起，可以在使用这些信号时，需要添加接口实例名" class="headerlink" title="由于接口可以将有关信号都集合在一起，可以在使用这些信号时，需要添加接口实例名"></a>由于接口可以将有关信号都集合在一起，可以在使用这些信号时，需要添加接口实例名</h5><h5 id="一种接口往往将有关信号集合在一起，因此，对于拥有多组不相关信号的设计而言，需要多个接口才能完成与其他模块的连接"><a href="#一种接口往往将有关信号集合在一起，因此，对于拥有多组不相关信号的设计而言，需要多个接口才能完成与其他模块的连接" class="headerlink" title="一种接口往往将有关信号集合在一起，因此，对于拥有多组不相关信号的设计而言，需要多个接口才能完成与其他模块的连接"></a>一种接口往往将有关信号集合在一起，因此，对于拥有多组不相关信号的设计而言，需要多个接口才能完成与其他模块的连接</h5><h3 id="其他注意点："><a href="#其他注意点：" class="headerlink" title="其他注意点："></a>其他注意点：</h3><h4 id="四值逻辑，比如reg、logic、integer，在仿真开始时的初始值为X"><a href="#四值逻辑，比如reg、logic、integer，在仿真开始时的初始值为X" class="headerlink" title="四值逻辑，比如reg、logic、integer，在仿真开始时的初始值为X"></a>四值逻辑，比如reg、logic、integer，在仿真开始时的初始值为X</h4><h4 id="二值逻辑bit在仿真开始的初值为0"><a href="#二值逻辑bit在仿真开始的初值为0" class="headerlink" title="二值逻辑bit在仿真开始的初值为0"></a>二值逻辑bit在仿真开始的初值为0</h4><h4 id="如果四值逻辑和二值逻辑发生转换，则把X和Z都转为0"><a href="#如果四值逻辑和二值逻辑发生转换，则把X和Z都转为0" class="headerlink" title="如果四值逻辑和二值逻辑发生转换，则把X和Z都转为0"></a>如果四值逻辑和二值逻辑发生转换，则把X和Z都转为0</h4><h4 id="二值逻辑也可以实现可综合电路，但是由于没有X、Z，可能出现仿真行为和综合电路的结果不一致的情况"><a href="#二值逻辑也可以实现可综合电路，但是由于没有X、Z，可能出现仿真行为和综合电路的结果不一致的情况" class="headerlink" title="二值逻辑也可以实现可综合电路，但是由于没有X、Z，可能出现仿真行为和综合电路的结果不一致的情况"></a>二值逻辑也可以实现可综合电路，但是由于没有X、Z，可能出现仿真行为和综合电路的结果不一致的情况</h4><h4 id="SV中还新增了void类型，用于在函数定义时表示无返回值，同C"><a href="#SV中还新增了void类型，用于在函数定义时表示无返回值，同C" class="headerlink" title="SV中还新增了void类型，用于在函数定义时表示无返回值，同C"></a>SV中还新增了void类型，用于在函数定义时表示无返回值，同C</h4><h4 id="SV中添加了shortreal表示32位单精度浮点数，同float；"><a href="#SV中添加了shortreal表示32位单精度浮点数，同float；" class="headerlink" title="SV中添加了shortreal表示32位单精度浮点数，同float；"></a>SV中添加了shortreal表示32位单精度浮点数，同float；</h4><p>而verilog中的real表示双精度浮点型，同double</p>

    </div>

    
    
    
      


    <footer class="post-footer"><div>
    
    <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i
            class="fa fa-paw"></i>再接再厉-------------</div>
    
</div>


<div class="my_post_copyright">
    <p><span>本文标题:</span><a href="/2022/05/10/55/">路科V0SV和Verilog的对比总结</a></p>
    <p><span>文章作者:</span><a href="/" title="访问 Jia 的个人博客">Jia</a></p>
    <p><span>发布时间:</span>2022年05月10日 - 21:05</p>
    <p><span>最后更新:</span>2022年05月10日 - 21:05</p>
    <p><span>原始链接:</span><a href="/2022/05/10/55/" title="路科V0SV和Verilog的对比总结">http://example.com/2022/05/10/55/</a></p>
    <p><span>许可协议:</span><i class="fab fa-creative-commons"></i>
        <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank"
            title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">
            署名-非商业性使用-禁止演绎 4.0 国际</a>
        转载请保留原文链接及作者。
    </p>
</div>

          <div class="post-tags">
              <a href="/tags/UVM/" rel="tag"><i class="fa fa-tag"></i> UVM</a>
              <a href="/tags/System-Verilog/" rel="tag"><i class="fa fa-tag"></i> System Verilog</a>
              <a href="/tags/IC%E9%AA%8C%E8%AF%81/" rel="tag"><i class="fa fa-tag"></i> IC验证</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/05/09/23/" rel="prev" title="路科V0P5P9SV入门">
                  <i class="fa fa-chevron-left"></i> 路科V0P5P9SV入门
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/05/10/00/" rel="next" title="路科V0SVP10P12验证环境">
                  路科V0SVP10P12验证环境 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jia</span>
</div><div>
<!--添加网站运行时间-->
<span>小破站已经在风雨中度过了</span>
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    function createtime() {
        const startTime = '02/11/2021 00:12:55',
            start = new Date(startTime)
        let mill = new Date() - start,
            seconds = Math.floor(mill / 1000),
            mins = Math.floor(seconds / 60),
            hours = Math.floor(mins / 60),
            days = Math.floor(hours / 24)
        const time = {
            seconds: seconds - mins * 60,
            mins: mins - hours * 60,
            hours: hours - days * 24,
        }
        for (const k in time) {
            time[k] = `${time[k]}`.padStart(2, '0')
        }
        document.getElementById("timeDate").innerHTML = ` ${days} 天`
        document.getElementById("times").innerHTML = ` ${time.hours} 小时 ${time.mins} 分 ${time.seconds} 秒`
    }
    setInterval(createtime, 500)
</script>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdn.jsdelivr.net/npm/pdfobject@2.2.7/pdfobject.min.js","integrity":"sha256-ph3Dk89VmuTVXG6x/RDzk53SU9LPdAh1tpv0UvnDZ2I="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>




  




<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: false
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>
