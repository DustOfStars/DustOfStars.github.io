<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1_数据探索</title>
    <url>/2022/03/30/53/</url>
    <content><![CDATA[<h2 id="第一步：简单观察训练集和测试集"><a href="#第一步：简单观察训练集和测试集" class="headerlink" title="第一步：简单观察训练集和测试集"></a>第一步：简单观察训练集和测试集</h2><blockquote>
<p>使用pyplot做直方图观察句子长度分布情况</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> re <span class="keyword">import</span> S</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">length_process</span>(<span class="params">data_dir</span>):</span><br><span class="line">    train_dir = data_dir</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(train_dir, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        tmp_x = []</span><br><span class="line">        <span class="keyword">for</span> i, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(f):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span>  <span class="comment"># skip the first line</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># line 的格式为：0,7442 27878 9601 235 4004 ， 9601 4004 ， 8194 2281 10893,5-30</span></span><br><span class="line">            <span class="comment"># 行号 英文逗号 短句 中文逗号 短句 英文逗号 行号</span></span><br><span class="line">            sent_ = line.strip().split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">            sent_ = [item.strip() <span class="keyword">for</span> item <span class="keyword">in</span> sent_.split(<span class="string">&quot;，&quot;</span>)]</span><br><span class="line">            sent_ = <span class="string">&quot; &quot;</span>.join(item <span class="keyword">for</span> item <span class="keyword">in</span> sent_).strip().split(<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line">            tmp_x.append(<span class="built_in">len</span>(sent_))</span><br><span class="line"></span><br><span class="line">        n, bins, patches = plt.hist(x=tmp_x, bins=<span class="string">&quot;auto&quot;</span>, alpha=<span class="number">0.7</span>, rwidth=<span class="number">0.85</span>)</span><br><span class="line">        plt.grid(axis=<span class="string">&quot;y&quot;</span>, alpha=<span class="number">0.75</span>)</span><br><span class="line">        plt.xlabel(<span class="string">&quot;sentence length&quot;</span>)</span><br><span class="line">        plt.ylabel(<span class="string">&quot;Frequency&quot;</span>)</span><br><span class="line">        plt.title(<span class="string">&quot;Histogram: sentence length&quot;</span>)</span><br><span class="line">        maxfreq = n.<span class="built_in">max</span>()</span><br><span class="line">        <span class="comment"># 设置y轴的上限</span></span><br><span class="line">        plt.ylim(ymax=np.ceil(maxfreq / <span class="number">10</span>) * <span class="number">10</span> <span class="keyword">if</span> maxfreq % <span class="number">10</span> <span class="keyword">else</span> maxfreq + <span class="number">10</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;maxfreq = &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(maxfreq))</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rootdir = os.sep.join(os.path.dirname(__file__).strip().split(os.sep)[:-<span class="number">2</span>])</span><br><span class="line">    train_dir = os.path.join(rootdir, <span class="string">&quot;dataset/datagrand_2021_train.csv&quot;</span>)</span><br><span class="line">    test_dir = os.path.join(rootdir, <span class="string">&quot;dataset/datagrand_2021_test.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line">    length_process(train_dir)</span><br><span class="line">    length_process(test_dir)</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/30/53/Figure_1.png"></p>
]]></content>
      <categories>
        <category>NLP</category>
        <category>EDA</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>NLP</tag>
        <tag>数据探索</tag>
      </tags>
  </entry>
  <entry>
    <title>3_lable词表制作</title>
    <url>/2022/03/30/02/</url>
    <content><![CDATA[<h2 id="第三步：制作lable词表"><a href="#第三步：制作lable词表" class="headerlink" title="第三步：制作lable词表"></a>第三步：制作lable词表</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">vocab_process</span>(<span class="params">data_dir, to_folder</span>):</span><br><span class="line">    <span class="comment"># label, 注意这个模型，标签是分为两层的， level_1是大类， level_2是全部的lable，算作小类</span></span><br><span class="line">    vocab_file_level_1 = os.path.join(to_folder, <span class="string">&quot;labels_level_1.txt&quot;</span>)</span><br><span class="line">    vocab_file_level_2 = os.path.join(to_folder, <span class="string">&quot;labels_level_2.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># label2freq</span></span><br><span class="line">    label2freq_level_1_file = os.path.join(to_folder, <span class="string">&quot;label2freq_level_1.json&quot;</span>)</span><br><span class="line">    label2freq_level_2_file = os.path.join(to_folder, <span class="string">&quot;label2freq_level_2.json&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(data_dir, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        vocab_level_1 = &#123;&#125;</span><br><span class="line">        vocab_level_2 = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(f):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            label_ = line.strip().split(<span class="string">&quot;,&quot;</span>)[-<span class="number">1</span>]</span><br><span class="line">            label_level_1 = label_.strip().split(<span class="string">&quot;-&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">            label_level_2 = label_</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> label_level_1 <span class="keyword">not</span> <span class="keyword">in</span> vocab_level_1:</span><br><span class="line">                vocab_level_1[label_level_1] = <span class="number">0</span></span><br><span class="line">            vocab_level_1[label_level_1] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> label_level_2 <span class="keyword">not</span> <span class="keyword">in</span> vocab_file_level_2:</span><br><span class="line">                vocab_level_2[label_level_2] = <span class="number">0</span></span><br><span class="line">            vocab_level_2[label_level_2] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        json.dump(vocab_level_1, <span class="built_in">open</span>(label2freq_level_1_file, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">        json.dump(vocab_level_2, <span class="built_in">open</span>(label2freq_level_2_file, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"></span><br><span class="line">        vocab_level_1 = <span class="built_in">list</span>(vocab_level_1.items())  <span class="comment"># dict.items() 输出所有的(k, v)元组组成的list</span></span><br><span class="line">        vocab_level_1 = <span class="built_in">sorted</span>(</span><br><span class="line">            vocab_level_1, key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span></span><br><span class="line">        )  <span class="comment"># 按照lable的数量进行排序，从大到小</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;vocab_level_1:&quot;</span>, vocab_level_1)</span><br><span class="line"></span><br><span class="line">        vocab_level_1 = [w[<span class="number">0</span>] <span class="keyword">for</span> w <span class="keyword">in</span> vocab_level_1]</span><br><span class="line"></span><br><span class="line">        vocab_level_2 = <span class="built_in">list</span>(vocab_level_2.items())</span><br><span class="line">        vocab_level_2 = <span class="built_in">sorted</span>(vocab_level_2, key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;vocab_level_2:&quot;</span>, vocab_level_2)</span><br><span class="line">        vocab_level_2 = [w[<span class="number">0</span>] <span class="keyword">for</span> w <span class="keyword">in</span> vocab_level_2]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(vocab_file_level_1, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f_out:</span><br><span class="line">            <span class="keyword">for</span> lab <span class="keyword">in</span> vocab_level_1:</span><br><span class="line">                f_out.write(lab + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(vocab_file_level_2, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f_out:</span><br><span class="line">            <span class="keyword">for</span> lab <span class="keyword">in</span> vocab_level_2:</span><br><span class="line">                f_out.write(lab + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rootdir = os.sep.join(os.path.dirname(__file__).strip().split(os.sep)[:-<span class="number">2</span>])</span><br><span class="line">    train_dir = os.path.join(rootdir, <span class="string">&quot;dataset/datagrand_2021_train.csv&quot;</span>)</span><br><span class="line">    <span class="comment"># test_dir = os.path.join(rootdir, &quot;dataset/datagrand_2021_test.csv&quot;)</span></span><br><span class="line">    phase_1_dir = os.path.join(rootdir, <span class="string">&quot;dataset/phase_1&quot;</span>)</span><br><span class="line">    vocab_process(train_dir, phase_1_dir)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="生成的文件及内容"><a href="#生成的文件及内容" class="headerlink" title="生成的文件及内容"></a>生成的文件及内容</h3><p><img src="/2022/03/30/02/2022-03-31_02-00.png" alt="生成文件"></p>
<p><img src="/2022/03/30/02/2022-03-31_02-01.png" alt="文件内容"></p>
]]></content>
      <categories>
        <category>NLP</category>
        <category>EDA</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>NLP</tag>
        <tag>数据探索</tag>
      </tags>
  </entry>
  <entry>
    <title>4_模型入口</title>
    <url>/2022/04/01/50/</url>
    <content><![CDATA[<p>第四步：模型入口</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> models.model_utils <span class="keyword">import</span> get_embedding_matrix_and_vocab</span><br><span class="line"><span class="keyword">from</span> src.classic_models.training.trainer <span class="keyword">import</span> Trainer</span><br><span class="line"><span class="keyword">from</span> src.classic_models.training.data_loader <span class="keyword">import</span> load_and_cache_examples</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;./&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_logger</span>():</span><br><span class="line">    logging.basicConfig(</span><br><span class="line">        <span class="built_in">format</span>=<span class="string">&quot;%(asctime)s - %(levelname)s - %(name)s -   %(message)s&quot;</span>,</span><br><span class="line">        datefmt=<span class="string">&quot;%m/%d/%Y %H:%M:%S&quot;</span>,</span><br><span class="line">        level=logging.INFO,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_seed</span>(<span class="params">args</span>):</span><br><span class="line">    random.seed(args.seed)</span><br><span class="line">    np.random.seed(args.seed)</span><br><span class="line">    torch.manual_seed(args.seed)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> args.no_cuda <span class="keyword">and</span> torch.cuda.is_available():</span><br><span class="line">        torch.cuda.manual_seed_all(args.seed)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">args</span>):</span><br><span class="line">    init_logger()</span><br><span class="line">    set_seed(args)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># load vocab and w2v</span></span><br><span class="line">    vocab_list, vector_list = get_embedding_matrix_and_vocab(</span><br><span class="line">        args.w2v_file, skip_first_line=<span class="literal">True</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    train_dataset = load_and_cache_examples(args, mode=<span class="string">&quot;train&quot;</span>, vocab_list=vocab_list)</span><br><span class="line">    dev_dataset = load_and_cache_examples(args, mode=<span class="string">&quot;dev&quot;</span>, vocab_list=vocab_list)</span><br><span class="line">    test_dataset = load_and_cache_examples(args, mode=<span class="string">&quot;test&quot;</span>, vocab_list=vocab_list)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;train_dataset: &quot;</span>, <span class="built_in">len</span>(train_dataset))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;dev_dataset: &quot;</span>, <span class="built_in">len</span>(dev_dataset))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;test_dataset: &quot;</span>, <span class="built_in">len</span>(test_dataset))</span><br><span class="line"></span><br><span class="line">    trainer = Trainer(args, train_dataset, dev_dataset, test_dataset)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.do_train:</span><br><span class="line">        trainer.train()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.do_eval:</span><br><span class="line">        trainer.load_model()</span><br><span class="line">        trainer.evaluate(<span class="string">&quot;dev&quot;</span>)</span><br><span class="line"></span><br><span class="line">        trainer.evaluate(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">python src/classic_models/training/main.py --data_dir ./datasets/phase_1/splits/fold_0 </span></span><br><span class="line"><span class="string">--label_file_level_1 datasets/phase_1/labels_level_1.txt </span></span><br><span class="line"><span class="string">--label_file_level_2 datasets/phase_1/labels_level_2.txt </span></span><br><span class="line"><span class="string">--task daguan --random_init_w2v --encoder lstm --aggregator max_pool </span></span><br><span class="line"><span class="string">--model_dir ./experiments/outputs/daguan/lstm_0815_1 --do_train </span></span><br><span class="line"><span class="string">--do_eval --train_batch_size 32 --num_train_epochs 50 </span></span><br><span class="line"><span class="string">--embeddings_learning_rate 6e-4 --learning_rate 20e-4 </span></span><br><span class="line"><span class="string">--classifier_learning_rate 20e-4 --warmup_steps 200 --max_seq_len 128 </span></span><br><span class="line"><span class="string">--hidden_dim 256 --embed_dim 256 </span></span><br><span class="line"><span class="string">--w2v_file resources/word2vec/dim_256/w2v.vectors </span></span><br><span class="line"><span class="string">--dropout_rate 0.2 --metric_key_for_early_stop &quot;macro avg__f1-score__level_2&quot; --logging_steps 400 --patience 5 </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line"></span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--task&quot;</span>, default=<span class="string">&quot;daguan&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&quot;The name of the task to train&quot;</span></span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--model_dir&quot;</span>,</span><br><span class="line">        default=<span class="string">&quot;/data2/code/DaguanFengxian/baseline/experiments/outputs/lstm_max_pool_wv256_epoch100&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">str</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;Path to save, load models&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--data_dir&quot;</span>,</span><br><span class="line">        default=<span class="string">&quot;/data2/nlpData/daguanfengxian/phase_1/splits/fold_0&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">str</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;The input dataload dir&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--label_file_level_1&quot;</span>,</span><br><span class="line">        default=<span class="string">&quot;/data2/nlpData/daguanfengxian/phase_1/labels_level_1.txt&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">str</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;Label file for level 1 label&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--label_file_level_2&quot;</span>,</span><br><span class="line">        default=<span class="string">&quot;/data2/nlpData/daguanfengxian/phase_1/labels_level_2.txt&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">str</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;Label file for level 2 label&quot;</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--seed&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">41</span>, <span class="built_in">help</span>=<span class="string">&quot;random seed for initialization&quot;</span></span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--train_batch_size&quot;</span>, default=<span class="number">32</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, <span class="built_in">help</span>=<span class="string">&quot;Batch size for training.&quot;</span></span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--eval_batch_size&quot;</span>, default=<span class="number">64</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, <span class="built_in">help</span>=<span class="string">&quot;Batch size for evaluation.&quot;</span></span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--max_seq_len&quot;</span>,</span><br><span class="line">        default=<span class="number">128</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">int</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;The maximum total input sequence length after tokenization.&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--num_train_epochs&quot;</span>,</span><br><span class="line">        default=<span class="number">100.0</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">float</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;Total number of training epochs to perform.&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--weight_decay&quot;</span>, default=<span class="number">0.0</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, <span class="built_in">help</span>=<span class="string">&quot;Weight decay if we apply some.&quot;</span></span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--gradient_accumulation_steps&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">int</span>,</span><br><span class="line">        default=<span class="number">1</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;Number of updates steps to accumulate before performing a backward/update pass.&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--adam_epsilon&quot;</span>, default=<span class="number">1e-8</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, <span class="built_in">help</span>=<span class="string">&quot;Epsilon for Adam optimizer.&quot;</span></span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--max_grad_norm&quot;</span>, default=<span class="number">1.0</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, <span class="built_in">help</span>=<span class="string">&quot;Max gradient norm.&quot;</span></span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--max_steps&quot;</span>,</span><br><span class="line">        default=-<span class="number">1</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">int</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;If &gt; 0: set total number of training steps to perform. Override num_train_epochs.&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--warmup_steps&quot;</span>, default=<span class="number">200</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, <span class="built_in">help</span>=<span class="string">&quot;Linear warmup over warmup_steps.&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--logging_steps&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">400</span>, <span class="built_in">help</span>=<span class="string">&quot;Log every X updates steps.&quot;</span></span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--save_steps&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">int</span>,</span><br><span class="line">        default=<span class="number">200</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;Save checkpoint every X updates steps.&quot;</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--do_train&quot;</span>, action=<span class="string">&quot;store_true&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;Whether to run training.&quot;</span></span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--do_eval&quot;</span>, action=<span class="string">&quot;store_true&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;Whether to run eval on the test set.&quot;</span></span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--no_cuda&quot;</span>, action=<span class="string">&quot;store_true&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;Avoid using CUDA when available&quot;</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># ----------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment"># embedding: 随机初始化；</span></span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--random_init_w2v&quot;</span>, action=<span class="string">&quot;store_true&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;是否直接随机初始化embedding； &quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--encoder&quot;</span>,</span><br><span class="line">        default=<span class="string">&quot;lstm&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">str</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;Model type selected in the list: [textcnn, lstm] &quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--aggregator&quot;</span>,</span><br><span class="line">        default=<span class="string">&quot;max_pool&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">str</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;Model type selected in the list: [slf_attn_pool, max_pool, avg_pool, dr_pool, ] &quot;</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--embed_dim&quot;</span>, default=<span class="number">256</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, <span class="built_in">help</span>=<span class="string">&quot;dims for embedding layer.&quot;</span></span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--hidden_dim&quot;</span>, default=<span class="number">256</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, <span class="built_in">help</span>=<span class="string">&quot;dims for intermediate layers.&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--embeddings_learning_rate&quot;</span>,</span><br><span class="line">        default=<span class="number">6e-4</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">float</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;The learning rate for Adam.&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--learning_rate&quot;</span>, default=<span class="number">20e-4</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, <span class="built_in">help</span>=<span class="string">&quot;The learning rate for Adam.&quot;</span></span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--classifier_learning_rate&quot;</span>,</span><br><span class="line">        default=<span class="number">20e-4</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">float</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;The learning rate for Adam.&quot;</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--w2v_file&quot;</span>,</span><br><span class="line">        default=<span class="string">&quot;/data2/nlpData/daguanfengxian/word2vec/dim_256_sg_0_hs_1_epochs_30/w2v.vectors&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">str</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;path to pretrained word2vec file&quot;</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    parser.add_argument(<span class="string">&quot;--dropout_rate&quot;</span>, default=<span class="number">0.2</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, <span class="built_in">help</span>=<span class="string">&quot;dropout_rate &quot;</span>)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--patience&quot;</span>, default=<span class="number">5</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, <span class="built_in">help</span>=<span class="string">&quot;patience for early stopping &quot;</span></span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--metric_key_for_early_stop&quot;</span>,</span><br><span class="line">        default=<span class="string">&quot;macro avg__f1-score__level_2&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">str</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;metric name for early stopping &quot;</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># prediction_output_file</span></span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--prediction_output_file&quot;</span>,</span><br><span class="line">        default=<span class="literal">None</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">str</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;file for writing out the predictions &quot;</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 针对不均衡样本</span></span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--class_weights_level_1&quot;</span>,</span><br><span class="line">        default=<span class="literal">None</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">str</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;class_weights, written in string like &#x27;1.0,2.0,2.0,5.0,200.0,300.0,400.0,500.0,500.0&#x27; &quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--class_weights_level_2&quot;</span>,</span><br><span class="line">        default=<span class="literal">None</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">str</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;class_weights, written in string like &#x27;0.828,1.241,1.465,1.622,1.963,2.002,2.173,2.507,2.564,2.572,2.707,4.244,4.469,4.953,5.460,5.693,6.477,6.694,7.174,7.804,8.648,8.988,9.090,10.06,10.25,11.94,15.53,25.80,32.65,48.48,50.0,80.0,84.21,88.88,100.0&#x27; &quot;</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    parser.add_argument(<span class="string">&quot;--use_focal_loss&quot;</span>, default=<span class="string">&quot;True&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;use focal loss&quot;</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--focal_loss_gamma&quot;</span>, default=<span class="number">2.0</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, <span class="built_in">help</span>=<span class="string">&quot;gamma in focal loss&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ----------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    main(args)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>这一部分非常需要展开来看，先从models&#x2F;model_untils.py开始：</strong></p>
</blockquote>
<h2 id="model-untils-py-存放功能组件函数"><a href="#model-untils-py-存放功能组件函数" class="headerlink" title="model_untils.py 存放功能组件函数"></a>model_untils.py 存放功能组件函数</h2><h3 id="1-加载w2v生成的embedding"><a href="#1-加载w2v生成的embedding" class="headerlink" title="1. 加载w2v生成的embedding"></a>1. 加载w2v生成的embedding</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_embedding_matrix_and_vocab</span>(<span class="params">w2v_file, skip_first_line=<span class="literal">True</span>, include_special_tokens=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Construct embedding matrix</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        embed_dic : word-embedding dictionary</span></span><br><span class="line"><span class="string">        skip_first_line : 是否跳过第一行</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        embedding_matrix: return embedding matrix (numpy)</span></span><br><span class="line"><span class="string">        embedding_matrix: return embedding matrix</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    embedding_dim = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 先遍历一次，得到一个vocab list 和向量list</span></span><br><span class="line">    vocab_list = []</span><br><span class="line">    vector_list = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(w2v_file, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f_in:</span><br><span class="line">        <span class="keyword">for</span> i, line <span class="keyword">in</span> tqdm.tqdm(<span class="built_in">enumerate</span>(f_in)):</span><br><span class="line">            <span class="keyword">if</span> skip_first_line:</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">            line = line.strip()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            line = line.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">            w_ = line[<span class="number">0</span>]</span><br><span class="line">            vec_ = line[<span class="number">1</span>:]</span><br><span class="line">            vec_ = [<span class="built_in">float</span>(w.strip()) <span class="keyword">for</span> w <span class="keyword">in</span> vec_]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> embedding_dim == <span class="literal">None</span>:</span><br><span class="line">                embedding_dim = <span class="built_in">len</span>(vec_)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">assert</span> embedding_dim == <span class="built_in">len</span>(vec_)</span><br><span class="line"></span><br><span class="line">            vocab_list.append(w_)</span><br><span class="line">            vector_list.append(vec_)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加两个特殊字符：PAD和UNK</span></span><br><span class="line">    <span class="keyword">if</span> include_special_tokens:</span><br><span class="line">        vocab_list = [<span class="string">&#x27;pad&#x27;</span>, <span class="string">&#x27;unk&#x27;</span>] + vocab_list</span><br><span class="line">        <span class="comment"># 随机初始化两个向量</span></span><br><span class="line">        pad_vec_ = (np.random.rand(embedding_dim).astype(np.float32) * <span class="number">0.05</span>).tolist()</span><br><span class="line">        unk_vec_ = (np.random.rand(embedding_dim).astype(np.float32) * <span class="number">0.05</span>).tolist()</span><br><span class="line">        vector_list = [pad_vec_, unk_vec_] + vector_list</span><br><span class="line">    <span class="keyword">return</span> vocab_list, vector_list</span><br></pre></td></tr></table></figure>

<blockquote>
<p>models&#x2F;training&#x2F;data_loader.py 部分</p>
</blockquote>
<h2 id="data-loader-py-加载数据的函数"><a href="#data-loader-py-加载数据的函数" class="headerlink" title="data_loader.py 加载数据的函数"></a>data_loader.py 加载数据的函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_and_cache_examples</span>(<span class="params">args, mode, vocab_list=<span class="literal">None</span></span>):</span><br><span class="line">    processor = processors[args.task](args)</span><br><span class="line"></span><br><span class="line">    cached_features_file = os.path.join(</span><br><span class="line">        args.data_dir, <span class="string">&quot;cached_&#123;&#125;_&#123;&#125;_&#123;&#125;&quot;</span>.<span class="built_in">format</span>(mode, args.task, args.max_seq_len)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(cached_features_file):</span><br><span class="line">        logger.info(<span class="string">&quot;Loading features from cached file %s&quot;</span>, cached_features_file)</span><br><span class="line">        features = torch.load(cached_features_file)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        logger.info(<span class="string">&quot;Creating features from dataset file at %s&quot;</span>, args.data_dir)</span><br><span class="line">        <span class="keyword">if</span> mode == <span class="string">&quot;train&quot;</span>:</span><br><span class="line">            examples = processor.get_examples(<span class="string">&quot;train&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> mode == <span class="string">&quot;dev&quot;</span>:</span><br><span class="line">            examples = processor.get_examples(<span class="string">&quot;dev&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> mode == <span class="string">&quot;test&quot;</span>:</span><br><span class="line">            examples = processor.get_examples(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;For mode, Only train, dev, test is available&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Use cross entropy ignore index as padding label id so that only real label ids contribute to the loss later</span></span><br><span class="line">        features = convert_examples_to_features(</span><br><span class="line">            examples, args.max_seq_len, vocab_list=vocab_list</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;Saving features into cached file %s&quot;</span>, cached_features_file)</span><br><span class="line">        torch.save(features, cached_features_file)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Convert to Tensors and build dataset</span></span><br><span class="line">    all_input_ids = torch.tensor([f.input_ids <span class="keyword">for</span> f <span class="keyword">in</span> features], dtype=torch.long)</span><br><span class="line">    all_attention_mask = torch.tensor(</span><br><span class="line">        [f.attention_mask <span class="keyword">for</span> f <span class="keyword">in</span> features], dtype=torch.long</span><br><span class="line">    )</span><br><span class="line">    all_label_id_level_1s = torch.tensor(</span><br><span class="line">        [f.label_id_level_1 <span class="keyword">for</span> f <span class="keyword">in</span> features], dtype=torch.long</span><br><span class="line">    )</span><br><span class="line">    all_label_id_level_2s = torch.tensor(</span><br><span class="line">        [f.label_id_level_2 <span class="keyword">for</span> f <span class="keyword">in</span> features], dtype=torch.long</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    dataset = TensorDataset(</span><br><span class="line">        all_input_ids,</span><br><span class="line">        all_attention_mask,</span><br><span class="line">        all_label_id_level_1s,</span><br><span class="line">        all_label_id_level_2s,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataset</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>NLP</category>
        <category>Torch</category>
        <category>Model</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>NLP</tag>
        <tag>Torch</tag>
        <tag>Model</tag>
      </tags>
  </entry>
  <entry>
    <title>BLE的分层介绍</title>
    <url>/2022/08/29/05/</url>
    <content><![CDATA[<h1 id="深入浅出低功耗蓝牙-BLE-协议栈"><a href="#深入浅出低功耗蓝牙-BLE-协议栈" class="headerlink" title="深入浅出低功耗蓝牙(BLE)协议栈"></a>深入浅出低功耗蓝牙(BLE)协议栈</h1><blockquote>
<p>BLE协议栈为什么要分层？怎么理解BLE“连接”？如果BLE协议只有ATT层没有GATT层会发生什么？</p>
</blockquote>
<h2 id="1-协议栈框架"><a href="#1-协议栈框架" class="headerlink" title="1.协议栈框架"></a>1.协议栈框架</h2><p>一般而言，我们把某个协议的实现代码称为协议栈（protocol stack），BLE协议栈就是实现低功耗蓝牙协议的代码，理解和掌握BLE协议是实现BLE协议栈的前提。在深入BLE协议栈各个组成部分之前，我们先看一下BLE协议栈整体架构。</p>
<p>要实现一个BLE应用，首先需要一个支持BLE射频的芯片，然后还需要提供一个与此芯片配套的BLE协议栈，最后在协议栈上开发自己的应用。可以看出BLE协议栈是连接芯片和应用的桥梁，是实现整个BLE应用的关键。</p>
<p>那BLE协议栈具体包含哪些功能呢？简单来说，<strong>BLE协议栈主要用来对你的应用数据进行层层封包，以生成一个满足BLE协议的空中数据包，也就是说，把应用数据包裹在一系列的帧头（header）和帧尾（tail）中。具体来说，BLE协议栈主要由如下几部分组成：</strong></p>
<ul>
<li>PHY层（Physical layer物理层）。<strong>PHY层用来指定BLE所用的无线频段，调制解调方式和方法等</strong>。PHY层做得好不好，直接决定整个BLE芯片的功耗，灵敏度以及selectivity等射频指标。</li>
<li>LL层（Link Layer链路层）。LL层是整个BLE协议栈的核心，也是BLE协议栈的难点和重点。像Nordic的BLE协议栈能同时支持20个link（连接），就是LL层的功劳。LL层要做的事情非常多，比如<strong>具体选择哪个射频通道进行通信，怎么识别空中数据包，具体在哪个时间点把数据包发送出去，怎么保证数据的完整性，ACK如何接收，如何进行重传，以及如何对链路进行管理和控制等等。LL层只负责把数据发出去或者收回来，对数据进行怎样的解析则交给上面的GAP或者ATT</strong>。</li>
<li>HCI（Host controller interface）。HCI是可选的（具体请参考文章： <a href="https://www.cnblogs.com/iini/p/8834970.html">三种蓝牙架构实现方案（蓝牙协议栈方案）</a>），<strong>HCI主要用于2颗芯片实现BLE协议栈的场合，用来规范两者之间的通信协议和通信命令等</strong>。</li>
<li>GAP层（Generic access profile）。GAP是对LL层payload（有效数据包）如何进行解析的两种方式中的一种，而且是最简单的那一种。GAP简单的对LL payload进行一些规范和定义，因此GAP能实现的功能极其有限。<strong>GAP目前主要用来进行广播，扫描和发起连接等</strong>。</li>
<li>L2CAP层（Logic link control and adaptation protocol）。L2CAP对LL进行了一次简单封装，<strong>LL只关心传输的数据本身，L2CAP就要区分是加密通道还是普通通道，同时还要对连接间隔进行管理</strong>。</li>
<li>SMP（Secure manager protocol）。SMP用来管理BLE连接的加密和安全的，如何保证连接的安全性，同时不影响用户的体验，这些都是SMP要考虑的工作。</li>
<li>ATT（Attribute protocol）。简单来说，<strong>ATT层用来定义用户命令及命令操作的数据，比如读取某个数据或者写某个数据</strong>。BLE协议栈中，<strong>开发者接触最多的就是ATT</strong>。BLE引入了attribute概念，用来描述一条一条的数据。Attribute除了定义数据，同时定义该数据可以使用的ATT命令，因此这一层被称为ATT层。</li>
<li>GATT（Generic attribute profile ）。<strong>GATT用来规范attribute中的数据内容，并运用group（分组）的概念对attribute进行分类管理。没有GATT，BLE协议栈也能跑，但互联互通就会出问题，也正是因为有了GATT和各种各样的应用profile，BLE摆脱了ZigBee等无线协议的兼容性困境，成了出货量最大的2.4G无线通信产品</strong>。</li>
</ul>
<p>我相信很多人看了上面的介绍，还是不懂BLE协议栈的工作原理，以及每一层具体干什么的，为什么要这么分层。下面我以如何发送一个数据包为例来讲解BLE协议栈各层是如何紧密配合，以完成发送任务的。</p>
<h2 id="2-如何通过无线发送一个数据包"><a href="#2-如何通过无线发送一个数据包" class="headerlink" title="2. 如何通过无线发送一个数据包"></a>2. 如何通过无线发送一个数据包</h2><p>假设有设备A和设备B，设备A要把自己目前的电量状态83%（十六进制表示为0x53）发给设备B，该怎么做呢？作为一个开发者，他希望越简单越好，对他而言，他希望调用一个简单的API就能完成这件事，比如<code>send(0x53)</code>，实际上我们的BLE协议栈就是这样设计的，开发者只需调用<code>send(0x53)</code>就可以把数据发送出去了，其余的事情BLE协议栈帮你搞定。很多人会想，BLE协议栈是不是直接在物理层就把0x53发出去?</p>
<p>这种方式初看起来挺美的，但由于很多细节没有考虑到，实际是不可行的。首先，它没有考虑用哪一个<strong>射频信道</strong>来进行传输，在不更改API的情况下，我们只能对协议栈进行分层，为此引入<strong>LL层</strong>，开发者还是调用<code>send(0x53)</code>，<code>send(0x53)</code>再调用<code>send_LL(0x53,2402M)</code>（注：2402M为信道频率）。这里还有一个问题，设备B怎么知道这个数据包是发给自己的还是其他人的，为此BLE引入<strong>access address</strong>概念，<strong>用来指明接收者身份</strong>，其中，<code>0x8E89BED6</code>这个access address比较特殊，它表示要发给周边所有设备，即<strong>广播</strong>。如果你要<strong>一对一的进行通信（BLE协议将其称为连接）</strong>，即设备A的数据包只能设备B接收，同样设备B的数据包只能设备A接收，那么就必须<strong>生成一个独特的随机access address以标识设备A和设备B两者之间的连接</strong>。</p>
<h3 id="2-1-广播方式"><a href="#2-1-广播方式" class="headerlink" title="2.1 广播方式"></a>2.1 广播方式</h3><p>我们先来看一下简单的广播情况，这种情况下，我们把设备A叫<strong>advertiser</strong>（广播者），设备B叫<strong>scanner</strong>或者<strong>observer</strong>（扫描者）。</p>
<p>广播状态下设备A的LL层API将变成<code>send_LL(0x53,2402M, 0x8E89BED6)</code>。由于设备B可以同时接收到很多设备的广播，因此数据包还必须包含设备A的<code>device address（0xE1022AAB753B）</code>以确认该广播包来自设备A，为此<code>send_LL</code>参数需要变成<code>(0x53,2402M, 0x8E89BED6, 0xE1022AAB753B)</code>。</p>
<p>LL层还要<strong>检查数据的完整性</strong>，即数据在传输过程中有没有发生窜改，为此引入<strong>CRC24</strong>对数据包进行检验 (假设为0xB2C78E) 。同时为了调制解调电路工作更高效，<em>每一个数据包的最前面会加上1个字节的preamble（前导帧）</em>，preamble一般为0x55或者0xAA。这样，整个空中包就变成（注：空中包用小端模式表示！）：??</p>
<p>上面这个数据包还有如下问题：</p>
<ul>
<li><strong>没有对数据包进行分类组织</strong>，设备B无法找到自己想要的数据0x53。为此我们需要在<code>access address</code>之后加入两个字段：<strong>LL header和长度字节</strong>。<ul>
<li>LL header用来表示数据包的LL类型，</li>
<li>长度字节用来指明payload的长度</li>
</ul>
</li>
<li>设备B什么时候开启射频窗口以接收空中数据包？当设备A的数据包在空中传输的时候，设备B把接收窗口关闭，此时通信将失败；当设备A没有在空中发送数据包时，设备B把接收窗口打开，此时通信也将失败。只有设备A的数据包在空中传输时，设备B正好打开射频接收窗口，此时通信才能成功，换句话说，<strong>LL层还必须定义通信时序</strong>。</li>
<li>当设备B拿到数据0x53后，该<strong>如何解析这个数据呢</strong>？它到底表示湿度还是电量，还是别的意思？<strong>这个就是GAP层要做的工作，GAP层引入了LTV（Length-Type-Value）结构来定义数据</strong>，比如020105，02-长度，01-类型（强制字段，表示广播flag，广播包必须包含该字段），05-值。由于广播包最大只能为31个字节，它能定义的数据类型极其有限，像这里说的电量，GAP就没有定义，因此要通过广播方式把电量数据发出去，<strong>只能使用供应商自定义数据类型0xFF，即04FF590053，其中04表示长度，FF表示数据类型（自定义数据），0x0059是供应商ID（自定义数据中的强制字段），0x53就是我们的数据(设备双方约定0x53就是表示电量，而不是其他意思)。</strong></li>
</ul>
<p>最终空中传输的数据包将变成：<code>AAD6BE898E600E3B75AB2A02E102010504FF5900538EC7B2</code></p>
<ul>
<li>AA – 前导帧(preamble)</li>
<li>D6BE898E – 访问地址(access address)</li>
<li>60 – LL帧头字段(LL header)</li>
<li>0E – 有效数据包长度(payload length)</li>
<li>3B75AB2A02E1 – 广播者设备地址(advertiser address)</li>
<li>02010504FF590053 – 广播数据</li>
<li>8EC7B2 – CRC24值</li>
</ul>
<p>有了PHY，LL和GAP，就可以发送广播包了，但广播包携带的信息极其有限，而且还有如下几大限制：</p>
<ul>
<li>无法进行一对一通信 （广播是一对多通信，而且是单方向的通信）</li>
<li>由于不支持组包和拆包，因此无法传输大数据</li>
<li>通信不可靠。广播信道不能太多，否则将导致扫描端效率低下。为此，BLE只使用37(2402MHz) &#x2F;38(2426MHz) &#x2F;39(2480MHz)三个信道进行广播和扫描，因此广播不支持跳频。由于广播是一对多的，所以广播也无法支持ACK。这些都使广播通信变得不可靠。</li>
<li>扫描端功耗高。由于扫描端不知道设备端何时广播，也不知道设备端选用哪个频道进行广播，扫描端只能拉长扫描窗口时间，并同时对37&#x2F;38&#x2F;39三个通道进行扫描，这样功耗就会比较高。</li>
</ul>
<p>而<strong>连接</strong>则可以很好解决上述问题，下面我们就来看看连接是如何将0x53发送出去的。</p>
<h3 id="2-2-连接方式"><a href="#2-2-连接方式" class="headerlink" title="2.2 连接方式"></a>2.2 连接方式</h3><p>到底什么叫连接(connection)？像有线UART，很容易理解，就是用线（Rx和Tx等）把设备A和设备B相连，即为连接。用“线”把两个设备相连，实际是让2个设备有共同的通信媒介，并让两者时钟同步起来。蓝牙连接有何尝不是这个道理，<strong>所谓设备A和设备B建立蓝牙连接，就是指设备A和设备B两者“同步”成功</strong>，其具体包含以下几方面：</p>
<ul>
<li>设备A和设备B对接下来要使用的<strong>物理信道</strong>达成一致</li>
<li>设备A和设备B双方<strong>建立一个共同的时间锚点</strong>，也就是说，把双方的时间原点变成同一个点</li>
<li>设备A和设备B两者<strong>时钟同步成功</strong>，即双方都知道对方什么时候发送数据包什么时候接收数据包</li>
<li>连接成功后，设备A和设备B通信流程如下所示：</li>
</ul>
<p>一旦设备A和设备B连接成功（此种情况下，我们把设备A称为Master或者Central，把设备B称为Slave或者Peripheral），<strong>设备A将周期性以CI（connection interval）为间隔向设备B发送数据包，而设备B也周期性地以CI为间隔打开射频接收窗口以接收设备A的数据包</strong>。</p>
<p>同时按照蓝牙spec要求，<strong>设备B收到设备A数据包<code>150us</code>后，设备B切换到发送状态，把自己的数据发给设备A；设备A则切换到接收状态，接收设备B发过来的数据</strong>。</p>
<p>由此可见，连接状态下，设备A和设备B的射频发送和接收窗口都是周期性地有计划地开和关，而且开的时间非常短，从而大大减低系统功耗并大大提高系统效率。</p>
<p>现在我们看看连接状态下是如何把数据0x53发送出去的，从中大家可以体会到蓝牙协议栈分层的妙处。</p>
<ul>
<li><p>对开发者来说，很简单，他只需要调用<code>send(0x53)</code></p>
</li>
<li><p>GATT层<strong>定义数据的类型和分组</strong>，方便起见，我们用0x0013表示电量这种数据类型，这样GATT层把数据打包成130053（<em><strong>小端模式！</strong></em>）</p>
</li>
<li><p>ATT层用来<strong>选择具体的通信命令</strong>，比如读&#x2F;写&#x2F;notify&#x2F;indicate等，这里选择notify命令0x1B，这样数据包变成了：<code>1B130053</code></p>
</li>
<li><p>L2CAP用来<strong>指定connection interval（连接间隔）</strong>，比如每10ms同步一次（CI不体现在数据包中），同时<strong>指定逻辑通道编号</strong>0004（表示ATT命令），最后把ATT数据长度0x0004加在包头，这样数据就变为：040004001B130053</p>
</li>
<li><p>LL层要做的工作很多，首先LL层需要<strong>指定用哪个物理信道进行传输</strong>（物理信道不体现在数据包中），然后再给此连接<strong>分配一个Access address</strong>（0x50655DAB）以标识此连接只为设备A和设备B直连服务，然后加上<code>LL header</code>和<code>payload length</code>字段，LL header标识此packet为数据packet，而不是control packet等，payload length为整个L2CAP字段的长度，最后加上CRC24字段，以保证整个packet的数据完整性，所以数据包最后变成：<code>AAAB5D65501E08040004001B130053D550F6</code></p>
</li>
<li><p>AA – 前导帧(preamble)</p>
</li>
<li><p>0x50655DAB – 访问地址(access address)</p>
</li>
<li><p>1E – LL帧头字段(LL header)</p>
</li>
<li><p>08 – 有效数据包长度(payload length)</p>
</li>
<li><p>04000400 – ATT数据长度，以及L2CAP通道编号</p>
</li>
<li><p>1B – notify command</p>
</li>
<li><p>0x0013 – 电量数据handle</p>
</li>
<li><p>0x53 – 真正要发送的电量数据</p>
</li>
<li><p>0xF650D5 – CRC24值</p>
</li>
</ul>
<p>虽然开发者只调用了 <code>send(0x53)</code>，但由于低功耗蓝牙协议栈层层打包，最后空中实际传输的数据将变成上面所示的模样，这就既满足了低功耗蓝牙通信的需求，又让用户API变得简单，可谓一箭双雕！</p>
<p>上面只是对BLE协议栈实现原理做了一个简单概述，即便如此，由于都是关于BLE协议栈底层的东西，很多开发者还是会觉得比较枯燥和晦涩，而且对很多开发者来说，他们也不关心BLE协议栈是如何实现的，他们更关心的是BLE协议栈的使用，即怎么开发一个BLE应用。BLE应用是实打实的东西，不能像上面讲述协议栈一样泛泛而谈，必须结合具体的蓝牙芯片和蓝牙协议栈来讲解，为此后面将以Nordic芯片及协议栈作为范例，来具体讲解如何开发BLE应用，以及如何通过代码去理解BLE协议中定义的一些概念和术语。</p>
]]></content>
      <categories>
        <category>NXP</category>
      </categories>
      <tags>
        <tag>BLE</tag>
        <tag>NXP</tag>
      </tags>
  </entry>
  <entry>
    <title>C++STL--单向链表&lt;forward_list&gt;</title>
    <url>/2022/03/19/57/</url>
    <content><![CDATA[<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    forward_list&lt;<span class="type">int</span>&gt; l; <span class="comment">//构造空的单向链表</span></span><br><span class="line">    <span class="comment">//不提供size()的成员方法，使用算法distance()获取</span></span><br><span class="line">    cout &lt;&lt; l.<span class="built_in">max_size</span>() &lt;&lt; endl; <span class="comment">//最大的元素个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function">forward_list&lt;<span class="type">int</span>&gt; <span class="title">l2</span><span class="params">(<span class="number">5</span>)</span></span>;                         <span class="comment">//构造5个元素的单向链表，值为类型的默认值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一个元素值：&quot;</span> &lt;&lt; *l2.<span class="built_in">begin</span>() &lt;&lt; endl; <span class="comment">//最大的元素个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function">forward_list&lt;<span class="type">int</span>&gt; <span class="title">l3</span><span class="params">(<span class="number">5</span>, <span class="number">111</span>)</span></span>;                    <span class="comment">//构造5个元素的单向链表，每个元素值为111</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一个元素值：&quot;</span> &lt;&lt; *l3.<span class="built_in">begin</span>() &lt;&lt; endl; <span class="comment">//最大的元素个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function">forward_list&lt;<span class="type">int</span>&gt; <span class="title">l4</span><span class="params">(l3)</span></span>;                        <span class="comment">//拷贝构造</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一个元素值：&quot;</span> &lt;&lt; *l4.<span class="built_in">begin</span>() &lt;&lt; endl; <span class="comment">//最大的元素个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证forward_list的内存结构(不连续)</span></span><br><span class="line">    <span class="keyword">for</span> (forward_list&lt;<span class="type">int</span>&gt;::iterator it = l3.<span class="built_in">begin</span>(); it != l3.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &amp;(*it) &lt;&lt; <span class="string">&quot;    &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 576460752303423487</span></span><br><span class="line"><span class="comment">// 第一个元素值：0</span></span><br><span class="line"><span class="comment">// 第一个元素值：111</span></span><br><span class="line"><span class="comment">// 第一个元素值：111</span></span><br><span class="line"><span class="comment">// 0x55555556d368    0x55555556d388    0x55555556d3a8    0x55555556d3c8    0x55555556d3e8   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="迭代器使用"><a href="#迭代器使用" class="headerlink" title="迭代器使用"></a>迭代器使用</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(T begin, T end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (T p = begin; p != end; ++p)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *p &lt;&lt; <span class="string">&quot;     &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">forward_list&lt;<span class="type">int</span>&gt; <span class="title">l3</span><span class="params">(<span class="number">5</span>, <span class="number">111</span>)</span></span>;                    <span class="comment">//构造5个元素的单向链表，每个元素值为111</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一个元素值：&quot;</span> &lt;&lt; *l3.<span class="built_in">begin</span>() &lt;&lt; endl; <span class="comment">//最大的元素个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证迭代器类别,forward  iterator 前向迭代器</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(forward_list&lt;<span class="type">int</span>&gt;::iterator::iterator_category).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前向迭代器 比 双向迭代器 功能更少一些，支持++、= 、！= 、 == 、 * ，不支持 --</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支持++    *   =</span></span><br><span class="line">    forward_list&lt;<span class="type">int</span>&gt;::iterator it = l3.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">    *(++it) = <span class="number">222</span>;</span><br><span class="line">    *(++it) = <span class="number">333</span>;</span><br><span class="line">    *(++it) = <span class="number">444</span>;</span><br><span class="line">    *(++it) = <span class="number">555</span>; <span class="comment">//指向最后一个</span></span><br><span class="line"></span><br><span class="line">    ++it; <span class="comment">//指向最后一个的下一个</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;是否指向最后一个的下一个: &quot;</span> &lt;&lt; (it == l3.<span class="built_in">end</span>()) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//--it;//不可以--，因为是单向的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// const_iterator指向的元素不可赋值</span></span><br><span class="line">    forward_list&lt;<span class="type">int</span>&gt;::const_iterator it2 = l3.<span class="built_in">cbegin</span>();</span><br><span class="line">    <span class="comment">//*it2 = 1;//const_iterator指向的元素不可赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//正向遍历forward_list</span></span><br><span class="line">    <span class="keyword">for</span> (forward_list&lt;<span class="type">int</span>&gt;::iterator it = l3.<span class="built_in">begin</span>(); it != l3.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot;    &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有反向的迭代器，不支持，因为是单向链表</span></span><br><span class="line">    <span class="comment">// forward_list&lt;int&gt;::reverse_iterator</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证Print ,迭代器带来的好处，让算法无需知道容器的细节</span></span><br><span class="line">    Print&lt;forward_list&lt;<span class="type">int</span>&gt;::iterator&gt;(l3.<span class="built_in">begin</span>(), l3.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// --- 输出 ---</span></span><br><span class="line"><span class="comment">// 第一个元素值：111</span></span><br><span class="line"><span class="comment">// St20forward_iterator_tag</span></span><br><span class="line"><span class="comment">// 是否指向最后一个的下一个: 1</span></span><br><span class="line"><span class="comment">// 111    222    333    444    555    </span></span><br><span class="line"><span class="comment">// 111     222     333     444     555</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="增加、删除、插入元素"><a href="#增加、删除、插入元素" class="headerlink" title="增加、删除、插入元素"></a>增加、删除、插入元素</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    forward_list&lt;<span class="type">int</span>&gt; l;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 温习一下单链表的插入</span></span><br><span class="line"><span class="comment">    pNew-&gt;next =  pHead -&gt;next;//新节点的下一个指向插入前的第一个节点</span></span><br><span class="line"><span class="comment">    pHead -&gt;next= pNew;//将头指针指向新节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    l.<span class="built_in">push_front</span>(<span class="number">111</span>); <span class="comment">//从头部插入元素</span></span><br><span class="line">    l.<span class="built_in">push_front</span>(<span class="number">222</span>); <span class="comment">//从头部插入元素</span></span><br><span class="line">    l.<span class="built_in">push_front</span>(<span class="number">333</span>); <span class="comment">//从头部插入元素</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       为什么没有insert_before() ？</span></span><br><span class="line"><span class="comment">     pInsert -&gt;next;</span></span><br><span class="line"><span class="comment">     你无法知道当前节点的前一个节点的地址，所以，你就无法将前一个的pLast-&gt;next=pNew</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     为什么insert_after()可以？</span></span><br><span class="line"><span class="comment">     pNew-&gt;next= pInsert-&gt;next;</span></span><br><span class="line"><span class="comment">     pInsert-&gt;next = pNew;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    l.<span class="built_in">insert_after</span>(l.<span class="built_in">begin</span>(), <span class="number">444</span>); <span class="comment">//在某个迭代器后面插入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (forward_list&lt;<span class="type">int</span>&gt;::iterator it = l.<span class="built_in">begin</span>(); it != l.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot;    &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问头结点</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;front():  &quot;</span> &lt;&lt; l.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 温习一下单链表的删除</span></span><br><span class="line"><span class="comment">    pHead -&gt;next= pDelete-&gt;next;//将头指针指向删除节点的下一个</span></span><br><span class="line"><span class="comment">    delete pDelete；//删除当前节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    l.<span class="built_in">pop_front</span>(); <span class="comment">//删除头结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    为什么没有erase_before(),还是因为，你无法知道pDelete的前一个，</span></span><br><span class="line"><span class="comment">    你就无法将前一个的pLast-&gt;next= pDelete-&gt;next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    为什么erase_after()可以?</span></span><br><span class="line"><span class="comment">    pTemp= pDelete-&gt;next;</span></span><br><span class="line"><span class="comment">    pDelete-&gt;next= pDelete-&gt;next-&gt;next;</span></span><br><span class="line"><span class="comment">    delete pTemp;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    l.<span class="built_in">erase_after</span>(l.<span class="built_in">begin</span>()); <span class="comment">//删除迭代器节点的下一个</span></span><br><span class="line"></span><br><span class="line">    l.<span class="built_in">erase_after</span>(l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>()); <span class="comment">//删除迭代器区间</span></span><br><span class="line"></span><br><span class="line">    l.<span class="built_in">clear</span>(); <span class="comment">//删除所有元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (forward_list&lt;<span class="type">int</span>&gt;::iterator it = l.<span class="built_in">begin</span>(); it != l.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot;    &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="尝试运行LeetCode206-反转链表"><a href="#尝试运行LeetCode206-反转链表" class="headerlink" title="尝试运行LeetCode206.反转链表"></a>尝试运行LeetCode206.反转链表</h2>]]></content>
      <categories>
        <category>STL</category>
        <category>forward_list</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>ROM_RAM_FLASH傻傻分不清楚</title>
    <url>/2022/07/28/11/</url>
    <content><![CDATA[<h2 id="ROM-Read-Only-Memory-程序存储器"><a href="#ROM-Read-Only-Memory-程序存储器" class="headerlink" title="ROM (Read Only Memory)程序存储器"></a>ROM (Read Only Memory)程序存储器</h2><p>是一种只能读出<strong>事先所存的数据</strong>的固态半导体存储器。ROM中所存数据稳定，<strong>一旦存储数据就再也无法将之改变或者删除，断电后所存数据也不会消失</strong>。其结构简单，因而<strong>常用于存储各种固化程序和数据</strong>。</p>
<p>在单片机中<strong>用来存储程序数据及常量数据或变量数据，凡是c文件及h文件中所有代码、全局变量、局部变量、‘const’限定符定义的常量数据、startup.asm文件中的代码（类似ARM中的bootloader或者X86中的BIOS，一些低端的单片机是没有这个的）通通都存储在ROM中</strong>。</p>
<p>为了便于使用和大批量生产，进一步发展出了可编程只读存储器（PROM）、可擦除可编程只读存储器（EPROM）。EPROM需要用紫外线长时间照射才能擦除，使用很不方便。1980s又出现了电可擦除可编程只读存储器（EEPROM），它克服了EPROM的不足，但是集成度不高、价格较贵。于是又发展出了一种新型的存储单元结构同EPROM类似的快闪存储器（FLASH MEMORY）。FLASH集成度高、功耗低、体积小，又能在线快速擦除，因而获得了快速发展。</p>
<h2 id="FLASH-存储器"><a href="#FLASH-存储器" class="headerlink" title="FLASH 存储器"></a>FLASH 存储器</h2><p>Flash 存储器（FLASH EEPROM）又称<strong>闪存，快闪</strong>。它是EEPROM的一种。它结合了ROM和RAM的长处。不仅具备电子可擦除可编辑（EEPROM）的性能，还<strong>不会断电丢失数据同时可以快速读取数据</strong>。它于EEPROM的最大区别是，<strong>FLASH按扇区（block）操作，而EEPROM按照字节操作</strong>。FLASH的电路结构较简单，同样容量占芯片面积较小，成本自然比EEPROM低，因此适合用于做程序存储器。</p>
<h2 id="RAM-Random-Access-Memory-随机访问存储器"><a href="#RAM-Random-Access-Memory-随机访问存储器" class="headerlink" title="RAM (Random Access Memory)随机访问存储器"></a>RAM (Random Access Memory)随机访问存储器</h2><p>RAM又称<strong>随机存取存储器</strong>，存储单元的内容<strong>可按照需要随机取出或存入，且存取的速度与存储单元的位置无关。这种存储器在断电时，将丢失其存储内容，所以主要用于存储短时间使用的程序</strong>。</p>
<p>它主要用来存储程序中用到的变量。<strong>凡是整个程序中，所用到的需要被改写的量（包括全局变量、局部变量、堆栈段等），都存储在RAM中</strong>。</p>
<h2 id="ROM-FLASH和RAM的区别"><a href="#ROM-FLASH和RAM的区别" class="headerlink" title="ROM, FLASH和RAM的区别"></a>ROM, FLASH和RAM的区别</h2><p>对于RAM, ROM以及FLASH的区别，简单地说，在计算机中，<strong>RAM 、ROM都是数据存储器。RAM 是随机存取存储器，它的特点是易挥发性，即掉电失忆。ROM 通常指固化存储器(一次写入，反复读取)，它的特点与RAM 相反。ROM又分一次性固化、光擦除和电擦除重写两种类型。</strong></p>
<p>在应用中，<strong>常规上ROM是用来存储固化程序的，RAM是用来存放数据的。</strong>由于<strong>FLASH ROM比普通的ROM读写速度快，擦写方便，一般用来存储用户程序和需要永久保存的数据。</strong></p>
<p>譬如说，现在家用的电子式电度表，它的内核是一款单片机，该单片机的程序就是存放在ROM里的。电度表在工作过程中，是要运算数据的，要采集电压和电流，并根据电压和电流计算出电度来。电压和电流是一个实时的数据，用户不关心，它只是用来计算电度用，计算完后该次采集的数据就用完了，然后再采集下一次，因此这些值就没必要永久存储，就把它放在RAM里边。<strong>然而计算完的电度，是需要永久保存的，单片机会定时或者在停电的瞬间将电度数存入到FLASH里</strong>。</p>
]]></content>
      <categories>
        <category>NXP</category>
      </categories>
      <tags>
        <tag>NXP</tag>
        <tag>ROM</tag>
        <tag>RAM</tag>
        <tag>FLASH</tag>
      </tags>
  </entry>
  <entry>
    <title>2_数据集制作</title>
    <url>/2022/03/30/30/</url>
    <content><![CDATA[<h2 id="第二步：数据集分割制作"><a href="#第二步：数据集分割制作" class="headerlink" title="第二步：数据集分割制作"></a>第二步：数据集分割制作</h2><blockquote>
<p>提前做个5折交叉的准备，注意代码中zip的使用</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">split_train</span>(<span class="params">train_file, dev_ratio=<span class="number">0.2</span>, to_folder=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># split train into train &amp; dev</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(train_file, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        dict_label_name2sents = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> i, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(f):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            line = line.strip()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">id</span>, sent, label_name = line.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">            dict_label_name2sents[label_name].append(sent)  <span class="comment"># 这里的sent包括逗号，是几个短句的组合</span></span><br><span class="line"></span><br><span class="line">        to_train_file = os.path.join(to_folder, <span class="string">&quot;train.txt&quot;</span>)</span><br><span class="line">        to_dev_file = os.path.join(to_folder, <span class="string">&quot;dev.txt&quot;</span>)</span><br><span class="line">        to_test_file = os.path.join(to_folder, <span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">        train_samples = []</span><br><span class="line">        dev_samples = []</span><br><span class="line">        <span class="keyword">for</span> label_name, sents <span class="keyword">in</span> dict_label_name2sents.items():</span><br><span class="line">            random.shuffle(sents)  <span class="comment"># 把每个lable下的sents随机打乱</span></span><br><span class="line"></span><br><span class="line">            train_sents_ = sents[<span class="built_in">int</span>(dev_ratio * <span class="built_in">len</span>(sents)) + <span class="number">1</span> :]</span><br><span class="line">            dev_sents_ = sents[: <span class="built_in">int</span>(dev_ratio * <span class="built_in">len</span>(sents)) + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">            train_samples.extend([(w, label_name) <span class="keyword">for</span> w <span class="keyword">in</span> train_sents_])</span><br><span class="line">            dev_samples.extend([(w, label_name) <span class="keyword">for</span> w <span class="keyword">in</span> dev_sents_])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> samps, file_path <span class="keyword">in</span> <span class="built_in">zip</span>(</span><br><span class="line">            [train_samples, dev_samples], [to_train_file, to_dev_file]</span><br><span class="line">        ):</span><br><span class="line">            f_out = <span class="built_in">open</span>(file_path, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">            <span class="keyword">for</span> i, samp <span class="keyword">in</span> <span class="built_in">enumerate</span>(samps):</span><br><span class="line">                f_out.write(</span><br><span class="line">                    <span class="string">&quot;%d,%s,%s&quot;</span> % (i, samp[<span class="number">0</span>], samp[<span class="number">1</span>]) + <span class="string">&quot;\n&quot;</span></span><br><span class="line">                )  <span class="comment"># samp[0]是sent，samp[1]是label_name</span></span><br><span class="line">            f_out.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">split_train_to_5folds</span>(<span class="params">train_file, to_folder, num_folds=<span class="number">5</span></span>):</span><br><span class="line">    os.makedirs(to_folder, exist_ok=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_folds):</span><br><span class="line">        to_folder_i = os.path.join(to_folder, <span class="string">&quot;fold_%d&quot;</span> % i)</span><br><span class="line">        os.makedirs(to_folder_i, exist_ok=<span class="literal">True</span>)</span><br><span class="line">        split_train(train_file, dev_ratio=<span class="number">0.2</span>, to_folder=to_folder_i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rootdir = os.sep.join(os.path.dirname(__file__).strip().split(os.sep)[:-<span class="number">2</span>])</span><br><span class="line">    train_dir = os.path.join(rootdir, <span class="string">&quot;dataset/datagrand_2021_train.csv&quot;</span>)</span><br><span class="line">    <span class="comment"># test_dir = os.path.join(rootdir, &quot;dataset/datagrand_2021_test.csv&quot;)</span></span><br><span class="line">    to_folder = os.path.join(rootdir, <span class="string">&quot;dataset/phase_1/splits&quot;</span>)</span><br><span class="line">    split_train_to_5folds(train_dir, to_folder, num_folds=<span class="number">5</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><img src="/2022/03/30/30/2022-03-31_01-33.png"></p>
]]></content>
      <categories>
        <category>NLP</category>
        <category>EDA</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>NLP</tag>
        <tag>数据探索</tag>
      </tags>
  </entry>
  <entry>
    <title>STL之vector</title>
    <url>/2022/03/22/13/</url>
    <content><![CDATA[<h1 id="STL之vector-向量"><a href="#STL之vector-向量" class="headerlink" title="STL之vector  向量"></a>STL之vector  向量</h1><p>vector是一个多功能的、能够操作多种数据结构和算法的模板类和函数库。</p>
<p>vector之所以被认为是一个容器，是因为它能够像容器一样存放各种类型的对象，简单地说，<strong>vector是一个能够存放任意类型的动态数组，能够增加和压缩数据</strong>。</p>
<p>向量可将元素存储在<strong>连续的内存位置</strong>中，并在<strong>运行时根据需要分配内存</strong>。</p>
<h2 id="vector和array的区别"><a href="#vector和array的区别" class="headerlink" title="vector和array的区别"></a>vector和array的区别</h2><p>数组array遵循<strong>静态方法</strong>，这意味着在运行时不能更改其大小，而vector实现<strong>动态数组</strong>意味着在添加元素时会自动调整其大小。</p>
<h2 id="vector基础使用"><a href="#vector基础使用" class="headerlink" title="vector基础使用"></a>vector基础使用</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建vector</span></span><br><span class="line"><span class="comment">// vector&lt;object_type&gt; v1;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; v1;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="string">&quot;C++ STL&quot;</span>);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="string">&quot;VECTOR&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;string&gt;::iterator itr = v1.<span class="built_in">begin</span>(); itr != v1.<span class="built_in">end</span>(); ++itr)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *itr &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="vector的常用成员函数"><a href="#vector的常用成员函数" class="headerlink" title="vector的常用成员函数"></a>vector的常用成员函数</h2><ul>
<li>at(idx) : 传回索引idx所指向的数据，如果idx越界，抛出out_of_range;</li>
<li>back() : 返回最后一个元素，不检查这个数据是否存在；</li>
<li>front() : 返回第一个元素，不检查这个数据是否存在；</li>
<li>swap() : 交换两个vector；</li>
<li>push_back() : 在vector的末尾追加一个元素；</li>
<li>pop_back() : 在vector中删除最后一个元素；</li>
<li>empty() : 判断vector是否为空，为空则返回true；</li>
<li>insert() : 在指定位置插入新元素；</li>
<li>erase() : 删除指定的元素？？？</li>
<li>resize() : 修改vector的大小；</li>
<li>clear() : 从vector中删除所有元素；</li>
<li>size() : 返回vector的元素个数；</li>
<li>capacity() : 返回vector在不重新分配内存的情况下，当前最多可以容纳的元素个数；</li>
<li>assige() : 将新值分配给vector；</li>
<li>operator&#x3D;() : 将新值分配给vector容器；</li>
<li>operator<a href></a> : 访问指定的元素；</li>
<li>end() : 返回最末尾元素的迭代器；</li>
<li>emplace() : 在位置pos之前，插入一个新的元素；</li>
<li>emplace_back() : 在末尾插入一个元素；</li>
<li>rend() : 指向vector的第一个元素之前的元素；</li>
<li>rbegin() : 指向vector的最后一个元素；</li>
<li>begin() : 返回第一个元素的迭代器；</li>
<li>max_size() : 返回vector所能容纳的元素的最大数量（上限值）；</li>
<li>cend() : 指向vector中的last-last-element;</li>
<li>cbegin() : 指向vector的第一个元素；</li>
<li>crbegin() : 指向vector的最后一个字符；</li>
<li>crend() : 指向vector第一个元素之前的元素；？？？</li>
<li>data() : 将vector的数据写入array；</li>
<li>shrink_to_fit() : 减小vector的容量，使它等于vector的大小；</li>
</ul>
<h3 id="val-x3D-v1-at-idx"><a href="#val-x3D-v1-at-idx" class="headerlink" title="val &#x3D; v1.at(idx)"></a>val &#x3D; v1.at(idx)</h3><p>返回索引位置的值，和<code>v1[idx]</code>一样;</p>
<p>栗子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; v1.<span class="built_in">at</span>(i) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="val-x3D-v1-back"><a href="#val-x3D-v1-back" class="headerlink" title="val &#x3D; v1.back()"></a>val &#x3D; v1.back()</h3><p>返回最后一个元素，不管存在不存在，<code>v1.end()</code>考虑下差别；</p>
<ul>
<li><code>v1.back()</code>返回最后一个元素；</li>
<li><code>v1.front()</code>返回第一个元素；</li>
</ul>
<p>栗子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; v1&#123;</span><br><span class="line">        <span class="string">&quot;begin&quot;</span>,</span><br><span class="line">        <span class="string">&quot;middle&quot;</span>,</span><br><span class="line">        <span class="string">&quot;end&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; v1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; v1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发现一个问题：string居然区分单引号双引号，必须双引号才可以！</span></span><br></pre></td></tr></table></figure>


<h3 id="v1-swap-v2"><a href="#v1-swap-v2" class="headerlink" title="v1.swap(v2)"></a>v1.swap(v2)</h3><p>交换两个vector中的元素；</p>
<p>如果两个vector的size不一样，会自动扩容，因为vector的长度可变。</p>
<p>栗子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2 = &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;在交换之前，v1的元素是 :&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;在交换之前，v2的元素是 :&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v2.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cout &lt;&lt; v2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    v1.<span class="built_in">swap</span>(v2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换后，v1的元素为  :&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换后，v2的元素为  :&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v2.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cout &lt;&lt; v2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2022/03/22/13/2022-03-26_15-54.png" alt="测试图片"></p>
]]></content>
      <categories>
        <category>STL</category>
        <category>vector</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title>STL开篇</title>
    <url>/2022/03/22/57/</url>
    <content><![CDATA[<h1 id="STL开篇"><a href="#STL开篇" class="headerlink" title="STL开篇"></a>STL开篇</h1><p>STL 实际上，是一套封装好的C++模板类。提供通用的模板类和函数，用来高性能的实现常用的算法和数据结构，比如：向量vector、链表、队列、栈。</p>
<p>STL 做到了数据结构和算法的分离，比如：vector的底层是顺序表（数组），list的底层为双向链表，deque的底层是循环队列，set的底层是红黑树，hash_set的底层是哈希表。</p>
<p>C++ STL 的核心包括三个组件：</p>
<ul>
<li>容器（Containers）:容器用来管理<strong>某同一类对象</strong>的集合。C++的各种容器类型，比如：deque、list、vector、map等。</li>
<li>算法（Algorithms）：算法作用于容器。提供执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作；</li>
<li>迭代器（iterators）：迭代器用于遍历对象集合的元素，这些集合可能是容器，也可能是容器的子集。</li>
</ul>
<h2 id="一个简单的vector示例"><a href="#一个简单的vector示例" class="headerlink" title="一个简单的vector示例"></a>一个简单的vector示例</h2><p>vecotr和数组非常相似，唯一不同的是，vector在需要扩展大小的时候，会自动处理它的存储需求！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;vec的原始大小： &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;vec扩展后大小： &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;vec[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] 的值是：&quot;</span> &lt;&lt; vec[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用迭代器iterator访问值</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator v = vec.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (v != vec.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;迭代器*v的值：&quot;</span> &lt;&lt; *v &lt;&lt; endl;</span><br><span class="line">        v++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; *vec.<span class="built_in">begin</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="vector的常用函数："><a href="#vector的常用函数：" class="headerlink" title="vector的常用函数："></a>vector的常用函数：</h2><ul>
<li>push_back(): 向vector的末尾插入值，如有必要，会扩展向量的大小；</li>
<li>size(): 显示向量的大小；</li>
<li>begin(): 返回一个指向向量开头的<strong>迭代器</strong>；</li>
<li>end(): 返回一个指向向量结尾的<strong>迭代器</strong></li>
<li>vector<int>::iterator v &#x3D; vec.begin();</int></li>
</ul>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>Thread协议基础</title>
    <url>/2022/08/02/05/</url>
    <content><![CDATA[<h2 id="General-Thread-introduction"><a href="#General-Thread-introduction" class="headerlink" title="General Thread introduction"></a>General Thread introduction</h2><h3 id="1-1-家用无线网络的要求"><a href="#1-1-家用无线网络的要求" class="headerlink" title="1.1 家用无线网络的要求"></a>1.1 家用无线网络的要求</h3><p>✔低功耗</p>
<p>✔弹性（网状）</p>
<p>✔基于IP</p>
<p>✔开放协议</p>
<p>✔安全和用户友好</p>
<p>✔快速上市</p>
<p>✔现有无线电芯片</p>
<h4 id="关于弹性组网：-Resilient-mesh"><a href="#关于弹性组网：-Resilient-mesh" class="headerlink" title="关于弹性组网： Resilient (mesh)"></a>关于弹性组网： Resilient (mesh)</h4><ul>
<li>No single point of failure 无单点故障</li>
<li>Self-healing 自我修复</li>
<li>Interference robustness 干扰鲁棒性</li>
<li>Self-extending 自我扩展</li>
<li>Reliable enough for critical infrastructure 足够可靠，适用于关键基础设施</li>
</ul>
<h3 id="1-2-What-is-THREAD-？"><a href="#1-2-What-is-THREAD-？" class="headerlink" title="1.2 What is THREAD ？"></a>1.2 What is THREAD ？</h3><ul>
<li>为家庭及其连接产品提供安全的无线网状网络</li>
<li>基于久经考验的现有技术构建<ul>
<li>在现有 802.15.4 芯片上运行</li>
<li>使用 6LoWPAN 和 IPv6 寻址</li>
<li>UDP Transport</li>
</ul>
</li>
<li>新的强制性安全体系结构</li>
<li>添加&#x2F;删除产品简单且安全</li>
<li>可扩展到每个网络 250 多个产品</li>
<li>设计用于超低功耗操作</li>
<li>适用于关键基础设施</li>
</ul>
<p><img src="/2022/08/02/05/thread.PNG" alt="thread"></p>
<h3 id="1-3-THREAD-target-applocations"><a href="#1-3-THREAD-target-applocations" class="headerlink" title="1.3 THREAD target applocations"></a>1.3 THREAD target applocations</h3><p>Thread专为家庭中的各种产品而设计</p>
<ul>
<li>Appliances</li>
<li>Access control</li>
<li>Climate control</li>
<li>Energy management</li>
<li>Lighting</li>
<li>Safety</li>
<li>Security</li>
</ul>
<h2 id="Thread-networking-architecture"><a href="#Thread-networking-architecture" class="headerlink" title="Thread networking architecture"></a>Thread networking architecture</h2><h3 id="2-1-网络拓扑"><a href="#2-1-网络拓扑" class="headerlink" title="2.1 网络拓扑"></a>2.1 网络拓扑</h3><p><em>Many</em> <strong>Border Router</strong> +</p>
<p><em>One</em> <strong>Thread Leader</strong> +</p>
<p><em>Up to 31</em> <strong>Thread Active Router</strong> +</p>
<p><em>Up to 512 per Active Router</em> <strong>End Device</strong> &#x3D;</p>
<p><strong>Thousands of Devices Per Network (16K)</strong></p>
<p><img src="/2022/08/02/05/Border%20Router.PNG" alt="Border Router"></p>
<p><img src="/2022/08/02/05/Thread%20Leader.PNG" alt="Thread Leader"></p>
<p><img src="/2022/08/02/05/Thread%20Active%20Router.PNG" alt="Thread Active Router"></p>
<p><img src="/2022/08/02/05/End%20Device.PNG" alt="End Device"></p>
<p>可路由设备：</p>
<ul>
<li>Active Router : 当网络的连接性相对有限时，REED 请求领导者使其成为活动路由器。 例如：当现有活动路由器的总数小于 &lt; 16</li>
<li>Router Eligible End Device (REED) : 在最初通过现有的Active Routers加入网络后，或在网络有足够的连接性时，立即加入网络。</li>
<li>Leader : 如果它是网络分区中的初始设备，或者当当前的领导者不可用时;</li>
</ul>
<p><strong>The Border Router</strong> :</p>
<ul>
<li>Usually is a subset of Router Eligible Device</li>
<li>Has at least one more different interface than IEEE 802.15.4 (e.g.: Wi-Fi, Ethernet,  USB)</li>
<li>Facilitates IP packet forwarding to and from the Thread network to home LAN or upstream IP infrastructure</li>
<li>Can be a specialized networking device:<ul>
<li>wireless access point</li>
<li>home gateway</li>
</ul>
</li>
<li>Or can be embedded in a consumer product:<ul>
<li>thermostat</li>
<li>appliance</li>
</ul>
</li>
</ul>
<p><img src="/2022/08/02/05/Border%20Router2.PNG" alt="Board Router2"></p>
<h3 id="2-2-flexible-network"><a href="#2-2-flexible-network" class="headerlink" title="2.2 flexible network"></a>2.2 flexible network</h3><ul>
<li>Devices join as <em>Router Eligible End Devices</em> or <em>End Devices</em>;</li>
<li>REED 可以成为一个<em>Router</em>，如果<em>Leader</em>确定需要更好的覆盖范围；</li>
<li>所有<em>Router</em>通过<em>Trickle</em>机制和<em>MLE</em>向所有其他路由器保持状态；</li>
<li>所有<em>Router</em>通过<em>Trickle</em>机制和<em>MLE</em>维持<em>Border Router</em>的状态；</li>
<li>Sleeping End Devices route through parent Router</li>
<li>Router Eligible Devices can also maintain state</li>
<li><em>Leader</em> used to make decisions within network；</li>
</ul>
<h3 id="2-3-No-single-point-of-failure-无单点故障"><a href="#2-3-No-single-point-of-failure-无单点故障" class="headerlink" title="2.3 No single point of failure 无单点故障"></a>2.3 No single point of failure 无单点故障</h3><ul>
<li>不需要识别网络中的专门设备；</li>
<li><em>Leader</em>作出决定，但一旦失败，另一个<em>Router</em>将成为<em>Leader</em></li>
<li>网络将在需要时增加<em>Active Routers</em>以改善连接性。</li>
</ul>
<h3 id="2-4-Low-Power-End-Devices"><a href="#2-4-Low-Power-End-Devices" class="headerlink" title="2.4 Low-Power End Devices"></a>2.4 Low-Power End Devices</h3><ul>
<li>睡眠设备轮询父母的信息（或远程设备，如果应用程序已配置）</li>
<li>睡眠设备不需要与父母设备check in，从而实现低功耗操作</li>
<li>父母为睡眠设备<strong>保留信息</strong></li>
<li>睡眠设备在失去连接时自动切换parent</li>
</ul>
<h2 id="Thread-IP-addressing-architecture"><a href="#Thread-IP-addressing-architecture" class="headerlink" title="Thread IP addressing architecture"></a>Thread IP addressing architecture</h2><h3 id="3-1-IP地址分配"><a href="#3-1-IP地址分配" class="headerlink" title="3.1 IP地址分配"></a>3.1 IP地址分配</h3><ul>
<li>IP Addresses are assigned at the border between the IP layer and each specific Media Interface below the IP stack（IP地址是在IP层和IP堆栈下面的每个特定媒体接口之间的边界上分配的）</li>
<li>Multiple IP address can be assigned to the same Media Interface（多个IP地址可以分配给同一个媒体接口）</li>
<li>The same address can be assigned to the multiple Media Interfaces on the same device or on different devices（同一个地址可以分配给同一个设备上的多个媒体接口，也可以分配给不同设备上的多个媒体接口。）</li>
</ul>
<h3 id="3-2-IPV6地址符号基础"><a href="#3-2-IPV6地址符号基础" class="headerlink" title="3.2 IPV6地址符号基础"></a>3.2 IPV6地址符号基础</h3><ul>
<li>An IPv6 address has <strong>16 bytes (128 bits)</strong>, represented as eight 2-byte groups:<ul>
<li><code>2001:3344:5566:7788:99AA:BBCC:DDEE:0000</code></li>
</ul>
</li>
<li>All <code>0000</code> groups can be represented as a single <code>0</code></li>
<li>每个group开头的0可以省略</li>
<li>所有0组的最长连续集合可表示为2个冒号:<ul>
<li><code>2001:0044:0000:0000:0000:BBCC:00EE:0000</code> is equivalent to <code>2001:44::BBCC:EE:0</code></li>
</ul>
</li>
<li>Addresses 分为 <em>Network Prefix</em> and <em>Network Address</em> 网络前缀和网络地址:</li>
<li>Representing the length  of the network prefix can be done with a <code>/prefixlen notation</code><ul>
<li><code>2001:3344:5566:7788:99AA:BBCC:DDEE:FF00/64</code></li>
</ul>
</li>
</ul>
<h3 id="3-3-IPV6-ADDRESS-CLASSES"><a href="#3-3-IPV6-ADDRESS-CLASSES" class="headerlink" title="3.3 IPV6 ADDRESS CLASSES"></a>3.3 IPV6 ADDRESS CLASSES</h3><ul>
<li><strong>Unicast</strong> –Identifies a single Media Interface on a single network host(识别单一网络主机上的单一媒体接口):<ul>
<li>Network Prefix: 64 bits</li>
<li>Network Address &#x3D; Interface Identifier (IID): 64 bits</li>
</ul>
</li>
<li><strong>Multicast</strong>–Identifies all network hosts which have assigned a multicast group to one or more Media Interfaces(识别已将multicast group分配给一个或多个媒体接口的所有network hosts)<ul>
<li>Multicast Prefix: 8 bits all 1s (multicast address format FF::)</li>
<li>Flags: 4 bits</li>
<li>Scope: 4 bits</li>
<li>Multicast Group: 112 bits</li>
</ul>
</li>
<li><strong>Anycast</strong>–Identifies a unicast-like address assigned to multiple interfaces where the final destination of packets can be any of the nodes using the address(标识分配给多个接口的类似单播的地址，其中数据包的最终目的地可以是使用该地址的任何节点)</li>
</ul>
<h3 id="3-4-HOW-MANY-ADDRESSES-DOES-A-THREAD-DEVICE-GET"><a href="#3-4-HOW-MANY-ADDRESSES-DOES-A-THREAD-DEVICE-GET" class="headerlink" title="3.4 HOW MANY ADDRESSES DOES A THREAD DEVICE GET?"></a>3.4 HOW MANY ADDRESSES DOES A THREAD DEVICE GET?</h3><p>Once joined to a network, a Thread  device will get:</p>
<ul>
<li>At least 3 Unicast IPv6 addresses to the Thread Interface:<ul>
<li>Link local address (LL64): </li>
<li>Mesh local address (ML16, RLOC): </li>
<li>Mesh local address (ML64, ML-EID):</li>
</ul>
</li>
<li>Two All Thread Nodes multicast addresses:<ul>
<li>Link local all Thread  Nodes(Multicast):</li>
<li>Realm  local all Thread  Nodes(Multicast):</li>
</ul>
</li>
<li>Optional  will  also get:<ul>
<li>Unique  local address (ULA):</li>
<li>Global  unique  address (GUA):</li>
</ul>
</li>
</ul>
<h3 id="3-5-THREAD-SCOPES"><a href="#3-5-THREAD-SCOPES" class="headerlink" title="3.5 THREAD SCOPES"></a>3.5 THREAD SCOPES</h3><ul>
<li><strong>SCOPES</strong>在使用和转发地址的数据包时指定网络的边界;</li>
<li><strong>Link Local</strong> single-hop within radio range</li>
<li><strong>Mesh Local</strong> multi-hop within the PAN</li>
<li><strong>Unique Local</strong> multi-hop within the PAN and inter-PAN for the same network</li>
<li><strong>Global</strong> internet addressable</li>
</ul>
<h4 id="UNICAST-LINK-LOCAL-ADDRESS-LL64"><a href="#UNICAST-LINK-LOCAL-ADDRESS-LL64" class="headerlink" title="UNICAST LINK LOCAL ADDRESS LL64"></a>UNICAST LINK LOCAL ADDRESS LL64</h4><ul>
<li>允许在IEEE802.15.4无线电范围内的<strong>直接邻居之间</strong>进行通信，换句话说，就是那些相距一跳的链接。</li>
<li>LL64接口标识符被设置为MAC扩展地址（$thr get randomaddr），universal&#x2F;local bit被颠倒。</li>
</ul>
<h4 id="UNICAST-MESH-LOCAL-ADDRESS-ML16"><a href="#UNICAST-MESH-LOCAL-ADDRESS-ML16" class="headerlink" title="UNICAST MESH LOCAL ADDRESS ML16"></a>UNICAST MESH LOCAL ADDRESS ML16</h4><ul>
<li>到达 Thread 网络中的任何设备，供 Thread 堆栈内部使用。</li>
<li>RLOC 嵌入了Router ID（分配了leader）和Child ID（分配了路由器）</li>
<li>每当 Thread Network 分区拓扑发生变化时，ML16 都会发生变化</li>
</ul>
<h4 id="UNICAST-MESH-LOCAL-ADDRESS"><a href="#UNICAST-MESH-LOCAL-ADDRESS" class="headerlink" title="UNICAST MESH LOCAL ADDRESS"></a>UNICAST MESH LOCAL ADDRESS</h4><ul>
<li>到达 Thread 网络中的任何节点</li>
<li>强烈推荐application使用</li>
<li>Mesh Local Endpoint Identifier (ML-EID)由 Thread Stack 随机生成，并在重启后保持不变</li>
</ul>
<h4 id="Multicast"><a href="#Multicast" class="headerlink" title="Multicast"></a>Multicast</h4><p><strong>Link local all Thread nodes</strong></p>
<p>执行Multicast而不重试数据包，消息包将只被IEEE 802.15.4无线电范围内的邻居接收。</p>
<p><strong>Realm local all Thread nodes</strong></p>
<ul>
<li>数据包可以到达网络的每个节点，<em>只要节点距离请求者最多 2 个“跳”</em></li>
<li>每次到达路由器时，数据包都会被转发 3 次。</li>
</ul>
]]></content>
      <categories>
        <category>NXP</category>
      </categories>
      <tags>
        <tag>NXP</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>UART_Polling模式代码</title>
    <url>/2022/10/17/01/</url>
    <content><![CDATA[<h1 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h1><blockquote>
<p>usart_polling.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> ch;</span><br><span class="line">    <span class="type">usart_config_t</span> config;                              <span class="comment">// 配置波特率、帧格式、上升下降沿、奇偶校验、停止位等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Security code to allow debug access */</span></span><br><span class="line">    SYSCON-&gt;CODESECURITYPROT = <span class="number">0x87654320</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* attach clock for USART(debug console) */</span></span><br><span class="line">    CLOCK_AttachClk(BOARD_DEBUG_UART_CLK_ATTACH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reset FLEXCOMM for USART */</span></span><br><span class="line">    RESET_PeripheralReset(kFC0_RST_SHIFT_RSTn);</span><br><span class="line"></span><br><span class="line">    BOARD_BootClockRUN();</span><br><span class="line">    BOARD_InitDebugConsole();</span><br><span class="line">    BOARD_InitPins();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * config.baudRate_Bps = 115200U;</span></span><br><span class="line"><span class="comment">     * config.parityMode = kUSART_ParityDisabled;</span></span><br><span class="line"><span class="comment">     * config.stopBitCount = kUSART_OneStopBit;</span></span><br><span class="line"><span class="comment">     * config.loopback = false;</span></span><br><span class="line"><span class="comment">     * config.enableTx = false;</span></span><br><span class="line"><span class="comment">     * config.enableRx = false;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    USART_GetDefaultConfig(&amp;config);                    <span class="comment">// 使用默认配置，传入config的引用</span></span><br><span class="line">    config.baudRate_Bps = BOARD_DEBUG_UART_BAUDRATE;    <span class="comment">// 客制化usart配置</span></span><br><span class="line">    config.enableTx     = <span class="literal">true</span>;</span><br><span class="line">    config.enableRx     = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    USART_Init(DEMO_USART, &amp;config, DEMO_USART_CLK_FREQ);           <span class="comment">// 使用config和外部时钟初始化USART实例，其中外部时钟只在设置波特率时使用</span></span><br><span class="line"></span><br><span class="line">    USART_WriteBlocking(DEMO_USART, txbuff, <span class="keyword">sizeof</span>(txbuff) - <span class="number">1</span>);    <span class="comment">// 将数组中的值写入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PRINTF(<span class="string">&quot;READ:\n\r&quot;</span>);</span><br><span class="line">        USART_ReadBlocking(DEMO_USART, &amp;ch, <span class="number">1</span>);                     <span class="comment">// 数据逐个从FIFORD读入ch，这里只读入一位</span></span><br><span class="line">        PRINTF(<span class="string">&quot;\n\rWRITE:\n\r&quot;</span>);</span><br><span class="line">        USART_WriteBlocking(DEMO_USART, &amp;ch, <span class="number">1</span>);                    <span class="comment">// 数据逐个从ch写入FIFOWR，这里只读入一位，等待TX进入IDLE模式结束</span></span><br><span class="line">        PRINTF(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="只接收一个char"><a href="#只接收一个char" class="headerlink" title="只接收一个char"></a>只接收一个char</h2><p>实验结果：</p>
<p><img src="/2022/10/17/01/%E5%8D%95%E5%AD%97%E7%AC%A6%E5%AE%9E%E9%AA%8C.jpg" alt="单字符实验"></p>
<h2 id="接收字符串"><a href="#接收字符串" class="headerlink" title="接收字符串"></a>接收字符串</h2><p>原始代码修改为接收一个定长5的array，代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> <span class="built_in">array</span>[<span class="number">6</span>];</span><br><span class="line">    <span class="type">usart_config_t</span> config;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Security code to allow debug access */</span></span><br><span class="line">    SYSCON-&gt;CODESECURITYPROT = <span class="number">0x87654320</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* attach clock for USART(debug console) */</span></span><br><span class="line">    CLOCK_AttachClk(BOARD_DEBUG_UART_CLK_ATTACH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reset FLEXCOMM for USART */</span></span><br><span class="line">    RESET_PeripheralReset(kFC0_RST_SHIFT_RSTn);</span><br><span class="line"></span><br><span class="line">    BOARD_BootClockRUN();</span><br><span class="line">    BOARD_InitDebugConsole();</span><br><span class="line">    BOARD_InitPins();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * config.baudRate_Bps = 115200U;</span></span><br><span class="line"><span class="comment">     * config.parityMode = kUSART_ParityDisabled;</span></span><br><span class="line"><span class="comment">     * config.stopBitCount = kUSART_OneStopBit;</span></span><br><span class="line"><span class="comment">     * config.loopback = false;</span></span><br><span class="line"><span class="comment">     * config.enableTx = false;</span></span><br><span class="line"><span class="comment">     * config.enableRx = false;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    USART_GetDefaultConfig(&amp;config);</span><br><span class="line">    config.baudRate_Bps = BOARD_DEBUG_UART_BAUDRATE;</span><br><span class="line">    config.enableTx     = <span class="literal">true</span>;</span><br><span class="line">    config.enableRx     = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    USART_Init(DEMO_USART, &amp;config, DEMO_USART_CLK_FREQ);</span><br><span class="line"></span><br><span class="line">    USART_WriteBlocking(DEMO_USART, txbuff, <span class="keyword">sizeof</span>(txbuff) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PRINTF(<span class="string">&quot;READ:\n\r&quot;</span>);</span><br><span class="line">        USART_ReadBlocking(DEMO_USART, &amp;<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>) - <span class="number">1</span>);</span><br><span class="line">        PRINTF(<span class="string">&quot;\n\rWRITE:\n\r&quot;</span>);</span><br><span class="line">        USART_WriteBlocking(DEMO_USART, &amp;<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>) - <span class="number">1</span>);</span><br><span class="line">        PRINTF(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实验结果：</p>
<p><img src="/2022/10/17/01/%E5%AE%9A%E9%95%BFarray%E5%AE%9E%E9%AA%8C.jpg" alt="定长array实验"></p>
]]></content>
      <categories>
        <category>NXP</category>
      </categories>
      <tags>
        <tag>NXP</tag>
        <tag>UART</tag>
      </tags>
  </entry>
  <entry>
    <title>UART总结</title>
    <url>/2022/10/17/02/</url>
    <content><![CDATA[<h1 id="总线协议-–-UART"><a href="#总线协议-–-UART" class="headerlink" title="总线协议 – UART"></a>总线协议 – UART</h1><h2 id="一、-UART简介"><a href="#一、-UART简介" class="headerlink" title="一、 UART简介"></a>一、 UART简介</h2><blockquote>
<p>UART: Universal Asynchronous Receiver Transmitter（通用异步收发器），</p>
<p>通用的<em>串行、异步</em>通信总线，它有<strong>两条</strong>数据线，实现<strong>全双工</strong>发送和接收。</p>
</blockquote>
<h3 id="1-1-通信基础"><a href="#1-1-通信基础" class="headerlink" title="1.1 通信基础"></a>1.1 通信基础</h3><p>串行、并行：</p>
<ul>
<li>并行通信：总线在传递数据的时候，可以一次性收发多个位的数据。并行虽然快，但是要考虑多个线的<em>资源占用</em>，以及多条线<em>互相干扰</em>的问题；</li>
<li>串行通信：每一位数据逐次传递；（<strong>IIC\SPI都是串行通信</strong>）</li>
</ul>
<p>单工、双工：</p>
<ul>
<li>单工通信：只能是单向的，<mark>发送器给接收器发送数据</mark>，而不能反过来；</li>
<li>双工通信：可以是A到B，也可以是B到A；<ul>
<li>半双工：不能同时发生；只有一根线，发送时就不能接收；</li>
<li>全双工：可以同时发送和接收，有两根线；</li>
</ul>
</li>
</ul>
<p>波特率：</p>
<ul>
<li><p>波特率：描述UART通信速度，单位<strong>bps</strong>，(bit per second)，每秒传送的bit的数量；</p>
<ul>
<li>每秒的波特数，波特等于单个信号包含的码元数量</li>
</ul>
</li>
<li><p>比特率：是指每秒传送的比特(bit)数。单位为 bps(Bit Per Second)，比特率越高，每秒传送数据就越多。</p>
</li>
<li><p>波特率：表示每秒钟传送码元符号的个数，是衡量数据传送速率的指标。</p>
<ul>
<li>在信息传输通道中，携带数据信息的信号单元叫码元，每秒钟通过信道传输的码元数称为码元传输速率，简称<strong>波特率</strong>。波特率是传输通道频宽的指标。</li>
<li>比特率&#x3D;波特率x单个调制状态对应的二进制位数</li>
<li>两相调制(单个调制状态对应1个二进制位)的比特率等于波特率;四相调制(单个调制状态对应2个二进制位)的比特率为波特率的两倍;八相调制(单个调制状态对应3个二进制位)的比特率为波特率的三倍;依次类推。</li>
</ul>
</li>
</ul>
<h3 id="1-2-UART帧格式"><a href="#1-2-UART帧格式" class="headerlink" title="1.2 UART帧格式"></a>1.2 UART帧格式</h3><p><img src="/2022/10/17/02/frame_struct.JPG" alt="UART帧格式"></p>
<ul>
<li><input disabled type="checkbox"> 起始位：1bit的0，标志发送开始；因为空闲时为1，所以开始为0；</li>
<li><input checked disabled type="checkbox"> 数据位： 5-8bit，<strong>先发低位，后发高位</strong>；</li>
<li><input disabled type="checkbox"> 校验位：可有可无；奇偶校验，是校验奇数还是偶数个1； </li>
<li><input disabled type="checkbox"> 停止位：高电平1；</li>
<li><input disabled type="checkbox"> 空闲位：</li>
</ul>
<blockquote>
<p>注意： UART<strong>空闲</strong>的时候，用<strong>高电平</strong>表示；</p>
<p>串口协议从低位先发，最后发高位；</p>
<p><mark>串口每次都只发一个byte，下一个byte又重新开始起始位，是因为它是<strong>异步的</strong>，发送方和接收方的时钟不是同一个，防止由于时钟不同步导致误差累积；</mark></p>
<p>IIC和SPI都是同步通信，可以发多个字节；</p>
</blockquote>
<h3 id="1-3-Tx-amp-Rx"><a href="#1-3-Tx-amp-Rx" class="headerlink" title="1.3 Tx &amp; Rx"></a>1.3 Tx &amp; Rx</h3><blockquote>
<p>串口的信号一般较弱，通信距离短，容易被干扰，所以增加了一块专有芯片用来增加抗干扰能力，使发送距离更远；(TTL信号转为232信号)</p>
</blockquote>
<p>发送STEPs：</p>
<ol>
<li>待发送数据放入FIFO</li>
<li>增加了UART协议的各种头，比如起始和校验，然后拷贝放入shifter；</li>
<li>shifter每个bit依次移位到引脚来发送，<strong>先发低位，后发高位</strong>；</li>
</ol>
<p><em>即发送时：      FIFO –&gt; shifter –&gt; TxD;</em></p>
<p><em>接收时顺序相反，RxD –&gt; shifter –&gt; FIFO;</em></p>
<h3 id="1-4-UART工作模式"><a href="#1-4-UART工作模式" class="headerlink" title="1.4 UART工作模式"></a>1.4 UART工作模式</h3><p><em><strong>CPU会通过总线，和接收和发送的BUFFer相连，用来读写数据，另外，也和控制单元相连，对控制单元的设置进行修改；</strong></em></p>
<blockquote>
<p>look-back: <strong>回环模式look-back</strong>是在内部将Tx和Rx短接，一般用于测试；</p>
</blockquote>
<p><img src="/2022/10/17/02/workMode.JPG" alt="几种工作模式"></p>
<p>三种常见的工作模式：</p>
<ol>
<li>polling  轮询<ul>
<li>CPU不断地对FIFO进行访问，查询需要的数据有没有发过来；</li>
<li>CPU的状态： 工作 –&gt; 轮询 –&gt; 工作 –&gt; 轮询 …</li>
<li>直到查找到需要的数据；</li>
<li>费时费力，消耗资源</li>
</ul>
</li>
<li>interrupt  中断<ul>
<li>CPU和FIFO约定，CPU<strong>不主动</strong>去查询，当FIFO收到数据要发送过来的时候，给CPU发送<strong>中断信号</strong>，CPU中断当前工作，接收FIFO的数据；</li>
<li><strong>比polling模式省资源</strong>；</li>
</ul>
</li>
<li>DMA  直接存储器访问<ul>
<li>CPU收到FIFO的数据，最终也是要放入某一块内存中去使用的；</li>
<li>DMA模式<strong>跳过CPU</strong>，当FIFO数据过来时，直接放入需要的内存中；</li>
</ul>
</li>
</ol>
<h2 id="二、-polling模式实验（以qn9090为例）"><a href="#二、-polling模式实验（以qn9090为例）" class="headerlink" title="二、 polling模式实验（以qn9090为例）"></a>二、 polling模式实验（以qn9090为例）</h2><h3 id="2-1-主函数"><a href="#2-1-主函数" class="headerlink" title="2.1 主函数"></a>2.1 主函数</h3><blockquote>
<p>usart_polling.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> ch;</span><br><span class="line">    <span class="type">usart_config_t</span> config;                              <span class="comment">// 配置波特率、帧格式、上升下降沿、奇偶校验、停止位等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Security code to allow debug access */</span></span><br><span class="line">    SYSCON-&gt;CODESECURITYPROT = <span class="number">0x87654320</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* attach clock for USART(debug console) */</span></span><br><span class="line">    CLOCK_AttachClk(BOARD_DEBUG_UART_CLK_ATTACH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reset FLEXCOMM for USART */</span></span><br><span class="line">    RESET_PeripheralReset(kFC0_RST_SHIFT_RSTn);</span><br><span class="line"></span><br><span class="line">    BOARD_BootClockRUN();</span><br><span class="line">    BOARD_InitDebugConsole();</span><br><span class="line">    BOARD_InitPins();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * config.baudRate_Bps = 115200U;</span></span><br><span class="line"><span class="comment">     * config.parityMode = kUSART_ParityDisabled;</span></span><br><span class="line"><span class="comment">     * config.stopBitCount = kUSART_OneStopBit;</span></span><br><span class="line"><span class="comment">     * config.loopback = false;</span></span><br><span class="line"><span class="comment">     * config.enableTx = false;</span></span><br><span class="line"><span class="comment">     * config.enableRx = false;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    USART_GetDefaultConfig(&amp;config);                    <span class="comment">// 使用默认配置，传入config的引用</span></span><br><span class="line">    config.baudRate_Bps = BOARD_DEBUG_UART_BAUDRATE;    <span class="comment">// 客制化usart配置</span></span><br><span class="line">    config.enableTx     = <span class="literal">true</span>;</span><br><span class="line">    config.enableRx     = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    USART_Init(DEMO_USART, &amp;config, DEMO_USART_CLK_FREQ);           <span class="comment">// 使用config和外部时钟初始化USART实例，其中外部时钟只在设置波特率时使用</span></span><br><span class="line"></span><br><span class="line">    USART_WriteBlocking(DEMO_USART, txbuff, <span class="keyword">sizeof</span>(txbuff) - <span class="number">1</span>);    <span class="comment">// 将数组中的值写入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PRINTF(<span class="string">&quot;READ:\n\r&quot;</span>);</span><br><span class="line">        USART_ReadBlocking(DEMO_USART, &amp;ch, <span class="number">1</span>);                     <span class="comment">// 数据逐个从FIFORD读入ch，这里只读入一位</span></span><br><span class="line">        PRINTF(<span class="string">&quot;\n\rWRITE:\n\r&quot;</span>);</span><br><span class="line">        USART_WriteBlocking(DEMO_USART, &amp;ch, <span class="number">1</span>);                    <span class="comment">// 数据逐个从ch写入FIFOWR，这里只读入一位，等待TX进入IDLE模式结束</span></span><br><span class="line">        PRINTF(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-只接收一个char"><a href="#2-2-只接收一个char" class="headerlink" title="2.2 只接收一个char"></a>2.2 只接收一个char</h3><p>实验结果：</p>
<p><img src="/2022/10/17/02/%E5%8D%95%E5%AD%97%E7%AC%A6%E5%AE%9E%E9%AA%8C.jpg" alt="单字符实验"></p>
<h2 id="接收字符串"><a href="#接收字符串" class="headerlink" title="接收字符串"></a>接收字符串</h2><p>原始代码修改为接收一个定长5的array，代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> <span class="built_in">array</span>[<span class="number">6</span>];</span><br><span class="line">    <span class="type">usart_config_t</span> config;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Security code to allow debug access */</span></span><br><span class="line">    SYSCON-&gt;CODESECURITYPROT = <span class="number">0x87654320</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* attach clock for USART(debug console) */</span></span><br><span class="line">    CLOCK_AttachClk(BOARD_DEBUG_UART_CLK_ATTACH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reset FLEXCOMM for USART */</span></span><br><span class="line">    RESET_PeripheralReset(kFC0_RST_SHIFT_RSTn);</span><br><span class="line"></span><br><span class="line">    BOARD_BootClockRUN();</span><br><span class="line">    BOARD_InitDebugConsole();</span><br><span class="line">    BOARD_InitPins();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * config.baudRate_Bps = 115200U;</span></span><br><span class="line"><span class="comment">     * config.parityMode = kUSART_ParityDisabled;</span></span><br><span class="line"><span class="comment">     * config.stopBitCount = kUSART_OneStopBit;</span></span><br><span class="line"><span class="comment">     * config.loopback = false;</span></span><br><span class="line"><span class="comment">     * config.enableTx = false;</span></span><br><span class="line"><span class="comment">     * config.enableRx = false;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    USART_GetDefaultConfig(&amp;config);</span><br><span class="line">    config.baudRate_Bps = BOARD_DEBUG_UART_BAUDRATE;</span><br><span class="line">    config.enableTx     = <span class="literal">true</span>;</span><br><span class="line">    config.enableRx     = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    USART_Init(DEMO_USART, &amp;config, DEMO_USART_CLK_FREQ);</span><br><span class="line"></span><br><span class="line">    USART_WriteBlocking(DEMO_USART, txbuff, <span class="keyword">sizeof</span>(txbuff) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PRINTF(<span class="string">&quot;READ:\n\r&quot;</span>);</span><br><span class="line">        USART_ReadBlocking(DEMO_USART, &amp;<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>) - <span class="number">1</span>);</span><br><span class="line">        PRINTF(<span class="string">&quot;\n\rWRITE:\n\r&quot;</span>);</span><br><span class="line">        USART_WriteBlocking(DEMO_USART, &amp;<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>) - <span class="number">1</span>);</span><br><span class="line">        PRINTF(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实验结果：</p>
<p><img src="/2022/10/17/02/%E5%AE%9A%E9%95%BFarray%E5%AE%9E%E9%AA%8C.jpg" alt="定长array实验"></p>
<h2 id="三、补充"><a href="#三、补充" class="headerlink" title="三、补充"></a>三、补充</h2><h3 id="3-1-SDK中典型使用"><a href="#3-1-SDK中典型使用" class="headerlink" title="3.1 SDK中典型使用"></a>3.1 SDK中典型使用</h3><p>在NXP的QN9090的SDK中，提供了丰富的示例：</p>
<ul>
<li>polling method 收发</li>
<li>interrupt method 收发</li>
<li>ringbuffer接收数据</li>
<li>DMA method 收发</li>
</ul>
<p>文档 ： <code>MCUXpresso SDK API Reference Manual.pdf</code></p>
<p><img src="/2022/10/17/02/%E5%85%B8%E5%9E%8B%E7%A4%BA%E4%BE%8B.jpg" alt="典型示例"></p>
<h3 id="3-2-串口的工作原理"><a href="#3-2-串口的工作原理" class="headerlink" title="3.2 串口的工作原理"></a>3.2 串口的工作原理</h3><p>一个byte的数据，如何转为串口输出的bit？ 通过移位寄存器原理实现</p>
<p>移位寄存器原理：</p>
<p><img src="/2022/10/17/02/%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8.jpg" alt="移位寄存器"></p>
<p>初始状态： A3A2A1A0＝ 1011</p>
<p>然后Q3的输出，是在每个时钟节拍，按照这个先后顺序，把A3A2A1A0串行的输出出去。(小端)</p>
<p>其实利用的就是D触发器的特性。</p>
<p>如果我们使用8位的移位寄存器，就可以利用8个clk的时间，发一组8bit的数据通过一根导线传输出去。</p>
]]></content>
      <categories>
        <category>NXP</category>
      </categories>
      <tags>
        <tag>NXP</tag>
        <tag>UART</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim使用</title>
    <url>/2022/04/05/20/</url>
    <content><![CDATA[<h1 id="Vim使用"><a href="#Vim使用" class="headerlink" title="Vim使用"></a>Vim使用</h1><p>本周学习了小彭老师的vim教程，很受启发，学习记录在这。</p>
<blockquote>
<p><strong>先放链接：</strong></p>
<p><a href="https://www.bilibili.com/video/BV1H44y1V7DW?spm_id_from=333.999.0.0" title="小彭老师B站链接">【Vim插件整合包】C++&#x2F;Python自动补全，模糊查找文件，编译CMake工程等</a></p>
</blockquote>
<ul>
<li>F4  &#x3D;&#x3D; :wa 保存文件</li>
<li>F5      cmake多文件运行</li>
<li>F7      单文件运行</li>
<li>F8      打开一个外部shell</li>
<li>F8 执行完命令之后，按Ctrl+D退出shell，回到文件中</li>
<li>F9      打开nerdtree</li>
<li>ctrl + T  打开&#x2F;关闭终端</li>
<li>ctrl + \  ctrl + n 终端进入普通模式，可选中</li>
<li>ctrl + w + “” 在终端中粘贴；如果来自别的寄存器a，则ctrl + w + “a</li>
<li>可视模式按y复制，按p粘贴，按u撤销，按ctrl+r恢复撤销，按x删除单个字符，按dw删除单词，按dd删除行</li>
<li>Z   &#x3D;&#x3D; ZZ 保存并退出</li>
<li>Q         直接退出所有窗口</li>
<li>F10      快速修改error</li>
<li>ctrl + ww 切换窗口</li>
<li>ctrl + wk 或者 wj 上下切换窗口</li>
<li>:split  和  :vsplit 分割窗口</li>
<li>普通模式 gq 快速修复</li>
<li>普通模式 gf 格式化代码</li>
<li>gd 跳转到定义</li>
<li>gD 跳转到声明</li>
<li>gr 跳转到引用</li>
<li>gy 跳转到类型定义</li>
<li>gI 跳转到函数实现</li>
<li>gn 重命名当前光标下的变量名</li>
<li>g + tab  查找命令表</li>
<li>gci   批量注释和反注释</li>
<li>K  查看当前光标下的symbol的文档</li>
<li>ctrl + i 或者 ctrl + o 光标跳转到上一次、下一次的位置</li>
<li>然后，不同的窗口之间切换，F2 F3</li>
<li>:Git blame 显示每一行的提交信息</li>
<li>空格 + g   打开所有当前git仓库中的文件</li>
<li>空格 + s   相当于git status</li>
<li>空格 + h   显示最近打开过的文件</li>
<li>空格 + b   显示目前已经打开的所有文件</li>
<li>空格 + l    搜索已打开文件中的内容</li>
<li>空格 + o    只在当前文件中搜索</li>
<li>空格 + r   在目前没打开的文件中搜索name</li>
<li>% 跳转到匹配的括号</li>
</ul>
<p>一些可以修改的运行tasks配置：</p>
<ul>
<li>位置： <code>~/.vim/tasks.ini</code></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>ZigBeePRO-Fundamentals_Training</title>
    <url>/2022/07/28/05/</url>
    <content><![CDATA[<h1 id="1-ZigBeePRO-Fundamentals-Training"><a href="#1-ZigBeePRO-Fundamentals-Training" class="headerlink" title="1_ZigBeePRO-Fundamentals_Training"></a>1_ZigBeePRO-Fundamentals_Training</h1><h2 id="0-Agend"><a href="#0-Agend" class="headerlink" title="0 Agend"></a>0 Agend</h2><ul>
<li>Zigbee Basics</li>
<li>Zigbee Architecture</li>
<li>ZigBee PRO Networks</li>
<li>ZigBee Profiles, Devices and Clusters</li>
<li>Network Commissioning</li>
<li>Network Security</li>
</ul>
<h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><ul>
<li>低功耗：将传输范围限制在0-10m line-of-sight.</li>
<li>ZigBee 通常用于需要较长电池寿命和安全网络的<strong>低数据速率</strong>应用。</li>
<li>ZigBee 的定义速率为 250 Kbit&#x2F;s，最适合来自传感器或输入设备的间歇性数据传输intermittent data transmissions</li>
<li>10 kbps to 115 kbps data throughput </li>
<li>10 to 75 m coverage range</li>
</ul>
<ul>
<li>Up to 100 collocated networks</li>
</ul>
<ul>
<li>Up to 2 years of battery life on standard alkaline  batteries</li>
</ul>
<h2 id="1-Basic"><a href="#1-Basic" class="headerlink" title="1. Basic"></a>1. Basic</h2><h3 id="1-1-ZigBee的理想应用"><a href="#1-1-ZigBee的理想应用" class="headerlink" title="1.1 ZigBee的理想应用"></a>1.1 ZigBee的理想应用</h3><ul>
<li>点对点cable  replacement（例如，无线鼠标、遥控器、玩具） </li>
<li>安全系统（例如，火灾和入侵者）</li>
<li>环境控制（例如，供暖和空调）</li>
<li>医院病人监控</li>
<li>照明控制</li>
<li>家庭自动化（例如，家庭娱乐、门、大门、窗帘和百叶窗）</li>
<li>自动抄表 (AMR)</li>
<li>工业自动化（例如，工厂监控）</li>
</ul>
<p><img src="/2022/07/28/05/different.PNG" alt="different"></p>
<h2 id="2-Architecture"><a href="#2-Architecture" class="headerlink" title="2. Architecture"></a>2. Architecture</h2><h3 id="2-1-适用于-ZigBee-堆栈的-OSI-模型"><a href="#2-1-适用于-ZigBee-堆栈的-OSI-模型" class="headerlink" title="2.1 适用于 ZigBee 堆栈的 OSI 模型"></a>2.1 适用于 ZigBee 堆栈的 OSI 模型</h3><p><img src="/2022/07/28/05/OSI.PNG" alt="OSI"></p>
<h3 id="2-2-软件架构"><a href="#2-2-软件架构" class="headerlink" title="2.2 软件架构"></a>2.2 软件架构</h3><p><img src="/2022/07/28/05/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84.jpg" alt="软件架构"></p>
<h2 id="3-ZigBee-Pro-Networks"><a href="#3-ZigBee-Pro-Networks" class="headerlink" title="3. ZigBee Pro Networks"></a>3. ZigBee Pro Networks</h2><h3 id="3-1-网络节点"><a href="#3-1-网络节点" class="headerlink" title="3.1 网络节点"></a>3.1 网络节点</h3><ul>
<li>Coordinator ：<ul>
<li>每个网络都必须有一个Co-ordinator；</li>
<li>开启整个网络；</li>
<li>允许子节点通过它加入网络；</li>
<li>能作为父节点，允许有children Coordinator；</li>
</ul>
</li>
<li>Router ： <ul>
<li>网络可以有多个router；</li>
<li>router有路由能力；</li>
<li>允许其他节点通过它加入网络；</li>
<li>能作为parent，也能作为child；</li>
</ul>
</li>
<li>End Device ： <ul>
<li>网络可以有很多终端设备；</li>
<li>只有收发数据的能力；</li>
<li>不能做parents，不能有child；</li>
</ul>
</li>
</ul>
<h3 id="3-2-Network-Identity"><a href="#3-2-Network-Identity" class="headerlink" title="3.2 Network Identity"></a>3.2 Network Identity</h3><ul>
<li>PAN ID<ul>
<li>16位的值，叫做PAN ID （Personal Area Network Identifier).</li>
<li>网络运行时，由Cooridnator随机选择；</li>
<li>新安装的网络生成的PAN ID可能与同一radio channel同一neighborhood的已有的网络存在冲突；</li>
</ul>
</li>
<li>Extended PAN ID： 64位的值，叫做EPID；</li>
</ul>
<h3 id="3-2-Network-Addressing"><a href="#3-2-Network-Addressing" class="headerlink" title="3.2 Network Addressing"></a>3.2 Network Addressing</h3><ul>
<li>IEEE (MAC) 地址：<ul>
<li>这是一个 64 位地址，由 IEEE 分配，唯一标识设备</li>
<li>在 ZigBee 网络中，有时称为“extended”地址。</li>
</ul>
</li>
<li>网络地址：<ul>
<li>此16位地址标识网络中的节点</li>
<li>有时称为“short”地址。</li>
<li>当节点首次加入网络时，由父节点动态分配为随机 16 位值。</li>
</ul>
</li>
<li>协调器始终拥有网络地址 0x0000</li>
</ul>
<h3 id="3-3-NerghborTables"><a href="#3-3-NerghborTables" class="headerlink" title="3.3 NerghborTables"></a>3.3 NerghborTables</h3><blockquote>
<p>路由节点（Router 或 Coordinator）保存有关其相邻节点的信息，该信息存储在 Neighbor 表中，其中包含节点的直接子节点的条目.</p>
</blockquote>
<h3 id="3-4-网络创建的过程"><a href="#3-4-网络创建的过程" class="headerlink" title="3.4 网络创建的过程"></a>3.4 网络创建的过程</h3><ol>
<li>初始化IEEE 802.15.4 stack</li>
<li>创建PAN Coordinator</li>
<li>设置网络的PAN ID</li>
<li>设置PAN Coordinator的short地址；</li>
<li>选择radio frequency channel</li>
<li>start网络</li>
<li>加入其他设备</li>
<li>开始传输数据</li>
</ol>
<h3 id="3-5-Descriptors"><a href="#3-5-Descriptors" class="headerlink" title="3.5 Descriptors"></a>3.5 Descriptors</h3><ul>
<li>Node Descriptor<ul>
<li>类型（End Device, Router or Coordinator) </li>
<li>使用的频段（868 MHz、902 MHz 或 2400 MHHz）</li>
</ul>
</li>
<li>Node Power Descriptor<ul>
<li>Power mode</li>
<li>Available power sources</li>
</ul>
</li>
<li>Simple Descriptor<ul>
<li>The endpoint on which the application communicates</li>
<li>Lists of input and output clusters</li>
</ul>
</li>
</ul>
<h2 id="4-ZIGBEE-PROFILES-DEVICES-AND-CLUSTER"><a href="#4-ZIGBEE-PROFILES-DEVICES-AND-CLUSTER" class="headerlink" title="4. ZIGBEE PROFILES, DEVICES AND CLUSTER"></a>4. ZIGBEE PROFILES, DEVICES AND CLUSTER</h2><h3 id="4-1-ZigBee-Endpoints"><a href="#4-1-ZigBee-Endpoints" class="headerlink" title="4.1 ZigBee Endpoints"></a>4.1 ZigBee Endpoints</h3><ul>
<li>一个设备可以运行多个应用程序或同一应用程序的多个实例</li>
<li>endpoint是为应用程序实例提供通信端口的软件实体</li>
<li>endpoint number用于在向node发送消息时标识目标应用程序</li>
<li>256 个endpoints，编号0 到 255：<ul>
<li>0 保留给 ZDO（ZigBee Device Objects</li>
<li>1 到 240 可用于应用程序实例</li>
<li>241 到 254 保留，242 保留给 ZigBee Green Power</li>
<li>255 用于广播到所有应用程序实例</li>
</ul>
</li>
</ul>
<h3 id="4-2-Application-Profiles"><a href="#4-2-Application-Profiles" class="headerlink" title="4.2 Application Profiles"></a>4.2 Application Profiles</h3><ul>
<li>应用程序配置文件定义了一组设备，这些设备可以一起用于实现特定市场领域的应用程序——例如：<ul>
<li>照明系统的开&#x2F;关 switch、调光开关和占用传感器用于光照系统；</li>
</ul>
</li>
<li>ZigBee 联盟定义了许多“公共”配置文件-例如：<ul>
<li>智能能源</li>
<li>家庭自动化</li>
</ul>
</li>
<li><strong>公共配置文件确保来自不同制造商的 ZigBee 设备的互操作性</strong> -例如：<ul>
<li>允许一个供应商的开关与另一个供应商的灯具（包含负载控制器）一起工作</li>
</ul>
</li>
<li>可互操作的产品必须经过测试和认证，以符合相关的 ZigBee 应用规范</li>
</ul>
<h3 id="4-3-Device-Types"><a href="#4-3-Device-Types" class="headerlink" title="4.3 Device Types"></a>4.3 Device Types</h3><ul>
<li>ZigBee 配置文件（例如家庭自动化）包含许多设备类型</li>
<li>设备类型是：<ul>
<li>对应于功能设备的软件实体（例如可调光）</li>
<li>在节点上作为具有相应端点的应用程序实施</li>
</ul>
</li>
<li>设备类型由许多功能“集群”支持：<ul>
<li>一些集群是强制性的（例如基本集群），一些是可选的</li>
<li>一些集群是特定于配置文件的</li>
<li>一些集群由配置文件共享并来自 ZigBee Cluster Library (ZCL)</li>
</ul>
</li>
<li>在设备结构中启用了所需的集群</li>
<li>可以在同一节点上实现多个设备类型（或同一设备类型的多个实例）</li>
</ul>
<h3 id="4-4-Clusters-and-Attributes"><a href="#4-4-Clusters-and-Attributes" class="headerlink" title="4.4 Clusters and Attributes"></a>4.4 Clusters and Attributes</h3><ul>
<li>集群是最小的功能构建块，对应于特定功能（例如开&#x2F;关、可调光、恒温器</li>
<li>集群包含<strong>属性和用于与它们交互的命令</strong></li>
<li>属性是保存的<strong>数据实体</strong>（例如温度）在设备上并且可以在设备之间进行通信</li>
<li>例如，恒温器集群包含与以下相关的属性：<ul>
<li>当前温度</li>
<li>最低温度</li>
<li>最高温度</li>
</ul>
</li>
<li>ZigBee 联盟已经定义了标准集群：<ul>
<li>在 ZigBee Cluster Library(ZCL)中收集的一组常见集群</li>
<li>作为公共应用程序配置文件一部分的特定集群，例如智能能源</li>
</ul>
</li>
<li>一个集群有两种形式——<strong>客户端和服务端</strong>——存在于两个通信设备上</li>
</ul>
<h3 id="4-5-Cluster-Servers-and-Clients"><a href="#4-5-Cluster-Servers-and-Clients" class="headerlink" title="4.5 Cluster Servers and Clients"></a>4.5 Cluster Servers and Clients</h3><p>一个集群有两种形式，服务器和客户端：</p>
<ul>
<li>Cluster Server：<strong>用于存储属性并接收命令来操作它们</strong></li>
<li>Cluster Client：用于通过<strong>发送命令</strong>来操作相应集群server中的属性（通常是“写”命令设置属性值，“读”命令获取属性值）</li>
</ul>
<h2 id="5-NETWORK-COMMISSIONING"><a href="#5-NETWORK-COMMISSIONING" class="headerlink" title="5. NETWORK COMMISSIONING"></a>5. NETWORK COMMISSIONING</h2><h3 id="5-1-Service-Discovery-服务发现"><a href="#5-1-Service-Discovery-服务发现" class="headerlink" title="5.1 Service Discovery  服务发现"></a>5.1 Service Discovery  服务发现</h3><ul>
<li>允许加入设备找到与之操作的兼容节点（例如，调光开关可能需要找到可调光）</li>
<li>有关节点的信息保存在节点的“descriptors”中<ul>
<li>根据兼容的集群进行匹配</li>
<li>集群信息是保存在节点上的简单描述符中</li>
</ul>
</li>
<li>加入节点broadcast一个匹配描述符请求（Match Descriptor Request），列出感兴趣的集群</li>
<li>具有相关集群的节点单播unicast一个Match Descriptor Response，包含地址和端点信息<ul>
<li>加入节点可能会收到多个响应</li>
<li>加入节点上的应用程序，必须确定它将与哪个响应节点一起工作</li>
</ul>
</li>
</ul>
<p><img src="/2022/07/28/05/Service%20Discovery.PNG" alt="Service Discovery"></p>
<h3 id="5-2-Direct-Addressing-Grouping-and-Binding-直接寻址、分组和绑定"><a href="#5-2-Direct-Addressing-Grouping-and-Binding-直接寻址、分组和绑定" class="headerlink" title="5.2 Direct Addressing, Grouping and Binding 直接寻址、分组和绑定"></a>5.2 Direct Addressing, Grouping and Binding 直接寻址、分组和绑定</h3><p>节点可以通过直接寻址、分组或绑定与compatible node进行通信：</p>
<ul>
<li>Direct Addressing 涉及使用其地址向各个节点发送消息。</li>
<li>Grouping 涉及创建具有关联 16 位组地址的一组节点：<ul>
<li>Group Table保存在每个远程（目标）节点</li>
<li>此表包含节点所属组的组的地址</li>
<li>组的消息发送到相应的组地址</li>
<li>当一个group的消息已经receive，仅当组地址在表中时才接受此消息</li>
</ul>
</li>
<li>Binding 涉及创建一组预定义的链接或与远程节点的绑定：<ul>
<li>将本地端点（应用程序）与远程节点上的端点（应用程序）绑定</li>
<li>包含这些链路的绑定表保存在本地（源）节点上</li>
<li>来自本地端点的所有后续通信都自动发送到绑定的远程端点</li>
<li>可以本地或远程创建绑定</li>
</ul>
</li>
</ul>
<h3 id="5-3-Sending-Data-Packets-by-Direct-Addressing-通过直接寻址发送数据包"><a href="#5-3-Sending-Data-Packets-by-Direct-Addressing-通过直接寻址发送数据包" class="headerlink" title="5.3 Sending Data Packets by Direct Addressing 通过直接寻址发送数据包"></a>5.3 Sending Data Packets by Direct Addressing 通过直接寻址发送数据包</h3><p><img src="/2022/07/28/05/send.PNG" alt="send"></p>
<h3 id="5-4-Sending-Data-Packets-by-Group-Addressing-通过组寻址发送数据包"><a href="#5-4-Sending-Data-Packets-by-Group-Addressing-通过组寻址发送数据包" class="headerlink" title="5.4 Sending Data Packets by Group Addressing  通过组寻址发送数据包"></a>5.4 Sending Data Packets by Group Addressing  通过组寻址发送数据包</h3><p>要在group中包括node，必须使用“Add Group”命令将group address添加到node上的“Group Table”中。</p>
<h3 id="5-5-Local-and-Remote-Binding"><a href="#5-5-Local-and-Remote-Binding" class="headerlink" title="5.5 Local and Remote Binding"></a>5.5 Local and Remote Binding</h3><h4 id="Local-Binding"><a href="#Local-Binding" class="headerlink" title="Local Binding"></a>Local Binding</h4><p>Local device writes details of bound endpoint into its Binding Table.</p>
<p><img src="/2022/07/28/05/local.PNG" alt="local"></p>
<h4 id="Remote-Binding-Watch-Trap"><a href="#Remote-Binding-Watch-Trap" class="headerlink" title="Remote Binding(Watch,  Trap)"></a>Remote Binding(Watch,  Trap)</h4><p>Local device requests remote devices to write its details into their Binding Tables.</p>
<p><img src="/2022/07/28/05/remote.PNG" alt="remote"></p>
<h3 id="5-6-Sending-Data-Packets-to-Bound-Endpoints"><a href="#5-6-Sending-Data-Packets-to-Bound-Endpoints" class="headerlink" title="5.6 Sending Data Packets to Bound Endpoints"></a>5.6 Sending Data Packets to Bound Endpoints</h3><p><img src="/2022/07/28/05/send2.PNG" alt="send2"></p>
<h3 id="5-6-Attribute-Reporting"><a href="#5-6-Attribute-Reporting" class="headerlink" title="5.6 Attribute Reporting"></a>5.6 Attribute Reporting</h3><ul>
<li>一个节点可能需要向另一个节点发送regular&#x2F;periodic报告。比如，一个开&#x2F;关灯将其状态报告给Control Bridge（用于物联网）</li>
<li>属性报告涉及从集群服务器主动向客户端发送属性值（而不是客户端轮询polling服务器）： <ul>
<li>减少网络流量</li>
<li>允许休眠服务器报告唤醒时的属性值</li>
</ul>
</li>
<li>“属性报告”可以通过以下方式发出：<ul>
<li>通过用户应用程序中的函数调用（在服务器设备上）</li>
<li>由 ZCL 自动发出</li>
</ul>
</li>
<li>自动属性报告涉及两种机制：<ul>
<li>报告由属性值变化触发</li>
<li>定期为属性发布报告</li>
<li>这些机制可以同时运行</li>
</ul>
</li>
</ul>
<p>必须首先使用Configure Reporting命令配置属性报告。</p>
<h2 id="6-NETWORK-SECURITY"><a href="#6-NETWORK-SECURITY" class="headerlink" title="6. NETWORK SECURITY"></a>6. NETWORK SECURITY</h2><h2 id="6-1-Security-Schemes-安全方案"><a href="#6-1-Security-Schemes-安全方案" class="headerlink" title="6.1 Security Schemes 安全方案"></a>6.1 Security Schemes 安全方案</h2><p>安全措施由信任中心管理：</p>
<ul>
<li>Trust Center Policy 信任中心策略<ul>
<li>White Listing白名单：仅允许预定义的“友好”节点加入网络</li>
<li>Security Key Distribution安全密钥分发：生成和传输用于加密的密钥</li>
</ul>
</li>
<li>Encryption Schemes加密方案<ul>
<li>高度安全的基于 AES 的加密系统</li>
<li>128 位加密密钥</li>
<li>可应用于两个级别：<ul>
<li>Network Level网络级别：相同的“网络密钥”用于所有网络通信</li>
<li>Application Level应用级别（可选）：每对应用程序之间的唯一“Link key”</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-2-Network-Key-Provisioning"><a href="#6-2-Network-Key-Provisioning" class="headerlink" title="6.2 Network Key Provisioning"></a>6.2 Network Key Provisioning</h3><ul>
<li>下图说明了从Trust Centre到joining node的Network Key的提供。</li>
<li>该过程假定预配置的Link Key（全局或唯一）可用。</li>
<li>使用唯一link key，Trust Centre检查其是否具有与joining node的 MAC 地址相对应的密钥。</li>
</ul>
<p><img src="/2022/07/28/05/key.PNG" alt="key"></p>
<h3 id="6-3-Application-level-Security"><a href="#6-3-Application-level-Security" class="headerlink" title="6.3 Application-level Security"></a>6.3 Application-level Security</h3><ul>
<li>可以为一对节点设置</li>
<li>允许两个节点之间的专用通信，使用application link key进行加密&#x2F;解密</li>
<li>link key是唯一的，一对节点独占的</li>
<li>link key由信任中心颁发：<ul>
<li>来自 TC 的一个请求节点链接密钥</li>
<li>TC 将密钥发送到两个节点</li>
<li>密钥的传输使用Network Key和TC和target node中间的link key加密（如果适用的话）</li>
</ul>
</li>
</ul>
<p><img src="/2022/07/28/05/Application-level.png" alt="Application-level"></p>
<h3 id="6-4-Data-Encryption-x2F-Decryption-in-Stack"><a href="#6-4-Data-Encryption-x2F-Decryption-in-Stack" class="headerlink" title="6.4 Data Encryption&#x2F;Decryption in Stack"></a>6.4 Data Encryption&#x2F;Decryption in Stack</h3><p><img src="/2022/07/28/05/Encryption_Decryption.png" alt="Encryption_Decryption"></p>
<h2 id="7-ZIGBEE-CERTIFICATION"><a href="#7-ZIGBEE-CERTIFICATION" class="headerlink" title="7. ZIGBEE CERTIFICATION"></a>7. ZIGBEE CERTIFICATION</h2><p>Zigbee 3.0</p>
<ul>
<li>完整的 loT solution — 从mesh network到允许智能对象协同工作的通用语言。</li>
<li>Zigbee增加了用户和开发人员的选择和灵活性;并让人们相信产品和服务将协同工作。</li>
<li>Zigbee服务于智能家居和商业建筑市场。</li>
</ul>
]]></content>
      <categories>
        <category>NXP</category>
      </categories>
      <tags>
        <tag>NXP</tag>
        <tag>ZigBee</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/03/18/57/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>pyTorch学习</title>
    <url>/2022/03/17/11/</url>
    <content><![CDATA[<h2 id="一、-MLP-模型的实现"><a href="#一、-MLP-模型的实现" class="headerlink" title="一、 MLP 模型的实现"></a>一、 MLP 模型的实现</h2><ul>
<li>数据 <code>sigmoid.csv</code>, 前几列是特征值，最后一列是lable；</li>
<li>通过建立自己的数据集跑出结果；</li>
</ul>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B…H</th>
<th>I</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-0.882353</td>
<td align="center">…</td>
<td>0</td>
</tr>
<tr>
<td align="center">-0.882353</td>
<td align="center">…</td>
<td>1</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line"><span class="comment">### 自己实现Dataset类去加载本地的CSV数据 ###</span></span><br><span class="line"><span class="comment">### 需要三个函数： init get_item len</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, filepath</span>):</span><br><span class="line">        xy = np.loadtxt(filepath, delimiter=<span class="string">&quot;,&quot;</span>, dtype=np.float32)</span><br><span class="line">        self.<span class="built_in">len</span> = xy.shape[<span class="number">0</span>] <span class="comment"># 行数</span></span><br><span class="line">        self.x_data = torch.from_numpy(xy[:, :-<span class="number">1</span>])  <span class="comment">#所有的行，不包括最后一列的其他列</span></span><br><span class="line">        self.y_data = torch.from_numpy(xy[:, [-<span class="number">1</span>]]) <span class="comment">#所有的行，最后一列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="keyword">return</span> self.x_data[index], self.y_data[index]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">len</span></span><br><span class="line"></span><br><span class="line">dataset = MyDataset(<span class="string">&#x27;./sigmoid.csv&#x27;</span>)</span><br><span class="line">train_loader = DataLoader(dataset=dataset, batch_size=<span class="number">32</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Model, self).__init__()</span><br><span class="line">        self.linear1 = torch.nn.Linear(<span class="number">8</span>, <span class="number">6</span>)</span><br><span class="line">        self.linear2 = torch.nn.Linear(<span class="number">6</span>, <span class="number">4</span>)</span><br><span class="line">        self.linear3 = torch.nn.Linear(<span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line">        self.sigmoid = torch.nn.Sigmoid()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.sigmoid(self.linear1(x))</span><br><span class="line">        x = self.sigmoid(self.linear2(x))</span><br><span class="line">        x = self.sigmoid(self.linear3(x))</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">model = Model()</span><br><span class="line"><span class="comment">### 建立 损失函数 和 优化器</span></span><br><span class="line">criterion = torch.nn.BCELoss(reduction=<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="keyword">for</span> i, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        inputs, labels = data</span><br><span class="line">        y_pred = model(inputs)</span><br><span class="line">        loss = criterion(y_pred, labels)</span><br><span class="line">        <span class="built_in">print</span>(epoch, i, loss.item())</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.bachward()</span><br></pre></td></tr></table></figure>

<h2 id="二、CNN模型"><a href="#二、CNN模型" class="headerlink" title="二、CNN模型"></a>二、CNN模型</h2><ul>
<li>mnist数据集，只有20个，用来举例</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MnistDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, image_path, image_label, transform=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(MnistDataset, self).__init__()</span><br><span class="line">        self.image_path = image_path  <span class="comment"># 初始化图像路径列表</span></span><br><span class="line">        self.image_label = image_label  <span class="comment"># 初始化图像标签列表</span></span><br><span class="line">        self.transform = transform  <span class="comment"># 初始化数据增强方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        获取对应index的图像，并视情况进行数据增强</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        image = Image.<span class="built_in">open</span>(self.image_path[index])</span><br><span class="line">        image = np.array(image)</span><br><span class="line">        label = <span class="built_in">int</span>(self.image_label[index])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.transform <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            image = self.transform(image)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> image, torch.tensor(label)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.image_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_path_label</span>(<span class="params">img_root, label_file_path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取数字图像的路径和标签并返回对应列表</span></span><br><span class="line"><span class="string">    @para: img_root: 保存图像的根目录</span></span><br><span class="line"><span class="string">    @para:label_file_path: 保存图像标签数据的文件路径 .csv 或 .txt 分隔符为&#x27;,&#x27;</span></span><br><span class="line"><span class="string">    @return: 图像的路径列表和对应标签列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    data = pd.read_csv(label_file_path, names=[<span class="string">&quot;img&quot;</span>, <span class="string">&quot;label&quot;</span>])</span><br><span class="line">    data[<span class="string">&quot;img&quot;</span>] = data[<span class="string">&quot;img&quot;</span>].apply(<span class="keyword">lambda</span> x: img_root + x)</span><br><span class="line">    <span class="keyword">return</span> data[<span class="string">&quot;img&quot;</span>].tolist(), data[<span class="string">&quot;label&quot;</span>].tolist()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取训练集路径列表和标签列表</span></span><br><span class="line">dir_path = os.path.dirname(__file__)</span><br><span class="line">train_data_root = dir_path + <span class="string">&quot;/mnist_data/train/&quot;</span></span><br><span class="line">train_label = dir_path + <span class="string">&quot;/mnist_data/train.txt&quot;</span></span><br><span class="line">train_img_list, train_label_list = get_path_label(train_data_root, train_label)</span><br><span class="line"><span class="comment"># 训练集dataset</span></span><br><span class="line">train_dataset = MnistDataset(</span><br><span class="line">    train_img_list,</span><br><span class="line">    train_label_list,</span><br><span class="line">    transform=transforms.Compose([transforms.ToTensor()]),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取测试集路径列表和标签列表</span></span><br><span class="line"></span><br><span class="line">test_data_root = dir_path + <span class="string">&quot;/mnist_data/test/&quot;</span></span><br><span class="line">test_label = dir_path + <span class="string">&quot;/mnist_data/test.txt&quot;</span></span><br><span class="line">test_img_list, test_label_list = get_path_label(test_data_root, test_label)</span><br><span class="line"><span class="comment"># 测试集sdataset</span></span><br><span class="line">test_dataset = MnistDataset(</span><br><span class="line">    test_img_list,</span><br><span class="line">    test_label_list,</span><br><span class="line">    transform=transforms.Compose([transforms.ToTensor()]),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">num_epochs = <span class="number">5</span></span><br><span class="line">num_classes = <span class="number">10</span></span><br><span class="line">batch_size = <span class="number">10</span></span><br><span class="line">learning_rate = <span class="number">0.001</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">train_loader = torch.utils.data.DataLoader(</span><br><span class="line">    dataset=train_dataset, batch_size=batch_size, shuffle=<span class="literal">True</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">test_loader = torch.utils.data.DataLoader(</span><br><span class="line">    dataset=test_dataset, batch_size=batch_size, shuffle=<span class="literal">False</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConvNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_classes=<span class="number">10</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(ConvNet, self).__init__()</span><br><span class="line">        <span class="comment">## 池化+batchnorm+relu激活+池化</span></span><br><span class="line">        self.layer1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">1</span>, <span class="number">16</span>, kernel_size=<span class="number">5</span>, stride=<span class="number">1</span>, padding=<span class="number">2</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">16</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>),</span><br><span class="line">        )</span><br><span class="line">        self.layer2 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">16</span>, <span class="number">32</span>, kernel_size=<span class="number">5</span>, stride=<span class="number">1</span>, padding=<span class="number">2</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">32</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>),</span><br><span class="line">        )</span><br><span class="line">        self.fc = nn.Linear(<span class="number">7</span> * <span class="number">7</span> * <span class="number">32</span>, num_classes)  <span class="comment">## 全链接</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        out = self.layer1(x)</span><br><span class="line">        out = self.layer2(out)</span><br><span class="line">        out = out.reshape(out.size(<span class="number">0</span>), -<span class="number">1</span>)</span><br><span class="line">        out = self.fc(out)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = ConvNet(num_classes)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Loss and optimizer</span></span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Train the model</span></span><br><span class="line">total_step = <span class="built_in">len</span>(train_loader)</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">    <span class="keyword">for</span> i, (images, labels) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        images = images</span><br><span class="line">        labels = labels</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Forward pass</span></span><br><span class="line">        outputs = model(images)</span><br><span class="line">        loss = criterion(outputs, labels)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Backward and optimize</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="comment"># if (i + 1) % 2 == 0:</span></span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;Epoch [&#123;&#125;/&#123;&#125;], Step [&#123;&#125;/&#123;&#125;], Loss: &#123;:.4f&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">                epoch + <span class="number">1</span>, num_epochs, i + <span class="number">1</span>, total_step, loss.item()</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="三、-RNN"><a href="#三、-RNN" class="headerlink" title="三、 RNN"></a>三、 RNN</h2>]]></content>
      <categories>
        <category>NLP代码详解</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>pyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>基础准备1_Numpy</title>
    <url>/2022/04/01/29/</url>
    <content><![CDATA[<h2 id="0-Numpy的随机数"><a href="#0-Numpy的随机数" class="headerlink" title="0. Numpy的随机数"></a>0. Numpy的随机数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">随机数</span></span><br><span class="line"><span class="string">numpy.random.rand() 产生一个[0,1)之间的随机数, 包含0不包含1</span></span><br><span class="line"><span class="string">numpy.random.randn() 产生一个标准正态分布的随机数 np.random.randn(2,4)</span></span><br><span class="line"><span class="string">np.random.normal(loc=0.0, scale=1.0, size=None)  参数loc决定均值，参数scale决定标准差，参数size决定数量</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">numpy.random.randint(low, high=None, size=None, dtype=&#x27;l&#x27;) 产生一个或多个随机整数，范围区间为[low, high)   np.random.randint(-5,5,size=(2,2))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">numpy.random.random_sample(size=None)</span></span><br><span class="line"><span class="string">numpy.random.random(size=None)</span></span><br><span class="line"><span class="string">numpy.random.ranf(size=None)</span></span><br><span class="line"><span class="string">numpy.random.sample(size=None) 都是产生[0,1)之间的随机数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">np.random.choice(5,size=(3,2)) 产生一个或多个随机整数，范围区间为[0,5)   np.random.choice([1,2,3,4,5],size=(3,2))</span></span><br><span class="line"><span class="string">demo_list = [&#x27;lenovo&#x27;, &#x27;sansumg&#x27;,&#x27;moto&#x27;,&#x27;xiaomi&#x27;, &#x27;iphone&#x27;]</span></span><br><span class="line"><span class="string">np.random.choice(demo_list,size=(3,3), p=[0.1,0.6,0.1,0.1,0.1])    注意p的长度必须和demo_list的长度一致,且p的和为1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">numpy.random.seed() 设置随机数种子</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="1-Numpy的数组"><a href="#1-Numpy的数组" class="headerlink" title="1. Numpy的数组"></a>1. Numpy的数组</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>NLP</category>
        <category>Numpy</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Numpy</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式系统1--简介</title>
    <url>/2022/09/01/08/</url>
    <content><![CDATA[<h1 id="嵌入式系统1–简介"><a href="#嵌入式系统1–简介" class="headerlink" title="嵌入式系统1–简介"></a>嵌入式系统1–简介</h1><h2 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h2><p>是不是RTOS，由<strong>任务调度策略</strong>决定：</p>
<ul>
<li>Windows等OS不是实时操作系统，因为，CPU为任务分配时间片，到了时间不管有没有执行完都换下一个任务，所有任务都有机会运行到，是<strong>时间线轮转策略</strong>；</li>
<li>RTOS有uCosⅡ、VxWorks等，CPU对多个任务分配优先级，执行完一个才执行下一个，是<strong>基于优先级的调度策略</strong>；</li>
</ul>
<h2 id="硬件最小系统"><a href="#硬件最小系统" class="headerlink" title="硬件最小系统"></a>硬件最小系统</h2><ul>
<li>处理器<ul>
<li>51</li>
<li>arm</li>
<li>powerpc</li>
<li>MIPS</li>
</ul>
</li>
<li>电源电路</li>
<li>复位电路</li>
<li>时钟电路</li>
<li>存储电路<ul>
<li>RAM：掉电丢失<ul>
<li>SRAM</li>
<li>DRAM：需要周期性刷新，不然不断电也丢数据</li>
</ul>
</li>
<li>ROM：只读，不能写，掉电不丢失<ul>
<li>PROM：只能写一次</li>
<li>EPROM：可擦除，所以可写入多次，写入前必须擦除，擦除需要紫外线；</li>
<li>EEPROM：先擦后写，电可擦除，容量小，2k左右</li>
</ul>
</li>
<li>FLASH:多次写入，先擦后写<ul>
<li>NORFlash</li>
<li>NANDFlash</li>
<li>EMMC</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="嵌入式软件开发模式"><a href="#嵌入式软件开发模式" class="headerlink" title="嵌入式软件开发模式"></a>嵌入式软件开发模式</h2><ul>
<li>开发主机（Host） — 也叫<strong>上位机</strong><ul>
<li>代码编写、编译</li>
</ul>
</li>
<li>目标板（Target） — 也叫<strong>下位机</strong><ul>
<li>代码运行</li>
</ul>
</li>
<li>连接介质</li>
</ul>
<p><img src="/2022/09/01/08/1.PNG"></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>ARM</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式系统2--开发板介绍</title>
    <url>/2022/09/01/18/</url>
    <content><![CDATA[<h1 id="嵌入式系统2–开发板介绍"><a href="#嵌入式系统2–开发板介绍" class="headerlink" title="嵌入式系统2–开发板介绍"></a>嵌入式系统2–开发板介绍</h1><h2 id="T-PAD开发板简介"><a href="#T-PAD开发板简介" class="headerlink" title="T-PAD开发板简介"></a>T-PAD开发板简介</h2><p>核心板+底板：</p>
<p><img src="/2022/09/01/18/TPAD.PNG" alt="TPAD"></p>
<p>核心板：</p>
<p><img src="/2022/09/01/18/%E6%A0%B8%E5%BF%83%E6%9D%BF.PNG" alt="核心板"></p>
<ul>
<li>DDRAM: 1G</li>
<li>EMMC: 掉电不丢失，相当于硬盘，8G</li>
</ul>
<p>接线方式：</p>
<p><img src="/2022/09/01/18/%E6%8E%A5%E7%BA%BF%E6%96%B9%E5%BC%8F.PNG" alt="接线方式"></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>ARM</tag>
      </tags>
  </entry>
  <entry>
    <title>总线协议之 -- UART</title>
    <url>/2022/09/21/59/</url>
    <content><![CDATA[<h1 id="总线协议之-–-UART"><a href="#总线协议之-–-UART" class="headerlink" title="总线协议之 – UART"></a>总线协议之 – UART</h1><h2 id="UART简介"><a href="#UART简介" class="headerlink" title="UART简介"></a>UART简介</h2><blockquote>
<p>UART: Universal Asynchronous Receiver Transmitter（通用异步收发器），</p>
<p>通用的<em>串行、异步</em>通信总线，它有<strong>两条</strong>数据线，实现<strong>全双工</strong>发送和接收。</p>
</blockquote>
<h3 id="通信基础"><a href="#通信基础" class="headerlink" title="通信基础"></a>通信基础</h3><p>串行、并行：</p>
<ul>
<li>并行通信：总线在传递数据的时候，可以一次性收发多个位的数据。并行虽然快，但是要考虑多个线的<em>资源占用</em>，以及多条线<em>互相干扰</em>的问题；</li>
<li>串行通信：每一位数据逐次传递；（<strong>IIC\SPI都是串行通信</strong>）</li>
</ul>
<p>单工、双工：</p>
<ul>
<li>单工通信：只能是单向的，<mark>发送器给接收器发送数据</mark>，而不能反过来；</li>
<li>双工通信：可以是A到B，也可以是B到A；<ul>
<li>半双工：不能同时发生；只有一根线，发送时就不能接收；</li>
<li>全双工：可以同时发送和接收，有两根线；</li>
</ul>
</li>
</ul>
<p>波特率：</p>
<ul>
<li><p>波特率：描述UART通信速度，单位<strong>bps</strong>，(bit per second)，每秒传送的bit的数量；</p>
<ul>
<li>每秒的波特数，波特等于单个信号包含的码元数量</li>
</ul>
</li>
<li><p>比特率：是指每秒传送的比特(bit)数。单位为 bps(Bit Per Second)，比特率越高，每秒传送数据就越多。</p>
</li>
<li><p>波特率：表示每秒钟传送码元符号的个数，是衡量数据传送速率的指标。</p>
<ul>
<li>在信息传输通道中，携带数据信息的信号单元叫码元，每秒钟通过信道传输的码元数称为码元传输速率，简称<strong>波特率</strong>。波特率是传输通道频宽的指标。</li>
<li>比特率&#x3D;波特率x单个调制状态对应的二进制位数</li>
<li>两相调制(单个调制状态对应1个二进制位)的比特率等于波特率;四相调制(单个调制状态对应2个二进制位)的比特率为波特率的两倍;八相调制(单个调制状态对应3个二进制位)的比特率为波特率的三倍;依次类推。</li>
</ul>
</li>
</ul>
<h2 id="UART帧格式"><a href="#UART帧格式" class="headerlink" title="UART帧格式"></a>UART帧格式</h2><p><img src="/2022/09/21/59/frame_struct.JPG" alt="UART帧格式"></p>
<ul>
<li><input disabled type="checkbox"> 起始位：1bit的0，标志发送开始；因为空闲时为1，所以开始为0；</li>
<li><input checked disabled type="checkbox"> 数据位： 5-8bit，<strong>先发低位，后发高位</strong>；</li>
<li><input disabled type="checkbox"> 校验位：可有可无；奇偶校验，是校验奇数还是偶数个1； </li>
<li><input disabled type="checkbox"> 停止位：高电平1；</li>
<li><input disabled type="checkbox"> 空闲位：</li>
</ul>
<blockquote>
<p>注意： UART<strong>空闲</strong>的时候，用<strong>高电平</strong>表示；</p>
<p>串口协议从低位先发，最后发高位；</p>
<p><mark>串口每次都只发一个byte，下一个byte又重新开始起始位，是因为它是<strong>异步的</strong>，发送方和接收方的时钟不是同一个，防止由于时钟不同步导致误差累积；</mark></p>
<p>IIC和SPI都是同步通信，可以发多个字节；</p>
</blockquote>
<h2 id="Exynos4412下的UART控制器"><a href="#Exynos4412下的UART控制器" class="headerlink" title="Exynos4412下的UART控制器"></a>Exynos4412下的UART控制器</h2><blockquote>
<p>串口的信号一般较弱，通信距离短，容易被干扰，所以增加了一块专有芯片用来增加抗干扰能力，使发送距离更远；(TTL信号转为232信号)</p>
</blockquote>
<p><img src="/2022/09/21/59/shifter.JPG" alt="shifter"></p>
<p>STEPs：</p>
<ol>
<li>待发送数据放入FIFO</li>
<li>增加了UART协议的各种头，比如起始和校验，然后拷贝放入shifter；</li>
<li>shifter每个bit依次移位到引脚来发送，<strong>先发低位，后发高位</strong>；</li>
</ol>
<p><em>接收时顺序相反，RxD –&gt; shifter –&gt; FIFO;</em></p>
<h3 id="UART控制器的总体框图"><a href="#UART控制器的总体框图" class="headerlink" title="UART控制器的总体框图"></a>UART控制器的总体框图</h3><p><img src="/2022/09/21/59/diagram.JPG" alt="框图"></p>
<p><em><strong>CPU会通过总线，和接收和发送的BUFFer相连，用来读写数据，另外，也和控制单元相连，对控制单元的设置进行修改；</strong></em></p>
<h2 id="UART寄存器详解"><a href="#UART寄存器详解" class="headerlink" title="UART寄存器详解"></a>UART寄存器详解</h2><blockquote>
<p>补充一个细节，<strong>回环模式look-back</strong>是在内部将Tx和Rx短接，一般用于测试；</p>
</blockquote>
<p><img src="/2022/09/21/59/workMode.JPG" alt="几种工作模式"></p>
<p>三种工作模式：</p>
<ol>
<li>polling  轮询<ul>
<li>CPU不断地对FIFO进行访问，查询需要的数据有没有发过来；</li>
<li>CPU的状态： 工作 –&gt; 轮询 –&gt; 工作 –&gt; 轮询 …</li>
<li>直到查找到需要的数据；</li>
<li>费时费力，消耗资源</li>
</ul>
</li>
<li>interrupt  中断<ul>
<li>CPU和FIFO约定，CPU<strong>不主动</strong>去查询，当FIFO收到数据要发送过来的时候，给CPU发送<strong>中断信号</strong>，CPU中断当前工作，接收FIFO的数据；</li>
<li><strong>比polling模式省资源</strong>；</li>
</ul>
</li>
<li>DMA  直接存储器访问<ul>
<li>CPU收到FIFO的数据，最终也是要放入某一块内存中去使用的；</li>
<li>DMA模式<strong>跳过CPU</strong>，当FIFO数据过来时，直接放入需要的内存中；</li>
</ul>
</li>
</ol>
<p><mark>UART编程之前，设置需要的寄存器，以及顺序：</mark></p>
<p><img src="/2022/09/21/59/regSet.JPG" alt="regSet"></p>
<h2 id="UART编程"><a href="#UART编程" class="headerlink" title="UART编程"></a>UART编程</h2><h3 id="STEP-1：-串口初始化"><a href="#STEP-1：-串口初始化" class="headerlink" title="STEP 1： 串口初始化"></a>STEP 1： 串口初始化</h3><p><img src="/2022/09/21/59/uartInit.JPG" alt="uartInit"></p>
<h3 id="STEP-2：-main函数"><a href="#STEP-2：-main函数" class="headerlink" title="STEP 2： main函数"></a>STEP 2： main函数</h3><p><img src="/2022/09/21/59/UATRmain.JPG" alt="UATRmain"></p>
<h3 id="STEP-3：-收发函数封装"><a href="#STEP-3：-收发函数封装" class="headerlink" title="STEP 3： 收发函数封装"></a>STEP 3： 收发函数封装</h3><ul>
<li>发送数据：</li>
</ul>
<p><img src="/2022/09/21/59/uartSend.JPG" alt="uartSend"></p>
<ul>
<li>接收数据：</li>
</ul>
<p><img src="/2022/09/21/59/uartRec.JPG" alt="uartRec"></p>
<h3 id="STEP-4：-优化"><a href="#STEP-4：-优化" class="headerlink" title="STEP 4： 优化"></a>STEP 4： 优化</h3><blockquote>
<p>电脑 – &gt; 开发板， 然后开发板收到数据+1，再返回给电脑；</p>
</blockquote>
<p><img src="/2022/09/21/59/uartAdd1.JPG" alt="uartAdd1"></p>
<h2 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h2><blockquote>
<p>这种通过判断发送寄存器是不是空，来把数据放入UART的寄存器中，就是相当于printf重定向到UART串口，而其他操作系统中，是重定向到显卡或者磁盘；</p>
</blockquote>
<p>尝试写一个发送字符串的函数：</p>
<p><img src="/2022/09/21/59/uartSendStr.JPG" alt="uartSendStr"></p>
<p><img src="/2022/09/21/59/uartSend.JPG" alt="uartSend"></p>
]]></content>
      <categories>
        <category>NXP</category>
      </categories>
      <tags>
        <tag>NXP</tag>
        <tag>UART</tag>
      </tags>
  </entry>
  <entry>
    <title>数字设计流程</title>
    <url>/2022/05/06/22/</url>
    <content><![CDATA[<h1 id="数字设计流程"><a href="#数字设计流程" class="headerlink" title="数字设计流程"></a>数字设计流程</h1><blockquote>
<p>先放地址，来源于B站比特大陆相关的学习资料。 <a href="https://www.bilibili.com/video/BV1yY411P7SR?spm_id_from=333.999.0.0">链接</a></p>
</blockquote>
<h2 id="一、-项目立项"><a href="#一、-项目立项" class="headerlink" title="一、 项目立项"></a>一、 项目立项</h2><h3 id="1-1-项目解读"><a href="#1-1-项目解读" class="headerlink" title="1.1 项目解读"></a>1.1 项目解读</h3><p>市场、研发、架构、编译器 等相关人员，进行市场需求和竞品分析，初步决定芯片功能、面积、功耗等相关指标。</p>
<h3 id="1-2-技术调研"><a href="#1-2-技术调研" class="headerlink" title="1.2 技术调研"></a>1.2 技术调研</h3><p>软件建模、硬件预实现、方案可行性分析等，生成一个市场需求报告。</p>
<h3 id="1-3-开发计划制定"><a href="#1-3-开发计划制定" class="headerlink" title="1.3 开发计划制定"></a>1.3 开发计划制定</h3><p>有几个方面会影响到芯片开发的时间线：</p>
<ul>
<li>购买IP，比如PCI接口、DDR等，IP供应商也要时间准备进行定制化开发；</li>
<li>代工厂排期；</li>
<li>预留研发调试时间；</li>
</ul>
<h2 id="二、-研发阶段"><a href="#二、-研发阶段" class="headerlink" title="二、 研发阶段"></a>二、 研发阶段</h2><h3 id="2-1-技术研讨方案制定"><a href="#2-1-技术研讨方案制定" class="headerlink" title="2.1 技术研讨方案制定"></a>2.1 技术研讨方案制定</h3><p>划分芯片的子系统和模块、软硬件工作的划分和规划、各个子系统也要有性能指标定义等。</p>
<h3 id="2-2-详细设计"><a href="#2-2-详细设计" class="headerlink" title="2.2 详细设计"></a>2.2 详细设计</h3><p><img src="/2022/05/06/22/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%E6%AD%A5%E9%AA%A4.png" alt="详细设计"></p>
<blockquote>
<p>算法和硬件架构、硬件电路设计、功能验证都属于前端设计部分；</p>
<p>逻辑综合、静态时序分析、一致性验证算是中端；</p>
<p>布局布线等等都属于后端；</p>
</blockquote>
<p>下面，对这些步骤进行详细介绍：</p>
<h4 id="2-2-1-算法和硬件架构设计"><a href="#2-2-1-算法和硬件架构设计" class="headerlink" title="2.2.1 算法和硬件架构设计"></a>2.2.1 算法和硬件架构设计</h4><ul>
<li>输入： 功能需求</li>
<li>输出： 软件参考模型</li>
<li>过程： 架构人员使用Matlab、C++、System C、 System Verilog 等语言工具，完成芯片中数字部分的高层次算法或架构的分析和建模，为硬件提供正确的软件功能模型，更为重要的是，通过大量的高层次仿真和调试，为RTL实现提供总体性的设计指导。越是复杂的数字电路，这部分算法模型仿真越重要。</li>
</ul>
<p><img src="/2022/05/06/22/%E7%AE%97%E6%B3%95%E5%92%8C%E7%A1%AC%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.png" alt="算法和硬件架构设计"></p>
<h4 id="2-2-2-硬件电路设计"><a href="#2-2-2-硬件电路设计" class="headerlink" title="2.2.2 硬件电路设计"></a>2.2.2 硬件电路设计</h4><ul>
<li>输入： 从架构拿到的软件参考模型</li>
<li>输出： RTL代码、详细的设计文档、逻辑综合报告、语法检查报告</li>
</ul>
<p><img src="/2022/05/06/22/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1.png" alt="硬件电路设计"></p>
<ul>
<li>spyglass: 时序校验、语法校验等</li>
<li>Design Compiler： 预综合，观察时序面积功耗等是否达到要求；</li>
</ul>
<h4 id="2-2-3-功能验证"><a href="#2-2-3-功能验证" class="headerlink" title="2.2.3 功能验证"></a>2.2.3 功能验证</h4><ul>
<li>输入： 设计规格、设计代码、软件模型；</li>
<li>输出： 代码覆盖率和功能覆盖率报告；</li>
</ul>
<p><img src="/2022/05/06/22/%E5%8A%9F%E8%83%BD%E9%AA%8C%E8%AF%81.png" alt="功能验证"></p>
<h4 id="2-2-4-逻辑综合"><a href="#2-2-4-逻辑综合" class="headerlink" title="2.2.4 逻辑综合"></a>2.2.4 逻辑综合</h4><ul>
<li>输入： RTL代码、工艺库、约束；</li>
<li>输出： 网表、标准延迟文件SDF、工程文件(.ddc)、各类报告；</li>
</ul>
<p><img src="/2022/05/06/22/%E9%80%BB%E8%BE%91%E7%BB%BC%E5%90%88.png" alt="逻辑综合"></p>
<h4 id="2-2-5-静态时序分析"><a href="#2-2-5-静态时序分析" class="headerlink" title="2.2.5 静态时序分析"></a>2.2.5 静态时序分析</h4><ul>
<li>中端人员使用静态时序分析工具 Prime Time，从静态分析角度，保证设计中所有的路径，满足内部时序单元对建立时间和保持时间的要求。</li>
<li>即无论起点是什么，信号都可以被及时的传递到该路径的终点，并且在电路正常工作所需的时间段内保持恒定；</li>
</ul>
<p><img src="/2022/05/06/22/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90.png" alt="静态时序分析"></p>
<h4 id="2-2-6-一致性验证"><a href="#2-2-6-一致性验证" class="headerlink" title="2.2.6 一致性验证"></a>2.2.6 一致性验证</h4><ul>
<li>输入： RTL代码、网表、约束；</li>
<li>输出： match（两张图的节点是否一致）和verify（计算得到的两张图的功能是否一致）的报告；</li>
<li>过程： RTL和网表都可以抽象成两幅图，由节点和边组成，中端人员使用Formality、Conformal工具进行一致性验证，采用类似于直接比较两幅图是否一致的方法，来确定网表是否正确。</li>
</ul>
<p><img src="/2022/05/06/22/%E4%B8%80%E8%87%B4%E6%80%A7%E9%AA%8C%E8%AF%81.png" alt="一致性验证"></p>
<h4 id="2-2-7-布局布线"><a href="#2-2-7-布局布线" class="headerlink" title="2.2.7 布局布线"></a>2.2.7 布局布线</h4><ul>
<li>布图规划（floor plan）： 后端人员使用IC complier、 Encounter等工具进行布局前的规划，目标是优化芯片的面积，时序收敛，稳定，方便走线。是整个后端最重要的一步，也是弹性最大的一步。因为没有标准的最佳方案，但又有很多细节需要考虑。</li>
<li>布局： 布局就是摆放标准单元，I&#x2F;o pad（用于胡须连接芯片引脚），宏单元来实现电路逻辑。布局目标：利用率越高越好，总线越短越好，时序越快越好。但是利用率高布线就困难，总线就长，时序就慢，因此要做个平衡取舍。</li>
<li>时钟树综合（clock tree synthesis）： 简单说就是时钟的布线，因为时钟信号在数字电路的全局指挥最用，它的分布应该是对称式连接到各个寄存器单元的，从而时钟从一个时钟源到各个寄存器时，时钟延迟差异最小。这也是为什么时钟信号需要单独布线的原因。</li>
<li>布线： 在满足工艺规则和布线层数限制、线宽、线间距限制和各线网可靠绝缘的电性能约束条件下，根据电路的连接关系，将各单元和I&#x2F;O pad用互连线连接起来。</li>
</ul>
<p><img src="/2022/05/06/22/%E5%B8%83%E5%B1%80%E5%B8%83%E7%BA%BF.png" alt="布局布线"></p>
<h4 id="2-2-8-生成版图并验证"><a href="#2-2-8-生成版图并验证" class="headerlink" title="2.2.8 生成版图并验证"></a>2.2.8 生成版图并验证</h4><ul>
<li>寄生参数提取： 由于导线本身存在电阻，相邻导线之间的互感，耦合电容在芯片内部会产生信号噪声，串扰和反射。这些效应会产生信号完整性的问题，导致信号电压波动和变化，如果严重就会导致信号失真错误。提取寄生参数进行再次分析验证，分析信号完整性是非常重要的。</li>
<li>生成版图并验证： 对完成布线的物理版图进行功能和时序上的验证，大概包括以下方面： LVS（layout vs schematic）、 DRC（Design Rule Checking）、 ERC（Electrical Rule Checking）</li>
</ul>
<p><img src="/2022/05/06/22/%E7%94%9F%E6%88%90%E7%89%88%E5%9B%BE%E5%B9%B6%E9%AA%8C%E8%AF%81.png" alt="生成版图并验证"></p>
]]></content>
      <categories>
        <category>数字IC</category>
      </categories>
      <tags>
        <tag>设计流程</tag>
      </tags>
  </entry>
  <entry>
    <title>数组02移除元素</title>
    <url>/2022/07/15/21/</url>
    <content><![CDATA[<h1 id="数组02–移除元素"><a href="#数组02–移除元素" class="headerlink" title="数组02–移除元素"></a>数组02–移除元素</h1><h2 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h2><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">Given an integer<span class="built_in"> array </span>nums<span class="built_in"> and </span>an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed.</span><br><span class="line"></span><br><span class="line">Since it is impossible to change the length of the<span class="built_in"> array </span>in some languages, you must instead have the result be placed in the first part of the<span class="built_in"> array </span>nums. More formally,<span class="built_in"> if </span>there are k elements after removing the duplicates, then the first k elements of nums should hold the<span class="keyword"> final</span> result. It does<span class="built_in"> not </span>matter what you leave beyond the first k elements.</span><br><span class="line"></span><br><span class="line">Return k after placing the<span class="keyword"> final</span> result in the first k slots of nums.</span><br><span class="line"></span><br><span class="line">Do<span class="built_in"> not </span>allocate extra space for another array. You must do this by modifying the input<span class="built_in"> array </span>in-place with O(1) extra memory.</span><br></pre></td></tr></table></figure>

<p>Example 1:</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">Input: nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], val = <span class="number">3</span></span><br><span class="line">Output: <span class="number">2</span>, nums = [<span class="number">2</span>,<span class="number">2</span>,_,_]</span><br><span class="line">Explanation: Your <span class="keyword">function</span> <span class="title">should</span> <span class="keyword">return</span> <span class="type">k</span> = <span class="number">2</span>, <span class="keyword">with</span> the first two elements <span class="keyword">of</span> nums being <span class="number">2</span>.</span><br><span class="line">It does <span class="keyword">not</span> matter what you leave beyond the returned k (hence they are underscores).</span><br></pre></td></tr></table></figure>

<h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暴力解法：两个循环，一个for遍历数组，一个for更新数组</span></span><br><span class="line"><span class="comment">// 时间 O(n^2)</span></span><br><span class="line"><span class="comment">// 空间 O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == val)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; size; j++)&#123;</span><br><span class="line">                    nums[j<span class="number">-1</span>] = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                i --;<span class="comment">//因为i后面的都前移一位，所以i也要前移一位，</span></span><br><span class="line">                     <span class="comment">//i++回来，再从这个位置计算，因为新的i位置可能还是那个val，要重新判断</span></span><br><span class="line">                size --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h2><blockquote>
<p>双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。</p>
</blockquote>
<p>双指针法（快慢指针法）：<br><strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p>
<p>定义快慢指针:</p>
<ul>
<li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li>
<li>慢指针：指向更新新数组下标的位置</li>
</ul>
<p>很多同学这道题目做的很懵，就是不理解 快慢指针究竟都是什么含义，所以一定要明确含义，后面的思路就更容易理解了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快慢指针法</span></span><br><span class="line"><span class="comment">// 时间O(n)</span></span><br><span class="line"><span class="comment">// 空间O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> fastIndex = <span class="number">0</span>; fastIndex &lt; nums.<span class="built_in">size</span>(); fastIndex++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(val != nums[fastIndex])&#123;</span><br><span class="line">                nums[slowIndex] = nums[fastIndex];</span><br><span class="line">                slowIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowIndex;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="其他相关题目"><a href="#其他相关题目" class="headerlink" title="其他相关题目"></a>其他相关题目</h2><ul>
<li>26.删除排序数组中的重复项</li>
<li>283.移动零</li>
<li>844.比较含退格的字符串</li>
<li>977.有序数组的平方</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>代码随想录</tag>
        <tag>双指针</tag>
        <tag>数组</tag>
        <tag>移除元素</tag>
      </tags>
  </entry>
  <entry>
    <title>数组01二分查找</title>
    <url>/2022/07/14/21/</url>
    <content><![CDATA[<h1 id="数组01–二分查找"><a href="#数组01–二分查找" class="headerlink" title="数组01–二分查找"></a>数组01–二分查找</h1><h2 id="1-数组的基本理论"><a href="#1-数组的基本理论" class="headerlink" title="1. 数组的基本理论"></a>1. 数组的基本理论</h2><ul>
<li>数组下标从0开始；</li>
<li>数组内存空间连续；<ul>
<li>导致数组增加和删除元素需要<strong>移动其他元素，开销很大</strong>！</li>
<li>vector 和 array 的区别：<ul>
<li>vector 的<em>底层是用array实现的，所以，vector是容器，而不是数组</em>！</li>
</ul>
</li>
<li>数组的元素是不能删除的，只能覆盖！</li>
</ul>
</li>
<li>二维数组的内存地址一般是连续的，可能不同，C++是连续的；</li>
<li>测试二维数组的内存地址空间是否连续：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_arr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> array[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    cout &lt;&lt; &amp;array[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;array[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;array[<span class="number">0</span>][<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;array[<span class="number">1</span>][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;array[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;array[<span class="number">1</span>][<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test_arr</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-二分查找"><a href="#2-二分查找" class="headerlink" title="2. 二分查找"></a>2. 二分查找</h2><h3 id="704-Binary-Search"><a href="#704-Binary-Search" class="headerlink" title="704 Binary Search"></a>704 Binary Search</h3><blockquote>
<p>Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.</p>
</blockquote>
<p>You must write an algorithm with O(log n) runtime complexity.</p>
<p>Example 1:</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Input</span>: nums = [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">12</span>], target = <span class="number">9</span></span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Explanation: <span class="number">9</span> <span class="keyword">exists</span> <span class="keyword">in</span> nums <span class="keyword">and</span> its <span class="keyword">index</span> <span class="keyword">is</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Input:</span> nums = [-<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">12</span>], target = <span class="number">2</span></span><br><span class="line"><span class="symbol">Output:</span> -<span class="number">1</span></span><br><span class="line"><span class="symbol">Explanation:</span> <span class="number">2</span> does <span class="built_in">not</span> exist <span class="keyword">in</span> nums so <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>Constraints:</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">104</span></span><br><span class="line"><span class="number">-104</span> &lt; nums[i], target &lt; <span class="number">104</span></span><br><span class="line"><span class="keyword">All</span> the integers <span class="keyword">in</span> nums are <span class="keyword">unique</span>.</span><br><span class="line">nums <span class="keyword">is</span> sorted <span class="keyword">in</span> ascending <span class="keyword">order</span>.</span><br></pre></td></tr></table></figure>

<p>经典二分查找的模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;  <span class="comment">//定义target在左闭右闭空间[left, right]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;  <span class="comment">// 因为left==right时，闭区间依然有效</span></span><br><span class="line">            <span class="type">int</span> middle = left + ((right - left) / <span class="number">2</span>);  <span class="comment">// 防止溢出</span></span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>C语言写法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = numsSize <span class="number">-1</span>;    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> middle = (left + right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[middle]) &#123;</span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[middle]) &#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二分查找的第二种方法"><a href="#二分查找的第二种方法" class="headerlink" title="二分查找的第二种方法"></a>二分查找的第二种方法</h3><ul>
<li>第一种写法是<strong>左闭右闭区间</strong>，这里考虑改成左闭右开区间[left, right)</li>
<li>这样，判断的边界条件就发生了变化；</li>
</ul>
<p>如下两点：</p>
<ul>
<li>while (left &lt; right)，这里使用 &lt; ,因为left &#x3D;&#x3D; right在区间[left, right)是没有意义的<br>if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>二分查找最重要的地方，是搞清3点!<ol>
<li>根本点： 使用闭区间还是开区间；</li>
<li>while中的条件在该区间下是否存在；</li>
<li>闭区间的right是middle-1，开区间的right是middle；但是left都是middle+1；<strong>因为开区间的时候，middle为right就刚好是取不到的情况！</strong></li>
</ol>
</li>
</ul>
<h3 id="其他相关题目"><a href="#其他相关题目" class="headerlink" title="其他相关题目"></a>其他相关题目</h3><ul>
<li>35</li>
<li>34</li>
<li>69</li>
<li>367</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>代码随想录</tag>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>数组03有序数组的平方</title>
    <url>/2022/07/20/21/</url>
    <content><![CDATA[<h1 id="数组03–有序数组的平方"><a href="#数组03–有序数组的平方" class="headerlink" title="数组03–有序数组的平方"></a>数组03–有序数组的平方</h1><h2 id="977-Squares-of-a-Sorted-Array"><a href="#977-Squares-of-a-Sorted-Array" class="headerlink" title="977. Squares of a Sorted Array"></a>977. Squares of a Sorted Array</h2><blockquote>
<p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p>
</blockquote>
<blockquote>
<p>示例 1： 输入：nums &#x3D; [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</p>
</blockquote>
<blockquote>
<p>示例 2： 输入：nums &#x3D; [-7,-3,2,3,11] 输出：[4,9,9,49,121]</p>
</blockquote>
<h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><ul>
<li>直接每个数求平方，然后排序</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            nums[i] *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">//快速排序</span></span><br><span class="line">        <span class="keyword">return</span> nums;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ul>
<li>时间复杂度：**O(n + nlogn)**， 可以说是O(nlogn)的时间复杂度，但为了和下面双指针法算法时间复杂度有鲜明对比，我记为 O(n + nlog n)；</li>
<li>空间复杂度： ？？快排的空间复杂度是多少？</li>
</ul>
<h2 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h2><p>数组其实是有序的， 只不过负数平方之后可能成为最大数了。</p>
<p><strong>那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</strong></p>
<ol>
<li>此时可以考虑双指针法了，i指向起始位置，j指向终止位置。</li>
<li>定义一个新数组result，和nums数组一样的大小，让k指向result数组终止位置。<ul>
<li>如果 nums[i] * nums[i] &lt; nums[j] * nums[j] 那么result[k–] &#x3D; nums[j] * nums[j];</li>
<li>如果 nums[i] * nums[i] &gt;&#x3D; nums[j] * nums[j] 那么result[k–] &#x3D; nums[i] * nums[i];</li>
<li>相当于通过双指针，把nums中的元素一个个拉进来result中；</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = nums.<span class="built_in">size</span>()<span class="number">-1</span>; i&lt;=j; ) &#123;  <span class="comment">// 注意这里i&lt;=j，因为最后i=j的时候还有一个元素没有放进去result</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]*nums[i] &lt; nums[j]*nums[j]) &#123;</span><br><span class="line">                result[k] = nums[j]*nums[j];</span><br><span class="line">                k--;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                result[k] = nums[i] * nums[i];</span><br><span class="line">                k--;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<ul>
<li>时间复杂度： <strong>O(n)</strong>;</li>
<li>空间复杂度： ？？？</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>代码随想录</tag>
        <tag>双指针</tag>
        <tag>数组</tag>
        <tag>有序数组的平方</tag>
      </tags>
  </entry>
  <entry>
    <title>数组04长度最小的子数组</title>
    <url>/2022/07/21/21/</url>
    <content><![CDATA[<h1 id="数组04–长度最小的子数组"><a href="#数组04–长度最小的子数组" class="headerlink" title="数组04–长度最小的子数组"></a>数组04–长度最小的子数组</h1><h2 id="209-Minimum-Size-Subarray-Sum"><a href="#209-Minimum-Size-Subarray-Sum" class="headerlink" title="209. Minimum Size Subarray Sum"></a>209. Minimum Size Subarray Sum</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><blockquote>
<p>给定一个含有 n 个正整数的数组nums和一个正整数 target ，</p>
<p>找出该数组中满足其sum ≥ target 的长度最小的<strong>连续子数组</strong>，并返回其长度。</p>
<p>如果不存在符合条件的子数组，返回 0。</p>
</blockquote>
<p>示例：</p>
<blockquote>
<p>输入：s &#x3D; 7, nums &#x3D; [2,3,1,2,4,3] </p>
<p>输出：2 </p>
<p>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>滑动窗口！</strong></p>
<h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><ul>
<li>两个for循环，不断寻找符合条件的子序列，</li>
<li>时间复杂度是<strong>O(n^2)</strong>;</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = INT32_MAX;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> subLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123; <span class="comment">// 子序列起点为i</span></span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum &gt;= target)&#123;</span><br><span class="line">                    subLength = j - i + <span class="number">1</span>;</span><br><span class="line">                    result = result &lt; subLength ? result : subLength; <span class="comment">//长度最小的子数组</span></span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 找到一个子数组之后就break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == INT32_MAX ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>接下来就开始介绍数组操作中另一个重要的方法：<strong>滑动窗口</strong>。</p>
<ul>
<li>所谓滑动窗口，就是<strong>不断的调节子序列的起始位置和终止位置</strong>，从而得出我们要想的结果。</li>
<li>在暴力解法中，是一个for循环滑动窗口的起始位置，一个for循环为滑动窗口的终止位置，用两个for循环完成了一个不断搜索区间的过程。</li>
<li>滑动窗口如何<strong>用一个for循环来完成这个操作</strong>。</li>
<li>注意： 只用一个for循环，那么这个循环的索引，一定是表示<strong>滑动窗口的终止位置</strong>。</li>
<li>那么问题来了， 滑动窗口的起始位置如何移动呢？</li>
</ul>
<p>滑动窗口的思路需要解决几个问题：</p>
<ol>
<li>窗口内是什么？</li>
<li>如何移动窗口的起始位置？</li>
<li>如何移动窗口的结束位置？</li>
</ol>
<ul>
<li>窗口就是<strong>满足其和 ≥ target 的长度最小的连续子数组</strong>。</li>
<li>窗口的起始位置如何移动：如果当前窗口的值大于target了，<strong>窗口就要向前移动</strong>了（也就是该缩小了）。</li>
<li>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。</li>
</ul>
<blockquote>
<p><strong>可以发现滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)!!</strong></p>
</blockquote>
<p>为什么时间复杂度是O(n)?</p>
<ul>
<li>不要以为for里放一个while就以为是O(n^2)啊， 主要是看每一个元素被操作的次数，</li>
<li>每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是 2 × n 也就是O(n)。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = INT32_MAX;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> subLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="comment">// while循环每次更新起始位置i，并比较子序列是否符合条件</span></span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">                subLength = j - i + <span class="number">1</span>;</span><br><span class="line">                result = result &lt; subLength ? result : subLength;</span><br><span class="line">                sum -= nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == INT32_MAX ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ul>
<li>904</li>
<li>76</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>代码随想录</tag>
        <tag>数组</tag>
        <tag>滑动窗口</tag>
        <tag>长度最小的子数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数组05螺旋矩阵Ⅱ</title>
    <url>/2022/08/29/21/</url>
    <content><![CDATA[<h1 id="数组05–螺旋矩阵Ⅱ"><a href="#数组05–螺旋矩阵Ⅱ" class="headerlink" title="数组05–螺旋矩阵Ⅱ"></a>数组05–螺旋矩阵Ⅱ</h1><h2 id="59-Spiral-Matrix-II"><a href="#59-Spiral-Matrix-II" class="headerlink" title="59. Spiral Matrix II"></a>59. Spiral Matrix II</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><blockquote>
<p>给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p>
</blockquote>
<p>示例:</p>
<blockquote>
<p>输入: 3</p>
<p>输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题并不涉及到什么算法，就是模拟过程，考察对代码的掌控能力。如何画出这个螺旋排列的正方形矩阵呢？</p>
<blockquote>
<p>很多同学刚开始做这种题目的时候，上来就是一波判断猛如虎。</p>
<p>结果运行的时候各种问题，然后开始各种修修补补，最后发现改了这里那里有问题，改了那里这里又跑不起来了。</p>
</blockquote>
<p>求解本题依然是要<strong>坚持循环不变量原则</strong>。</p>
<p>模拟顺时针画矩阵的过程:</p>
<ul>
<li>填充上行，从左到右；</li>
<li>右列，从上到下；</li>
<li>下行，从右到左；</li>
<li>左列，从下到上；</li>
</ul>
<p>要画每四条边，这四条边怎么画，每画一条边都要<strong>坚持一致的左闭右开，或者左开右闭的原则</strong>，这样这一圈才能按照统一的规则画下来。</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>)); <span class="comment">//使用vector定义一个二维数组</span></span><br><span class="line">        <span class="type">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>; <span class="comment">//循环一个圈的起始位置</span></span><br><span class="line">        <span class="type">int</span> loop = n / <span class="number">2</span>;  <span class="comment">// 循环几个圈，</span></span><br><span class="line">        <span class="type">int</span> mid = n / <span class="number">2</span>;  <span class="comment">//矩阵中间的位置，比如，n=3时，中心点为(1,1)</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>; <span class="comment">// 用来给矩阵中每一个格子赋值</span></span><br><span class="line">        <span class="type">int</span> offset = <span class="number">1</span>; <span class="comment">// 控制每一条边遍历的长度，每次循环右边界收缩一位</span></span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (loop --) &#123;</span><br><span class="line">            i = startx;</span><br><span class="line">            j = starty;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 四个for循环模拟四条边转圈</span></span><br><span class="line">            <span class="keyword">for</span> (j = starty; j &lt; n - offset; j++) &#123;</span><br><span class="line">                res[startx][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (i = startx; i &lt; n - offset; i++) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (; j &gt; starty; j--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (; i &gt; startx; i--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 第二圈开始的时候，起始位置各自加一</span></span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line">            </span><br><span class="line">            offset += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当n为奇数时，需要单独给最后中心值赋值</span></span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span>) &#123;</span><br><span class="line">            res[mid][mid] = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ul>
<li>54.螺旋矩阵</li>
<li>剑指Offer 29.顺时针打印矩阵</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>代码随想录</tag>
        <tag>数组</tag>
        <tag>螺旋矩阵Ⅱ</tag>
      </tags>
  </entry>
  <entry>
    <title>数组06--总结</title>
    <url>/2022/09/28/01/</url>
    <content><![CDATA[<h1 id="数组06–总结"><a href="#数组06–总结" class="headerlink" title="数组06–总结"></a>数组06–总结</h1><h2 id="数组的理论基础"><a href="#数组的理论基础" class="headerlink" title="数组的理论基础"></a>数组的理论基础</h2><blockquote>
<p><strong>数组是存放在内存连续空间上的相同类型的数据的集合</strong>；</p>
</blockquote>
<p><img src="/2022/09/28/01/storeStructure.JPG" alt="storeStructure"></p>
<p>两个注意点：</p>
<ol>
<li>下标从<code>0</code>开始；</li>
<li>内存地址连续；</li>
</ol>
<blockquote>
<p>So： 正是因为内存地址连续，所以在删除和增加元素的时候，就<mark><strong>必须移动其他元素</strong></mark>，导致时间开销大！</p>
<p>在C++中，要注意<code>vector</code>和<code>array</code>的区别，<code>vector</code>的底层实现是<code>array</code>，严格来讲<mark><strong>vector是容器，不是数组</strong></mark>。</p>
<p><strong>数组的元素是不能删的，只能覆盖</strong>。</p>
</blockquote>
<p><img src="/2022/09/28/01/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84.JPG" alt="二维数组"></p>
<h2 id="数组经典题目"><a href="#数组经典题目" class="headerlink" title="数组经典题目"></a>数组经典题目</h2><blockquote>
<p>大概四种，对应之前例题</p>
</blockquote>
<h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><ul>
<li>暴力解法：时间复杂度<code>O(n)</code>;</li>
<li>二分法：时间复杂度<code>O(logn)</code>;</li>
</ul>
<p><strong>循环不变量原则</strong> : 只有在循环中坚持对区间的定义，才能清楚的把握循环中的各种细节。</p>
<h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p><strong>双指针法（快慢指针法）</strong> ： 通过一个快指针和慢指针<mark>在一个for循环下完成两个for循环的工作</mark>。</p>
<ul>
<li>暴力解法 : 时间复杂度：<code>O(n^2)</code></li>
<li>双指针   : 时间复杂度：<code>O(n)</code></li>
</ul>
<p>数组中的元素为什么不能删除，主要是因为以下两点：</p>
<ul>
<li>数组在内存中是<strong>连续的地址空间，不能释放单一元素，如果要释放，就是全释放（程序运行结束，回收内存栈空间）</strong>。</li>
<li>C++中vector和array的区别一定要弄清楚，vector的底层实现是array，封装后使用更友好。</li>
</ul>
<p>双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察<em><strong>数组和链表操作的面试题，都使用双指针法</strong></em>。</p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><ul>
<li>暴力解法 : 时间复杂度：<code>O(n^2)</code></li>
<li>滑动窗口 : 时间复杂度：<code>O(n)</code></li>
</ul>
<blockquote>
<p><strong>主要要理解滑动窗口如何移动 窗口起始位置，达到动态更新窗口大小的条件，从而得出长度最小的符合条件的长度。</strong></p>
</blockquote>
<p>滑动窗口的精妙之处在于 : <mark><strong>根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。</strong></mark></p>
<p>如果没有接触过这一类的方法，很难想到类似的解题思路，滑动窗口方法还是很巧妙的。</p>
<h3 id="模拟行为"><a href="#模拟行为" class="headerlink" title="模拟行为"></a>模拟行为</h3><p>模拟类的题目在数组中很常见，不涉及到什么算法，就是单纯的模拟，考察对代码的掌控能力。</p>
<p>在这道题目中，我们再一次介绍到了<strong>循环不变量原则</strong>，其实这也是写程序中的重要原则。</p>
<p>相信大家有遇到过这种情况： 感觉题目的边界调节超多，一波接着一波的判断，找边界，拆了东墙补西墙，好不容易运行通过了，代码写的十分冗余，毫无章法，其实<strong>真正解决题目的代码都是简洁的，或者有原则性的</strong>，大家可以在这道题目中体会到这一点。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/09/28/01/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93.jpg" alt="数组总结"></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>代码随想录</tag>
        <tag>数组</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>考研英语100句Day1</title>
    <url>/2022/07/21/59/</url>
    <content><![CDATA[<h1 id="考研英语100句–Day1"><a href="#考研英语100句–Day1" class="headerlink" title="考研英语100句–Day1"></a>考研英语100句–Day1</h1><h2 id="Sentence-01"><a href="#Sentence-01" class="headerlink" title="Sentence 01"></a>Sentence 01</h2><p><em>We become defensive when criticised, and apply negative stereotypes to others to boost our own esteem.</em></p>
<blockquote>
<p>一旦受到批评，我们就会为自己辩护，并将他人定格为消极的老套形象，以此增强自己的<br>自尊心。</p>
</blockquote>
<h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><ul>
<li>defensive</li>
<li>criticised</li>
<li>negative</li>
<li>stereotypes</li>
<li>boost</li>
<li>esteem</li>
</ul>
<h3 id="词组"><a href="#词组" class="headerlink" title="词组"></a>词组</h3><ul>
<li>when criticised</li>
<li>apply sth to sb</li>
<li>boost our esteem</li>
</ul>
<h2 id="Sentence-02"><a href="#Sentence-02" class="headerlink" title="Sentence 02"></a>Sentence 02</h2><p><em>Devoted concertgoers who reply that recordings are no substitute for live performance are missing the point.</em></p>
<blockquote>
<p>那些忠诚的音乐会听众回应说现场演出绝非是唱片所能替代的，可这些听众没有领会到问题<br>的关键点。</p>
</blockquote>
<h3 id="单词-1"><a href="#单词-1" class="headerlink" title="单词"></a>单词</h3><ul>
<li>devoted</li>
<li>concertgoers</li>
<li>recordings</li>
<li>substitute</li>
<li>live performance</li>
</ul>
<h3 id="词组-1"><a href="#词组-1" class="headerlink" title="词组"></a>词组</h3><ul>
<li>recordings are no substitute for live performance</li>
<li>miss the point</li>
</ul>
<h2 id="Sentence-03"><a href="#Sentence-03" class="headerlink" title="Sentence 03"></a>Sentence 03</h2><p><em>Ants keep predatory insects away from where their aphids feed;</em></p>
<p><em>Gmail keeps the spammers out of our inboxes.</em></p>
<blockquote>
<p>蚂蚁让食肉昆虫远离蚜虫进食的地方；谷歌邮箱让滥发垃圾邮件的人远离我们的收件箱。</p>
</blockquote>
<h3 id="单词-2"><a href="#单词-2" class="headerlink" title="单词"></a>单词</h3><ul>
<li>predatory</li>
<li>insect</li>
<li>aphid</li>
<li>spammer</li>
</ul>
<h3 id="词组-2"><a href="#词组-2" class="headerlink" title="词组"></a>词组</h3><ul>
<li>keep sb away from sb</li>
</ul>
<h2 id="Sentence-04"><a href="#Sentence-04" class="headerlink" title="Sentence 04"></a>Sentence 04</h2><p><em>At the same time, people continue to treat fire as an event that needs to be wholly controlled and unleashed only out of necessity.</em></p>
<blockquote>
<p>与此同时，人们继续把用火视为一种需要全面控制的事件，只有在必要之时才放出来使用。</p>
</blockquote>
<h3 id="单词-3"><a href="#单词-3" class="headerlink" title="单词"></a>单词</h3><ul>
<li>wholly</li>
<li>unleash</li>
</ul>
<h3 id="词组-3"><a href="#词组-3" class="headerlink" title="词组"></a>词组</h3><ul>
<li>continue to do sth</li>
<li>needs to be wholly controlled</li>
<li>needs to be unleashed only out of necessity</li>
<li>treat fire as an event ..</li>
</ul>
<h2 id="Sentence-05"><a href="#Sentence-05" class="headerlink" title="Sentence 05"></a>Sentence 05</h2><p><em>As boards scrutinize succession plans in response to shareholder pressure, executives who don’t get the nod also may wish to move on.</em></p>
<blockquote>
<p>在董事会迫于股东的压力严格审查继任计划的时候，那些没被选中的高管们也可能想离开。</p>
</blockquote>
<h3 id="单词-4"><a href="#单词-4" class="headerlink" title="单词"></a>单词</h3><ul>
<li>boards</li>
<li>scrutinize</li>
<li>succession plans</li>
<li>shareholder</li>
<li>executive</li>
</ul>
<h3 id="词组-4"><a href="#词组-4" class="headerlink" title="词组"></a>词组</h3><ul>
<li>in response to sth</li>
<li>get the nod</li>
<li>wish to do</li>
<li>move on</li>
</ul>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>考研英语100句</tag>
      </tags>
  </entry>
  <entry>
    <title>考研英语100句Day10</title>
    <url>/2022/09/06/20/</url>
    <content><![CDATA[<h1 id="考研英语100句–Day10"><a href="#考研英语100句–Day10" class="headerlink" title="考研英语100句–Day10"></a>考研英语100句–Day10</h1><h2 id="Sentence-46"><a href="#Sentence-46" class="headerlink" title="Sentence 46"></a>Sentence 46</h2><p><em>While the researchers assumed that the well-structured daily plans would be most effective when it came to the execution of tasks, they were wrong: the detailed daily plans demotivated students.</em></p>
<blockquote>
<p>尽管研究人员认为，在执行任务时，详尽的每日目标是最为高效的，但他们错了，详细的每日计划使学生失去了动力。</p>
</blockquote>
<h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><ul>
<li>assume</li>
<li>well-structured</li>
<li>execution</li>
<li>demotivate</li>
</ul>
<h3 id="词组"><a href="#词组" class="headerlink" title="词组"></a>词组</h3><ul>
<li>sb assumed that ..</li>
<li>the execution of tasks</li>
<li>when it came to ..</li>
<li>the detailed daily plans</li>
</ul>
<h2 id="Sentence-47"><a href="#Sentence-47" class="headerlink" title="Sentence 47"></a>Sentence 47</h2><p><em>While fossil fuels—coal, oil, gas—still generate roughly 85 percent of the world’s energy supply, it’s clearer than ever that the future belongs to renewable sources such as wind and solar.</em></p>
<blockquote>
<p>虽然化石燃料——煤、石油、天然气——仍然占据世界能源供应的85%左右，但比以往任何时候都更明显的是，未来属于风能和太阳能等可再生能源。</p>
</blockquote>
<h3 id="单词-1"><a href="#单词-1" class="headerlink" title="单词"></a>单词</h3><ul>
<li>fossil</li>
<li>coal, oil, gas—still</li>
<li>generate</li>
<li>roughly</li>
</ul>
<h3 id="词组-1"><a href="#词组-1" class="headerlink" title="词组"></a>词组</h3><ul>
<li>fossil fuels</li>
<li>energy supply</li>
<li>it’s clear than</li>
<li>the future belongs to ..</li>
<li>renewable sources</li>
</ul>
<h2 id="Sentence-48"><a href="#Sentence-48" class="headerlink" title="Sentence 48"></a>Sentence 48</h2><p><em>Only if the jobless arrive at the jobcentre with a CV, register for online job search, and start looking for work will they be eligible for benefit—and then they should report weekly rather than fortnightly.</em></p>
<blockquote>
<p>只有当失业者带着简历来到就业服务中心，注册在线求职，并开始寻找工作，他们才有资格获得补助金，然后他们应该每周而不是每两周汇报一次求职情况。</p>
</blockquote>
<h3 id="单词-2"><a href="#单词-2" class="headerlink" title="单词"></a>单词</h3><ul>
<li>jobcentre</li>
<li>the jobless</li>
<li>register</li>
<li>eligible</li>
<li>fortnightly</li>
</ul>
<h3 id="词组-2"><a href="#词组-2" class="headerlink" title="词组"></a>词组</h3><ul>
<li>register for online job search</li>
<li>start looking for work</li>
<li>be eligible for benefit</li>
</ul>
<h2 id="Sentence-49"><a href="#Sentence-49" class="headerlink" title="Sentence 49"></a>Sentence 49</h2><p><em>It is not that pink is intrinsically bad, but it is such a tiny slice of the rainbow and, though it may celebrate girlhood in one way, it also repeatedly and firmly fuses girls’ identity to appearance.</em></p>
<blockquote>
<p>究其本质，粉红色本身并没有什么不好，它只不过是彩虹上微小的一抹。虽然从某种程度上来说它歌颂了少女时代，但它也反复且坚定地把女孩的个性和外表融合起来。</p>
</blockquote>
<h3 id="单词-3"><a href="#单词-3" class="headerlink" title="单词"></a>单词</h3><ul>
<li>intrinsically</li>
<li>celebrate</li>
<li>firmly</li>
<li>fuse</li>
<li>identity</li>
<li>appearance</li>
</ul>
<h3 id="词组-3"><a href="#词组-3" class="headerlink" title="词组"></a>词组</h3><ul>
<li>such a tiny slice of the rainbow</li>
<li>in one way</li>
<li>fuse girls’ identity to appearance</li>
</ul>
<h2 id="Sentence-50"><a href="#Sentence-50" class="headerlink" title="Sentence 50"></a>Sentence 50</h2><p><em>Here, Darwinism seems to offer justification, for if all humans share common origins, it seems reasonable to suppose that cultural diversity could also be traced to more constrained beginnings.</em></p>
<blockquote>
<p>在此，达尔文学说似乎给出了合理化的解释，这是因为如果整个人类有相同的起源，那么我们就有理由认为，文化多样性同样也可以追溯到更为有限的开端。</p>
</blockquote>
<h3 id="单词-4"><a href="#单词-4" class="headerlink" title="单词"></a>单词</h3><ul>
<li>justification  解释；理由</li>
<li>reasonable</li>
<li>diversity</li>
<li>constrained</li>
</ul>
<h3 id="词组-4"><a href="#词组-4" class="headerlink" title="词组"></a>词组</h3><ul>
<li>it seems to</li>
<li>offer justification</li>
<li>share common origins</li>
<li>suppose that ..</li>
<li>cultural diversity</li>
<li>be traced to</li>
<li>more constrained beginnings</li>
</ul>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>考研英语100句</tag>
      </tags>
  </entry>
  <entry>
    <title>考研英语100句Day11</title>
    <url>/2022/09/06/22/</url>
    <content><![CDATA[<h1 id="考研英语100句–Day11"><a href="#考研英语100句–Day11" class="headerlink" title="考研英语100句–Day11"></a>考研英语100句–Day11</h1><h2 id="Sentence-51"><a href="#Sentence-51" class="headerlink" title="Sentence 51"></a>Sentence 51</h2><p><em>If you are working on a word processor, you can take advantage of its capacity to make additions and deletions as well as move entire paragraphs by making just a few simple keyboard commands.</em></p>
<blockquote>
<p>尽如果你正借助文字处理软件进行工作，只需通过几个简单的键盘指令，你就可以利用它来进行删减、增加或移动整段文字。</p>
</blockquote>
<h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><ul>
<li>processor</li>
</ul>
<h3 id="词组"><a href="#词组" class="headerlink" title="词组"></a>词组</h3><ul>
<li>take advantage of its capacity to ..</li>
<li>move entire paragraphs</li>
<li>make commands</li>
</ul>
<h2 id="Sentence-52"><a href="#Sentence-52" class="headerlink" title="Sentence 52"></a>Sentence 52</h2><p><em>This success, coupled with later research showing that memory itself is not genetically determined, led Ericsson to conclude that the act of memorizing is more of a cognitive exercise than an intuitive one.</em></p>
<blockquote>
<p>这次的成功，加上后来表明记忆本身不由基因决定的研究，让埃里克森得出结论：记忆行为与其说是一种直觉性的活动，不如说是一种认知性的活动。</p>
</blockquote>
<h3 id="单词-1"><a href="#单词-1" class="headerlink" title="单词"></a>单词</h3><ul>
<li>genetically</li>
<li>cognitive</li>
<li>intuitive</li>
</ul>
<h3 id="词组-1"><a href="#词组-1" class="headerlink" title="词组"></a>词组</h3><ul>
<li>coupled with</li>
<li>showing that</li>
<li>genetically determined</li>
<li>lead sb to conclude that ..</li>
<li>the act of memorizing</li>
<li>sth is more of a cognitive exercise than an intuitive one</li>
</ul>
<h2 id="Sentence-53"><a href="#Sentence-53" class="headerlink" title="Sentence 53"></a>Sentence 53</h2><p><em>That’s because Congress has always envisioned joint federal-state immigration enforcement and explicitly encourages state officers to share information and cooperate with federal colleagues.</em></p>
<blockquote>
<p>那是因为美国国会一直希望联邦政府能与州政府联合执行移民法案，并明确鼓励州政府官员与联邦政府的同事加强合作、信息共享。</p>
</blockquote>
<h3 id="单词-2"><a href="#单词-2" class="headerlink" title="单词"></a>单词</h3><ul>
<li>Congress</li>
<li>federal-state</li>
<li>immigration</li>
<li>enforcement</li>
<li>explicitly</li>
<li>encourage</li>
<li>colleague</li>
<li>cooperate</li>
</ul>
<h3 id="词组-2"><a href="#词组-2" class="headerlink" title="词组"></a>词组</h3><ul>
<li>has always envisioned joint sb sth</li>
<li>explicitly encourages sb to do</li>
<li>cooperate with sb.</li>
</ul>
<h2 id="Sentence-54"><a href="#Sentence-54" class="headerlink" title="Sentence 54"></a>Sentence 54</h2><p><em>Ministers should also look at creating greater certainty in the rental environment, which would have a significant impact on the ability of registered providers to fund new developments from revenues.</em></p>
<blockquote>
<p>部长们也应该考虑提高房屋租赁市场的稳定性，这对注册供应商从收入中拨出资金来进行新的开发会产生重大的影响。</p>
</blockquote>
<h3 id="单词-3"><a href="#单词-3" class="headerlink" title="单词"></a>单词</h3><ul>
<li>Minister</li>
<li>certainty</li>
<li>rental</li>
<li>revenue</li>
<li>fund  n.基金、钱    v.投资</li>
</ul>
<h3 id="词组-3"><a href="#词组-3" class="headerlink" title="词组"></a>词组</h3><ul>
<li>should look at doing  应该考虑做某事</li>
<li>create greater certainty in the rental environment</li>
<li>have a significant impact on ..</li>
</ul>
<h2 id="Sentence-55"><a href="#Sentence-55" class="headerlink" title="Sentence 55"></a>Sentence 55</h2><p><em>Such hijacked media are the opposite of earned media: an asset or campaign becomes hostage to consumers, other stakeholders, or activists who make negative allegations about a brand or product.</em></p>
<blockquote>
<p>这种被操纵的媒体和赚钱的媒体完全不同：一项资产或一场活动受那些对某个品牌或产品有不满说法的消费者、其他利益相关者或积极分子所左右。</p>
</blockquote>
<h3 id="单词-4"><a href="#单词-4" class="headerlink" title="单词"></a>单词</h3><ul>
<li>hijacked</li>
<li>asset</li>
<li>campaign</li>
<li>hostage</li>
<li>stakeholder</li>
<li>brand</li>
<li>allegation</li>
</ul>
<h3 id="词组-4"><a href="#词组-4" class="headerlink" title="词组"></a>词组</h3><ul>
<li>hijacked media</li>
<li>sth is the opposite of sth</li>
<li>who make negative allegations about a brand or product</li>
<li>make negative allegations about</li>
<li>sth becomes hostage to sb    受某人左右</li>
</ul>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>考研英语100句</tag>
      </tags>
  </entry>
  <entry>
    <title>考研英语100句Day12</title>
    <url>/2022/09/06/23/</url>
    <content><![CDATA[<h1 id="考研英语100句–Day12"><a href="#考研英语100句–Day12" class="headerlink" title="考研英语100句–Day12"></a>考研英语100句–Day12</h1><h2 id="Sentence-56"><a href="#Sentence-56" class="headerlink" title="Sentence 56"></a>Sentence 56</h2><p><em>The policy follows similar efforts from other journals, after widespread concern that basic mistakes in data analysis are contributing to the irreproducibility of many published research findings.</em></p>
<blockquote>
<p>这项政策效仿了与其他杂志类似的尝试，此前人们普遍担忧数据分析中的基本错误正导致许多已发表的研究结果无法被再现。</p>
</blockquote>
<h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><ul>
<li>policy</li>
<li>widespread</li>
<li>irreproducibility</li>
</ul>
<h3 id="词组"><a href="#词组" class="headerlink" title="词组"></a>词组</h3><ul>
<li>follows similar efforts from other journals</li>
<li>widespread concern that ..</li>
<li>sth are contributing to ..</li>
<li>the irreproducibility of published research findings</li>
</ul>
<h2 id="Sentence-57"><a href="#Sentence-57" class="headerlink" title="Sentence 57"></a>Sentence 57</h2><p><em>They should exhibit strong interest and respect for whatever currently interests their fledgling adult （as naive or ill conceived as it may seem） while becoming a partner in exploring options for the future.</em></p>
<blockquote>
<p>对当前让这些羽翼未丰的成年人感兴趣的任何事物（也许看上去很幼稚或欠考虑周全），父母都应该表现出强烈的兴趣和尊重，同时要成为他们的伙伴，与他们一起探索未来的选择。</p>
</blockquote>
<h3 id="单词-1"><a href="#单词-1" class="headerlink" title="单词"></a>单词</h3><ul>
<li>exhibit</li>
<li>fledgling</li>
<li>conceived</li>
</ul>
<h3 id="词组-1"><a href="#词组-1" class="headerlink" title="词组"></a>词组</h3><ul>
<li>exhibit strong interest and respect</li>
<li>become a partner in doing sth</li>
<li>explore options for the future  探索未来的选择</li>
<li>as naive or ill conceived as it may seem</li>
<li>ill conceived</li>
</ul>
<h2 id="Sentence-58"><a href="#Sentence-58" class="headerlink" title="Sentence 58"></a>Sentence 58</h2><p><em>In other words, at a time when the working class has turned the country on its political head, frustrated that the opportunity that once defined America is vanishing, one obvious solution is staring us in the face.</em></p>
<blockquote>
<p>换句话说，在工人阶级彻底改变这个国家的政治格局，对曾经使美国之所以成为美国的机会正在消失而感到沮丧的时候，一个显而易见的解决方案就摆在我们面前。</p>
</blockquote>
<h3 id="单词-2"><a href="#单词-2" class="headerlink" title="单词"></a>单词</h3><ul>
<li>frustrated</li>
<li>opportunity</li>
<li>vanish</li>
</ul>
<h3 id="词组-2"><a href="#词组-2" class="headerlink" title="词组"></a>词组</h3><ul>
<li>In other words</li>
<li>at a time when ..</li>
<li>the working class  工人阶级</li>
<li>turned the country on its political head</li>
<li>one obvious solution is staring us in the face</li>
</ul>
<h2 id="Sentence-59"><a href="#Sentence-59" class="headerlink" title="Sentence 59"></a>Sentence 59</h2><p><em>Brain researchers have discovered that when we consciously develop new habits, we create parallel synaptic paths, and even entirely new brain cells, that can jump our trains of thought onto new, innovative tracks.</em></p>
<blockquote>
<p>大脑研究人员发现，当我们有意识地培养新习惯的时候，大脑会创建出平行的突触路径，甚至是全新的脑细胞，这样可以使我们的思路跳转到全新的、创造性的轨道中。</p>
</blockquote>
<h3 id="单词-3"><a href="#单词-3" class="headerlink" title="单词"></a>单词</h3><ul>
<li>consciously</li>
<li>certainty</li>
<li>parallel</li>
<li>synaptic</li>
<li>innovative</li>
</ul>
<h3 id="词组-3"><a href="#词组-3" class="headerlink" title="词组"></a>词组</h3><ul>
<li>discovered that ..</li>
<li>develop new habits</li>
<li>synaptic paths</li>
<li>jump our trains of thought onto new, innovative tracks</li>
<li>trains of thought</li>
<li>innovative track</li>
</ul>
<h2 id="Sentence-60"><a href="#Sentence-60" class="headerlink" title="Sentence 60"></a>Sentence 60</h2><p><em>This type of integrity requires well-enforced laws in government transparency, such as records of official meetings, rules on lobbying, and information about each elected leader’s source of wealth.</em></p>
<blockquote>
<p>这种廉政要求在政府透明度方面有严格执行的法律，如官方会议记录、游说规则以及每位当选领导人的财富来源的信息。</p>
</blockquote>
<h3 id="单词-4"><a href="#单词-4" class="headerlink" title="单词"></a>单词</h3><ul>
<li>integrity</li>
<li>transparency</li>
<li>lobbying</li>
</ul>
<h3 id="词组-4"><a href="#词组-4" class="headerlink" title="词组"></a>词组</h3><ul>
<li>well-enforced law</li>
<li>official meetings</li>
<li>rules on ..</li>
<li>source of wealth</li>
</ul>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>考研英语100句</tag>
      </tags>
  </entry>
  <entry>
    <title>考研英语100句Day13</title>
    <url>/2022/09/07/24/</url>
    <content><![CDATA[<h1 id="考研英语100句–Day13"><a href="#考研英语100句–Day13" class="headerlink" title="考研英语100句–Day13"></a>考研英语100句–Day13</h1><h2 id="Sentence-61"><a href="#Sentence-61" class="headerlink" title="Sentence 61"></a>Sentence 61</h2><p><em>In the past couple of weeks a quarrel has illustrated the value to advertisers of such fine-grained information: Should advertisers assume that people are happy to be tracked and sent behavioural ads?</em></p>
<blockquote>
<p>在过去几周里，一场争论已经阐明了这种精确的信息对于广告商的价值：广告商是否可以认为用户愿意被追踪其在网络上的行为并接收基于他们在网络上的行为而制定的广告？</p>
</blockquote>
<h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><ul>
<li>quarrel</li>
<li>illustrate</li>
<li>fine-grained</li>
<li>assume</li>
<li>behavioural</li>
</ul>
<h3 id="词组"><a href="#词组" class="headerlink" title="词组"></a>词组</h3><ul>
<li>the value to advertisers of such fine-grained information</li>
<li>sb is happy to be tracked</li>
<li>behavioural ads</li>
</ul>
<h2 id="Sentence-62"><a href="#Sentence-62" class="headerlink" title="Sentence 62"></a>Sentence 62</h2><p><em>Last year, the Transportation Security Administration （ TSA ） found in a secret check that undercover investigators were able to sneak weapons—both fake and real—past airport security nearly every time they tried.</em></p>
<blockquote>
<p>去年，美国运输安全管理局，在一次秘密检查中发现，便衣调查员几乎每次尝试私携武器——无论是伪造的武器还是真的武器——都能顺利通过机场安检。</p>
</blockquote>
<h3 id="单词-1"><a href="#单词-1" class="headerlink" title="单词"></a>单词</h3><ul>
<li>transportation</li>
<li>security</li>
<li>administration</li>
<li>secret</li>
<li>undercover</li>
<li>investigator</li>
<li>sneak</li>
<li>weapon</li>
</ul>
<h3 id="词组-1"><a href="#词组-1" class="headerlink" title="词组"></a>词组</h3><ul>
<li>the Transportation Security Administration</li>
<li>in a secret check</li>
<li>nearly every time they tried</li>
</ul>
<h2 id="Sentence-63"><a href="#Sentence-63" class="headerlink" title="Sentence 63"></a>Sentence 63</h2><p><em>California has asked the justices to refrain from a sweeping ruling, particularly one that upsets the old assumptions that authorities may search through the possessions of suspects at the time of their arrest.</em></p>
<blockquote>
<p>加利福尼亚州已经要求法官们避免做出一刀切的裁决，尤其是不能做出那种颠覆了当局在逮捕嫌疑人时可以搜查其财产这些存在已久的假定的裁决。</p>
</blockquote>
<h3 id="单词-2"><a href="#单词-2" class="headerlink" title="单词"></a>单词</h3><ul>
<li>justice</li>
<li>refrain    避免</li>
<li>particularly</li>
<li>upset</li>
<li>assumption</li>
<li>authority</li>
<li>possession</li>
<li>suspect</li>
<li>arrest</li>
</ul>
<h3 id="词组-2"><a href="#词组-2" class="headerlink" title="词组"></a>词组</h3><ul>
<li>ask sb to do sth</li>
<li>refrain from</li>
<li>refrain from a sweeping ruling</li>
<li>search through</li>
<li>at the time of their arrest</li>
</ul>
<h2 id="Sentence-64"><a href="#Sentence-64" class="headerlink" title="Sentence 64"></a>Sentence 64</h2><p><em>Priestly explains how the deep blue color of the assistant’s sweater descended over the years from fashion shows to department stores and to the bargain bin in which the poor girl doubtless found her garment.</em></p>
<blockquote>
<p>普里斯特利解释了这位助理身上这件针织衫所采用的深蓝色这些年来是如何从时装秀没落到百货商店，最后沦落到商品打折处理区的，而这位可怜的女孩无疑是在那里淘到了这件衣服。</p>
</blockquote>
<h3 id="单词-3"><a href="#单词-3" class="headerlink" title="单词"></a>单词</h3><ul>
<li>explain</li>
<li>assistant</li>
<li>sweater</li>
<li>descend</li>
<li>bargain</li>
<li>doubtless</li>
<li>garment</li>
</ul>
<h3 id="词组-3"><a href="#词组-3" class="headerlink" title="词组"></a>词组</h3><ul>
<li>over the years</li>
<li>the bargain bin</li>
</ul>
<h2 id="Sentence-65"><a href="#Sentence-65" class="headerlink" title="Sentence 65"></a>Sentence 65</h2><p><em>If the district is essentially giving a pass to students who do not do their homework because of complicated family lives, it is going riskily close to the implication that standards need to be lowered for poor children.</em></p>
<blockquote>
<p>如果该学区让那些因为家庭环境复杂而不做家庭作业的学生通过考试的话，那么这就危险地近乎于暗示着，对于贫穷的孩子，学业标准需要降低。</p>
</blockquote>
<h3 id="单词-4"><a href="#单词-4" class="headerlink" title="单词"></a>单词</h3><ul>
<li>district</li>
<li>essentially    实质上</li>
<li>complicated</li>
<li>implication    暗示</li>
<li>standard</li>
</ul>
<h3 id="词组-4"><a href="#词组-4" class="headerlink" title="词组"></a>词组</h3><ul>
<li>give a pass to sb</li>
<li>because of complicated family lives</li>
<li>it is going riskily close to sth</li>
</ul>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>考研英语100句</tag>
      </tags>
  </entry>
  <entry>
    <title>考研英语100句Day14</title>
    <url>/2022/09/07/25/</url>
    <content><![CDATA[<h1 id="考研英语100句–Day14"><a href="#考研英语100句–Day14" class="headerlink" title="考研英语100句–Day14"></a>考研英语100句–Day14</h1><h2 id="Sentence-66"><a href="#Sentence-66" class="headerlink" title="Sentence 66"></a>Sentence 66</h2><p><em>The findings of a research institution have consistently shown that workers in all countries can be trained on the job to achieve radically higher productivity and, as a result, radically higher standards of living.</em></p>
<blockquote>
<p>一所研究机构的研究结果一致表明，所有国家的工人都可以通过在岗培训，从根本上提高生产率，从而从根本上提高生活水平。</p>
</blockquote>
<h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><ul>
<li>institution</li>
<li>consistently</li>
<li>achieve</li>
<li>radically</li>
<li>productivity</li>
</ul>
<h3 id="词组"><a href="#词组" class="headerlink" title="词组"></a>词组</h3><ul>
<li>achieve radically higher productivity</li>
<li>as a result</li>
<li>higher standards of living</li>
</ul>
<h2 id="Sentence-67"><a href="#Sentence-67" class="headerlink" title="Sentence 67"></a>Sentence 67</h2><p><em>Their analysis ruled out the possibility that it was firms’ political influence, rather than their CSR stand, that accounted for the leniency: Companies that contributed more to political campaigns did not receive lower fines.</em></p>
<blockquote>
<p>他们的分析排除了这样的可能性，即：是公司的政治影响力，而非他们的企业社会责任立场让公司获得了宽大处理，因为那些支持政治运动更多的公司并没有被处以更少的罚金。</p>
</blockquote>
<h3 id="单词-1"><a href="#单词-1" class="headerlink" title="单词"></a>单词</h3><ul>
<li>analysis</li>
<li>firm</li>
<li>political</li>
<li>leniency</li>
<li>campaign</li>
</ul>
<h3 id="词组-1"><a href="#词组-1" class="headerlink" title="词组"></a>词组</h3><ul>
<li>rule out    排除</li>
<li>political influence</li>
<li>that accounted for the leniency<ul>
<li>accounte for    解释</li>
</ul>
</li>
<li>receive lower fines</li>
<li>contribute more to</li>
<li>political campaign</li>
</ul>
<h2 id="Sentence-68"><a href="#Sentence-68" class="headerlink" title="Sentence 68"></a>Sentence 68</h2><p><em>The potential evolution of today’s technology, and its social consequences, is dazzlingly complicated, and it’s perhaps best left to science fiction writers and futurologists to explore the many possibilities we can envisage.</em></p>
<blockquote>
<p>当今科技的潜在发展及其社会影响惊人地复杂，或许我们最好把诸多可能留给科幻作家和未来学家去探索。</p>
</blockquote>
<h3 id="单词-2"><a href="#单词-2" class="headerlink" title="单词"></a>单词</h3><ul>
<li>potential</li>
<li>evolution</li>
<li>technology</li>
<li>consequence</li>
<li>dazzlingly    眼花缭乱地</li>
<li>complicated    复杂的</li>
<li>explore</li>
<li>envisage</li>
</ul>
<h3 id="词组-2"><a href="#词组-2" class="headerlink" title="词组"></a>词组</h3><ul>
<li>social consequences</li>
<li>be left to sb</li>
<li>science fiction writers</li>
<li>explore the many possibilities we can envisage</li>
</ul>
<h2 id="Sentence-69"><a href="#Sentence-69" class="headerlink" title="Sentence 69"></a>Sentence 69</h2><p><em>The company, a major energy supplier in New England, provoked justified outrage in Vermont last week when it announced it was reneging on a longstanding commitment to abide by the strict nuclear regulations.</em></p>
<blockquote>
<p>当上周新英格兰地区的主要能源供应商宣布它将放弃遵守严格的核安全条例这一长期承诺时，该公司在佛蒙特州激起了民众无可厚非的愤怒。</p>
</blockquote>
<h3 id="单词-3"><a href="#单词-3" class="headerlink" title="单词"></a>单词</h3><ul>
<li>provoke    激怒、挑衅</li>
<li>justified    正当的</li>
<li>outrage    愤怒</li>
<li>announce</li>
<li>renege    背叛</li>
<li>longstanding    长期坚持的</li>
<li>commitment    承诺</li>
<li>abide    遵守</li>
<li>regulation    规章、法规</li>
</ul>
<h3 id="词组-3"><a href="#词组-3" class="headerlink" title="词组"></a>词组</h3><ul>
<li>a major energy supplier</li>
<li>be reneging on sth</li>
<li>a longstanding commitment</li>
</ul>
<h2 id="Sentence-70"><a href="#Sentence-70" class="headerlink" title="Sentence 70"></a>Sentence 70</h2><p><em>Of all the changes that have taken place in English-language newspapers during the past quarter-century, perhaps the most far-reaching has been the inexorable decline in the scope and seriousness of their arts coverage.</em></p>
<blockquote>
<p>在过去的25年英文报纸所发生的变化中，影响最深远的可能是其艺术方面的报道在范围和严肃程度上都不可阻挡地下降了。</p>
</blockquote>
<h3 id="单词-4"><a href="#单词-4" class="headerlink" title="单词"></a>单词</h3><ul>
<li>quarter-century</li>
<li>far-reaching</li>
<li>inexorable    坚决的、不可阻挡的</li>
<li>decline</li>
<li>scope</li>
<li>seriousness</li>
<li>coverage</li>
</ul>
<h3 id="词组-4"><a href="#词组-4" class="headerlink" title="词组"></a>词组</h3><ul>
<li>take place in English-language newspapers</li>
<li>during the past quarter-century</li>
<li>the most far-reaching    影响最深远的</li>
<li>inexorable decline in ..</li>
</ul>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>考研英语100句</tag>
      </tags>
  </entry>
  <entry>
    <title>考研英语100句Day15</title>
    <url>/2022/09/08/26/</url>
    <content><![CDATA[<h1 id="考研英语100句–Day15"><a href="#考研英语100句–Day15" class="headerlink" title="考研英语100句–Day15"></a>考研英语100句–Day15</h1><h2 id="Sentence-71"><a href="#Sentence-71" class="headerlink" title="Sentence 71"></a>Sentence 71</h2><p><em>Infants are wired to look at parents’ faces to try to understand their world, and if those faces are blank and unresponsive — as they often are when absorbed in a device — it can be extremely disconcerting for the children.</em></p>
<blockquote>
<p>婴幼儿天生会观察父母的表情，试图理解他们的世界，如果父母的脸上毫无表情和反应——沉浸于电子设备时经常如此——这会让孩子们极其不安。</p>
</blockquote>
<h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><ul>
<li>infant</li>
<li>unresponsive</li>
<li>absorbed</li>
<li>extremely</li>
<li>disconcerting</li>
</ul>
<h3 id="词组"><a href="#词组" class="headerlink" title="词组"></a>词组</h3><ul>
<li>are wired to do ..    天生就会做..</li>
<li>try to understand their world</li>
<li>when absorbed in a device</li>
<li>be extremely disconcerting for sb.</li>
</ul>
<h2 id="Sentence-72"><a href="#Sentence-72" class="headerlink" title="Sentence 72"></a>Sentence 72</h2><p><em>Scientists have found that although we are prone to snap overreactions, if we take a moment and think about how we are likely to react, we can reduce or even eliminate the negative effects of our quick, hard-wired responses.</em></p>
<blockquote>
<p>科学家们已经发现：虽然我们易于快速做出过度反应，但是如果我们花点时间考虑一下我们可能会做何反应，就可以减少，甚至是消除我们快速、本能的反应所带来的消极影响。</p>
</blockquote>
<h3 id="单词-1"><a href="#单词-1" class="headerlink" title="单词"></a>单词</h3><ul>
<li>prone    易于的，俯卧的，有倾向的..</li>
<li>snap    折断，快照，突然的</li>
<li>overreaction    过度反应</li>
<li>reduce</li>
<li>eliminate    消除</li>
</ul>
<h3 id="词组-1"><a href="#词组-1" class="headerlink" title="词组"></a>词组</h3><ul>
<li>have found that ..</li>
<li>be prone to do sth..    易于，有倾向于做某事</li>
<li>be prone to snap overreactions</li>
<li>take a moment and think about how ..</li>
<li>how we are likely to react</li>
<li>be likely to do ..</li>
<li>reduce the negative effects of our hard-wired responses</li>
<li>hard-wired responses</li>
</ul>
<h2 id="Sentence-73"><a href="#Sentence-73" class="headerlink" title="Sentence 73"></a>Sentence 73</h2><p><em>Further arrangements — and there may be many — between the NHS and DeepMind will be carefully scrutinised to ensure that all necessary permissions have been asked of patients and all unnecessary data has been cleaned.</em></p>
<blockquote>
<p>英国国民医疗服务体系（NHS）和DeepMind之间的进一步的协议——也许还有很多协议——将受到仔细审查，以确保从病人那里获得了所有必要的许可，以及所有不必要的数据都已被清除。</p>
</blockquote>
<h3 id="单词-2"><a href="#单词-2" class="headerlink" title="单词"></a>单词</h3><ul>
<li>arrangement</li>
<li>scrutinize    审查</li>
<li>ensure</li>
<li>permission</li>
</ul>
<h3 id="词组-2"><a href="#词组-2" class="headerlink" title="词组"></a>词组</h3><ul>
<li>further arrangements</li>
<li>be carefully scrutinised to ensure that</li>
<li>necessary permission</li>
</ul>
<h2 id="Sentence-74"><a href="#Sentence-74" class="headerlink" title="Sentence 74"></a>Sentence 74</h2><p><em>Studies of both animals and humans have shown that sex hormones somehow affect the stress response, causing females under stress to produce more of the trigger chemicals than <strong>do males</strong> under the same conditions.</em></p>
<blockquote>
<p>对动物和人类的研究表明：性激素会以某种方式影响应激反应，使处于压力下的雌性比处于相同条件下的雄性产生更多的能触发不良反应的化学物质。</p>
</blockquote>
<h3 id="单词-3"><a href="#单词-3" class="headerlink" title="单词"></a>单词</h3><ul>
<li>hormone</li>
<li>somehow</li>
<li>affect</li>
<li>chemical</li>
</ul>
<h3 id="词组-3"><a href="#词组-3" class="headerlink" title="词组"></a>词组</h3><ul>
<li>sex hormones</li>
<li>affect the stress response</li>
<li>under stress</li>
<li>causing females under stress to produce more of the trigger chemicals</li>
<li>under the same conditions</li>
<li>trigger chemical</li>
</ul>
<h2 id="Sentence-75"><a href="#Sentence-75" class="headerlink" title="Sentence 75"></a>Sentence 75</h2><p><em>“Carry a book with you at all times” can actually work too – providing you dip in often enough, so that reading becomes the default state from which you temporarily surface to take care of business, before dropping back down.</em></p>
<blockquote>
<p>如果你能经常翻阅的话，“随时携带一本书”这种方式也能奏效，从而让阅读成为你的常态，你可以在需要处理事务的时候从书中暂时抽离出来，之后再重新开始阅读。</p>
</blockquote>
<h3 id="单词-4"><a href="#单词-4" class="headerlink" title="单词"></a>单词</h3><ul>
<li>actually</li>
<li>temporarily</li>
<li>dip    浸入，深入</li>
</ul>
<h3 id="词组-4"><a href="#词组-4" class="headerlink" title="词组"></a>词组</h3><ul>
<li>Carry a book with you at all times</li>
<li>dip in often enough</li>
<li>default state</li>
<li>drop back down</li>
</ul>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>考研英语100句</tag>
      </tags>
  </entry>
  <entry>
    <title>考研英语100句Day16</title>
    <url>/2022/09/08/27/</url>
    <content><![CDATA[<h1 id="考研英语100句–Day16"><a href="#考研英语100句–Day16" class="headerlink" title="考研英语100句–Day16"></a>考研英语100句–Day16</h1><h2 id="Sentence-76"><a href="#Sentence-76" class="headerlink" title="Sentence 76"></a>Sentence 76</h2><p><em>Today, widespread social pressure to immediately go to college in conjunction with increasingly high expectations in a fast-moving world often causes students to completely overlook the possibility of taking a gap year.</em></p>
<blockquote>
<p>如今，高中毕业后即刻升入大学这一普遍的社会压力，加之快速发展的世界对学生寄予越来越高的期望，这常常导致学生完全忽略了选择间隔年这一可能。</p>
</blockquote>
<h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><ul>
<li>widespread</li>
<li>immediately</li>
<li>expectation</li>
<li>conjunction</li>
<li>overlook</li>
</ul>
<h3 id="词组"><a href="#词组" class="headerlink" title="词组"></a>词组</h3><ul>
<li>widespread social pressure</li>
<li>go to college</li>
<li>increasingly high expectations in a fast-moving world</li>
<li>in conjunction with</li>
<li>the possibility of taking a gap year</li>
<li>cause sb. to do sth.</li>
</ul>
<h2 id="Sentence-77"><a href="#Sentence-77" class="headerlink" title="Sentence 77"></a>Sentence 77</h2><p><em>It could be that we are evolving two communities of social scientists: one that is discipline-oriented and publishing in highly specialized journals, and one that is problem-oriented and publishing elsewhere, such as policy briefs.</em></p>
<blockquote>
<p>这可能是因为我们发展出了两类社会科学家群体：一类是学科导向型并在高度专业的期刊上发表文章，另一类是问题导向型并在如政策简报等其他地方发表文章。</p>
</blockquote>
<h3 id="单词-1"><a href="#单词-1" class="headerlink" title="单词"></a>单词</h3><ul>
<li>evolve</li>
<li>community</li>
<li>discipline-oriented</li>
<li>problem-oriented</li>
<li>brief</li>
</ul>
<h3 id="词组-1"><a href="#词组-1" class="headerlink" title="词组"></a>词组</h3><ul>
<li>two communities of social scientists</li>
<li>publish in highly specialized journals</li>
</ul>
<h2 id="Sentence-78"><a href="#Sentence-78" class="headerlink" title="Sentence 78"></a>Sentence 78</h2><p><em>Steelworkers, airline employees, and now those in the auto industry are joining millions of families who must worry about interest rates, stock market fluctuation, and the harsh reality that they may outlive their retirement money.</em></p>
<blockquote>
<p>炼钢工人、航空公司职员，以及现在那些在汽车行业的员工都正在加入那些不得不担心利率股市波动和退休金不够用这一残酷现实的数百万家庭的行列。</p>
</blockquote>
<h3 id="单词-2"><a href="#单词-2" class="headerlink" title="单词"></a>单词</h3><ul>
<li>steelworkers</li>
<li>worry about</li>
<li>interest rate    利率</li>
<li>fluctuation</li>
<li>harsh</li>
<li>outlive</li>
</ul>
<h3 id="词组-2"><a href="#词组-2" class="headerlink" title="词组"></a>词组</h3><ul>
<li>the harsh reality</li>
<li>retirement money</li>
</ul>
<h2 id="Sentence-79"><a href="#Sentence-79" class="headerlink" title="Sentence 79"></a>Sentence 79</h2><p><em>After all, four decades of evidence has now shown that corporations in Europe as well as the US are evading the meritocratic hiring and promotion of women to top position — no matter how much “soft pressure” is put upon them.</em></p>
<blockquote>
<p>毕竟四十年的事实现已表明，不管被施加多大的“软压力”，欧洲和美国的企业一直在回避英才管理制度，限制女性晋升到高层。</p>
</blockquote>
<h3 id="单词-3"><a href="#单词-3" class="headerlink" title="单词"></a>单词</h3><ul>
<li>decade</li>
<li>corporation</li>
<li>evade</li>
<li>meritocratic</li>
<li>promotion</li>
</ul>
<h3 id="词组-3"><a href="#词组-3" class="headerlink" title="词组"></a>词组</h3><ul>
<li>after all</li>
<li>four decades of evidence has now shown that ..</li>
<li>no matter how ..</li>
<li>as well as</li>
<li>the meritocratic hiring</li>
</ul>
<h2 id="Sentence-80"><a href="#Sentence-80" class="headerlink" title="Sentence 80"></a>Sentence 80</h2><p><em>His analysis should therefore end any self-contentedness among those who may believe that the global position of English is so stable that the young generation of the United Kingdom do not need additional language capabilities.</em></p>
<blockquote>
<p>有些人可能认为英语的全球地位如此稳定以至于英国的年轻一代不需要获得额外的语言能力；他的分析应该会结束那些人的自满情绪。</p>
</blockquote>
<h3 id="单词-4"><a href="#单词-4" class="headerlink" title="单词"></a>单词</h3><ul>
<li>self-contentedness    自满</li>
<li>stable</li>
<li>generation</li>
<li>additional</li>
<li>capability</li>
</ul>
<h3 id="词组-4"><a href="#词组-4" class="headerlink" title="词组"></a>词组</h3><ul>
<li>end any self-contentedness among those who ..</li>
<li>the global position of English</li>
<li>the young generation of the United Kingdom</li>
<li>additional language capabilities</li>
</ul>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>考研英语100句</tag>
      </tags>
  </entry>
  <entry>
    <title>考研英语100句Day17</title>
    <url>/2022/09/14/28/</url>
    <content><![CDATA[<h1 id="考研英语100句–Day17"><a href="#考研英语100句–Day17" class="headerlink" title="考研英语100句–Day17"></a>考研英语100句–Day17</h1><h2 id="Sentence-81"><a href="#Sentence-81" class="headerlink" title="Sentence 81"></a>Sentence 81</h2><p><em>The Internet — and pressure from funding agencies, who are questioning why commercial publishers are making money from government-funded research by restricting access to it — is making access to scientific results a reality.</em></p>
<blockquote>
<p>提供资金的机构施加压力，质疑为什么商业出版商可以通过限制人们查看政府资助的研究结果而从中牟利，来自这方面的压力和互联网正在使阅读科研结果成为现实。</p>
</blockquote>
<h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><ul>
<li>agency</li>
<li>commercial</li>
<li>restrict    限制</li>
</ul>
<h3 id="词组"><a href="#词组" class="headerlink" title="词组"></a>词组</h3><ul>
<li>funding agencies</li>
<li>commercial publisher</li>
<li>make money from government-funded research by restricting access to it</li>
<li>make access to sth a reality</li>
<li>make sth a reality</li>
</ul>
<h2 id="Sentence-82"><a href="#Sentence-82" class="headerlink" title="Sentence 82"></a>Sentence 82</h2><p><em>There is pressure for change from within the profession, but opponents of change among the regulators insist that keeping outsiders out of a law firm isolates lawyers from the pressure to make money rather than serve clients ethically.</em></p>
<blockquote>
<p>在行业内部存在着改革的压力，但是监管部门中反对变革的人坚称，将外部人士排除在律师事务所之外，可以让律师远离赚钱的压力，从而遵守职业道德为委托人服务。</p>
</blockquote>
<h3 id="单词-1"><a href="#单词-1" class="headerlink" title="单词"></a>单词</h3><ul>
<li>opponent</li>
<li>regulator    调整者，规定者</li>
<li>insist    坚持</li>
<li>ethically    道德上</li>
</ul>
<h3 id="词组-1"><a href="#词组-1" class="headerlink" title="词组"></a>词组</h3><ul>
<li>within the profession</li>
<li>keep outsiders out of a law firm</li>
<li>isolate lawyers from the pressure to make money</li>
<li>rather than serve clients</li>
</ul>
<h2 id="Sentence-83"><a href="#Sentence-83" class="headerlink" title="Sentence 83"></a>Sentence 83</h2><p><em>The force of geographic conditions peculiar to America, the interplay of the varied national groups upon one another, and the sheer difficulty of maintaining old-world ways in a raw, new continent caused significant changes.</em></p>
<blockquote>
<p>美国特有的地理条件的影响，不同民族之间的相互作用，以及在这片原始新大陆上维持旧有方式的困难，这些因素引起了重大的变化。</p>
</blockquote>
<h3 id="单词-2"><a href="#单词-2" class="headerlink" title="单词"></a>单词</h3><ul>
<li>force</li>
<li>geographic</li>
<li>peculiar    特别的，奇异的</li>
<li>interplay</li>
<li>sheer</li>
<li>continent</li>
<li>significant</li>
</ul>
<h3 id="词组-2"><a href="#词组-2" class="headerlink" title="词组"></a>词组</h3><ul>
<li>peculiar to</li>
<li>the varied national groups</li>
</ul>
<h2 id="Sentence-84"><a href="#Sentence-84" class="headerlink" title="Sentence 84"></a>Sentence 84</h2><p><em>Yet, when one looks at the photographs of the garden created by the homeless, it strikes one that, for all their diversity of styles, these gardens speak of various other fundamental urges, beyond that of decoration and creative expression.</em></p>
<blockquote>
<p>然而，当人们看到那些无家可归者所创建的花园的照片时，受到了深深的震撼：尽管这些花园风格多样，但它们除了表现出创作者的装饰和创造力表达的需求之外，还表现出各种其他根本的需求。</p>
</blockquote>
<h3 id="单词-3"><a href="#单词-3" class="headerlink" title="单词"></a>单词</h3><ul>
<li>photograph</li>
<li>strike</li>
<li>diversity</li>
<li>fundamental</li>
<li>urge</li>
<li>decoration    装饰</li>
</ul>
<h3 id="词组-3"><a href="#词组-3" class="headerlink" title="词组"></a>词组</h3><ul>
<li>it strikes one that</li>
<li>the diversity of styles</li>
<li>creative expression</li>
</ul>
<h2 id="Sentence-85"><a href="#Sentence-85" class="headerlink" title="Sentence 85"></a>Sentence 85</h2><p><em>Under the plan, for example, the agency said it would not prosecute landowner or businesses that unintentionally kill, harm, or disturb the bird, as long as they had signed a range-wide management plan to restore prairie chicken habitat.</em></p>
<blockquote>
<p>例如，根据此项计划，只要他们签署了一项大范围的管理计划来恢复小草原松鸡的栖息地，该管理局称其不会起诉那些无意杀死、伤害或干扰小草原松鸡的土地所有者或企业。</p>
</blockquote>
<h3 id="单词-4"><a href="#单词-4" class="headerlink" title="单词"></a>单词</h3><ul>
<li>prosecute</li>
<li>landowner</li>
<li>unintentionally</li>
<li>disturb</li>
<li>restore</li>
<li>prairie</li>
<li>habitat</li>
</ul>
<h3 id="词组-4"><a href="#词组-4" class="headerlink" title="词组"></a>词组</h3><ul>
<li><strong>under</strong> the plan</li>
<li>as long as</li>
<li>sign a range-wide management plan</li>
</ul>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>考研英语100句</tag>
      </tags>
  </entry>
  <entry>
    <title>考研英语100句Day18</title>
    <url>/2022/09/14/29/</url>
    <content><![CDATA[<h1 id="考研英语100句–Day18"><a href="#考研英语100句–Day18" class="headerlink" title="考研英语100句–Day18"></a>考研英语100句–Day18</h1><h2 id="Sentence-86"><a href="#Sentence-86" class="headerlink" title="Sentence 86"></a>Sentence 86</h2><p><em>In his article “How Intelligent Is Intelligence Testing?”, Sternberg notes that traditional tests best assess analytical and verbal skills but fail to measure creativity and practical knowledge, components also critical to problem solving and life success.</em></p>
<blockquote>
<p>在斯腾伯格的文章《智力测试有多明智？》中，他指出传统的测试能最大程度地评估分析能力和语言表达能力，但不能衡量创造力和实践知识，这些部分对于解决问题和获得人生成功也极其重要。</p>
</blockquote>
<h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><ul>
<li>intelligent</li>
<li>traditional</li>
<li>critical</li>
<li>component</li>
</ul>
<h3 id="词组"><a href="#词组" class="headerlink" title="词组"></a>词组</h3><ul>
<li>he notes that ..</li>
<li>analytical and verbal skills</li>
<li>measure creativity and practical knowledge</li>
<li>critical to problem solving and life success</li>
</ul>
<h2 id="Sentence-87"><a href="#Sentence-87" class="headerlink" title="Sentence 87"></a>Sentence 87</h2><p><em>At a time when Thomas Piketty and other economists are warning of rising inequality and the increasing power of inherited wealth, it is bizarre that wealthy aristocratic families should still be the symbolic heart of modern democratic states.</em></p>
<blockquote>
<p>在托马斯·皮凯蒂和其他经济学家提醒民众警惕不断加剧的不平等现象和不断增加的继承财富的权力时，这些富有的贵族家庭仍然是现代民主国家的象征性核心，这是很奇怪的。</p>
</blockquote>
<h3 id="单词-1"><a href="#单词-1" class="headerlink" title="单词"></a>单词</h3><ul>
<li>economist</li>
<li>inherit    继承</li>
<li>bizarre    奇怪的</li>
<li>aristocratic    贵族的</li>
<li>democratic    民主的</li>
</ul>
<h3 id="词组-1"><a href="#词组-1" class="headerlink" title="词组"></a>词组</h3><ul>
<li>at a time when ..</li>
<li>warn of sth</li>
<li>rising inequality</li>
<li>the increasing power of inherited wealth</li>
</ul>
<h2 id="Sentence-88"><a href="#Sentence-88" class="headerlink" title="Sentence 88"></a>Sentence 88</h2><p><em>Calls to disassemble all telescopes on Mauna Kea or to ban future development there ignore the reality that astronomy and Hawaiian culture both seek to answer big questions about who we are, where we come from and where we are going.</em></p>
<blockquote>
<p>拆除莫纳克亚山上所有的望远镜或禁止未来在那里新建望远镜的呼声忽略了这样一个事实，即天文学和夏威夷文化都在寻求关于“我们是谁”“我们来自哪里”“我们要去何处”这些重大问题的答案。</p>
</blockquote>
<h3 id="单词-2"><a href="#单词-2" class="headerlink" title="单词"></a>单词</h3><ul>
<li>disassemble</li>
<li>telescope</li>
<li>astronomy    天文学</li>
</ul>
<h3 id="词组-2"><a href="#词组-2" class="headerlink" title="词组"></a>词组</h3><ul>
<li>ignore the reality that ..</li>
<li>seek to answer big questions about ..</li>
</ul>
<h2 id="Sentence-89"><a href="#Sentence-89" class="headerlink" title="Sentence 89"></a>Sentence 89</h2><p><em>Humans are unique in their capacity to not only make tools but then turn around and use them to create superfluous material goods—paintings, sculpture and architecture— and superfluous experiences—music, literature, religion and philosophy.</em></p>
<blockquote>
<p>人类的独特之处在于，他们不仅有能力制造工具，而且还能反过来使用工具来创作额外的有形物品——绘画、雕塑和建筑——和额外的精神体验——音乐、文学、宗教和哲学。</p>
</blockquote>
<h3 id="单词-3"><a href="#单词-3" class="headerlink" title="单词"></a>单词</h3><ul>
<li>superfluous    额外的</li>
<li>material</li>
<li>sculpture</li>
<li>architecture</li>
<li>experience</li>
<li>literature</li>
<li>religion</li>
<li>philosophy</li>
</ul>
<h3 id="词组-3"><a href="#词组-3" class="headerlink" title="词组"></a>词组</h3><ul>
<li>are unique in their capacity to ..</li>
<li>turn around</li>
</ul>
<h2 id="Sentence-90"><a href="#Sentence-90" class="headerlink" title="Sentence 90"></a>Sentence 90</h2><p><em>As a discovery claim works its way through the community, the interaction and confrontation between shared and competing beliefs about the science and the technology involved transforms an individual’s discovery claim into the community’s credible discovery.</em></p>
<blockquote>
<p>当一个发现声明逐步通过科学界的审查时，与该科技相容和矛盾的观点就会相互作用和对抗，这样就会把个人的发现声明转变为科学界的可靠发现。</p>
</blockquote>
<h3 id="单词-4"><a href="#单词-4" class="headerlink" title="单词"></a>单词</h3><ul>
<li>discovery</li>
<li>claim</li>
<li>community</li>
<li>interaction</li>
<li>confrontation</li>
<li>individual</li>
<li>credible</li>
</ul>
<h3 id="词组-4"><a href="#词组-4" class="headerlink" title="词组"></a>词组</h3><ul>
<li>transforms sth. into sth.</li>
</ul>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>考研英语100句</tag>
      </tags>
  </entry>
  <entry>
    <title>考研英语100句Day19</title>
    <url>/2022/09/14/31/</url>
    <content><![CDATA[<h1 id="考研英语100句–Day19"><a href="#考研英语100句–Day19" class="headerlink" title="考研英语100句–Day19"></a>考研英语100句–Day19</h1><h2 id="Sentence-91"><a href="#Sentence-91" class="headerlink" title="Sentence 91"></a>Sentence 91</h2><p><em>But in her new book Join the Club, Tina Rosenberg contends that peer pressure can also be a positive force through what she calls the social cure, in which organizations and officials use the power of group dynamics to help individuals improve their lives and possibly the world.</em></p>
<blockquote>
<p>但是，蒂娜·罗森堡在她的新书《加入俱乐部》中主张，同辈压力也可以通过她所说的“社会治疗”转化成一种积极的力量。在社会治疗的过程中，各机构及官员可以利用群体动力来帮助个人改善生活，甚至可能改善整个世界。</p>
</blockquote>
<h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><ul>
<li>contend</li>
<li>cure</li>
</ul>
<h3 id="词组"><a href="#词组" class="headerlink" title="词组"></a>词组</h3><ul>
<li>peer pressure</li>
<li>a positive force</li>
<li>the social cure</li>
<li>help individuals improve their lives</li>
</ul>
<h2 id="Sentence-92"><a href="#Sentence-92" class="headerlink" title="Sentence 92"></a>Sentence 92</h2><p><em>Fundamentally, the USPS is in a historic squeeze between technological change that has permanently decreased demand for its bread-and-butter product, first-class mail, and a regulatory structure that denies management the flexibility to adjust its operations to the new reality.</em></p>
<blockquote>
<p>从根本上说，美国邮政署（USPS）正处于一个历史性的困境之中，一方面是技术变革永久性地降低了对其主要产品——普通邮件的需求，另一方面是监管结构拒绝让管理部门灵活调整其业务以适应新形势。</p>
</blockquote>
<h3 id="单词-1"><a href="#单词-1" class="headerlink" title="单词"></a>单词</h3><ul>
<li>fundamentally</li>
<li>historic</li>
<li>squeeze</li>
<li>permanently</li>
<li>decrease</li>
<li>demand</li>
<li>deny</li>
<li>flexibility</li>
<li>operations    经营，手术，操作，执行</li>
</ul>
<h3 id="词组-1"><a href="#词组-1" class="headerlink" title="词组"></a>词组</h3><ul>
<li>in a historic squeeze</li>
<li>permanently decreased demand for sth.</li>
<li>its bread-and-butter product</li>
<li>adjust its operations to the new reality</li>
</ul>
<h2 id="Sentence-93"><a href="#Sentence-93" class="headerlink" title="Sentence 93"></a>Sentence 93</h2><p><em>Unhappy parents rarely are provoked to wonder if they shouldn’t have had kids, but unhappy childless folks are bothered with the message that children are the single most important thing in the world: obviously their misery must be a direct result of the gaping baby-size holes in their lives.</em></p>
<blockquote>
<p>几乎没有事情会促使不幸福的父母去琢磨自己是否不该养孩子，但是不幸福的且没有孩子的人们却总是被“孩子是世上唯一最重要的东西”这一信息所困扰：显然他们的不幸肯定是他们一生中没有孩子的缺憾造成的。</p>
</blockquote>
<h3 id="单词-2"><a href="#单词-2" class="headerlink" title="单词"></a>单词</h3><ul>
<li>rarely</li>
<li>provoke    诱导，挑衅，煽动</li>
<li>folks    人们</li>
<li>obviously</li>
<li>misery</li>
</ul>
<h3 id="词组-2"><a href="#词组-2" class="headerlink" title="词组"></a>词组</h3><ul>
<li>be provoked to wonder if they should ..</li>
<li>be bothered with sth ..</li>
<li>must be a direct result of sth.</li>
</ul>
<h2 id="Sentence-94"><a href="#Sentence-94" class="headerlink" title="Sentence 94"></a>Sentence 94</h2><p><em>To encourage innovation and competition, the report calls for increased investment in research, the crafting of coherent curricula that improve students’ ability to solve problems and communicate effectively in the 21st century, increased funding for teachers and the encouragement of scholars to bring their learning to bear on the great challenges of the day.</em></p>
<blockquote>
<p>为了鼓励创新和竞争，报告呼吁增加对此项研究的投资，呼吁精心设计系统连贯的课程以提高学生在21世纪解决问题和有效沟通的能力，呼吁增加教师的经费，并鼓励学者应用他们的学识来应对当今巨大的挑战。</p>
</blockquote>
<h3 id="单词-3"><a href="#单词-3" class="headerlink" title="单词"></a>单词</h3><ul>
<li>encourage</li>
<li>innovation</li>
<li>competition</li>
<li>investment</li>
<li>craft    制定</li>
<li>coherent    配套的，连贯的</li>
<li>curricula    课程表，课程</li>
</ul>
<h3 id="词组-3"><a href="#词组-3" class="headerlink" title="词组"></a>词组</h3><ul>
<li>calls for sth ..    呼吁</li>
<li>increased investment in research</li>
<li>increased funding for teachers</li>
<li>improve students’ ability to solve problems</li>
<li>communicate effectively</li>
<li>bring their learning to bear on the great challenges of the day</li>
</ul>
<h2 id="Sentence-95"><a href="#Sentence-95" class="headerlink" title="Sentence 95"></a>Sentence 95</h2><p><em>Moreover, average overall margins are higher in wholesale than in retail; wholesale demand from the food service sector is growing quickly as more Europeans eat out more often; and changes in the competitive dynamics of this fragmented industry are at last making it feasible for wholesalers to consolidate.</em></p>
<blockquote>
<p>此外，批发业的平均总利润高于零售业；随着越来越多的欧洲人更加频繁地外出就餐，餐饮服务业的批发需求也迅速增长；这一零散产业竞争力量的变化最终会使批发商们的联合成为可能。</p>
</blockquote>
<h3 id="单词-4"><a href="#单词-4" class="headerlink" title="单词"></a>单词</h3><ul>
<li>moreover</li>
<li>overall</li>
<li>margin</li>
<li>wholesale</li>
<li>retail</li>
<li>sector    行业</li>
<li>competitive</li>
<li>fragmented</li>
<li>feasible    可行的</li>
<li>consolidate    整顿，整并</li>
</ul>
<h3 id="词组-4"><a href="#词组-4" class="headerlink" title="词组"></a>词组</h3><ul>
<li>average overall margins</li>
<li>this fragmented industry</li>
</ul>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>考研英语100句</tag>
      </tags>
  </entry>
  <entry>
    <title>考研英语100句Day2</title>
    <url>/2022/07/27/01/</url>
    <content><![CDATA[<h1 id="考研英语100句–Day2"><a href="#考研英语100句–Day2" class="headerlink" title="考研英语100句–Day2"></a>考研英语100句–Day2</h1><h2 id="Sentence-06"><a href="#Sentence-06" class="headerlink" title="Sentence 06"></a>Sentence 06</h2><p><em>Everyone needs to find their extra – their unique value contribution that makes them stand out in whatever is their field of employment.</em></p>
<blockquote>
<p>人人都需要找到自己的额外价值——让自己在任何所在职业领域中都脱颖而出的独特价值<br>贡献。</p>
</blockquote>
<h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><ul>
<li>extra</li>
<li>unique value contribution</li>
<li>stand out</li>
</ul>
<h3 id="词组"><a href="#词组" class="headerlink" title="词组"></a>词组</h3><ul>
<li>their field of employment</li>
<li>make sb stand out</li>
</ul>
<h2 id="Sentence-07"><a href="#Sentence-07" class="headerlink" title="Sentence 07"></a>Sentence 07</h2><p><em>It is also the reason why when we try to describe music with words, all we can do is articulate our reactions to it, and not grasp music itself.</em></p>
<blockquote>
<p>这也是为什么当我们试图用语言来描述音乐时，我们所能做的只能是说清楚对音乐的感受，<br>而不能理解音乐本身。</p>
</blockquote>
<h3 id="单词-1"><a href="#单词-1" class="headerlink" title="单词"></a>单词</h3><ul>
<li>articulate</li>
<li>reactions</li>
<li>grasp</li>
</ul>
<h3 id="词组-1"><a href="#词组-1" class="headerlink" title="词组"></a>词组</h3><ul>
<li>It is also the reason why</li>
<li>try to describe music with words</li>
<li>articulate our reactions to it</li>
<li>grasp music itself</li>
</ul>
<h2 id="Sentence-08"><a href="#Sentence-08" class="headerlink" title="Sentence 08"></a>Sentence 08</h2><p><em>Scientists jumped to the rescue with some distinctly shaky evidence to the effect that insects would eat us up if birds failed to control them.</em></p>
<blockquote>
<p>科学家们立即拿出某些明显站不住脚的证据前来“救驾”，其大意是说如果鸟儿不能控制这<br>些昆虫的数量的话，昆虫就会吃光一切。</p>
</blockquote>
<h3 id="单词-2"><a href="#单词-2" class="headerlink" title="单词"></a>单词</h3><ul>
<li>scientists</li>
<li>distinctly</li>
<li>shaky evidence</li>
<li>rescue</li>
</ul>
<h3 id="词组-2"><a href="#词组-2" class="headerlink" title="词组"></a>词组</h3><ul>
<li>jump to the rescue</li>
<li>some distinctly shaky evidence</li>
<li>eat us up</li>
<li>failed to control sth</li>
</ul>
<h2 id="Sentence-09"><a href="#Sentence-09" class="headerlink" title="Sentence 09"></a>Sentence 09</h2><p><em>A moralist, satirist, and social reformer, Dickens crafted complex plots and striking characters that capture the panorama of English society.</em></p>
<blockquote>
<p>作为一位道德家、讽刺作家和社会改革家，狄更斯精心设计了复杂的情节和引人注目的人物，<br>捕捉了英国社会的全貌。</p>
</blockquote>
<h3 id="单词-3"><a href="#单词-3" class="headerlink" title="单词"></a>单词</h3><ul>
<li>moralist</li>
<li>satirist</li>
<li>social reformer</li>
<li>complex plots</li>
<li>striking characters</li>
<li>capture</li>
<li>panorama</li>
</ul>
<h3 id="词组-3"><a href="#词组-3" class="headerlink" title="词组"></a>词组</h3><ul>
<li>capture the panorama of English society</li>
</ul>
<h2 id="Sentence-10"><a href="#Sentence-10" class="headerlink" title="Sentence 10"></a>Sentence 10</h2><p><em>Half a century of town and country planning has enabled it to retain an enviable rural coherence, while still permitting low-density urban living.</em></p>
<blockquote>
<p>半个世纪的城乡规划使其（英国）得以保留令人羡慕的乡村和谐，同时仍允许低密度的城镇<br>生活。</p>
</blockquote>
<h3 id="单词-4"><a href="#单词-4" class="headerlink" title="单词"></a>单词</h3><ul>
<li>century</li>
<li>retain</li>
<li>enviable</li>
<li>rural</li>
<li>coherence</li>
<li>permitting</li>
<li>low-density</li>
</ul>
<h3 id="词组-4"><a href="#词组-4" class="headerlink" title="词组"></a>词组</h3><ul>
<li>low-density urban living</li>
<li>has enabled it to retain an enviable rural coherence</li>
</ul>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>考研英语100句</tag>
      </tags>
  </entry>
  <entry>
    <title>考研英语100句Day20</title>
    <url>/2022/09/14/30/</url>
    <content><![CDATA[<h1 id="考研英语100句–Day20"><a href="#考研英语100句–Day20" class="headerlink" title="考研英语100句–Day20"></a>考研英语100句–Day20</h1><h2 id="Sentence-96"><a href="#Sentence-96" class="headerlink" title="Sentence 96"></a>Sentence 96</h2><p><em>Just as bosses and boards have finally sorted out their worst accounting and compliance troubles, and improved their feeble corporation governance, a new problem threatens to earn them — especially in America — the sort of nasty headlines that inevitably lead to heads rolling in the executive suite: data insecurity.</em></p>
<blockquote>
<p>就在老板和董事会终于处理好其最严重的财务和规章问题，改善了公司薄弱的管理之后，又一个新问题正威胁着他们——尤其是在美国——这个问题就是数据不安全性，这会让他们出现在令人不快的新闻头条中，将不可避免地使高层们受到严惩。</p>
</blockquote>
<h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><ul>
<li>feeble</li>
<li>corporation</li>
<li>governance</li>
<li>threaten</li>
<li>insecurity</li>
<li>nasty</li>
<li>headline</li>
<li>inevitably </li>
<li>executive    行政的，执行官</li>
</ul>
<h3 id="词组"><a href="#词组" class="headerlink" title="词组"></a>词组</h3><ul>
<li>sort out</li>
<li>accounting and compliance troubles</li>
<li>a new problem threatens to earn them</li>
<li>the sort of nasty headlines</li>
</ul>
<h2 id="Sentence-97"><a href="#Sentence-97" class="headerlink" title="Sentence 97"></a>Sentence 97</h2><p><em>The article is actually quite optimistic, as it outlines a potential solution to this problem, suggesting that an approach（which involves a one-hour, next-to-no-cost program） can close 63 percent of the achievement gap（measured by such factors as grades） between first-generation and other students.</em></p>
<blockquote>
<p>这篇文章实际上相当乐观，因为它针对这个问题简要描述了一种可能的解决方案，表示有一种方式（一个耗时一小时、几乎零成本的项目）能够缩小第一代大学生和其他学生之间63%的成绩差距（以分数等指标衡量）。</p>
</blockquote>
<h3 id="单词-1"><a href="#单词-1" class="headerlink" title="单词"></a>单词</h3><ul>
<li>optimistic    乐观的</li>
<li>outline</li>
<li>potential</li>
<li>achievement</li>
<li>involve</li>
<li>factor</li>
</ul>
<h3 id="词组-1"><a href="#词组-1" class="headerlink" title="词组"></a>词组</h3><ul>
<li>a potential solution to this problem</li>
</ul>
<h2 id="Sentence-98"><a href="#Sentence-98" class="headerlink" title="Sentence 98"></a>Sentence 98</h2><p><em>Precisely because readers from different historical periods, places and social experiences produce different but overlapping readings of the same words on the page — including for texts that engage with fundamental human concerns—debates about texts can play an important role in social discussion of beliefs and values.</em></p>
<blockquote>
<p>正因为来自不同历史时期、不同地域和有着不同社会经历的读者会对页面上那些相同的文字产生不同但有重叠的解读——包括对涉及人类所关注的基本问题的文本解读，关于文本解读的争议才能在信仰和价值观的社会讨论中发挥重要作用。</p>
</blockquote>
<h3 id="单词-2"><a href="#单词-2" class="headerlink" title="单词"></a>单词</h3><ul>
<li>precisely    正确地，清晰地</li>
<li>historical</li>
<li>period</li>
<li>overlapping</li>
<li>engage</li>
<li>debate</li>
<li>discussion</li>
</ul>
<h3 id="词组-2"><a href="#词组-2" class="headerlink" title="词组"></a>词组</h3><ul>
<li>different historical periods</li>
<li>they produce different but overlapping readings of the same words on the page</li>
<li>texts that engage with fundamental human concerns</li>
<li>play an important role in ..</li>
<li>debates about texts can play an important role in social discussion of beliefs and values.</li>
</ul>
<h2 id="Sentence-99"><a href="#Sentence-99" class="headerlink" title="Sentence 99"></a>Sentence 99</h2><p><em>At Tulane University’s Tear Analysis Laboratory, Dr.Peter Kastl and his colleagues report that they can use tears to detect drug abuse and exposure to medication, to determine whether a contact lens fits properly or why it may be uncomfortable, to study the causes of “dry eye” syndrome and the effects of eye surgery, and perhaps even to measure exposure to environmental pollutants.</em></p>
<blockquote>
<p>在杜兰大学的眼泪分析实验室，彼得·卡斯尔博士和他的同事报告称，他们可以用眼泪来检测出滥用毒品及使用药物的情况，确认隐形眼镜戴起来是否合适或者是戴着不舒适的原因，还能用来探究“干眼”综合征产生的原因和眼部手术的效果，也许甚至还能用来测量与环境污染物接触的情况。</p>
</blockquote>
<h3 id="单词-3"><a href="#单词-3" class="headerlink" title="单词"></a>单词</h3><ul>
<li>Laboratory</li>
<li>colleague</li>
<li>detect</li>
<li>exposure</li>
<li>abuse</li>
<li>contact    接触</li>
<li>syndrome</li>
<li>surgery</li>
<li>pollutant    污染物</li>
</ul>
<h3 id="词组-3"><a href="#词组-3" class="headerlink" title="词组"></a>词组</h3><ul>
<li>report that ..</li>
<li>detect drug abuse</li>
<li>detect exposure to medication</li>
<li>a contact lens    隐形眼镜</li>
<li>sth. fit properly</li>
<li>study the causes of ..    探究..的原因</li>
<li>environmental pollutants</li>
</ul>
<h2 id="Sentence-100"><a href="#Sentence-100" class="headerlink" title="Sentence 100"></a>Sentence 100</h2><p><em>Young people who are still getting started in life were more likely than older adults to prioritize personal fulfillment in their work, to believe they will advance their careers most by regularly changing jobs, to favor communities with more public services and a faster pace of life, to agree that couples should be financially secure before getting married or having children, and to maintain that children are best served by two parents working outside the home, the survey found.</em></p>
<blockquote>
<p>该调查发现，比起老年人，那些仍然处在生活起跑线的年轻人会更优先考虑他们在工作中的个人成就，更加认同通过定期换工作来推进个人职业生涯，更喜欢拥有较多公共服务的社区和节奏更快的生活，更坚信夫妻在结婚或者抚育孩子之前应该有经济上的保障，更主张父母双方都在外工作才能给孩子提供最好的生活。</p>
</blockquote>
<h3 id="单词-4"><a href="#单词-4" class="headerlink" title="单词"></a>单词</h3><ul>
<li><strong>prioritize</strong>    给..优先权</li>
<li>fulfillment    成就，满足感，实现</li>
<li>advance</li>
<li>pace    步伐</li>
<li>secure</li>
<li>maintain</li>
<li>survey</li>
</ul>
<h3 id="词组-4"><a href="#词组-4" class="headerlink" title="词组"></a>词组</h3><ul>
<li>be likely to do ..</li>
<li>personal fulfillment</li>
<li>be financially secure</li>
<li>get married</li>
</ul>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>考研英语100句</tag>
      </tags>
  </entry>
  <entry>
    <title>考研英语100句Day3</title>
    <url>/2022/07/28/01/</url>
    <content><![CDATA[<h1 id="考研英语100句–Day3"><a href="#考研英语100句–Day3" class="headerlink" title="考研英语100句–Day3"></a>考研英语100句–Day3</h1><h2 id="Sentence-11"><a href="#Sentence-11" class="headerlink" title="Sentence 11"></a>Sentence 11</h2><p><em>Integrity had collapsed, she argued, because of a collective acceptance that the only “sorting mechanism” in society should be profit and the market.</em></p>
<blockquote>
<p>她认为，诚信已瓦解，因为我们集体接受的观念是，社会中唯一的“分选机制”应该是利润和市场。</p>
</blockquote>
<h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><ul>
<li>argue</li>
<li>integrity</li>
<li>collapse</li>
<li>a collective acceptance</li>
<li>profit</li>
<li>mechanism</li>
</ul>
<h3 id="词组"><a href="#词组" class="headerlink" title="词组"></a>词组</h3><ul>
<li>because of a collective acceptance that ..</li>
</ul>
<h2 id="Sentence-12"><a href="#Sentence-12" class="headerlink" title="Sentence 12"></a>Sentence 12</h2><p><em>We need them to imagine the United States as a place where they can be productive for a while without committing themselves to staying forever.</em></p>
<blockquote>
<p>我们需要他们把美国想象为这样一个地方，在这里他们可以在一段时间内创造价值，而无需承诺永久居留于此。</p>
</blockquote>
<h3 id="单词-1"><a href="#单词-1" class="headerlink" title="单词"></a>单词</h3><ul>
<li>productive</li>
<li>commit</li>
</ul>
<h3 id="词组-1"><a href="#词组-1" class="headerlink" title="词组"></a>词组</h3><ul>
<li>imagine the United States as a place where ..</li>
<li>need sb to do sth</li>
<li>be productive for a while</li>
<li>without committing themselves to staying forever</li>
</ul>
<h2 id="Sentence-13"><a href="#Sentence-13" class="headerlink" title="Sentence 13"></a>Sentence 13</h2><p><em>The issue of voluntary part-time relates to Obamacare because one of the main purposes was to allow people to get insurance outside of employment.</em></p>
<blockquote>
<p>自愿兼职工作这一问题与奥巴马医改计划相关联，因为该计划的主要目的之一就是让人们不就业也能得到医疗保险。</p>
</blockquote>
<h3 id="单词-2"><a href="#单词-2" class="headerlink" title="单词"></a>单词</h3><ul>
<li>issue</li>
<li>voluntary</li>
<li>insurance</li>
<li>purpose</li>
</ul>
<h3 id="词组-2"><a href="#词组-2" class="headerlink" title="词组"></a>词组</h3><ul>
<li>one of the main purposes is to do ..</li>
<li>allow people to do ..</li>
<li>get insurance</li>
<li>outside of employment</li>
</ul>
<h2 id="Sentence-14"><a href="#Sentence-14" class="headerlink" title="Sentence 14"></a>Sentence 14</h2><p><em>Firms are now studying how genes interact, looking for correlations that might be used to determine the causes of disease or predict a drug’s efficacy.</em></p>
<blockquote>
<p>一些公司正在研究基因是如何相互作用的，寻找可能用来确定病因或者预测药物疗效的相关性。</p>
</blockquote>
<h3 id="单词-3"><a href="#单词-3" class="headerlink" title="单词"></a>单词</h3><ul>
<li>firm</li>
<li>correlation</li>
<li>determine</li>
<li>cause</li>
<li>disease</li>
<li>predict</li>
<li>efficacy</li>
</ul>
<h3 id="词组-3"><a href="#词组-3" class="headerlink" title="词组"></a>词组</h3><ul>
<li>how genes interact</li>
</ul>
<h2 id="Sentence-15"><a href="#Sentence-15" class="headerlink" title="Sentence 15"></a>Sentence 15</h2><p><em>Dead markets partly reflect the paralysis of banks which will not sell assets for fear of booking losses, yet are reluctant to buy all those supposed bargains.</em></p>
<blockquote>
<p>毫无活力的市场一定程度上反映了银行系统的瘫痪，由于担心账面损失，银行不会出售资产，但也不愿意收购那些所谓的廉价资产。</p>
</blockquote>
<h3 id="单词-4"><a href="#单词-4" class="headerlink" title="单词"></a>单词</h3><ul>
<li>reflect</li>
<li>paralysis</li>
<li>asset</li>
<li>supposed</li>
<li>bargain</li>
<li>reluctant</li>
</ul>
<h3 id="词组-4"><a href="#词组-4" class="headerlink" title="词组"></a>词组</h3><ul>
<li>dead market</li>
<li>for fear of booking losses</li>
<li>supposed bargain</li>
</ul>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>考研英语100句</tag>
      </tags>
  </entry>
  <entry>
    <title>考研英语100句Day4</title>
    <url>/2022/08/25/01/</url>
    <content><![CDATA[<h1 id="考研英语100句–Day4"><a href="#考研英语100句–Day4" class="headerlink" title="考研英语100句–Day4"></a>考研英语100句–Day4</h1><h2 id="Sentence-16"><a href="#Sentence-16" class="headerlink" title="Sentence 16"></a>Sentence 16</h2><p><em>He adds humbly that perhaps he was “superior to the common run of men in noticing things which easily escape attention, and in observing them carefully”.</em></p>
<blockquote>
<p>他谦虚地补充道，或许他“优于常人的地方在于能够注意到容易被忽视的东西，并对这些东西进行仔细观察”。</p>
</blockquote>
<h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><ul>
<li><p>humbly</p>
</li>
<li><p>perhaps</p>
</li>
<li><p>superior</p>
</li>
<li><p>escape</p>
</li>
<li><p>observing</p>
</li>
</ul>
<h3 id="词组"><a href="#词组" class="headerlink" title="词组"></a>词组</h3><ul>
<li>the common run of men in noticing things</li>
<li>easily escape attention</li>
</ul>
<h2 id="Sentence-17"><a href="#Sentence-17" class="headerlink" title="Sentence 17"></a>Sentence 17</h2><p><em>Many leading American universities want their undergraduates to have a grounding in the basic canon of ideas that every educated person should possess.</em></p>
<blockquote>
<p>许多顶尖的美国大学都希望他们的本科生接受对一些基本的、富含思想的经典作品的基础教学，这些思想是每个受教育人士都应该有的。</p>
</blockquote>
<h3 id="单词-1"><a href="#单词-1" class="headerlink" title="单词"></a>单词</h3><ul>
<li>undergraduate</li>
<li>possess</li>
<li>canon</li>
</ul>
<h3 id="词组-1"><a href="#词组-1" class="headerlink" title="词组"></a>词组</h3><ul>
<li>every educated person</li>
<li>the basic canon of ideas</li>
<li>have a grounding in …</li>
</ul>
<h2 id="Sentence-18"><a href="#Sentence-18" class="headerlink" title="Sentence 18"></a>Sentence 18</h2><p><em>Buying gifts or giving to charity is often more pleasurable than purchasing things for oneself, and luxuries are most enjoyable when they are consumed sparingly.</em></p>
<blockquote>
<p>买礼物或给慈善机构捐款往往会比给自己买东西更让人开心，有节制地消费奢侈品才会给人以最大的愉悦。</p>
</blockquote>
<h3 id="单词-2"><a href="#单词-2" class="headerlink" title="单词"></a>单词</h3><ul>
<li>charity</li>
<li>pleasurable</li>
<li>purchase</li>
<li>luxuries</li>
<li>sparingly</li>
<li>consume</li>
</ul>
<h3 id="词组-2"><a href="#词组-2" class="headerlink" title="词组"></a>词组</h3><ul>
<li>when they are consumed sparingly</li>
</ul>
<h2 id="Sentence-19"><a href="#Sentence-19" class="headerlink" title="Sentence 19"></a>Sentence 19</h2><p><em>These benefactors have succeeded in their chosen fields, they say, and they want to use their wealth to draw attention to those who have succeeded in science.</em></p>
<blockquote>
<p>他们说，这些捐助者在各自所选择的领域都很成功，而且他们想用自己的财富让人们注意到那些在科学领域有所成就的人。</p>
</blockquote>
<h3 id="单词-3"><a href="#单词-3" class="headerlink" title="单词"></a>单词</h3><ul>
<li>benefactor</li>
</ul>
<h3 id="词组-3"><a href="#词组-3" class="headerlink" title="词组"></a>词组</h3><ul>
<li>have succeeded in their chosen fields</li>
<li>draw attention to</li>
</ul>
<h2 id="Sentence-20"><a href="#Sentence-20" class="headerlink" title="Sentence 20"></a>Sentence 20</h2><p><em>Perhaps faintly, they hint that people should look to intangible qualities like character and intellect rather than dieting their way to size zero or wasp-waist physiques.</em></p>
<blockquote>
<p>这些禁令或许还隐约地暗示，人们应该注重如个性和才智等无形的品质，而不是通过节食来达到“零号身材”或“蜂腰体型”。</p>
</blockquote>
<h3 id="单词-4"><a href="#单词-4" class="headerlink" title="单词"></a>单词</h3><ul>
<li>faintly</li>
<li>hint</li>
<li>intangible</li>
<li>qualities</li>
<li>physiques</li>
<li>wasp-waist</li>
</ul>
<h3 id="词组-4"><a href="#词组-4" class="headerlink" title="词组"></a>词组</h3><ul>
<li>should look to sth.</li>
<li>diet their way to size zero or wasp-waist physiques</li>
</ul>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>考研英语100句</tag>
      </tags>
  </entry>
  <entry>
    <title>考研英语100句Day5</title>
    <url>/2022/08/29/01/</url>
    <content><![CDATA[<h1 id="考研英语100句–Day5"><a href="#考研英语100句–Day5" class="headerlink" title="考研英语100句–Day5"></a>考研英语100句–Day5</h1><h2 id="Sentence-21"><a href="#Sentence-21" class="headerlink" title="Sentence 21"></a>Sentence 21</h2><p><em>The Navy Department moved into the east wing in 1879, where elaborate wall and ceiling stenciling and marquetry floors decorated the office of the Secretary.</em></p>
<blockquote>
<p>海军部门于 1879 年搬进了东翼，在那里，精心制作的墙壁、天花板上的镂花涂装和镶嵌工艺地板装饰着部长办公室。</p>
</blockquote>
<h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><ul>
<li>nacy</li>
<li>department</li>
<li>elaborate</li>
<li>stenciling</li>
<li>marquetry</li>
<li>decorate</li>
<li>Secretary</li>
</ul>
<h3 id="词组"><a href="#词组" class="headerlink" title="词组"></a>词组</h3><ul>
<li><code>NONE</code></li>
</ul>
<h2 id="Sentence-22"><a href="#Sentence-22" class="headerlink" title="Sentence 22"></a>Sentence 22</h2><p><em>The researchers mapped not only the city’s vast and ornate ceremonial areas, but also hundreds of simpler apartment complexes where common people lived.</em></p>
<blockquote>
<p>研究人员不仅绘制了这座城市广阔且装饰华丽的庆典区，还绘制了数百个普通民众居住的简单公寓建筑群。</p>
</blockquote>
<h3 id="单词-1"><a href="#单词-1" class="headerlink" title="单词"></a>单词</h3><ul>
<li>researcher</li>
<li>vast</li>
<li>ornate</li>
<li>ceremonial</li>
<li>apartment</li>
<li>complexe</li>
</ul>
<h3 id="词组-1"><a href="#词组-1" class="headerlink" title="词组"></a>词组</h3><ul>
<li>map out</li>
</ul>
<h2 id="Sentence-23"><a href="#Sentence-23" class="headerlink" title="Sentence 23"></a>Sentence 23</h2><p><em>It may be said that the measure of the worth of any social institution is its effect in enlarging and improving experience, but this effect is not a part of its original motive.</em></p>
<blockquote>
<p>可以说，衡量任何社会制度价值的标准是其在扩大和改进经验上的成效，但这种成效并不是其最初动机的一部分。</p>
</blockquote>
<h3 id="单词-2"><a href="#单词-2" class="headerlink" title="单词"></a>单词</h3><ul>
<li>measure</li>
<li>institution</li>
<li>effect</li>
<li>enlarge</li>
<li>improve</li>
<li>motive</li>
</ul>
<h3 id="词组-2"><a href="#词组-2" class="headerlink" title="词组"></a>词组</h3><ul>
<li>the measure of the worth of any social institution</li>
<li>its effect in doing …</li>
<li>original motive</li>
</ul>
<h2 id="Sentence-24"><a href="#Sentence-24" class="headerlink" title="Sentence 24"></a>Sentence 24</h2><p><em>Our mental health doesn’t really go anywhere; like the sun behind a cloud, it can be temporarily hidden from view, but it is fully capable of being restored in an instant.</em></p>
<blockquote>
<p>我们的心理健康并不是真的消失不见了；就像云朵背后的太阳，它也许暂时被遮挡，但是它完全可以在瞬间重焕光芒。</p>
</blockquote>
<h3 id="单词-3"><a href="#单词-3" class="headerlink" title="单词"></a>单词</h3><ul>
<li>mental</li>
<li>go anywhere</li>
<li>temporarily</li>
</ul>
<h3 id="词组-3"><a href="#词组-3" class="headerlink" title="词组"></a>词组</h3><ul>
<li>be hidden from view</li>
<li>be fully capable of doing …</li>
<li>in an instant</li>
<li>be restored</li>
</ul>
<h2 id="Sentence-25"><a href="#Sentence-25" class="headerlink" title="Sentence 25"></a>Sentence 25</h2><p><em>No boy who went to a grammar school could be ignorant that the drama was a form of literature which gave glory to Greece and Rome and might yet bring honor to England.</em></p>
<blockquote>
<p>每个进入文法学校学习的学生都知道，戏剧是一种文学形式，这种文学形式赋予希腊和罗马以荣光，并且可能也会为英国带来荣耀。</p>
</blockquote>
<h3 id="单词-4"><a href="#单词-4" class="headerlink" title="单词"></a>单词</h3><ul>
<li>ignorant</li>
<li>glory</li>
<li>literature</li>
<li>honor</li>
</ul>
<h3 id="词组-4"><a href="#词组-4" class="headerlink" title="词组"></a>词组</h3><ul>
<li>be ignorant that</li>
<li>a form of literature</li>
<li>give glory to ..</li>
<li>bring honor to</li>
</ul>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>考研英语100句</tag>
      </tags>
  </entry>
  <entry>
    <title>考研英语100句Day6</title>
    <url>/2022/08/31/01/</url>
    <content><![CDATA[<h1 id="考研英语100句–Day6"><a href="#考研英语100句–Day6" class="headerlink" title="考研英语100句–Day6"></a>考研英语100句–Day6</h1><h2 id="Sentence-26"><a href="#Sentence-26" class="headerlink" title="Sentence 26"></a>Sentence 26</h2><p><em>The most loyal customers would still get the product they favor, the idea goes, and they’d feel like they were helping sustain the quality of something they believe in.</em></p>
<blockquote>
<p>这个想法是这样：那些最忠诚的顾客依旧会购买他们喜欢的产品，他们会觉得这是在帮助维护他们所信任的产品的品质。</p>
</blockquote>
<h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><ul>
<li>loyal</li>
<li>favor</li>
<li>sustain</li>
</ul>
<h3 id="词组"><a href="#词组" class="headerlink" title="词组"></a>词组</h3><ul>
<li>sustain the quality of something they believe in</li>
</ul>
<h2 id="Sentence-27"><a href="#Sentence-27" class="headerlink" title="Sentence 27"></a>Sentence 27</h2><p><em>But policymakers who refocus efforts on improving well-being rather than simply worrying about GDP figures could avoid the forecasted doom and may even see progress.</em></p>
<blockquote>
<p>但是那些重新致力于改善福祉，而不仅仅是担心国内生产总值数据的决策者们，就能够避免可预见的厄运，甚至可能看到进步。</p>
</blockquote>
<h3 id="单词-1"><a href="#单词-1" class="headerlink" title="单词"></a>单词</h3><ul>
<li>policymakers</li>
<li>refocus</li>
<li>improve</li>
<li>well-being</li>
<li>figure</li>
<li>avoid</li>
<li>forecasted</li>
<li>doom</li>
<li>progress</li>
</ul>
<h3 id="词组-1"><a href="#词组-1" class="headerlink" title="词组"></a>词组</h3><ul>
<li>refocus efforts on</li>
<li>rather than</li>
<li>worry about</li>
<li>avoid the forecasted doom</li>
</ul>
<h2 id="Sentence-28"><a href="#Sentence-28" class="headerlink" title="Sentence 28"></a>Sentence 28</h2><p><em>Indeed, there is something a little absurd in the state getting involved in the planning of such a fundamentally “grassroots” concept as community sports associations.</em></p>
<blockquote>
<p>确实，让国家参与像社区体育协会这样从根本上带有“草根阶层”意味的规划是有些荒唐的。</p>
</blockquote>
<h3 id="单词-2"><a href="#单词-2" class="headerlink" title="单词"></a>单词</h3><ul>
<li>Indeed</li>
<li>absurd</li>
<li>involve</li>
<li>fundamentally</li>
<li>concept</li>
<li>community</li>
<li>association</li>
</ul>
<h3 id="词组-2"><a href="#词组-2" class="headerlink" title="词组"></a>词组</h3><ul>
<li>a little absurd doing</li>
<li>get involved in ..</li>
</ul>
<h2 id="Sentence-29"><a href="#Sentence-29" class="headerlink" title="Sentence 29"></a>Sentence 29</h2><p><em>While few craftsmen or farmers, let alone dependents and servants, left literary compositions to be analyzed, it is obvious that their views were less fully intellectualized.</em></p>
<blockquote>
<p>尽管很少有工匠或农场主能留下可供分析的文学作品，更不用说他们的随从和佣人了，但很明显他们的观点并不十分理性。</p>
</blockquote>
<h3 id="单词-3"><a href="#单词-3" class="headerlink" title="单词"></a>单词</h3><ul>
<li>craftsman</li>
<li>servant</li>
<li>literary</li>
<li>composition</li>
<li>analyze</li>
<li>intellectualized</li>
</ul>
<h3 id="词组-3"><a href="#词组-3" class="headerlink" title="词组"></a>词组</h3><ul>
<li>let alone</li>
<li>it is obvious that</li>
<li>left literary compositions to be analyzed</li>
<li>less fully intellectualized</li>
</ul>
<h2 id="Sentence-30"><a href="#Sentence-30" class="headerlink" title="Sentence 30"></a>Sentence 30</h2><p><em>While comment and reaction from lawyers may enhance stories, it is preferable for journalists to rely on their own notions of significance and make their own judgments.</em></p>
<blockquote>
<p>尽管来自律师们的评论和反馈可能会提高新闻报道的质量，但新闻记者最好还是依靠自己对事件重要性的认识而做出自己的判断。</p>
</blockquote>
<h3 id="单词-4"><a href="#单词-4" class="headerlink" title="单词"></a>单词</h3><ul>
<li>reaction</li>
<li>enhance</li>
<li>preferable</li>
<li>journalist</li>
<li>significance</li>
<li>notion</li>
</ul>
<h3 id="词组-4"><a href="#词组-4" class="headerlink" title="词组"></a>词组</h3><ul>
<li>rely on their own notions of significance</li>
<li>make their own judgments</li>
</ul>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>考研英语100句</tag>
      </tags>
  </entry>
  <entry>
    <title>考研英语100句Day7</title>
    <url>/2022/09/05/01/</url>
    <content><![CDATA[<h1 id="考研英语100句–Day7"><a href="#考研英语100句–Day7" class="headerlink" title="考研英语100句–Day7"></a>考研英语100句–Day7</h1><h2 id="Sentence-31"><a href="#Sentence-31" class="headerlink" title="Sentence 31"></a>Sentence 31</h2><p><em>Social media allows users to experience news events more intimately and immediately while also permitting them to re-share news as a projection of their values and interests.</em></p>
<blockquote>
<p>社交媒体允许用户更密切、更迅速地体验新闻事件，同时也允许他们将新闻作为自己价值观和兴趣的投射而重新分享。</p>
</blockquote>
<h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><ul>
<li>experience</li>
<li>intimately</li>
<li>immediately</li>
<li>permitte</li>
<li>projection</li>
</ul>
<h3 id="词组"><a href="#词组" class="headerlink" title="词组"></a>词组</h3><ul>
<li>re-share sth as ..</li>
<li>a projection of sth.</li>
</ul>
<h2 id="Sentence-32"><a href="#Sentence-32" class="headerlink" title="Sentence 32"></a>Sentence 32</h2><p><em>According to research from Princeton University, people assess your competence, trustworthiness, and likeability in just a tenth of a second, solely based on the way you look.</em></p>
<blockquote>
<p>根据普林斯顿大学的研究，人们会在仅仅十分之一秒的时间内，仅根据你的外表去评判你的能力、可信度及你受人喜欢的程度。</p>
</blockquote>
<h3 id="单词-1"><a href="#单词-1" class="headerlink" title="单词"></a>单词</h3><ul>
<li>assess</li>
<li>competence</li>
<li>trustworthiness</li>
<li>likeability</li>
<li>solely</li>
</ul>
<h3 id="词组-1"><a href="#词组-1" class="headerlink" title="词组"></a>词组</h3><ul>
<li>according to</li>
<li>a tenth of a second</li>
<li>based on the way you look</li>
</ul>
<h2 id="Sentence-33"><a href="#Sentence-33" class="headerlink" title="Sentence 33"></a>Sentence 33</h2><p><em>Some attributed virtually every important cultural achievement to the inventions of a few, especially gifted people that, according to diffusionists, then spread to other cultures.</em></p>
<blockquote>
<p>有些人认为，几乎每一项重要的文化成就都是由少数特别有天赋的民族所发明创造的，根据传播论者的看法，这些发明后来传播到了其他的文化中。</p>
</blockquote>
<h3 id="单词-2"><a href="#单词-2" class="headerlink" title="单词"></a>单词</h3><ul>
<li>invention</li>
<li>virtually  几乎</li>
<li>cultural achievement</li>
<li>diffusionist</li>
<li>spread</li>
</ul>
<h3 id="词组-2"><a href="#词组-2" class="headerlink" title="词组"></a>词组</h3><ul>
<li>attributed sth to sb&#x2F;sth 归因于</li>
<li>gifted people</li>
</ul>
<h2 id="Sentence-34"><a href="#Sentence-34" class="headerlink" title="Sentence 34"></a>Sentence 34</h2><p><em><strong>The upside is the possibilities contained in knowing that everything is up to us; where before we were experts in the array of limitations, now we become authorities of what is possible.</strong></em></p>
<blockquote>
<p>积极的一面是，既然万事都取决于我们，那么就有无限可能。以前，我们能够熟练应对种种局限；现在，我们把握着未来的可能。</p>
</blockquote>
<h3 id="单词-3"><a href="#单词-3" class="headerlink" title="单词"></a>单词</h3><ul>
<li>upside</li>
<li>possibility</li>
<li>authority</li>
</ul>
<h3 id="词组-3"><a href="#词组-3" class="headerlink" title="词组"></a>词组</h3><ul>
<li>be expert in ..</li>
<li>become authorities of what is possible</li>
</ul>
<h2 id="Sentence-35"><a href="#Sentence-35" class="headerlink" title="Sentence 35"></a>Sentence 35</h2><p><em>If people in the network just two degrees removed from the initial influential prove resistant, for example, the cascade of change won’t propagate very far or affect many people.</em></p>
<blockquote>
<p>例如，如果网络中与最初的影响者只有两度之差的人被证明是有抵抗力的，那么这一连串的变化不会传播得很远，也不会影响很多人。</p>
</blockquote>
<h3 id="单词-4"><a href="#单词-4" class="headerlink" title="单词"></a>单词</h3><ul>
<li>cascade</li>
<li>propagate  传播</li>
<li>resistant</li>
</ul>
<h3 id="词组-4"><a href="#词组-4" class="headerlink" title="词组"></a>词组</h3><ul>
<li>the cascade of change</li>
<li>prove resistant</li>
<li>two degrees removed from</li>
</ul>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>考研英语100句</tag>
      </tags>
  </entry>
  <entry>
    <title>考研英语100句Day8</title>
    <url>/2022/09/05/05/</url>
    <content><![CDATA[<h1 id="考研英语100句–Day8"><a href="#考研英语100句–Day8" class="headerlink" title="考研英语100句–Day8"></a>考研英语100句–Day8</h1><h2 id="Sentence-36"><a href="#Sentence-36" class="headerlink" title="Sentence 36"></a>Sentence 36</h2><p><em>In a workplace that’s fundamentally indifferent to your life and its meaning, office speak can help you figure out how you relate to your work—and how your work defines who you are.</em></p>
<blockquote>
<p>在一个根本不关心你的生活及其意义的职场中，办公室用语能帮助你理清自己和工作的关系，以及工作对你的身份的定义。</p>
</blockquote>
<h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><ul>
<li>fundamentally</li>
</ul>
<h3 id="词组"><a href="#词组" class="headerlink" title="词组"></a>词组</h3><ul>
<li>is indifferent to your life and its meaning</li>
<li>figure out</li>
<li>how you relate to your work</li>
</ul>
<h2 id="Sentence-37"><a href="#Sentence-37" class="headerlink" title="Sentence 37"></a>Sentence 37</h2><p><em>Conversations are links, which means when you have a conversation with a new person a link gets formed and every conversation you have after that moment will strengthen the link.</em></p>
<blockquote>
<p>交谈是一种联系，这意味着当你和一个刚认识的人交谈时，一种联系就形成了，而在那之后的每一次交谈都会强化这一联系。</p>
</blockquote>
<h3 id="单词-1"><a href="#单词-1" class="headerlink" title="单词"></a>单词</h3><ul>
<li>strengthen</li>
</ul>
<h3 id="词组-1"><a href="#词组-1" class="headerlink" title="词组"></a>词组</h3><ul>
<li>which means ..</li>
<li>have a conversation with a new person</li>
<li>a link gets formed</li>
<li>strengthen the link</li>
</ul>
<h2 id="Sentence-38"><a href="#Sentence-38" class="headerlink" title="Sentence 38"></a>Sentence 38</h2><p><em>Researchers measured people’s cortisol, which is a stress marker, while they were at work and while they were at home and found it higher at what is supposed to be a place of refuge.</em></p>
<blockquote>
<p>研究人员测量了人们在工作和在家时的皮质醇，它是一种压力标志，并发现在家这个理应是庇护所的地方，人们的皮质醇水平更高。</p>
</blockquote>
<h3 id="单词-2"><a href="#单词-2" class="headerlink" title="单词"></a>单词</h3><ul>
<li>measure</li>
<li>cortisol</li>
<li>refuge</li>
</ul>
<h3 id="词组-2"><a href="#词组-2" class="headerlink" title="词组"></a>词组</h3><ul>
<li>a stress marker</li>
<li>what is supposed to be</li>
<li>a place of refuge</li>
</ul>
<h2 id="Sentence-39"><a href="#Sentence-39" class="headerlink" title="Sentence 39"></a>Sentence 39</h2><p><em>While Washington and Jefferson privately expressed distaste for slavery, they also understood that it was part of the political and economic bedrock of the country they helped to create.</em></p>
<blockquote>
<p>尽管华盛顿和杰斐逊私下都表达过对奴隶制的不满，但是他们也明白，奴隶制是他们帮助创建的这个国家的政治和经济基础的一部分。</p>
</blockquote>
<h3 id="单词-3"><a href="#单词-3" class="headerlink" title="单词"></a>单词</h3><ul>
<li>privately</li>
<li>express</li>
<li>distaste</li>
<li>slavery</li>
<li>political</li>
<li>economic</li>
<li>bedrock  基石</li>
</ul>
<h3 id="词组-3"><a href="#词组-3" class="headerlink" title="词组"></a>词组</h3><ul>
<li>it is part of the political bedrock</li>
<li>privately expressed distaste for ..</li>
</ul>
<h2 id="Sentence-40"><a href="#Sentence-40" class="headerlink" title="Sentence 40"></a>Sentence 40</h2><p><em>When younger kids learn computer science, they learn that it’s not just a confusing, endless string of letters and numbers—but a tool to build apps, or create artwork, or test hypotheses.</em></p>
<blockquote>
<p>当小孩子们学习计算机科学的时候，他们会发现它并不仅仅是一串令人困惑的、无穷无尽的字母和数字——它还是一种工具，这种工具能编写应用程序、创作艺术作品或测试假设。</p>
</blockquote>
<h3 id="单词-4"><a href="#单词-4" class="headerlink" title="单词"></a>单词</h3><ul>
<li>confusing</li>
<li>hypotheses</li>
</ul>
<h3 id="词组-4"><a href="#词组-4" class="headerlink" title="词组"></a>词组</h3><ul>
<li>a tool to build apps</li>
<li>test hypotheses</li>
</ul>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>考研英语100句</tag>
      </tags>
  </entry>
  <entry>
    <title>考研英语100句Day9</title>
    <url>/2022/09/05/15/</url>
    <content><![CDATA[<h1 id="考研英语100句–Day9"><a href="#考研英语100句–Day9" class="headerlink" title="考研英语100句–Day9"></a>考研英语100句–Day9</h1><h2 id="Sentence-41"><a href="#Sentence-41" class="headerlink" title="Sentence 41"></a>Sentence 41</h2><p><em>The Industrial Revolution didn’t go so well for Luddites whose jobs were displaced by mechanized looms, but it eventually raised living standards and created more jobs than it destroyed.</em></p>
<blockquote>
<p>尽管工业革命在工作被机械化织布机取代的卢德派分子中进展并不顺利，但它最终提高了生活水平，并创造了比被它摧毁的工作岗位更多的就业机会。</p>
</blockquote>
<h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><ul>
<li>mechanized</li>
</ul>
<h3 id="词组"><a href="#词组" class="headerlink" title="词组"></a>词组</h3><ul>
<li>the Industrial Revolution</li>
<li>go well for ..</li>
<li>be displaced by ..</li>
<li>living standards</li>
</ul>
<h2 id="Sentence-42"><a href="#Sentence-42" class="headerlink" title="Sentence 42"></a>Sentence 42</h2><p><em>That ruling produced an explosion in business-method patent filings, initially by emerging internet companies trying to stake out exclusive rights to specific types of online transactions.</em></p>
<blockquote>
<p>那项裁决使得商业方法专利申请文件数量激增，起初只是一些新兴的网络公司试图抢占对某些特定类型的在线交易方法的独家专有权。</p>
</blockquote>
<h3 id="单词-1"><a href="#单词-1" class="headerlink" title="单词"></a>单词</h3><ul>
<li>explosion</li>
<li>ruling</li>
<li>patent</li>
<li>transaction</li>
<li>exclusive</li>
</ul>
<h3 id="词组-1"><a href="#词组-1" class="headerlink" title="词组"></a>词组</h3><ul>
<li>produce an explosion in ..</li>
<li>patent filings</li>
<li>emerging companies</li>
<li>stake out exclusive rights</li>
<li>specific types of online transactions</li>
</ul>
<h2 id="Sentence-43"><a href="#Sentence-43" class="headerlink" title="Sentence 43"></a>Sentence 43</h2><p><em>Even though there is plenty of evidence that the quality of the teachers is the most important variable, teachers’ unions have fought against getting rid of bad ones and promoting good ones.</em></p>
<blockquote>
<p>虽然有充分的证据表明，教师素质是最重要的可变因素，但是教师工会却反对开除差教师、提拔好教师。</p>
</blockquote>
<h3 id="单词-2"><a href="#单词-2" class="headerlink" title="单词"></a>单词</h3><ul>
<li>evidence</li>
<li>quality</li>
<li>promote</li>
</ul>
<h3 id="词组-2"><a href="#词组-2" class="headerlink" title="词组"></a>词组</h3><ul>
<li>there is plenty of evidence that ..</li>
<li>the quality of the teachers</li>
<li>the most important variable</li>
<li>get rid of ..  开除</li>
<li>fight against</li>
</ul>
<h2 id="Sentence-44"><a href="#Sentence-44" class="headerlink" title="Sentence 44"></a>Sentence 44</h2><p><em>Yet most ancestry testing only considers a single lineage, either the Y chromosome inherited through men in a father’s line or mitochondrial DNA, which is passed down only from mothers.</em></p>
<blockquote>
<p>然而，大多数血统检测只考虑单一的血统，要么只考虑来自父亲的男性遗传的Y 染色体，要么只考虑从母亲那里遗传的线粒体DNA。</p>
</blockquote>
<h3 id="单词-3"><a href="#单词-3" class="headerlink" title="单词"></a>单词</h3><ul>
<li>ancestry</li>
<li>lineage</li>
<li>chromosome</li>
<li>inherit</li>
<li>mitochondrial</li>
</ul>
<h3 id="词组-3"><a href="#词组-3" class="headerlink" title="词组"></a>词组</h3><ul>
<li>ancestry testing</li>
<li>pass down</li>
</ul>
<h2 id="Sentence-45"><a href="#Sentence-45" class="headerlink" title="Sentence 45"></a>Sentence 45</h2><p><em>Moreover, even though humans have been upright for millions of years, our feet and back continue to struggle with bipedal posture and cannot easily withstand repeated strain imposed by oversize limbs.</em></p>
<blockquote>
<p>此外，尽管人类直立行走已达数百万年之久，但是我们的双脚和背部仍然在与两足行走的姿势作斗争，并且很难承受过长的四肢施加的持续压力。</p>
</blockquote>
<h3 id="单词-4"><a href="#单词-4" class="headerlink" title="单词"></a>单词</h3><ul>
<li>Moreover</li>
<li>struggle</li>
<li>posture</li>
<li>strain</li>
<li>withstand</li>
<li>limbs</li>
</ul>
<h3 id="词组-4"><a href="#词组-4" class="headerlink" title="词组"></a>词组</h3><ul>
<li>even though</li>
<li>continue to</li>
<li>struggle with</li>
<li>imposed by</li>
</ul>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>考研英语100句</tag>
      </tags>
  </entry>
  <entry>
    <title>芯片验证漫游指南0</title>
    <url>/2022/05/06/21/</url>
    <content><![CDATA[<p>本书从结构上分为四个部分，分别是：</p>
<ul>
<li>验证的通识部分（第1章至第6章）： 具备不同经验的读者都可以从中获取验证世界的全貌。<ul>
<li>第1章是对芯片验证的总览；</li>
<li>第2章从各个维度来介绍验证的策略；</li>
<li>第3章描述目前所有的验证方法；</li>
<li>第4章则从验证计划入手介绍如何量化验证；</li>
<li>第5章从验证管理的角度来论述其各个要素；</li>
<li>而第6章则作为进入下一部分（SystemVerilog语言）的准备来介绍验证环境的结构和组件。</li>
</ul>
</li>
<li>SystemVerilog语言部分（第7章至第9章）： 该部分不同于以往的语言类学习书籍，它的重点不在于提供完整的语法要点，而是结合贯穿于本书的设计MCDF来展开实践，带领读者思考如何利用SV的主要特性去构建一个完整的验证环境。因此，该部分是从<ul>
<li>验证环境基础要素学习（第7章）到</li>
<li>基本组件的实现（第8章），再到最后的</li>
<li>环境集成（第9章）。</li>
<li>这一部分对于缺少SV语言基础的读者会有帮助，同时建议参考对照SV语言的标准手册一同学习。对于具备SV经验的读者，阅读这一部分也会帮助其梳理以往容易出错的知识点。</li>
</ul>
</li>
<li>UVM验证方法学部分（第10章至第14章）：通过SV语言部分的学习，读者可以利用MCDF的 SV 轻量级环境来理解验证环境的共性，包括环境的组织、构建、通信和运行。当进入到UVM部分时，建议读者逐章阅读，以此达到循序渐进的效果。  <ul>
<li>第10章带领读者游览UVM世界，了解其重要的各个特性；</li>
<li>第11章则仿照SV的学习步骤，给读者介绍UVM的各个组件和环境构成；</li>
<li>第12章是UVM的TLM通信部分；</li>
<li>第13章是UVM的运行部分，即介绍序列的各种用法；</li>
<li>第14章是平行于UVM结构的部分但又不可或缺，即寄存器模型部分。</li>
<li>从SV部分过渡到UVM部分的读者会在这部分的各章节中有似曾相似识的感觉，因为UVM的主要特性和结构已经在SV部分中有类似的实现，这种连续性有助于将SV与UVM进行特性对比和学习。</li>
</ul>
</li>
<li>高级应用部分（第15章至第18章）： 该部分结合了实际项目和验证潮流，对中高级验证工程师有启示作用。我也希望读者可以从这些部分了解到，语言和方法学是验证的技能基础，但要解决项目的实际需求、提高整体的验证效率和一致性、实现跨平台、跨研发部分的验证平台，还需要做出更多的定制化解决方案。而对于目前还没有令人满意的解决方案的验证难题，我们还需要时间去构想推动新的验证方法和工具。<ul>
<li>第15章给出了如何实现验证平台自动化和测试标准化的方案，适用于大中型公司的验证效率提升；</li>
<li>第16章着眼于目前在标准制定过程中的便携激励标准，介绍了已有的便携激励工具和跨平台的验证结构；</li>
<li>第17章针对SV与UVM同其他语言的接口给予实践指导；</li>
<li>第18章则将一些分散的高级话题给出行业的解决方案。读者可以将这一部分作为工作的指导手册，在将来遇到相关问题时参考。</li>
</ul>
</li>
<li>尽管试图给出动态验证的全貌，但我也不得不遗憾地指出，几个重要内容暂未在本书首版中囊括，包括：从验证计划到功能覆盖率的量化手段和标准，功能覆盖率驱动的智能化收敛验证，断言的应用场景和复用实践，验证IP的开发模式和推广等，未尽的地方只能寄希望于在下一版中补缺，而在那时，验证世界风起云涌，又将出现什么新的技术还未尽可知，且让我们拭目以待吧。</li>
</ul>
]]></content>
      <categories>
        <category>IC验证</category>
      </categories>
      <tags>
        <tag>UVM</tag>
        <tag>System Verilog</tag>
        <tag>IC验证</tag>
      </tags>
  </entry>
  <entry>
    <title>芯片验证漫游指南1芯片验证全视</title>
    <url>/2022/05/06/31/</url>
    <content><![CDATA[<h1 id="1-功能验证简介"><a href="#1-功能验证简介" class="headerlink" title="1 功能验证简介"></a>1 功能验证简介</h1><p>如果你在设计一款处理器，你需要考虑将其拆分成为运算器（算术逻辑运算单元，ALU,Arithmetic Logic Unit）、高速缓冲存储器（Cache）和连接它们的总线（Bus）；如果你在设计一款系统集成芯片（SoC、System-on-Chip），那么它可能包括的子系统包括处理器、片上网络（NoC,Network-on-Chip）、存储器、I&#x2F;O 控制器（例如 USB,PCIe）等。你会发现，随着系统集成度的提高，系统自身的复杂性增加，而且结合实际工程项目来看，系统复杂度的提高对于功能验证的要求是首当其冲的。由于功能验证在芯片全流程中占据关键位置，验证工程师需要充分理解系统验证的全过程，这个过程就是功能验证的生命周期。功能验证在项目的延续中（目前芯片迭代周期越来越短的一个重要原因，就是依靠剪裁以前项目来做快速的芯片设计）得到不断的提升，而这要求验证工程师考虑如何完善验证流程和环境。在本书一开始，路桑将带领读者从芯片开发流程进入，检视芯片验证在整个项目中的作用（见图1.1）。</p>
<p><img src="/2022/05/06/31/%E8%8A%AF%E7%89%87%E7%A1%85%E5%89%8D%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B.png" alt="芯片硅前开发流程"></p>
<p>一般而言，新的芯片项目首先从市场人员与客户沟通开始。市场人员收集客户对芯片的要求（主要包括功能、尺寸、功耗、性能），这些指标被记录在设计结构和产品文档中。随后，客户关心的系统层面功能被系统设计人员按照功能进一步划分为各个独立的子系统。这些子系统如果本身过于庞大，则被划分为<strong>功能模块</strong>，直到被划分出来的尺寸可以被小的设计团队进行硬件实现。硬件设计人员按照芯片的功能模块划分成不同的小组，同时系统设计人员的数目随系统复杂度的升高而增加。在硬件设计过程中，硬件设计工程师将具体的功能描述文本通过逻辑翻译成为硬件描述语言（HDL,Hardware DescriptionLanguage模型），目前广泛使用的HDL语言VHDL和Verilog均被各大EDA（Electronic Design Automation）公司的软件支持。由于SystemVerilog囊括了Verilog语法和更多高级设计属性，其也被用做一种设计语言。</p>
<p>当细分的模块初步完成RTL级（寄存器级别，Register Transistor Level）的设计之后，验证人员要做几项工作来检查设计：</p>
<ul>
<li>设计文件是否正确地按照功能描述文档实施了？</li>
<li>硬件设计人员是否有遗漏掉的边界情况（corner case）？</li>
<li>硬件设计是否足够稳定以处理一些错误情况（error response）？</li>
</ul>
<p>在实际项目中，硬件设计人员和功能验证人员的合作是紧密的，具体表现在：</p>
<ul>
<li>系统设计团队将功能需求（抽象指标）翻译为功能描述（自然语言）之后，硬件设计团队和功能验证团队要围绕功能描述文档分别展开各自的工作。</li>
<li>在设计团队初步实现设计以后，验证团队要搭建验证环境展开各功能点的验证。</li>
<li>当验证环境测试出的结果与预期不符合时，需根据情况区别对待。如果设计与功能描述存在明显不符，验证人员应报告出设计缺陷，同时设计人员应修复设计，这样从验证到设计再转回到验证即完成一个缺陷检测和修正周期；当结果和预期有模糊边界时（例如时序<br>问题、状态机跳转问题），验证人员和设计人员对功能描述的理解可能存在分歧，此时他们应做初步讨论，确定哪一方的理解有偏差。当讨论未决时，双方应找系统设计人员进行“裁决”，以明确设计思想，统一对功能的理解。</li>
</ul>
<p>因此，硬件设计的完成度和缺陷率在设计人员和验证人员的迭代周期中不断得到完善，最终可以达到目标。关于功能验证目标的定义，我们会在1.4节详细讲述。芯片硬件和软件的开发集成过程在图1.2中给出。</p>
<p><img src="/2022/05/06/31/%E8%8A%AF%E7%89%87%E7%A1%AC%E4%BB%B6%E5%92%8C%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91%E9%9B%86%E6%88%90%E8%BF%87%E7%A8%8B.png" alt="芯片硬件和软件的开发集成过程"></p>
<p>功能验证完成后，后端人员（backend）将 RTL 文件综合生成门级网表（gate netlist），同时进行布局布线，最终使物理电路可以在设定的时钟频率上工作。在后端的各种流程中，与验证人员联系紧密的当属<strong>标准延时格式</strong>（SDF,Standard Delay Format）文件，该文件包含门级网表中各个门单元之间的延时信息，它们被用来准确描述物理电路的时序和检查要求。对于功能验证流程，我们所说的仿真可以<br>根据项目的实施流程将其划分为<strong>前端仿真和后端仿真</strong>：</p>
<ul>
<li>前端仿真指的是进行 RTL 仿真，在这种仿真中是<strong>没有真实延时情况</strong>的。对于一个寄存器（register），它的输出端（Q port）相对时钟输入端（Clk port）的延时为零延时（delta delay）。</li>
<li>后端仿真指的是进行<strong>门级（gate level）仿真</strong>。在实际项目中，由于后端SDF文件本身需要不断迭代（直至满足时钟频率要求），我们进一步将门级仿真划分为<strong>零延时（zero delay）仿真、单位延时（unit delay）仿真和SDF仿真</strong>。<ul>
<li>零延时仿真<strong>只有门级网表参与仿真</strong>，没有SDF文件来具体反向标注（back annotation）门级延时情况，所以门之间的延时仍然为零延时。这时门级零延时仿真与 RTL 仿真的区别仅在于前者是后者的逻辑映射，从寄存器级别到门级的逻辑转译，这一步是由后端的综合工具（synthesis tooling）完成的。</li>
<li>单位延时仿真类似于零延时仿真，也没有 SDF 输入，而是将各个单元门之间的路径延时和门内的延时都以单位延时计算，以此<strong>模拟时序的叠加</strong>，但并不准确，依然无法反映实际物理时序。此仿真同零延时仿真一样，<strong>只可用作逻辑实现检查，无法检查物理时序</strong>。</li>
<li>后端产生出SDF文件时，我们将门级网表反向标注上SDF文件中包含的时序信息，最终进行真实延时电路的仿真。</li>
</ul>
</li>
</ul>
<p>从验证完整性而言，前端仿真和后端仿真均需要在项目中实施，但它们侧重的目标有所不同。<strong>前端仿真是为了检测出功能逻辑的缺陷，而后端仿真是为了检测出门级电路由延迟导致采样失败所产生的功能缺陷</strong>。</p>
<p>因此，验证人员不能将前端仿真的功能缺陷检测任务下移到后端仿真阶段。就效率而言，前端仿真要显著高于后端仿真。同时，后端仿真之所以不能忽略，是因为它可以协助后端人员测试出实际生成电路中是否存在时序不满足的问题。</p>
<p>完成后端仿真以后，我们将后端生成的标准格式文件最终交付给芯片生产商进行流片（tape out）。从上面的描述来看，这是一颗完整的芯片从<strong>定义、分块、设计、验证和后端的硅前（pre-silicon）流程</strong>。</p>
<p>同时，芯片在流片以后所面临的硅后流程（post-silicon）也是一个完整的周期，包括组件测试、驱动、系统固件和应用软件编写，等等。由于功能验证处在硅前流程中，我们在这里主要阐述该流程，<br>同时将一些相对独立的部分略去（这并不代表它们不重要），例如，可测试性设计（DFT,Design For Test）。设计和验证团队协同工作示意于图1.3中。</p>
<p><img src="/2022/05/06/31/%E8%AE%BE%E8%AE%A1%E5%92%8C%E9%AA%8C%E8%AF%81%E5%9B%A2%E9%98%9F%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="设计和验证团队协同工作流程"></p>
<h1 id="2-验证的处境"><a href="#2-验证的处境" class="headerlink" title="2 验证的处境"></a>2 验证的处境</h1><h2 id="2-1-验证语言的发展"><a href="#2-1-验证语言的发展" class="headerlink" title="2.1 验证语言的发展"></a>2.1 验证语言的发展</h2><p>简单而言，验证的目标就是<strong>在一定的时间内尽可能多地测试硬件设计</strong>，发现设计缺陷并报告出来。同时，验证本身也是一项棘手的挑战，这一点可以从语言发展和各种快速发展的EDA工具上得到佐证。</p>
<p>我们从VHDL的语言发展线路来看，它的标准IEEE Std 1076-1987逐步经历了1076-1993,1076-2002再到1076-2008，这中间的年份从1987年逐步发展到2008年，可是我们真正在使用的设计标准是哪一部分呢？可能超过90%以上的设计都基于1076-1987和1076-1993，这是将近20年之前的标准，可是设计人员用它来描述电路已经足够了。因为设计面临的问题不是语言自身的局限，更多的是设计人员的经验和思想。</p>
<p>同样，我们看看Verilog语言的发展从IEEE Std 1364-1995到1364-2001再到1364-2005。目前我们所使用的Verilog代码也基本是在遵循1364-2001的标准，EDA工具商也主要在支持这一年份标准。</p>
<p>再来看看目前的主流验证语言SystemVerilog的发展情况，如果不考虑它之前在Accellera坐板凳的日子，它正式被认定位IEEE Std 1800-2005是从2005年才开始的！可我们看看它在这10年中便经历了1800-2009和1800-2012，更重要的是，<strong>它的每一次更新都得到了工具商的及时支持</strong>。为什么呢？因为实际验证的需要，绝对需要。</p>
<h2 id="2-2-验证面临的挑战"><a href="#2-2-验证面临的挑战" class="headerlink" title="2.2 验证面临的挑战"></a>2.2 验证面临的挑战</h2><p>随着芯片自身复杂度的日渐提高，以及一直存在的项目进度压力，如何实现验证的完整性和高效性成一个大家都关注的话题。概括来讲，验证目前面临的两大挑战是：</p>
<ul>
<li>如何穷尽所有可能的情况给设计产生激励。</li>
<li>如何在各种可能的激励情况下判断出不符合硬件描述的行为并报告出来。</li>
</ul>
<p>我们先看看第一个挑战——如何穷尽所有可能的情况。在这里以手机屏幕显示为例，假设手机屏幕分辨率是1920×1080，像素点的色彩值是232，同时，每个像素点之间的状态是独立的，那么屏幕可能分布的状态应该是：232×（1920×1080）&#x3D;8 906 044 184 985 600</p>
<p>如果再考虑到像素点色彩值的变化，那么在连续两个时钟下，像素点可能发生的状态跳转空间是：232×（1920×1080）×232×（1920×1080）&#x3D;7.9×1031<br>这仅仅是屏幕色彩的一个基本功能，而可以预见到的状态空间数目足以让人抓狂。所以，面对这样的挑战，我们需要<strong>作出一些平衡，这种平衡来自于状态空间本身的庞大和项目实施中的进度压力</strong>。如何<strong>划分出有效的测试空间、如何给出随机约束激励</strong>是验证人员需要具备的职业素质。</p>
<p>接下来我们看看第二个挑战，如何在各种可能的激励下判断出硬件设计的缺陷。首先把常见的硬件设计划分为如表1.1所示的几类，同时再看看针对不同设计的激励输入类型和结果判断的方法。</p>
<p><img src="/2022/05/06/31/%E4%B8%8D%E5%90%8C%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%BF%80%E5%8A%B1%E8%BE%93%E5%85%A5%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%BB%93%E6%9E%9C%E6%AF%94%E5%AF%B9%E6%96%B9%E6%B3%95.png" alt="不同设计的激励输入类型和结果比对方法"></p>
<p>从表1.1可以发现，不同类型的设计需要产生的激励类型和结果比对方法是不一样的。针对不同类型、不同复杂度、不同集成度的设计，应采用不同的验证方法。从验证工具的分类看，可以将其<strong>分为仿真验证和形式验证</strong>；从复杂度出发，可以划分为<strong>黑盒验证、白盒验证以及灰盒验证</strong>。关于验证的方式以及合适的运用场景，我们也会在第2章里面展开详细讨论。</p>
<h1 id="3-验证能力的5个维度"><a href="#3-验证能力的5个维度" class="headerlink" title="3 验证能力的5个维度"></a>3 验证能力的5个维度</h1><p>列出验证人员需要具备的5个能力维度：</p>
<ol>
<li>完备性</li>
<li>复用性</li>
<li>高效性</li>
<li>高产出</li>
<li>代码性能</li>
</ol>
<h2 id="3-1-完备性"><a href="#3-1-完备性" class="headerlink" title="3.1 完备性"></a>3.1 完备性</h2><p>完备性要求<strong>验证的充分</strong>。然而，充分一词对于验证而言边界是模糊的，很难量化到什么时候才可以达到完成验证的标准。所以，作为一名验证经理，需要引入各种数据来综合量化出验证的进度，其中<strong>包括验证功能点的覆盖率、代码覆盖率、是否经过效能验证流程（power aware verification）、是否经过跨时钟域（clock domain crossing）检查</strong>等。</p>
<p>通过数据量化，验证人员和验证经理更有信心来宣布在某一个项目节点中，设计已经得到“充分”的验证。当然，对于功能覆盖率部分，如何将功能描述文档充分理解，进而列出要测试的功能点并尽可能地细分出来，这需要系统人员、设计人员和验证人员的共同努力。同时，将抽象的验证计划转换到功能覆盖率要求验证人员具备这样的能力。</p>
<h2 id="3-2-复用性"><a href="#3-2-复用性" class="headerlink" title="3.2 复用性"></a>3.2 复用性</h2><p>从项目的实际运用角度看，复用性和完备性是同等重要的。没有人愿意在下一个项目中将以前的验证环境做较大的更新，因为这意味着额外的资源消耗，包括时间、人力和项目进度的考虑。</p>
<p>在硬件设计角度而言，通过<strong>标准总线协议</strong>，可以最大限度地在模块之间实现相对独立和快速集成。对于目前项目周期不断缩短的现状来看，一方面是市场的瞬息万变导致的，一方面也是由于SoC自身趋向于软件的周期迭代方式而形成的。对于一个系列芯片而言，后续芯片的<strong>性能提高、功耗优化</strong>都是建立在前一代的基础上的。而这些不断的提高和优化具体到每一个硬件子系统而言，可能就是它们的存储大小、时钟快慢、动态电源开关、总线宽度、缓存深度来综合决定的，并且下一代硬件设计自身一般不会有第一代芯片的艰难历程（否则也就称不上是系列芯片了）。</p>
<p>那么从硬件设计的角度看，这些更新如果不在逻辑上面有大的变动，那么带来的工作量是可以估计的。而从验证角度看，我们很自然地希望验证的工作量不要太大——可事实并不一定是这样的。首先从芯片项目的人员安排看，验证人员相比于设计人员流动性更高。那么当一个验证人员在尝试维护和修改上一个项目的验证代码时，就要看他的“运气”，而他的运气与上一个验证人员的代码风格有直接关系。因此，如何标准化验证环境和测试规范，成为验证复用性的一个重要考量。同时，验证人员在处理一些总线协议时要有意识引入参数来为日后的复用做好准备。不断融合的验证方法学走到今天，UVM（Universal Verification Methodology）之所以划分出不同的功能组件，实现小的颗粒度，提供快速插拔式的环境集成能力，也是从复用性考虑的。</p>
<h2 id="3-3-高效性"><a href="#3-3-高效性" class="headerlink" title="3.3 高效性"></a>3.3 高效性</h2><p>高效性指的是用尽可能少的工作量完成验证工作。在保证验证完备性的考虑下，实际上<strong>复用性和高效性会有存在冲突的可能</strong>。例如，验证人员会考虑如何“短平快”地在一个紧张周期内完成验证工作，但他可能不会采用UVM等方法学框架，也有可能不会考虑将参数引入到验证环境中。因为这些“额外”的因素虽然对复用性有帮助，但与高效性冲突（费时）。所以，验证人员需要针对不同的情况在维度之间做好平衡，至少需要保持一种意识，那就是工程学的执行阶段本身就是一种平衡。对于验证人员来讲，他需要做出的判断就是在每一个项目的验证任务中做好取舍，给出合适的验证考量综合维度。对于同一项验证任务而言，采取不同的验证策略有不同的验证效果。例如，一开始考虑采用随机约束的验证方法，那么单单就约束而言，它的约束一开始是比较窄合适，还是一开始比较宽合适？</p>
<p>这里我们给出图1.5来说明高效性在一项验证任务的不同周期需要有相应的变化。在开始阶段，考虑到设计不够完备且尚未经历过验证，我们将其称为<strong>基本功能验证阶段</strong>。这个阶段，我们将随机约束域降低到基本范围，尽可能少地触碰到边界情况，把重点放到如何先将各项基本功能都验证到。第二个阶段是在已经完成基本功能验证以后开始的<strong>完备功能验证阶段</strong>，这时可以逐渐放开随机约束域，而开放的域范围需要验证人员考虑到各种合理的情形再做限定。到了功能覆盖率一般上升到80%附近时，就处于<strong>最后的爬坡阶段</strong>。这时，再沿用之前广泛的约束域就会产生很多无效的随机种子，这些“无效”的随机种子对于剩下的验证覆盖率几乎没有什么帮助。这时，验证人员需要通过理解设计本身和随机约束两方面来考虑具体贡献覆盖率的测试序列，再进一步缩窄随机约束域，偏置（biasing）产生一些激励。对于最后这一阶段，一种极端的情况就是将随机约束域缩到尽可能地窄，甚至和<strong>定向测试</strong>（directed test）没有什么区别。</p>
<p><img src="/2022/05/06/31/%E9%9A%8F%E6%9C%BA%E7%BA%A6%E6%9D%9F%E5%9F%9F%E4%B8%8E%E5%8A%9F%E8%83%BD%E8%A6%86%E7%9B%96%E7%8E%87%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="随机约束域与功能覆盖率的关系"></p>
<h2 id="3-4-高产出"><a href="#3-4-高产出" class="headerlink" title="3.4 高产出"></a>3.4 高产出</h2><p>高产出指的是在一定的时间，能够调试、报告、帮助修正出多少设计缺陷，以及如何建立完整的验证环境。多年来，数字设计（RTL级别）的基础并没有发生太多变化，同时EDA厂商提供的自动化工具又进一步提高了设计的可靠性。但这一情况却并不适用于数字验证，因为EDA工具目前仍然只能作为辅助手段（例如提供更多的调试功能和接口），却不能帮助自动化建立复杂的验证环境。这也就不难解释2017年IC行业功能验证领域的调查数据显示，当前在设计和验证领域面临着最大的挑战之一就是为快速的芯片产品迭代和员工数量增长之间找到一个平衡点，实现单位产出的提高。</p>
<h2 id="3-5-代码性能"><a href="#3-5-代码性能" class="headerlink" title="3.5 代码性能"></a>3.5 代码性能</h2><p>代码性能似乎也跟高效性、高产出有冲突的地方。因为验证代码的整洁性、复用性甚至一点点的美感都与验证完备性没有直接联系。这也包括你的验证经理可能有好长时间都不会注意到你写的验证代码，除非有一天你验证的那个设计出了一个缺陷，而且是一个显而易见的缺陷却没有被发现，才会引起验证经理的注意并专门来回顾可能是一团糟的代码结构。每一位验证人员需要记住一句台词“出来混，迟早是要还的”。不管是别人的验证代码中存在着没有注释、没有缩进、超长函数等不良问题，还是你因为项目紧张，在快速搭建验证环境和编写测试用例时没有考虑到“后来阅读者”和“你后来阅读”而偷的各种懒。相信我，时间会让你为此买单的。所以，作为一名验证人员，请你在写每一行代码时把它当做你日后行业名声的荣誉墙。尽管你迫于项目的压力需要快速建立环境疲于完成验证计划，但等到你闲时会去改善那些代码吗？不要再相信这些鬼话了，现在就去做吧！</p>
<p>从上面的5个维度来看，做一名合格的验证人员实属不易，更不要说考虑到每一项验证任务量体裁衣制定出合适的5个维度指数。虽然项目执行没有尽善尽美，但针对验证人员自身，如果可以意识到这5个维度的存在，并且能够在实际工作中综合考量它们，那你就是有意识地在培养自己成为一名优秀的验证师了。</p>
<h1 id="4-验证的任务和目标"><a href="#4-验证的任务和目标" class="headerlink" title="4 验证的任务和目标"></a>4 验证的任务和目标</h1><p>验证师的工作就是完成分配给他的任务，这个任务可能是模块级（module level）、子系统级（subsystem level）或者系统级（chip level）的。准确来讲，验证的目标就是“按时保质低耗完成”目标硬件设计的验证工作，这句话实际也包含了要完成验证目标需要考虑到的三个方面。</p>
<ul>
<li>按时保质低耗<ul>
<li>按时<ul>
<li><blockquote>
<p>验证师需要按照项目预先的进度来考虑验证的节点（milestone），在项目开始时就将节点记挂在心上。之前提到的验证师的5个能力维度，在面对项目进度时，也需要考虑哪个维度为主、哪个维度为辅。例如，硬件设计的验证计划、验证环境的复杂度和复用性、大概需要用多少测试用例来尽快达到验证工作量的80%，这些都是要与项目进度一同考虑的。要知道“一个都不能少”在芯片流程中的重要性，没有一款芯片可以因为其中一个模块的验证延迟而有信心去流片。所以，整支验证队伍自上到下，覆盖到各个模块的验证师都应该有这种意识：即，无论何时，时间总是第一位的，时间就意味着客户的耐心和市场的窗口。</p>
</blockquote>
</li>
</ul>
</li>
<li>保质<ul>
<li><blockquote>
<p>保质指的是尽可能少地将缺陷暴露在流片以后，至少要尽可能少地暴露在客户和市场面前。因为从成本的角度看，缺陷暴露在不同的阶段造成的损失有指数级的差别。如果芯片交付给客户以后才被反馈出一些大的缺陷，那么芯片设计方就会背负很大的压力，除了要同客户一起进行高密度的对话、联调外，整个产品链都要为这个缺陷付出更大的人力、物力成本；如果芯片是在客户方通过测试却被市场发现自身性能不如预期的话，那么会对芯片设计公司和客户双方都造成消极的影响，无论是在市场反馈还是用户对品牌的认知度上，都是如此。</p>
</blockquote>
</li>
</ul>
</li>
<li>低耗<ul>
<li><blockquote>
<p>低消耗有两方面，用更短的时间、更少的人力来完成芯片设计任务，这是一笔前期看得见的可以预期控制的成本；同时，也有一些成本是突发的，其中一个就是缺陷的暴露问题。从图1.6可以看出，暴露在不同研发阶段的缺陷对芯片项目造成的额外成本是随着项目进程指数级递增。</p>
</blockquote>
</li>
<li><img src="/2022/05/06/31/%E5%9C%A8%E4%B8%8D%E5%90%8C%E9%98%B6%E6%AE%B5%E5%8F%91%E7%8E%B0%E8%AE%BE%E8%AE%A1%E7%BC%BA%E9%99%B7%E6%89%80%E5%AF%BC%E8%87%B4%E7%9A%84%E9%A2%9D%E5%A4%96%E6%88%90%E6%9C%AC%E6%9B%B2%E7%BA%BF.png" alt="在不同阶段发现设计缺陷所导致的额外成本曲线"></li>
<li><blockquote>
<p>硅前验证中RTL验证发现的缺陷带来的影响要明显小于Gate验证中带来的影响。因为RTL阶段发现的缺陷，只需要修改RTL代码，而Gate验证发现的缺陷除了需要同时做RTL修改和网表修改，更是要后端一系列流程的反复。如果在硅后测试中发现了缺陷，就需要考虑这个缺陷是不是致命的。所谓致命的，就是它无法使用一些重要功能，甚至本身会导致一些重要功能的失效和错误行为，且没有办法通过软件层面来做修复。这样的致命性缺陷就意味着芯片要做第二次流片，要针对致命缺陷做出修复、功能验证、后端流程，这样的过程通常耗时三个月以上。如果一个致命缺陷等到被交付给客户以后才发现，那么造成的损失则是双方的。对于客户来讲，他们需要为这个致命缺陷吞下产品延迟上市的苦酒；而对于芯片公司来讲，恐怕这可能是双方最后一次合作了。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>芯片研发与客户反馈<ul>
<li><blockquote>
<p>进一步来看，如果我们将硅前流程、硅后流程同客户反馈联系在一起（见图1.7），就能对芯片流程有一个更清晰的认识。从图1.7可以发现，芯片在出片以后被检测出的严重缺陷会直接导致芯片的二次流片，这对成本控制而言是一种额外的损失，同时将时间和人力资源消耗在本可以避免的二次流片上。所以，功能验证是唯一可以用低成本在硅前流程将上述目标“按时、保质、低耗”达成的方法。也正因如此，对于功能验证而言，验证经理通过量化的方式来衡量验证产出的进度。用来衡量的两个标准，一个是时间，一个是发现的缺陷数量。</p>
</blockquote>
</li>
<li><img src="/2022/05/06/31/%E8%8A%AF%E7%89%87%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%A2%E6%88%B7%E5%8F%8D%E9%A6%88%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png"></li>
</ul>
</li>
<li>缺陷增长曲线<ul>
<li><blockquote>
<p>通过缺陷数量在时间线上的记录，我们可以绘制出缺陷数量的增长曲线，如图1.8所示。</p>
</blockquote>
</li>
<li><img src="/2022/05/06/31/%E7%BC%BA%E9%99%B7%E6%95%B0%E9%87%8F%E7%9A%84%E5%A2%9E%E9%95%BF%E6%9B%B2%E7%BA%BF.png"></li>
<li><blockquote>
<p>一般来讲，缺陷数量的增长曲线是逐渐逼近趋于缓慢的。功能验证需要保证的是将缺陷数量的增值（至少是致命缺陷数量）保证在硅前阶段，不应该让其发生在硅后测试阶段。针对缺陷的类型，我们一般遵循先易后难的验证方法，这表现在两个方面：</p>
</blockquote>
<ul>
<li>我们给出的激励向量应该是先易后难，先从简单的激励向量测试设计的基本功能，这一点我们在1.3节提到随机约束域的宽窄设定和验证阶段之间的关系。当验证将基本功能测试完毕后，我们再朝着更复杂的情景着手去测试其他功能。</li>
<li>我们查找出的缺陷也应该是先基本后高级。这么做有两方面的好处，当开始的激励向量是基本形态的时，有助于设计本身在缺陷报告反馈中逐步稳定，同时留出一定的时间用来帮助设计师和验证师针对设计细节交换意见，在硬件描述上面统一理解。</li>
</ul>
</li>
<li>这种缓冲会使得在其后的复杂测试中，设计师和验证师双方就复杂情形中的硬件输出结果快速达成一致，因为之前已经就功能描述达成一致了。对于验证师而言，这么做也符合验证的曲线，也就是前期的缺陷曲线斜率较高，是因为设计本身容易被发现一些基本设计问题；随着验证周期的进展，缺陷曲线率慢慢减小，说明设计自身的稳定和功能完备情况趋于最终的设计目标。</li>
<li>对于验证经理，如果有追踪缺陷率曲线的习惯，那么一般建议检查两个地方：<ul>
<li>缺陷率曲线是否在收敛，或者斜率是否在变小，这一定程度上可以说明验证的状态是否在收敛和趋于完备。</li>
<li>需要注意验证过程中发现的缺陷种类，应从基本缺陷再到高级缺陷。假如到了后期，尽管缺陷率收敛，却发现了基本缺陷，这时应对整个验证质量打一个问号。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>有必要的话，同验证师一起回顾验证计划、验证环境和测试序列。因为越到后期越不应该发现基本类型的缺陷，否则验证经理无法对于整个验证任务的完成有足够的信心。</p>
<h1 id="5-验证的周期"><a href="#5-验证的周期" class="headerlink" title="5 验证的周期"></a>5 验证的周期</h1><h2 id="5-1-验证周期中的检查点"><a href="#5-1-验证周期中的检查点" class="headerlink" title="5.1 验证周期中的检查点"></a>5.1 验证周期中的检查点</h2><p>功能验证有着一整套完备的流程，从硬件系统定义贯穿到硅后测试部分。一般来讲，验证团队会基于时间差同时进行多个项目，多个项目之间自然也存在着借鉴、更新的关系，所以验证的环境和复用性也是在不断提高的。每一个项目在进行瀑布模式开发时，验证团队也<br>会在细分的流程中完成任务，同时在展开下一项任务之前进行一些重要检查点（checkpoint）的回顾工作。验证人员不断地在新项目中完善验证环境，验证的周期因而也是不断往复、螺旋上升的过程。</p>
<p>图1.9将功能验证的各个关键节点罗列并使之成为一个周期。<strong>验证周期的起始点从创建验证计划开始，验证计划需要参照系统工程师给出的功能详述文档。接着验证人员开发验证环境，在创建验证环境的过程中，验证人员一般会邀请设计人员和系统人员一同回顾验证计划，确保验证计划没有明显的遗漏，所以验证计划的回顾是第一个检查点</strong>。</p>
<p><img src="/2022/05/06/31/%E5%8A%9F%E8%83%BD%E9%AA%8C%E8%AF%81%E7%9A%84%E5%AE%8C%E5%A4%87%E5%91%A8%E6%9C%9F.png"></p>
<p>验证环境准备完毕且有一些可供测试的激励时，验证人员会比对设计的输出结果。如果发现有比对错误，验证人员首先要自己去调试环境，定位到硬件HDL文件存在缺陷的大致位置。如果验证人员有充分的经验，他还可以进一步给设计人员修改代码的建议。硬件设计经过一定数量的激励测试，验证人员就可以准备回归（regression）测试了。<strong>回归测试就是将已有的所有测试序列都执行一次</strong>。一般来讲，<strong>随机序列的回归测试覆盖率贡献要大于直接序列的回归测试，不过这种优势会随着验证率曲线的增长而变得不那么明显，具体的原因就是随机激励无法给出定向激励来填补剩余的验证空间，而定向测试则可以被有经验的验证人员运用，用来验证边界情况</strong>。在完成回归测试之前，我们需要进行第二个检查点——<strong>验证代码检查</strong>，这一检查点的作用是通过回顾验证代码从而发现可能遗漏的测试激励、不恰当的随机约束、代码结构的缺陷等。</p>
<p>完成回归测试后进行第三个重要的检查点——<strong>流片前验证完备性检查</strong>。一般这项检查是验证经理最后签字的。验证经理根据一份检查清单来将验证进度做量化的综合评定，最后判读是否完成验证的任务。当然，这一过程并非只有在流片前才会评估，而是发生在这一期间内若干阶段，包括<strong>模块验证阶段、子系统验证阶段、芯片系统验证阶段和最后的网表验证阶段</strong>。每一个阶段验证经理都有相应的通过标准和检查清单，判定模块、子系统和最终的芯片系统是否达到验证的目标。</p>
<p>即使在最终流片以后，验证团队也需要和硅后系统测试团队完成对接。这是由于，硅后系统测试阶段才是真正能够判定小到每一个功能模块大到整个芯片系统的各项功能能否正常工作的标准。通常，系统测试团队参考功能验证团队的验证计划，<strong>从底部测试每个模块的功能，逐步向上层走，最终测试整个芯片的联合功能</strong>。在系统测试环节中，如果发生了功能测试失败，系统测试人员与验证人员协作，最终定位到是硬件自身缺陷还是测试中的环境配置，或者是寄存器设置问题。如果最终测试发现了硬件缺陷，那么硬件团队和软件团队也会一起评估该缺陷是否是不可修复的。<strong>针对硅后测试发现缺陷的情况，一般首先考虑是否有软件修复的可能，接下来才考虑硬件上有无变通的办法。</strong>当两方面都无法解决时，我们只能宣告，一个无法硅后修复的缺陷在测试阶段发现了。当然，更糟糕的情况是，这个缺陷竟然是一个致命缺陷。</p>
<p>经过系统测试后，验证团队最终被硅后测试发现的缺陷<strong>展开逃逸分析</strong>，来检讨为什么漏洞会在硅后测试环节中被发现（而不是在硅前验证环节）。</p>
<p>可能引起漏洞在硅前验证阶段逃逸的情况包括：</p>
<ul>
<li>验证计划制定不充分，没有完全覆盖功能验证点。</li>
<li>激励序列生成不完全，没有覆盖全部的有效激励场景。</li>
<li>验证环境不完备，例如比较器（checker&#x2F;scoreboard）没有足够完善去比对输出结果。</li>
</ul>
<p>展开逃逸分析之后，要进行验证周期的最后一项检查——<strong>吸取教训</strong>。吸取教训是一种被动的方式，我们在完成的项目中犯了一些错误，如果不想被同一块石头绊倒两次（没有人会愿意吧），就需要吸取教训。这种被动的方式和主动提高验证效率没有冲突，恰恰是在我们没有考虑到的地方吸取教训，在我们考虑到的地方主动完善，使之成为一种内外结合提高验证质量的方式。</p>
<p>关于吸取教训，在这里我们给出一些建议：</p>
<ul>
<li><strong>请在整个验证周期内保持收集与验证完善相关信息，比如，突发状况以及如何克服，陷阱从哪里来，有哪些遗憾</strong>，等等。之所以这么做，是因为我们通常在项目结束以后会懈怠下来，我们的记忆无法保存事发当时的一些细节，也容易忘掉当时一些心理上的痛苦。所以<br>就像做一份验证记录一样，保持着这样一份完整记录，将来我们可以从中很快地回溯起来我们一路是如何走过的。</li>
<li>除了一些个别情况，验证缺陷的暴露与整个模块验证团队都有关系。因为可能我们一起制定的验证计划不够充分，一起回顾测试序列的时候也不够仔细……要思考团队整体的疏忽在什么地方。每个人都需要考虑到自己在验证周期的不同阶段应该充分履行的责任是什<br>么。</li>
<li>尽量从一些教训中量化今后可以加强的地方。比如，如果功能覆盖率和代码覆盖率的指标是硬性的，那么验证人员就不应该妥协，应想办法达到这个标准；又比如，一些跨时钟域的问题没有被发现或者在网表仿真时才被发现，以后就应该将跨时钟域检查、同步单元检<br>查作为标准在验证过程中执行下去。</li>
</ul>
<h2 id="5-2-功能详述"><a href="#5-2-功能详述" class="headerlink" title="5.2 功能详述"></a>5.2 功能详述</h2><p>对于一个芯片，大到芯片自身，小到可以细分的模块，都需要系统工程师给出功能详述文档。这里以较小颗粒度的模块功能文档为例，看看一个基本大小的模块如何依靠功能文档来实现硬件设计和功能验证。</p>
<p>一份功能文档，通常包含如下几方面的信息：</p>
<ul>
<li>接口信息。是不是标准接口、是标准接口的哪一个版本。如果接口是标准接口，那么功能详述中不需要详尽列出接口的时序信息、命令、数据传输等，而只需给出基本的时钟、复位、接口信号名。对于标准接口，设计人员和验证人员可以下载标准接口文档来更详尽地了解接口信息。如果接口是公司内部定义的接口，则需要参照内部定义的接口文档；如果是自定义接口，由于这种接口没有被规范化，功能文档中应尽可能周全地描述需要给出的信息，以方便日后设计人员和验证人员双方参考。</li>
<li>结构信息。结构信息将模块进一步细分为各个功能组件，以及包含组件之间的逻辑关系。各功能组件对设计人员而言可以匹配出对应的 RTL 文件，其后可以自底向上进行集成；对于验证人员而言，为了尽可能与设计保持同步，验证环境的开发可以同设计组件同步展<br>开。从设计组件A和验证环境VA，再到组件B和验证环境VB，再到组件C和验证环境VC，最后集成出模块M（A+B+C）和验证环境V（VA+VB+VC），就可以完成模块M的集成验证了。</li>
<li>交互信息。由于模块稍后会被集成到更高一级的子系统当中，所以功能详述文档中包含模块 M 同外界模块交互的示意图。必要时，这些交互信号之间也会给出准确的时序信息，确保集成后两个模块之间的交互按照预期定义的时序发生。比如一对握手（handshake）信号，需要指明输入信号的频率、是否需要考虑同步、是电平信号还是脉冲信号、大致维持几个时钟周期，相应的输出信号也要有类似的考量，以满足输出信号接收方的要求。</li>
</ul>
<p>功能详述文档是硬件设计和功能验证的基础部分，也是共同参考依照的标准。设计人员通过自己的理解将其实现成 RTL 文件，而验证人员也按照自己的理解为设计构建出验证环境。尽管看起来验证人员重复了一次功能上的理解，但正也是因为这样，确保了功能描述文件<br>可以被设计和验证双方理解一致。验证人员自己设计的参考模型（reference model）才也会按照功能详述文档做出正确的行为和数据输出。参考模型对应硬件设计，通过结果比对检查是否有不符合预期结果的情况。这种方式可以让功能文档变得易读清晰，降低设计人员误解功能描述和实现错误硬件的可能性。</p>
<h2 id="5-3-制定验证计划"><a href="#5-3-制定验证计划" class="headerlink" title="5.3 制定验证计划"></a>5.3 制定验证计划</h2><p>验证计划是为了完成验证目标的，因此它本身要回答两个问题——<strong>验证对象是谁、如何验证</strong>。制定验证计划的主体在不同公司可能不同，例如，公司A是由系统人员制定验证计划的，而公司B是由验证人员制定验证计划的。不过可以肯定的一点是，最后回顾验证计划<br>时，会将系统人员、设计人员和验证人员组织到一起来回顾，检查可能存在的验证漏洞。验证计划也存在颗粒度，与模块大小、处在系统的层次相关。</p>
<p>这里我们仍然以模块M为例，考虑验证计划中的检查事项：</p>
<ul>
<li><strong>验证方法：是采用直接验证、随机约束验证、形式验证还是其他的方式。</strong></li>
<li>验证工具：选择需要的验证工具来支持验证方法。</li>
<li>验证完备标准：量化出一些参数以衡量验证任务是否完成。</li>
<li>验证资源：包括人力、时间、硬件、软件等所有与项目预算有关的内容。</li>
<li>验证的功能点：需要给出验证的功能点以及在什么层次去验证它，更具体的包括生成何种激励、检查设计的何种状态和数据输出。</li>
</ul>
<h2 id="5-4-开发验证环境"><a href="#5-4-开发验证环境" class="headerlink" title="5.4 开发验证环境"></a>5.4 开发验证环境</h2><p>验证环境的开发是验证人员花费时间较多的部分。<strong>验证人员从搭建环境开始，实现激励产生器（stimulus generator）、参考模型（reference model）和数据比较器（data comparator）</strong>。</p>
<p>验证环境的运行需要软件工具的支持，目前的主流仿真工具均可以对仿真验证提供广泛支持。当然，制定验证计划时需要考虑采取何种验证方法，之后才开发验证环境。不同的验证方法决定不同验证环境的结构和所用的软件。<strong>伴随着设计缺陷的发现和修正，验证环境也需要保持更新，最终同硬件设计一样趋于稳定，进入验证的下一个阶段</strong>。</p>
<h2 id="5-5-调试环境和HDL文件"><a href="#5-5-调试环境和HDL文件" class="headerlink" title="5.5 调试环境和HDL文件"></a>5.5 调试环境和HDL文件</h2><p>验证人员在调试方面的时间投入最多。环境的建立在验证早期投入较多，设计的功能调试却是一步步向前推进的。验证刚开始时，验证人员调试的对象主要集中在环境的协调整合上；环境稳定后，验证人员递交测试，进行仿真验证。针对每一个功能点的验证均需要给出一个或者多个激励向量，在激励给入后，将参考模型和实际输出进行比较，发现比较错误时需要进一步定位问题的源头：</p>
<ul>
<li>环境是否有瑕疵；</li>
<li>测试序列是否合理；</li>
<li>参考模型是否遵循功能详述文档；</li>
<li>硬件设计本身是否存在功能缺陷。</li>
</ul>
<p>定位问题时，一般建议验证人员：</p>
<ol>
<li>先从环境着手，试图去稳定环境部分，因为这一部分是我们可以控制的。</li>
<li>让环境趋于稳定后，我们再去定位问题是否来源于硬件设计。判定设计存在缺陷时，验证人员需要了解设计、定位到缺陷的位置，提交给设计人员并得到反馈。</li>
<li>设计缺陷被修复后，应重复递交同一个测试用例，用例中产生的测试向量也不应该改变。如果使用的是随机约束方式，应记住上一次仿真出错的时间位置和随机种子（random seed），在后面重新递交时采用同一个随机种子以产生同样的测试向量，确保外部激励的场景是一致的。这种方式背后的逻辑是，在调试过程中应尽量减少变量的数量，理想情况下只有一个变量。对于上面的场景，这个变量就是设计缺陷在修复前和修复后的功能表现。</li>
<li>至于如何设定随机种子，在仿真器的用户使用文档中可以找到相应的使用方法和仿真选项。</li>
</ol>
<h2 id="5-6-回归测试"><a href="#5-6-回归测试" class="headerlink" title="5.6 回归测试"></a>5.6 回归测试</h2><p>回归测试指的是验证硬件在某个缺陷修复或添加了某项新功能后，仍然可以通过以前的所有测试用例（test case）和可能添加的新的测试用例。可能存在的环境变化包括硬件设计自身的改进、缺陷修复、功能添加和验证环境的更新。在每次的回归测试中都可能发现新的缺陷、添加新的测试用例或者更新验证环境。</p>
<p>每次回归测试都会帮助完成两个目标：</p>
<ul>
<li>确保这次改动没有引入新的缺陷，并修复了之前的漏洞，或者按照预定目标实现了新的功能。</li>
<li><strong>随机验证在每次递交时默认的随机种子不同，这对重复递交一套回归测试表也是有意义的。</strong>伴随着功能覆盖率，可以通过往复的回归测试和补充的定向测试来将逐步提高验证完备性。</li>
</ul>
<p>当代的回归测试逐步趋向自动化，需要一种合适的回归测试工具协助完成回归测试表的提交、分配到不同的服务器上面以计算量来换取时间的缩短、自动识别仿真的结果、到最后给出验证报告。</p>
<p>这种回归测试工具，可以从 EDA 公司的工具表中找到商业化的产品，同时大中型公司也有适合自己团队工作流程和需求的定制工具。回归测试是实现验证完备性的一项重要手段，因为只有通过将大量测试用例并行提交到服务器群，才可能完成覆盖率的快速上升，满足项目进度的要求。</p>
<h2 id="5-7-芯片生产"><a href="#5-7-芯片生产" class="headerlink" title="5.7 芯片生产"></a>5.7 芯片生产</h2><p>经历过回归测试阶段（RTL 回归和门级网表回归），意味着芯片的逻辑和物理数据都经过各项检查了。在将芯片最后送交给半导体生产商（fabrication facility）之前，项目经理与设计经理、验证经理、后端经理一起回顾整个检查表（checklist），确保所有的标准都已经通过。芯片的数据提交给生产商后，最终制造出来，我们称之为流片（tape-out）。</p>
<p><strong>值得注意的是，此时功能验证的流程并没有全部走完，仍然需要提交回归测试，通过保持不停的随机测试，在新的状态空间上测试，可能发现新的问题</strong>。如果在递交给厂商生产以后发现新的缺陷，要像硅后测试发现的缺陷一样对待。通过分析这些缺陷，考虑是否有软件补救办法，或者提交设计修改意见，在下一次流片前准备好设计方案和验证方案，将其计划到下一次验证周期内。</p>
<h2 id="5-8-硅后系统测试"><a href="#5-8-硅后系统测试" class="headerlink" title="5.8 硅后系统测试"></a>5.8 硅后系统测试</h2><p>芯片返回后，系统测试人员依照系统集成的顺序从底层模块开始测试。测试前，需将芯片同测试开发板结合起来，或将芯片植入到待开发的系统上。随后硅前人员（设计人员、验证人员、系统人员）和硅后人员（测试人员）保持频繁的沟通，一旦测试出了问题，第一时间判断是测试的方法不恰当还是硬件自身的问题。之所以要求硅前人员参与，是因为我们不期望硅后测试出现太多的问题，尤其是致命的缺陷。当一个硬件缺陷被发现之后，硅前人员需要讨论这个缺陷的严重性，从软件层面上讨论可行的补救办法，再从硬件层面看是否有其他办法使能这项功能，或者不使这项缺陷扩大影响面导致重要功能失败。如果最终无法避免这个缺陷，且该缺陷严重影响系统功能，就需要在下个芯片设计周期内去修改和验证这项功能。</p>
<h2 id="5-9-逃逸分析"><a href="#5-9-逃逸分析" class="headerlink" title="5.9 逃逸分析"></a>5.9 逃逸分析</h2><p>有时，我们难以避免个别的验证漏洞一直被忽视，导致它们可以从硅前验证阶段“逃走”，到硅后测试才被发现。遇到这样的情况，硬件设计人员和验证人员都要与测试人员沟通，尝试在硅前的仿真环境中重现遇到的测试失败场景。如果可以复现，设计人员和验证人员要再次思考这个漏洞逃脱的原因；<strong>如果无法复现，则仍旧无法保证硬件做出的更改可以在下次流片后修复这次测试的问题</strong>。这种硅后测试失败要求硅前验证重现的难度，相较于在交给客户之后遇到的应用失败场景还是容易很多的。因为一旦从硬件级别向上堆叠经过驱动层、固件层再到客户的应用层，更加难以在硅前验证环境中重现客户应用失败的场景。作为验证人员，如果你有幸遇到过这样的场景重现和失效点定位的问题，那么想必你会深深记住它的。当逃逸分析完成以后，这一过程会对下一个芯片周期中，设计人员如何规避设计陷阱、验证人员如何完善验证方案、产生尽可能多的有效测试序列都是很有意义的。在整个芯片过程中都贯穿着“吸取教训”四个字，<strong>因为要完成芯片从硅前到硅后的过程本身就很漫长（相比软件的迭代开发而言）。要积累尽可能多的经验，芯片工程师应该在每一个关键节点养成总结的习惯，并在下一个阶段有意识地去完善，保持一种不断成长的态度</strong>。</p>
<h1 id="6-作者结束语"><a href="#6-作者结束语" class="headerlink" title="6 作者结束语"></a>6 作者结束语</h1><blockquote>
<p>在刚进入职场时，我每天都在公司工作到很晚，倒不是工作太多、效率不高导致的，而是给自己设定了目标，需要在更短的时间熟悉公司的流程。我翻阅了公司内部和外部的很多文档，一天从早到晚除了睡觉以外，手边都放着各种文档。如果将这些文档分类，那么一部分是技术文档，我大致用了三年的时间掌握了主流验证技术；而另外一部分是验证流程的相关文档，这部分文档是常读常新的，我总可以在不懂时翻阅文档，或者请教更有经验的同事。有句话说，“自己知道得越多，知道自己不知道的也就越多”。在IC验证这条道路上我们面对的不仅仅是更新很快的验证知识，也包括一些“常识”。所谓常识，就同前辈教的道理一样，往往在遇到挫折时才想得起来，对此我也深有体会。之所以将这一章作为本书的开头，就是为了让读者能够清楚：在通往专业化的验证道路上，需要经历不少的磨炼。接下来，我们将从验证通识的各个方面分别展开论述。当然，你也可以跳过验证通识的内容部分，转而阅读SystemVerilog和UVM的知识。但请不要忘记一点，验证通识对于你提升自己的专业化素质会有很大的帮助。</p>
</blockquote>
]]></content>
      <categories>
        <category>IC验证</category>
      </categories>
      <tags>
        <tag>UVM</tag>
        <tag>System Verilog</tag>
        <tag>IC验证</tag>
      </tags>
  </entry>
  <entry>
    <title>芯片验证漫游指南2验证的策略</title>
    <url>/2022/05/06/06/</url>
    <content><![CDATA[<h1 id="1-设计的流程"><a href="#1-设计的流程" class="headerlink" title="1. 设计的流程"></a>1. 设计的流程</h1><p>我们在第1章给出了芯片产品开发的流程图，在描述中我们将开发流程分为两条主线：</p>
<ul>
<li>芯片功能的细分；</li>
<li>不同人员的任务分配。</li>
</ul>
<p>也就是说，不同人员需要在硅前不同阶段实现和测试芯片的模块功能。如果我们从另外一个角度看，芯片的开发即是将抽象级别逐次降低的过程，从一开始的抽象自然语言描述到硬件HDL语言描述再到最后的门级网表。在我们介绍过RTL设计和门级网表后，这里需要引入一个<strong>更高抽象级的描述方式TLM（事务级模型，Transaction Level Model）。TLM一般在早期用于模拟硬件的行为，侧重于它的功能描述，而不在于严格的时序</strong>。同时各个 TLM 模型也会被集成为一个系统，用来评估系统的整体性能和模块之间的交互。</p>
<p>TLM模型在早期的设计和验证中，如果足够准确的话，可以替代验证人员的参考模型，一方面为硬件设计提供了可以参考的设计（来源于系统描述），一方面也加速了验证（无须再构建参考模型，而且TLM模型足够准确反映硬件描述）。</p>
<h2 id="1-1-TLM模型的需求和ESL开发"><a href="#1-1-TLM模型的需求和ESL开发" class="headerlink" title="1.1 TLM模型的需求和ESL开发"></a>1.1 TLM模型的需求和ESL开发</h2><p>早期的芯片开发模式是遵循<strong>从系统结构设计到芯片设计制造，再到上层软件开发</strong>的。随着产品开发的进展，需要让系统人员、硬件人员和软件人员保持充沛的工作量，同时对于一个芯片项目而言，我们也希望硬件人员和软件人员可以尽可能地同时进行开发。这听起来怎么可能？毕竟芯片还没有制造出来，没有开发板怎么去构建软件呢？</p>
<p>在这里，系统结构人员会在早期构建一个高抽象级的系统，该系统具备相应的基本功能，且各模块的接口保持数据交互。通过将功能描述变成可运行的系统，让硬件人员和软件人员在早期利用该系统进行硬件参照和软件开发。这种可以为复杂系统建立模型、让多个流程分支可以并行开发的方式称为ESL（电子系统级，electronic systemlevel）开发。</p>
<h2 id="1-2-传统的系统设计流程"><a href="#1-2-传统的系统设计流程" class="headerlink" title="1.2 传统的系统设计流程"></a>1.2 传统的系统设计流程</h2><p>传统的系统设计流程如图2.1所示，是瀑布形式（waterfall）开发的，这种顺序开发的方式存在明显的边界：</p>
<ul>
<li>时间边界：不同的开发子过程之间顺序执行，几乎没有交叠的空间来缩短整体的项目交付时间。</li>
<li>组织边界：开发小组之间的交流发生在上一个过程结束、下一个过程开始时，这引入了额外的沟通成本;</li>
</ul>
<p><img src="/2022/05/06/06/%E4%BC%A0%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B.png" alt="传统的设计流程"></p>
<h2 id="1-3-ESL系统设计流程"><a href="#1-3-ESL系统设计流程" class="headerlink" title="1.3 ESL系统设计流程"></a>1.3 ESL系统设计流程</h2><p>图2.2为ESL系统设计流程。为了模糊或者融合这种边界，ESL开发流程通过建立虚拟原型（virtual prototype），又称TLM模型，使参与到系统开发的各小组做<strong>并行开发</strong>。之所以有这种魔力，是因为 TLM 模型不再是一种无法被硬件开发和软件开发利用的抽象描述，而是一种更早期开发的软件模型。在ESL开发的协助下，其余的开发流程可以更早地与系统设计一块进行开发，从整体上看，这种方式有助于缩短芯片开发的时间。除此之外，ESL在前期产品定义的阶段有相对可量化的模型，有助于早期评估产品的功能、性能是否满足客户要求，也能减轻一些低配置性能的风险以及降低过多设计的成本。</p>
<p>这是为什么呢？原因有以下几点：</p>
<ul>
<li>在早期定义产品时，市场部门将产品功能和性能要求从客户那里收集回来，交由系统结构人员来定义芯片结构。这中间存在一些问题，例如，系统结构人员无法深入到局部功能，更无从列举出所有的用例来判断功能是否满足需求，而在性能测试方面也只能通过一些表<br>格化数据做出静态估算。这时，TLM 模型可以帮助在系统级别完成模型搭建和系统集成，甚至测算系统的性能。这样，系统结构人员有更多的信心给出合理的结构配置。</li>
<li>正由于可以在芯片结构的定义阶段快速做出性能评估，系统结构人员才可以及时地做出资源调整来满足用户的需求。否则，尽管芯片可能是低缺陷率的，但如果它的执行速度不够快、功耗过高，那么仍然无法满足客户的要求。</li>
<li>过度设计的结构就像给一只袜子缀上水钻一样没有必要。客户给的报价摆在那里，你的设计过度，不但意味着成本的增长，也意味着更高的复杂度和风险。</li>
</ul>
<p><img src="/2022/05/06/06/ESL%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E6%96%B9%E5%BC%8F.png" alt="ESL系统设计流程"></p>
<p>ESL和TLM对系统模型的要求使得需要有一门语言具备这些特性：</p>
<ul>
<li>纵深多个抽象级别来进行模型描述；</li>
<li>标准开放；</li>
<li>高效的仿真性能和调试接口；</li>
<li>被主流仿真工具支持；</li>
<li>本身包含TLM事务级传输的接口。</li>
</ul>
<p>这样的语言就是接下来要介绍的SystemC。SystemC是可以满足TLM模型开发的一种语言。严格来讲，它本身不是一种语言，而是建立在C++之上的一种类库（class library）。SystemC语言可以用来描述系统级别的硬件行为，而这一点恰是其他语言无法满足的。2006年，SystemC被IEEE收入IEEE 1666标准，它本身也易于学习，具有C++&#x2F;Java基础和硬件设计概念的人使用起来都不需要太多的学习成本。</p>
<h2 id="1-4-语言的抽象级比较"><a href="#1-4-语言的抽象级比较" class="headerlink" title="1.4 语言的抽象级比较"></a>1.4 语言的抽象级比较</h2><p>不同的硬件领域使用到的建模语言都有它们各自适合的抽象级，图2.3指出了各个语言擅长的抽象级领域。从左至右，<strong>VHDL和Verilog主要用做RTL仿真和数字电路的综合</strong>，也用来在早期搭建一些验证平台。SystemVerilog&#x2F;Vera&#x2F;e是用来做功能验证语言的，其中包括了它们的随机约束重要特性，同时可以发现，SystemVerilog 本身可以用来描述硬件做 RTL仿真和门级综合。在此之上，<strong>SystemC 更偏向于系统层，它在结构层面上可以做更高抽象级的描述，虽然本身无法描述电路的综合网表，但它能够作为虚拟平台为上层软件开发做准备</strong>。MATLAB在信号处理上面被用来作为描述和算法验证。</p>
<p><img src="/2022/05/06/06/%E4%B8%8D%E5%90%8C%E7%A1%AC%E4%BB%B6%E7%9B%B8%E5%85%B3%E8%AF%AD%E8%A8%80%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%BA%A7%E6%AF%94%E8%BE%83.png" alt="不同硬件相关语言的抽象级比较"></p>
<h2 id="1-5-传统的系统集成视角"><a href="#1-5-传统的系统集成视角" class="headerlink" title="1.5 传统的系统集成视角"></a>1.5 传统的系统集成视角</h2><p>前面已经提到，传统的瀑布开发模型（见图2.4）无法让硬件人员和软件人员在系统结构定义早期参与其中。硬件的设计和验证人员需等待系统定义完成之后，才能将功能描述文档分别翻译出来，建立可综合模型和参考模型。软件人员只有在硬件流片以后才真正开始进行软件开发，尽管目前的FPGA有着比硬件更快的仿真优势，但无论从时间还是从速度来看，它仍然不是理想的软件开发平台。虽然FPGA等硬件加速工具对硅后系统测试有积极意义，但因介入较晚，加上基于速度层面的考量，其对软件系统层开发的贡献依然存在局限性。</p>
<p><img src="/2022/05/06/06/%E7%80%91%E5%B8%83%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B.png" alt="瀑布开发模型"></p>
<h2 id="1-6-ESL系统集成视角"><a href="#1-6-ESL系统集成视角" class="headerlink" title="1.6 ESL系统集成视角"></a>1.6 ESL系统集成视角</h2><p>新型的ESL系统开发方式（见图2.5）在系统定义阶段建立TLM模型。这一模型的建立对系统人员、硬件设计人员、验证人员和软件开发人员有显著帮助：</p>
<ul>
<li>系统人员在TLM模型集成系统上更易评估系统性能。</li>
<li>硬件设计人员同时利用功能描述文档和TLM模型，更准确地翻译为可综合的RTL设计。</li>
<li>验证人员可以直接将TLM模型作为参考模型集成到验证环境中，省去额外开发参考模型的时间。</li>
<li>软件开发人员可以在TLM集成后的虚拟系统上进行软件开发，在芯片真正出片后，则只需做一些基于实际硬件的软件移植；这可以把软件开发的起点大大提前。</li>
</ul>
<p>TLM 建模有很多优点。然而，在真正考虑施行 ESL 系统集成流程时，需要考虑一些实际的问题：</p>
<ul>
<li>TLM建模对系统人员有更高的技能要求。不但要求他们掌握SystemC开发，同时要求有硬件描述的基础。他们的工作量同时包括功能描述文档和 TLM 模型，且TLM需要准确翻译功能描述文档，确保一致性。从传统流程迈向 ESL 流程，可能需要做一些妥协，<strong>引入专门的虚拟建模（virtual prototyping）团队协助系统人员翻译功能描述文档。他们的共同产出最终作为一致的参考标准</strong>。</li>
<li>尽管已经有了可以被综合的 SystemC 的子集和代码规范，但这种方式目前仍未得到业界的广泛应用。在某个硬件模块没有就位或者需要加快仿真速度时，可以临时用TLM模型替换原先的硬件设计。<strong>前提是，系统的仿真行为保持不变，且TLM模型接口上的时序满足HDL仿真的要求</strong>。</li>
<li>当 TLM 模型被验证环境复用时，要求 TLM 与验证环境之间保持标准接口（TLM interface），以便于TLM模型的插拔。</li>
<li>软件开发需在完整的系统层面进行，因此当TLM协助软件开发时，TLM子模块要被尽早地集成到一起，作为整体系统为软件开发所用。TLM 模型需要具备标准接口，以便更快地实现系统集成。</li>
</ul>
<p><img src="/2022/05/06/06/ESL%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E6%96%B9%E5%BC%8F.png" alt="ESL系统开发方式"></p>
<p>目前常见的设计流程仍然是瀑布开发方式或类 ESL 开发方式。类 ESL 开发指的是开发流程并没有完全遵循上述流程，而是在一些地方引入TLM建模。在图2.6中，由于系统人员的技能限制，项目开发需要额外引入虚拟建模团队。虚拟建模团队服务的主要对象是软件开发一方，他们与硬件设计、验证团队的沟通会较少。这种类ESL的开发可能有多种组合，但需要警惕的是，在方便软件开发早期进入项目时，TLM模型应该与系统定义保持绝对的一致性，从而为硬件和软件方提供模型和代码参考。</p>
<p>从图2.6来看，这种类ESL的方式是存在风险的，因为虚拟建模团队从系统定义到TLM模型的过程存在二次翻译。如果翻译不准确、存在疏漏，可以想象，基于 TLM 模型的软件开发不会那么容易被移植到真正的硬件系统上，因为硬件本身也是二次翻译的。所以，理想的合作边界应该如图2.7所示，虚拟建模首先和系统定义保持原义的一致性，硬件和软件则可以将TLM模型视为功能描述的一致性翻译，然后各自在TLM模型上进行开发。</p>
<p><img src="/2022/05/06/06/ESL%E5%BC%80%E5%8F%91%E6%B2%9F%E9%80%9A%E5%85%85%E5%88%86.png" alt="ESL开发沟通充分"></p>
<h1 id="2-验证的层次"><a href="#2-验证的层次" class="headerlink" title="2. 验证的层次"></a>2. 验证的层次</h1><p>从系统定义阶段开始，我们将芯片系统划分为子系统，进而将每个子系统划分为不同的功能模块，直到划分为复杂度合适的模块。到设计阶段，按照自底向上的方式开始做硬件设计和集成。从定义阶段到设计阶段，再到后端部分，整个硅前的流程都是将芯片按照层次划分的，<strong>一般称为芯片系统级（chip level &#x2F;system level）、子系统级（sub-system level）和模块级（module level &#x2F;unit level）</strong>。</p>
<p>这种层次划分的方式对于芯片开发有哪些好处呢？</p>
<ul>
<li>便于拆解功能模块，实现人员的并行工作协同。这一点是从项目执行效率出发的。</li>
<li>对于系统定义而言，这是从主要的功能、性能要求量化为系统不同模块定义的方法。</li>
<li>从设计和验证角度出发，合适的复杂度模块有助于估计工作量和人员分配。设计最终是通过模块化来集成的，而验证环境在模块化后可方便地在更高层的环境中复用。</li>
<li>对于后端，在进行了合理的区域划分后，模块和芯片系统可以并行进行后续的物理设计流程。设计模块在每个阶段进行相关的设计检查，集成后的芯片系统最终进行设计检查并通过流片要求。</li>
</ul>
<p><img src="/2022/05/06/06/%E6%89%8B%E6%9C%BA%E9%80%9A%E4%BF%A1%E8%8A%AF%E7%89%87%E7%BB%93%E6%9E%84%E7%A4%BA%E4%BE%8B.png"></p>
<p>如果我们是在为一款手机设计通信芯片，如图2.8显示，一开始的系统定义阶段可能要规划出这么多的功能模块，还需考虑模块的性能因素。每一款芯片都包括多个子系统，每个子系统包含多个功能模块。从图1.3中的这款手机通信芯片结构来看，它包括的子系统有：</p>
<ul>
<li>处理器子系统；</li>
<li>协处理器子系统；</li>
<li>本地存储子系统；</li>
<li>外部存储控制器系统；</li>
<li>数据接口系统；</li>
<li>系统模块外设；</li>
<li>多媒体子系统；</li>
<li>调制解调子系统。</li>
</ul>
<p>核心模块调制解调子系统中的2G&#x2F;3G&#x2F;4G 由于自身的复杂性提高，可以进一步作为独立的系统来对待，进而细分下去。至于如何划分层次，我们一般从如下几个角度考虑：</p>
<ul>
<li>系统的复杂性：如果系统相对独立，自身就有作为子系统的条件；如果本身仍过于复杂，则可以进一步细分。</li>
<li>芯片集成的便利性：对于顶层芯片集成而言，一个合适的子系统应与外界有清晰的功能边界，如系统信号边界、标准总线边界、与其他子系统交互的边界，同时这些信号边界也尽可能保持稳定和精简。这是从顶层集成的工作量和后端布局布线的角度出发的。</li>
<li>验证的阶段：验证人员需要清楚，哪些功能点在模块级验证、哪些在子系统级验证和芯片系统级验证、是否有必要在不同级别重复验证、各个层次是否会保证验证完备性。</li>
<li>后端的流程：如果一个子系统占芯片整体面积的10%以上，那么后端就有理由考虑将其单独综合，因为合理的划分子系统且并行综合有助于后期整个芯片综合的收敛。</li>
</ul>
<p>接下来主要从验证的角度来考虑，如何选择合适的验证层次和对应的验证环境：</p>
<ul>
<li>模块级（block level &#x2F;unit level）；</li>
<li>子系统级（sub-system level）；</li>
<li>芯片系统级（chip level）；</li>
<li>硅后系统级（post-silicon system level）</li>
</ul>
<h2 id="2-1-模块级"><a href="#2-1-模块级" class="headerlink" title="2.1 模块级"></a>2.1 模块级</h2><p>如果是图2.8中的处理器子系统，考虑先将DMA（Direct Memory Access）、Cache缓存和 Core0&#x2F;Core1分别展开模块验证。每个模块验证首先要考虑的是，哪些功能点可以在模块一级完全验证。</p>
<p>决策基于如下因素：</p>
<ul>
<li>内部功能如状态机验证；</li>
<li>内部数据存储验证；</li>
<li>数据打包功能、编解码功能；</li>
<li>指令执行；</li>
<li>寄存器配置。</li>
</ul>
<p>同时需要考虑哪些功能无法在模块一级被验证到：</p>
<ul>
<li>与其他相邻模块的互动信号；</li>
<li>与其他子系统的互动信号；</li>
<li>与芯片外部的互动信号；</li>
<li>与电源开关的验证。</li>
</ul>
<p>我们需要考虑在更高的层次来验证这些部分。</p>
<h2 id="2-2-子系统级"><a href="#2-2-子系统级" class="headerlink" title="2.2 子系统级"></a>2.2 子系统级</h2><p>一个成熟的<strong>子系统，既拥有完备的功能可以执行专门的任务，也有足够稳定的接口用来在更高层做集成。与模块相比，子系统更稳定也更封闭</strong>，这对顶层集成是有好处的。也正是这种便于集成和相对封闭的特征，使得我们可以从公司外部或内部得到不同的子系统。</p>
<p>合格交付的子系统应该包含：</p>
<ul>
<li>设计包；</li>
<li>验证包；</li>
<li>回归测试表；</li>
<li>覆盖率收集脚本和数据；</li>
<li>完整的文档（设计、验证、集成、后端）。</li>
</ul>
<p>完备的交付可以增强顶层集成的信心，同时减少在集成过程中发生的一些接口理解分歧和参数化配置问题。单就验证而言，除了充分验证内部功能，如果对子系统的外部接口需要进行参数或编译预处理（compiler directive），验证人员则需要就这些参数和不同的编译选项（可能因此产生不同的硬件结构功能）给出完备验证。从子系统的封闭性和复用性来看，它们会在多个芯片项目中被使用，这对设计复用来讲是一件好事，而验证也需要将验证环境参数化以适应硬件的参数化配置。只有充分验证了参数化的子系统，才可能让它在不同的芯片项目中实现预期的功能。对验证管理而言，子系统验证是一个理想的可以切分的单元。这一层下面的模块之间互动很多，而这一层本身趋于封闭，与外围的接口有限，所以便于在子系统层设置独立的验证小组——“包产到组”。</p>
<h2 id="2-3-芯片系统级"><a href="#2-3-芯片系统级" class="headerlink" title="2.3 芯片系统级"></a>2.3 芯片系统级</h2><p>在芯片系统级，我们的验证平台的复用性较高，这主要是因为：</p>
<ul>
<li>外围的验证组件不需要像模块级、子系统级的组件那样，数量多且需经常更新。它们主要侧重于验证芯片的输入输出。</li>
<li>芯片内部的子系统之间的交互、协作检查主要交给处理器和子系统，从寄存器检查和数据检查入手，实现定向测试（directed test）用例。</li>
</ul>
<p>芯片系统级的验证侧重于不同子系统之间的信号交互以及实现更贴近实际场景的用例。这里的实际用例并非在系统软件层面，而是将系统软件层面的场景进一步拆分为多个模块互动情景后，再分开测试。</p>
<h2 id="2-4-硅后系统级"><a href="#2-4-硅后系统级" class="headerlink" title="2.4 硅后系统级"></a>2.4 硅后系统级</h2><p>尽管硅前验证部分与硅后系统软件开发联系较少，但尽早将硅后软件开发的实际用例用在硅前测试，能够发现一些实际使用中的问题。实际上，系统软件用例和硅前的随机测试具有互补的特性，功能验证中的缺陷如果没有在硅后测试、软件开发、用户使用中发现，那么隐藏的缺陷会静静地躺在那里，也许永远不会被发现（没有零缺陷的芯片，却有用户未发现缺陷的芯片）。所以，将硅后的驱动、固件和系统软件尽早在硅前引入验证过程，则可以与硅前的验证方法形成互补，使验证更加完善。</p>
<p>前面介绍了验证的4个阶段，给出了它们各自使用的测试场景。这里再给出可以遵循的几点原则，帮助大家在验证时选择适合的级别：</p>
<ul>
<li>能够在更低的级别完成某一项功能验证，就不要在更高层次上去验证。小的验证环境更有利于控制激励场景的产生，能更加全面地覆盖功能点。</li>
<li>低层次已经充分验证过某一项功能，高层次就不要重复验证。低层次无法完全覆盖功能点验证时，应在高层次完全覆盖。</li>
<li>在低层次的验证阶段应适当考虑高层次的测试用例，并在低层次创造一些条件模拟发生的条件和场景。</li>
<li>在高层次的验证阶段，验证环境中的参考模型、数据比对、监视器等模块应首先考虑从低层次环境复用，无法满足时再考虑重新构建。</li>
<li>对于新的模块或者新的功能，应投入更多精力、给于更高优先级，在不同层次充分验证。</li>
</ul>
<p>通过表2.1来更好地理解不同验证层次的侧重、性能和<br>使用方法。选择一个合适的验证层次，通过在不同层次分配不同的功能验证点，是最终迈向验证完备性的一项必备技能。</p>
<p><img src="/2022/05/06/06/%E4%B8%8D%E5%90%8C%E9%AA%8C%E8%AF%81%E5%B1%82%E6%AC%A1%E7%9A%84%E4%BE%A7%E9%87%8D%E3%80%81%E6%80%A7%E8%83%BD%E5%92%8C%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.png"></p>
<h1 id="3-验证的透明度"><a href="#3-验证的透明度" class="headerlink" title="3. 验证的透明度"></a>3. 验证的透明度</h1><p>可以按照激励的生成方式和检查的功能点分布将验证划分为三种基本方式：</p>
<ul>
<li>黑盒验证；</li>
<li>白盒验证；</li>
<li>灰盒验证。</li>
</ul>
<p>接下来，我们逐一解释这三种不同透明度的验证特征。</p>
<h2 id="3-1-黑盒验证"><a href="#3-1-黑盒验证" class="headerlink" title="3.1 黑盒验证"></a>3.1 黑盒验证</h2><p>如果验证人员对设计的细节缺乏认识，那么黑盒验证是一种合适的方式。因为验证环境只需要将激励给入设计的外部接口，检查设计的另一侧输出就足够了。测试成功与否只是根据一个输入是否得到一个正确的输出去判断，验证环境本身不会关注设计的内部。</p>
<p>图2.9是黑盒验证的结构。<br><img src="/2022/05/06/06/%E9%BB%91%E7%9B%92%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%84.png" alt="黑盒验证结构"></p>
<p>从图2.9可以看到，激励生成器（stimulator）只负责给设计灌入激励，监视器（monitor）和检查器（checker）只查看和比较输出信号。<strong>黑盒验证的一个缺点是缺少设计的透明度和激励的可控性</strong>，由此带来的问题包括：</p>
<ul>
<li>测试失败时无法更深层次地定位问题。验证人员只能判断测试是否成功，无法进一步定位到缺陷所在的位置进而与设计人员完成深度协作。</li>
<li>难以发现一些较深的缺陷。因为验证人员无法根据设计本身给出<strong>更窄的随机约束定向地生成一些激励</strong>，同时，这对设计内部功能点的功能覆盖率收敛没有太多的帮助。</li>
</ul>
<p>设计的接口采用标准接口时，图2.9中的激励生成器或总线功能模型可以使用成熟度高的验证IP。这些验证IP一般由第三方公司提供，有时公司内部也有这样的IP，它们的特点是像标准接口一样易于在验证环境中插拔和控制，且接口时序严格按照总线文档定义。监测器也来自于验证IP，这减少了验证人员底层开发的工作量。所以，当模块的接口是标准接口时，验证环境可以复用一些验证IP。</p>
<p>由于黑盒验证本身不包含设计的内部逻辑信息，所以当设计因缺陷而更新或添加新的特性时，原有的测试列表仍然较稳定，验证人员只需要对新添加的特性考虑新的测试场景。<strong>黑盒验证有利于保持测试环境的稳定，当后续项目中更新了设计时，新的验证人员也只需要很少的力气来维护继承的验证环境</strong>。</p>
<h2 id="3-2-白盒验证"><a href="#3-2-白盒验证" class="headerlink" title="3.2 白盒验证"></a>3.2 白盒验证</h2><p>白盒验证可以弥补黑盒验证的一些不足。验证人员了解设计的内部工作逻辑、层次、信号等，他们因而可以对更底层的设计细节进行测试。<strong>这种验证方式检查设计是否严格遵循功能描述文档，测试发生失败时可以更快速地定位到缺陷</strong>。对于白盒验证的环境，我们的参考模型逻辑非常简略，甚至不需要参考模型，<strong>只需要植入监视器和断言来检查各个内部逻辑。这种环境配置背后的原则是，充分检查各个逻辑驱动和结构以后，就不需要测试它的整体功能了。不过</strong>，使用白盒验证也面临一些方法学上的缺陷：</p>
<ul>
<li>由于本身专注于设计内部逻辑检查而忽略整体功能的测试，<strong>设计本身违反规范时，白盒验证难以发现缺陷</strong>。</li>
<li>在数据一致性检查方面，白盒验证难以从整体入手给出实际测试用例。</li>
<li>白盒验证的测试用例很多是从设计细节入手的，所以，设计发生更新时，验证环境的维护成本偏高。这一点在项目间复用方面带来的影响更多，新接手验证环境的人要付出很大的成本去理解设计细节和验证环境的细节；这时候白盒验证环境的低复用性缺点就暴露出来<br>了。</li>
</ul>
<h2 id="3-3-灰盒验证"><a href="#3-3-灰盒验证" class="headerlink" title="3.3 灰盒验证"></a>3.3 灰盒验证</h2><p>黑盒验证和白盒验证各有优势和劣势。在实际验证中，我们倾向于将黑盒和白盒两种方法结合起来，以一种称为灰盒验证的方式（其结构见图2.10），<strong>将监视器、断言、参考模型一同用来完善验证</strong>。这种糅合方式带来的好处包括：</p>
<ul>
<li>监视器和断言可以有更好的透明度来着重检查设计的一些重要内部逻辑。</li>
<li>参考模型已经有了断言检查局部逻辑的帮助，所以可以降低一部分精确度，而主要专注在输入和输出数据的比较上。</li>
</ul>
<p>从复用性角度考虑，灰盒验证也有灵活的变动方式：</p>
<ul>
<li>对于新的设计，我们的验证人员需要更深入地理解设计本身。采用灰盒验证一开始通过监视器和断言来进行局部验证，待设计初步完善和趋于稳定时，验证人员就有了对设计更全局性的理解来构建参考模型。又因为前期监视器和断言保证局部逻辑的正确，参考模型的<br>构建不需要完全精确，只需要较少的精力来实现。</li>
<li>该设计移植到别的项目时，设计难免需要进行局部修改，这时，灰盒验证的复用性优势相对于验证环境就体现出来了。哪怕是新的验证人员接手这个验证环境，好的灰盒环境也可以清晰地将黑盒和白盒的部分划分开。在设计复用的项目中，建议首先打开黑盒开关，<br>这对新的验证人员来讲测试成本较低，也不需要对设计和验证环境了解太多。同时，这么做也可以第一时间保证原有功能的稳定性，并反馈给设计人员新的改动造成的影响。紧接着，验证人员可以针对新的特性创建特定的黑盒测试序列，新的黑盒测试序列因设计本身的稳定<br>而不需要关注设计内部的太多细节。</li>
<li>完成黑盒验证环节后，可以在时间允许的情况下有序引入白盒的开关。首先应考虑创建新的白盒断言点或功能检查点，关注新的功能部分；其次，完成新的功能点白盒覆盖后，考虑逐个打开原有的白盒功能检查开关。打开白盒检查开关时，我们也遵循着每次添加较少<br>的开关来跑回归测试的策略，便于发现问题后快速定位到新打开的开关一侧；另外，白盒检查点的开关有优先级，如果验证人员足够专业，在他的代码或者文档中会对这些白盒开关给出说明和重要性排列。文档说明有助于新的验证人员按照优先级的高低来打开不同的开关。</li>
</ul>
<p>所以，灰盒验证不但可以继承黑盒验证和白盒验证的优势，而且对验证环境在新项目中的复用有明显优势。</p>
<p><img src="/2022/05/06/06/%E9%BB%91%E7%9B%92%E3%80%81%E7%99%BD%E7%9B%92%E5%92%8C%E7%81%B0%E7%9B%92%E7%9A%84%E9%AA%8C%E8%AF%81%E7%89%B9%E7%82%B9.png"></p>
<p>最后，我们通过表2.2来总结黑盒验证、白盒验证和灰盒验证的特点。可以看出，灰盒验证可以<strong>最好地平衡设计增量和验证复用</strong>。在设计阶段，如果验证人员有充分的经验来实现灰盒验证环境，清晰划分黑盒部分和白盒部分，那么在后续的项目中，灰盒验证的良好复用性和灵活性会给模块的集成带来便利。在高度集成化的今天，我们对设计复用性的考量，是从整个设计交付包（design delivery package）出发的，包括之前提到的设计包、验证包、文档包、回归测试包和覆盖率包等。</p>
<p>无论设计人员还是验证人员，都需要从各自的角度考虑复用性，全盘考虑设计的整个流程。设计交付只有能带来更好的“用户体验”，缩短集成时间（设计和验证），这才是好的设计和验证方式。</p>
<h1 id="4-激励的原则"><a href="#4-激励的原则" class="headerlink" title="4. 激励的原则"></a>4. 激励的原则</h1><p>激励的原则实际上就是为了解决一个问题，<strong>即如何保证激励源最大的自由度。只有从环境结构上保证了激励源最大的自由度，才能在输入一侧提供更丰富的组合，有条件地穷历一些测试序列</strong>。</p>
<p>按照这个核心原则，我们可以按下面这些因素评估激励的自由度：</p>
<ul>
<li>接口类型；</li>
<li>序列颗粒度；</li>
<li>可控性；</li>
<li>组件独立性；</li>
<li>组合自由度。</li>
</ul>
<p>下面我们具体了解激励在这些方面的表现和评估方法。</p>
<h2 id="4-1-接口类型"><a href="#4-1-接口类型" class="headerlink" title="4.1 接口类型"></a>4.1 接口类型</h2><p>面对一个设计的输入接口，我们可以先判断接口的类型<br>（interface type）。如果设计的接口类型复杂多样，可以通过接口类型的划分，化繁为简地找到从哪里下手给出激励。常见的接口类型可以分为：</p>
<ul>
<li>系统控制接口（system control interface）。例如，时钟、复位、安全、电源开关等，以及这些系统控制信号旁生出的控制信号，如时钟门控信号（clock gating signal）。</li>
<li>标准总线接口（standard bus interface）。公开的行业标准总线协议，例如常见的AMBA系列协议、OCP、MIPI系列协议等，其文档详细，同时有丰富的验证IP提供服务。</li>
<li>非标准总线接口（non-standard bus interface）。公司内部定义的接口，或者根据模块功能需求定义的接口。<strong>接口时序相对简单，文档也较粗略</strong>。公司内部即使有可复用的验证IP，验证IP本身也可能未经过充分测试，而且在非标准协议定制的背景下，验证IP的复用性较低。</li>
<li>测试接口（test interface）。该测试接口主要留给可测性（DFT,Design For Test）功能使用，在功能验证中禁用即可。</li>
<li>其他控制接口（miscellaneous control interface）。如果被测设计是处于子系统中的功能模块且与相邻多个模块交互，那么该控制接口的信号数量较多、功能较分散；如果该设计是子系统，则该类型的控制接口数量较少且功能较集中。</li>
</ul>
<p>有了清晰的分类，验证人员就可根据不同的接口类型选择验证IP，或者自己着手搭建激励组件（verification component）了。</p>
<h2 id="4-2-序列颗粒度"><a href="#4-2-序列颗粒度" class="headerlink" title="4.2 序列颗粒度"></a>4.2 序列颗粒度</h2><p>对不同的接口我们会引入不同的验证组件。激励生成器（stimulus generator&#x2F;driver）是接口验证组件的重要部分，它提供一些基本的功能方法用来生成小颗粒度的激励（sequence granularity）。用户也可以进一步做上层封装，从更高抽象级的角度生成大颗粒度或宏颗粒度的激励序列。我们按照软件层概念将激励序列颗粒度划分为下面的层级：</p>
<ul>
<li>基本颗粒层；</li>
<li>高级颗粒层；</li>
<li>宏颗粒层；</li>
<li>用户自定义颗粒层。</li>
</ul>
<p>从激励生成器提供的方法继承和封装入手，可以将这些颗粒层的关系表现为，<strong>基本颗粒层提供基本颗粒生成方法，而在其上，高级颗粒层和宏颗粒层做了深入的封装，帮助建立数据包（packet）和帧（frame）的概念。用户也可以依赖基本颗粒层，根据实际场景的需要实现自定义颗粒层，以方便特定场景的激励控制。序列的颗粒层次如图2.11所示</strong>。</p>
<p><img src="/2022/05/06/06/%E5%BA%8F%E5%88%97%E7%9A%84%E9%A2%97%E7%B2%92%E5%B1%82%E6%AC%A1.png" alt="序列的颗粒层次"></p>
<p>我们以一个商业总线验证IP为例。该验证IP包具有基本颗粒层和高级颗粒层来生成不同级别的测试序列，在一些情况下，验证IP也提供宏颗粒层的定义来满足更高规模的数据传输。这里的抽象级<strong>指的是从时序和数据量传输的角度出发，越高的抽象级越不关注底层的时序而更重视数据的传输量，也是 TLM（Transaction Level Model）含义的延伸。当验证人员不能从已有的各种颗粒层中生成自己期望的测试序列时，便可以利用已有的基本颗粒层和高级颗粒层来构建自己的颗粒层</strong>。</p>
<h2 id="4-3-可控性"><a href="#4-3-可控性" class="headerlink" title="4.3 可控性"></a>4.3 可控性</h2><p>可控性（controllability）是从对不同颗粒层的控制角度出发的。按照序列颗粒度的划分，对应的可控性评估如表2.3所示。</p>
<p><img src="/2022/05/06/06/%E5%BA%8F%E5%88%97%E7%9A%84%E9%A2%97%E7%B2%92%E5%B1%82%E6%AC%A1.png"></p>
<p>在<strong>功能验证周期的初期阶段，应从基本颗粒层中选择激励方法，这有利于我们在接口的基本功能中调节测试不同的总线传输情况</strong>，这里的验证点<strong>侧重于协议功能和时序检查</strong>。随着设计趋于稳定，我们逐渐选择高级颗粒层和宏颗粒层，将验证精力<strong>转移到数据量的一致性传输和性能评估</strong>上，而这两层的颗粒控制性没有像基本颗粒层那样细致到可以调节每一个参数变量，它们会同验证重点保持一致，主要提供跟数据量有关的可约束参数。</p>
<h2 id="4-4-组件独立性"><a href="#4-4-组件独立性" class="headerlink" title="4.4 组件独立性"></a>4.4 组件独立性</h2><p>将一个设计的边界信号划分为不同的接口类型，并创建出对应的接口验证组件之后，我们就应该考虑各个组件之间的独立性了。<strong>组件的独立性（component independency）实际上也是协调性的基本保障，因为有了独立性，各个组件之间才会最大程度地不受其他组件的制约，同时又可以通过有效的通信机制实现组件之间的同步协调</strong>。我们接下来看看实现组件独立性需要考虑的因素：</p>
<ul>
<li>必须按照接口类型来划分组件。</li>
<li>对于系统控制信号组件，尽可能将信号的关系按照实际集成关系做控制，例如，多个时钟是不是同步关系，多个复位信号是否可以单独控制等。</li>
<li>对于总线接口（标准或者非标准），实现一对一的控制关系。例如，若有两组相同的总线，则应引入两个总线组件分别控制，而非建立一个总线组件却拥有两套总线接口；后者有悖于可控性和复用性的要求。</li>
<li>对于其他控制接口，应从实际相邻设计那里准确了解各信号的使能极性、脉冲有效还是电平有效、是否存在握手关系、时序等真实的设计信息，来模拟高层集成环境中的控制场景。同时由于这部分信号偏于杂乱，在尽可能梳理信号的不同来源和功能后，需要在接口组<br>件中通过封装好的方法来实现灵活驱动。</li>
<li>验证环境中的系统控制信号组件会与其他接口组件发生连接，例如提供必要的时钟和复位信息，那么这些连接也应遵循实际集成的情况，确保组件驱动端的时钟输入与设计的时钟输入端同步。</li>
</ul>
<h2 id="4-5-组合自由度"><a href="#4-5-组合自由度" class="headerlink" title="4.5 组合自由度"></a>4.5 组合自由度</h2><p>最后一个衡量因素——组合自由度（combination space）是对上述因素的整体评估。<strong>只有通过底层的精细划分，建立抽象级更高的颗粒度，通过独立组件之间的协调来给出激励，才能提供较高的组合自由度。在这里，除了组件的独立性外，需要考虑组件之间的协调方式。</strong></p>
<p>一般将协调方式分为两种：</p>
<ul>
<li><strong>中心统筹式</strong>（centrally organized）。通过中心化的调遣，将不同的任务统一分派给各个接口组件，产生不同的激励组合场景。</li>
<li><strong>分布事件驱动式</strong>（distributed event driven）。将激励控制权交给各个接口组件，通过接口组件之间的通信来实现分布式的事件驱动模式，即组件之间的通信通过事件（event）、信箱（mailbox）、接口信号（interface signal）等方式实现同步通信。</li>
</ul>
<p>通过上述因素，我们可以评定出一个验证环境中各个接口组件之间的组合，是否可以提供足够的自由度，最终有可能穷历出预定的激励序列。</p>
<h1 id="5-检查的方法"><a href="#5-检查的方法" class="headerlink" title="5. 检查的方法"></a>5. 检查的方法</h1><p>懂得了如何实现和评估激励自由度的方法后，需要考虑在各种可能的激励组合下如何选择适当的检查，以完成验证环境的另外一项核心要素——检查。检查就是查看设计是否按照功能描述做出期望的行为，识别所有错误的输出，发现设计缺陷。我们是按照接口类型来划分激励的；</p>
<p>对于检查，类型的划分方式则基于被检查逻辑的层次，这些层次包括：</p>
<ul>
<li>模块的内部设计细节；</li>
<li>模块的输入输出；</li>
<li>模块与相邻模块的互动信号；</li>
<li>模块在芯片系统级的应用角色。</li>
</ul>
<p>不同的检查层次，可以考虑采用不同的检查方法，如表2.4所示。</p>
<p><img src="/2022/05/06/06/%E4%B8%8D%E5%90%8C%E5%B1%82%E6%AC%A1%E7%9A%84%E6%A3%80%E6%9F%A5%E6%96%B9%E6%B3%95.png"></p>
<p>从表2.4可以看出，<strong>经常使用的方法有监测器（monitor）、断言（assertion）、参考模型（reference model）、比较器（comparator&#x2F;scoreboard）、定向测试和形式验证等</strong>。接下来，我们简要分析不同检查方法的要点，关于这些方法的更多介绍，读者可以在8.6节详细了解。</p>
<p>一般而言，<strong>监测器（monitor）是必备的组件，它便于我们观察硬件信号。所以，在各个层次都可以找到监测器的身影</strong>。查看设计内部信号另外一个可行办法是使用 SystemVerilog绑定（bind）的特性。由于监测器可能被置入到各种方法中，我们需要从复用的角度，在构建监测器的时候考虑如下因素：</p>
<ul>
<li>监测器一般跟激励发生器的作用域一致。这指的是，如果该激励发生器对应一组总线，那么应该有一个对应的监视器负责监视总线的传输。</li>
<li>监测器应根据检查的层次将信号监测分为模块内部和模块边界。</li>
</ul>
<p><strong>对于断言（assertion），我们主要依靠它检查模块的内部逻辑细节和时序信息。利用断言，我们可以通过仿真或形式验证来完成测试</strong>。是否选用仿真或形式验证的方式，这里给的建议是：</p>
<ul>
<li>如果是模块级别，断言通过形式验证完全覆盖设计的多数功能点从效率和完备性来看是可靠的。同时建议在子系统或芯片一级创建基本的测试用例进行仿真，以作为形式验证的补充。</li>
<li>如果断言验证的功能点较分散或主要关切于模块的核心逻辑、时序，则倾向于使用仿真验证，采取灰盒模式，而用断言来验证重要设计细节。</li>
<li>如果断言总体可以覆盖模块的所有设计功能部分，采取形式验证或者白盒仿真验证两种方法都是可取的。</li>
</ul>
<p><strong>除了待测设计本身的尺寸、复杂度以外，参考模型（reference model）的构建也与验证方法有关。从2.3节来看，白盒验证对参考模型的要求最低，而黑盒验证却将最大的压力交给如何实现准确的参考模型。</strong></p>
<p>比较器（comparator）的结构相对简单，一般依靠足够稳定的监测器和准确的参考模型，<strong>比较器只需要将监测的硬件输出和参考模型的输出做比较，给出充分的比较信息。测试用例结束时，给出自定义的测试报告即可</strong>。</p>
<p>当模块完成了模块测试、子系统测试，迁入到芯片系统级测试后，我们在系统一级复用监测器和断言。这些从低层次复用来的监测器和断言，在高层测试中主要用于覆盖目标模块与其他模块互动的功能点。在系统测试中，从实际应用场景出发，我们一般采用定向测试即C&#x2F;C++代码，编译后由系统中的处理器来执行。<strong>定向测试的一个好处是为硅后测试提供可复用的测试代码</strong>。</p>
<h1 id="6-集成的环境"><a href="#6-集成的环境" class="headerlink" title="6. 集成的环境"></a>6. 集成的环境</h1><p>分析完激励的原则和检查的方法后，验证平台（testbench）的核心要素就大致齐备了。接下来将进一步分析验证环境的集成需要考虑的因素，并梳理各部分之间的关系。从图2.12可以看出，验证集成环境分为：</p>
<ul>
<li>验证平台（verification platform）；</li>
<li>待验设计（design under verification）；</li>
<li>运行环境（runtime environment）；</li>
<li>验证管理（verification management）。</li>
</ul>
<p><img src="/2022/05/06/06/%E9%AA%8C%E8%AF%81%E7%8E%AF%E5%A2%83%E7%9A%84%E8%A6%81%E7%B4%A0.png" alt="验证环境的要素"></p>
<h2 id="6-1-验证平台"><a href="#6-1-验证平台" class="headerlink" title="6.1 验证平台"></a>6.1 验证平台</h2><p>验证平台是验证人员日常工作的对象。在建立或复用验证框架时，主要考虑激励分类和检查方法两部分，这两部分直接影响验证平台的框架。</p>
<p>激励分为如下两类：</p>
<ul>
<li>定向激励。一般通过文本激励、C代码激励、预先生成激励码等形式给入。</li>
<li>随机激励。通过随机约束给入激励，这里的随机方式不局限于SV，也包括其他随机验证语言，或者利用脚本语言来产生随机激励。</li>
</ul>
<p>检查一般分为如下三类：</p>
<ul>
<li>线上检查（online check）。在仿真的过程中动态比对数据，并给出比较结果。</li>
<li>线下检查（offline check）。在仿真结束后比对仿真中收集的数据，给出比较结果。</li>
<li>断言检查（assertion check）。通过仿真或形式验证的方式利用断言检查设计的功能点。</li>
</ul>
<h2 id="6-2-待验设计"><a href="#6-2-待验设计" class="headerlink" title="6.2 待验设计"></a>6.2 待验设计</h2><p>根据功能描述的建模方式，硬件设计可以分为两类：</p>
<ul>
<li>HDL 硬件模型。即，使用 HDL 语言描述的硬件模型，按照硬件层次可以分为RTL和网表。该模型的特点是与硬件设计师距离最近，也是最贴合硬件逻辑行为的模型。</li>
<li>虚拟原型（virtual prototype）。在硬件定义的早期阶段，引入虚拟原型对硬件的框架和性能进行评估。在数字信号处理模块中需要复杂的算法参与，所以在硬件实现之前，可以采用软件算法模型来代替硬件的功能（不考虑时序替代）。常用的虚拟原型语言包括<br>SystemC、C&#x2F;C++、MATLAB等。</li>
</ul>
<p>仿真过程中可以将 HDL 硬件模型与虚拟原型混合，进行联合仿真。这时，需要考虑虚拟原型的接口是否可以在硬件仿真环境中较为方便地集成，以及是否有对虚拟原型的接口时序的要求。</p>
<h2 id="6-3-运行环境"><a href="#6-3-运行环境" class="headerlink" title="6.3 运行环境"></a>6.3 运行环境</h2><p>运行环境的主要职责是将验证平台和待验设计进行融合（软件激励端和硬件模型端的互动）。</p>
<p>根据前面对验证平台和待验设计的分类，运行环境需要考虑的因素有：</p>
<ul>
<li>验证平台。运行环境需要传入参数，根据测试场景选择测试序列、随机种子数值、参数化的环境结构和实例化验证平台。</li>
<li>待验模型。除了考虑如何实现HDL硬件模型与虚拟原型在仿真器中<strong>协同仿真</strong>之外，还需要实现验证平台和待验设计的接口对接，包括硬件信号接口连接和内部信号的接口监测。</li>
<li>仿真全流程建立。包括验证和设计的文件提取<br>（extraction）、文件依赖度分析（dependency analysis）、编译（compilation and elaboration）、仿真（simulation）、结果分析（result analysis）和回归测试（regression test）等。全流程的建立一般是由环境建设者（environment builder）通过脚本（script）语言来做管理的，用于仿真流程建立的常见脚本语言包括Shell、Makefile、Perl、Tcl、Python等。</li>
</ul>
<h2 id="6-4-验证管理"><a href="#6-4-验证管理" class="headerlink" title="6.4 验证管理"></a>6.4 验证管理</h2><p>无论芯片的尺寸有多大，验证人员和验证经理都需要对自己负责的模块或芯片做量化的验证管理。除常见的 Excel 表格管理外，也可使用其他验证管理工具进行管理。这些验证管理工具需要考虑的因素有：</p>
<ul>
<li>验证计划和进度管理（verification plan and progress management）。验证计划需要将抽象内容与量化后的测试用例、功能覆盖率相对应，进而给出可视化的验证进度。</li>
<li>文件版本控制管理（file version control management）。文件版本控制在团队协作中几乎是必需品，常见的工具有SVN、Git、Clearcase等。</li>
<li>项目环境配置管理（project environment configuration management）。项目环境的配置文件不但包括项目中使用的各种工具的版本、单元库的版本、验证IP的版本，也包括验证环境的顶层配置。通过这些环境配置管理，每一个参与项目的人都可以很快地实现环境配置，省去同步验证环境的工作。</li>
<li>缺陷率跟踪管理（defect tracking management）。之前提到的缺陷率曲线，需要验证人员和验证经理保持记录的习惯，除了通过缺陷率曲线衡量验证的进度，还需要通过记录跟踪缺陷的修复、后续验证的工作。</li>
</ul>
<p>足够稳定的验证平台，能够在更早期利用不同抽象级别的待验模型展开验证环境的搭建和验证工作。通过模块化和自动化的运行方式，实现环境的从建立到检查，一个完善的验证环境能够给验证人员助力不少。从项目管理的角度，也需要一个完善的工具（可能是几个工具共同协助）帮助我们完成验证管理，最终达到验证目标。</p>
<h1 id="7-作者结束语"><a href="#7-作者结束语" class="headerlink" title="7. 作者结束语"></a>7. 作者结束语</h1><blockquote>
<p>笔者还记得接手的第一个验证环境是Specman eRM结构，当时苦于缺少合适的文档，很多代码和工具的使用让我吃了不少的苦头。经历了OVM的验证阶段后，再回头思考eRM，发现验证的思想有很多是可以借鉴和优化的。就是说，尽管我们验证者（Verifier）需要用更多的时间去适应变化更快的验证技术和工具，但在这背后都是逐步继承的关系。你学习到的知识，多年以后有一部分将被替代，而核心的部分还将被保留下来。本章关于验证策略的通识，就是属于那些不会被替代的部分。你会在任何一种验证语言或者验证方法学中捕捉到与验证策略有关的信息，因为它是验证作为一种综合技术能力的基础。</p>
</blockquote>
]]></content>
      <categories>
        <category>IC验证</category>
      </categories>
      <tags>
        <tag>UVM</tag>
        <tag>System Verilog</tag>
        <tag>IC验证</tag>
      </tags>
  </entry>
  <entry>
    <title>芯片验证漫游指南3验证的方法</title>
    <url>/2022/05/06/29/</url>
    <content><![CDATA[<p>到了目前的阶段，已经无法依赖单一的工具、语言或方法来达到验证的完备性。在实际的验证工作中，需要综合使用多种语言、方法、工具实现此目的。不同的语言、方法、脚本和工具之间没有绝对的优劣之分。比如，<strong>仿真验证协同形式验证一起完善功能覆盖率，也可以通过语言和脚本之间的整合完成一项验证流程</strong>。总而言之，作为一名有经验的工程师，需要掌握现有的各种方法和工具，通过合理的选择，“保质、高效、低耗”地完成验证任务。所以，我们在这里将验证方法分为若干类，梳理目前主流的验证方法和工具。</p>
<p>主要的验证方法包括：</p>
<ul>
<li>动态仿真（dynamic simulation）；</li>
<li>静态检查（formal check）；</li>
<li>虚拟模型（virtual prototype）；</li>
<li>硬件加速（hardware acceleration）；</li>
<li>电源功耗（power consumption）；</li>
<li>性能评估（performance evaluation）。</li>
</ul>
<p>基于此，我们引入一节“开发环境”，介绍日常的编码环境。所谓“工欲善其事，必先利其器”，一个应手的开发环境，是迈向高效的一步。</p>
<h1 id="1-动态仿真"><a href="#1-动态仿真" class="headerlink" title="1 动态仿真"></a>1 动态仿真</h1><p>动态仿真（dynamic<br>simulation）: 最常见的验证方式——，是<strong>通过测试序列和激励生成器给入待验设计适当的激励，随着仿真进程的推进，判断输出是否符合预期</strong>。简而言之，我们需要<strong>仿真器</strong>来配合这一项工作，验证人员也需要查看<strong>比较结果和仿真波形</strong>，最终判定测试用例是否通过。按激励生成方式和检查方式，可以将动态仿真进一步划分为：</p>
<ul>
<li>定向测试（directed test）；</li>
<li>随机测试（random test）；</li>
<li>参考模型检查（reference model check）；</li>
<li>断言检查（assertion check）。</li>
</ul>
<p>参考模型一般伴随着定向测试或随机测试，所以我们接下来着重了解定向测试、随机测试和断言检查。</p>
<h1 id="1-1-定向测试"><a href="#1-1-定向测试" class="headerlink" title="1.1 定向测试"></a>1.1 定向测试</h1><p>定向测试 ： 指的是<strong>激励内容在仿真之前已经决定下来，测试用例给出的激励序列不会在下一次提交任务时改变</strong>。</p>
<p>我们日常通过C&#x2F;C++代码来实现子系统级或芯片系统级的测试，这是因为待验设计往往包含处理器，而且从硅后测试复用的角度来看，我们也倾向于运用C代码来编写高层次的测试用例。从图3.2可以看出，测试用例经过编译，转换为硬件存储器可以读入的文件（一般为二进制格式，主要包含地址和数据两部分）。待验设计经过上电复位（power up and reset），从存储器中读取二进制文件，处理器将二进制数据译码（decoding）为指令和数据，进行运算或存储访问。定向测试最终的数据比较分为两种情况：</p>
<ul>
<li><strong>通过内置的C代码进行数据正确性检查</strong>；</li>
<li><strong>通过外置的参考模型或者其他检查器来进行信号一致性检查</strong>。</li>
</ul>
<p><img src="/2022/05/06/29/%E5%AE%9A%E5%90%91%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B.png" alt="定向测试流程"></p>
<p>有时我们考虑直接将第三方提供的可执行文件或二进制文件作为激励源交给存储器，这就省略了C代码编译的步骤，但这需要相应的运行环境兼容。</p>
<p>将上述定向测试流程与实际项目进行对比，如图3.3所示，<strong>测试用例可以通过C代码交给处理器进行硬件行为的仿真检查。如果模块验证环境中缺少处理器，如何在这一级实现C代码的垂直复用（从模块级到芯片系统级）呢</strong>？</p>
<p>可以考虑下面的步骤：</p>
<ul>
<li>将C代码交给转换器将其转换为文本命令格式；</li>
<li>文本命令格式可以被总线翻译器识别进而转换为总线上的读写操作。</li>
</ul>
<p><img src="/2022/05/06/29/C%E4%BB%A3%E7%A0%81%E7%9A%84%E5%9E%82%E7%9B%B4%E5%A4%8D%E7%94%A8%E6%96%B9%E6%A1%88.png" alt="C代码的垂直复用方案"></p>
<p>上面的步骤中需要引入转换器实现复用，也可以考虑将转换器和总线翻译器通过标准的SystermVerilog C-DPI接口，从而实现良好的复用性。关于如何应用C-DPI接口，读者可以在17.1节获取更多的进行<br>转换细节。</p>
<p>定向测试一般应用在模块测试的早期或者在系统级芯片测试场景中，它适合于测试设计的基本功能，能直接翻译出验证人员想要的场景。它的<strong>缺陷也很明显，就是每一个定向测试用例在通过之后的重复仿真是冗余的，因为这样无法产生新的测试序列，也不会带来更多的覆盖率</strong>。不过，正因为它的激励序列确定性（determinacy），<strong>定向测试可以用来构成基本测试表，在验证前期完成设计的基本功能检查</strong>。</p>
<h1 id="1-2-随机测试"><a href="#1-2-随机测试" class="headerlink" title="1.2 随机测试"></a>1.2 随机测试</h1><p>与定向测试序列相对的是<strong>随机序列（random sequence）。随机序列通过预先定义的约束，每次随机产生合理的数值，通过激励产生器给出测试序列。图3.4可以说明，与定向测试相比，随机测试可以直接<br>通过激励生成器发送测试序列</strong>。</p>
<p>产生随机数的方法有很多种，并且有很多语言可以实现。但考虑到灵活地给随机绑定一些约束时，我们就需要特定的语言提供这样的属性，目前常用的语言有SystemVerilog和e语言。从图3.5来自Wilson2014年的调查数据来看，SystemVerilog的使用率大致已经上升到了75%左右。</p>
<p><img src="/2022/05/06/29/%E9%9A%8F%E6%9C%BA%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B.png" alt="随机测试流程"></p>
<p><strong>约束实际上是决定随机激励能否符合接口协议的关键，也是朝向验证合理状态空间的关键。随机约束生成器一般通过静态约束或动态反馈约束给出每一轮的激励</strong>。从图3.6可以看出，在实际的验证环境中，往往有很多对随机约束起控制和反馈作用的因素，它们分别是：</p>
<ul>
<li><strong>静态随机约束</strong>。即默认的约束，一般与激励一起定义，不随测试而变化。</li>
<li>反馈的动态随机约束。在测试过程中通过上一轮的结果来对下一轮随机序列给予反馈，通过额外的偏置约束（biasing constraint）给出更小的随机域（random region）。</li>
<li><strong>待验设计的功能验证开关</strong>。待验设计的功能点有时可以通过测试序列来关联，进而从该序列是否要验证某一项功能来决定某一组随机约束是否生效。</li>
<li><strong>激励的结构成员</strong>。随机激励的成员一般分为接口成员（与设计进行交互）和成员间的逻辑变量（决定成员之间数值关系的变量）。</li>
<li>验证环境的配置参数。如果验证环境是可配置的，那么这些配置参数也可能会影响序列的产生。</li>
<li><strong>验证环境中不同激励组件之间的同步通信</strong>。如果验证环境中包含多个激励组件，那么要实现这些随机组件之间的协同，就需要考虑通过同步通信（synchronization communication）来实现。</li>
</ul>
<p><img src="/2022/05/06/29/%E9%9A%8F%E6%9C%BA%E7%BA%A6%E6%9D%9F%E7%9A%84%E6%8E%A7%E5%88%B6%E5%92%8C%E5%8F%8D%E9%A6%88%E5%9B%A0%E7%B4%A0.png" alt="随机约束的控制和反馈因素"></p>
<h2 id="1-3-基于覆盖率驱动的随机验证"><a href="#1-3-基于覆盖率驱动的随机验证" class="headerlink" title="1.3 基于覆盖率驱动的随机验证"></a>1.3 基于覆盖率驱动的随机验证</h2><p>目前常用的一种随机验证方式是基于覆盖率驱动的，这种方式与3.1.2节提到的影响随机生成的因素<strong>“反馈的动态随机约束”一样，有着类似的反馈控制原理</strong>。从图3.7可以看出，<strong>与常用随机约束验证方式不同的一点是，覆盖率收集器在每次测试中都通过监视器来收集覆盖率（主要指功能覆盖率），将其与已有的覆盖率数据库进行合并，同时根据现有的覆盖率数据库为下一次随机约束给出反馈。这些反馈被用来进一步缩窄随机约束域，使其偏置产生一些序列，覆盖那些未知的功能测试点</strong>。</p>
<p><img src="/2022/05/06/29/%E5%9F%BA%E4%BA%8E%E8%A6%86%E7%9B%96%E7%8E%87%E9%A9%B1%E5%8A%A8%E7%9A%84%E9%9A%8F%E6%9C%BA%E9%AA%8C%E8%AF%81%E6%B5%81%E7%A8%8B.png" alt="基于覆盖率驱动的随机验证流程"></p>
<h2 id="1-4-基于TLM的随机验证"><a href="#1-4-基于TLM的随机验证" class="headerlink" title="1.4 基于TLM的随机验证"></a>1.4 基于TLM的随机验证</h2><p>测试用例可以指定每一次激励的数据内容，也可以在较高层次上指定每一次激励数据包（data packet）的内容。我们在2.1节中介绍了通过TLM在产品定义早期对设计建立模型。<strong>在抽象层次上，TLM比硬件时序行为更高一级，被用来描述设计或验证环境。基于TLM的随机验证方式，指的是在随机环境中使用的最小颗粒是 TLM 级别的数据包。该激励数据包不止包含一个时钟周期给出的激励，而是在更长的时间范围内（一般为一次完整的数据操作，例如完整的数据读写或数据包传输）定义更多且有内在联系的数据</strong>。</p>
<p>TLM验证带来的<strong>好处是，验证人员可以更便捷地描述一些测试场景，更贴近真实的用例</strong>。比如硅后系统测试和固件开发，是基于系统级别的，它们专注的并非单一模块的某一项功能，而是子系统或整个系统的复杂工作模式。从图3.8可以看到，TLM测试抽象级较高，需要由TLM2RTL激励生成器做进一步的转换。将TLM激励生成器进一步放大，可以看到它内部的一些转换模块，包括读写操作、复位操作、中断操作和其他操作。<strong>这些方法一般是根据TLM操作命令经过转换去调用的，我们将这样的激励生成器称为总线功能模型</strong>（BFM,Bus Functional Model）。</p>
<p><strong>BFM的作用是将高抽象级的TLM命令转换为低抽象级的硬件端口时序</strong>。进一步看，在高抽象级到低抽象级的转换中，除了数据抽象度在降低外，激励所用的时间也在转换中被施加到待测接口上。因此，要完成一项 TLM 命令的转换，经常需要数十个甚至数百个时钟周期。</p>
<p><img src="/2022/05/06/29/%E5%9F%BA%E4%BA%8ETLM%E7%9A%84%E9%9A%8F%E6%9C%BA%E9%AA%8C%E8%AF%81%E6%B5%81%E7%A8%8B.png" alt="基于TLM的随机验证流程"></p>
<h2 id="1-5-断言检查"><a href="#1-5-断言检查" class="headerlink" title="1.5 断言检查"></a>1.5 断言检查</h2><p>影响验证产出的一个重要因素是<strong>如何准确地描述功能</strong>。如图3.9所示，清晰的描述可以帮助设计人员更方便地实现设计功能，验证人员也需要检查各种可能的行为是否符合预期。</p>
<p>断言（assertion）提供了这样的特性，它善于针对某一特定的逻辑或时序进行预设，一旦设计的实际行为不符合断言的描述，则给出检查报告。</p>
<p><img src="/2022/05/06/29/%E5%9B%BE3.9%20%E8%AE%BE%E8%AE%A1%E5%92%8C%E9%AA%8C%E8%AF%81%E5%85%B3%E4%BA%8E%E5%8A%9F%E8%83%BD%E7%9A%84%E4%B8%8D%E5%90%8C%E5%85%B3%E6%B3%A8%E8%A7%92%E5%BA%A6.png" alt="图3.9 设计和验证关于功能的不同关注角度"></p>
<p>断言本身不限定于某一种语言或者工具，它的特性可以准确地描述出设计的预期行为。所以有多种实现断言的方法和工具，在过去的20年间，这些被业界支持的基于断言的验证方法和工具如图3.10所示。</p>
<p><img src="/2022/05/06/29/%E6%94%AF%E6%8C%81%E6%96%AD%E8%A8%80%E7%9A%84%E8%AF%AD%E8%A8%80%E5%92%8C%E5%B7%A5%E5%85%B7%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B.png" alt="支持断言的语言和工具的发展历程"></p>
<p>在这里，我们按照断言方法不同的运用将它们分为如下几类：</p>
<ul>
<li>商业开发的断言IP，可用来插入到HDL中做检查，例如CheckWare（0-In&#x2F;Mentor）。</li>
<li>专门开发的断言语言，例如PSL（Property Specification Language）。</li>
<li>广义的验证模块，不依赖于特定的语言或工具，例如OVL（Open Verification Language&#x2F;Accellera），这些验证库中含有多个常用的验证模块，可用来在设计中例化。</li>
<li>根据广义的验证语言描述而使用其他语言实现的验证库，例如按照OVL实现的QVL（Questa Verification Library&#x2F;Mentor）和 OVA（OpenVera Assertion checker library&#x2F;Synopsys）。</li>
<li>扩展某一种语言的特性，延伸出断言的功能，例如SVA（SystemVerilog Assertion）。</li>
</ul>
<p>可以在验证平台中使用断言，也可以插入到设计中使用断言。<strong>断言可以同时为验证人员和设计人员所用</strong>。使用断言的优势在于以下几个方面：</p>
<ul>
<li>由于断言的位置更贴近于不同功能点的源码位置，这使得相应检查的功能点发生错误时能更快、更清晰地定位出错误源。</li>
<li>断言自身可以表达更长的时序，<strong>覆盖任意长度的功能时序</strong>，这使得它可以在更高的抽象级别描述设计行为。</li>
<li><strong>断言也有覆盖率的功能</strong>，通过断言覆盖率可以建立量化数据来衡量验证进度。</li>
<li>断言可以被直接置入到设计中（无论是设计人员置入还是验证人员置入），这使得断言可以在不同的层次上得到复用，使得它有更久的生命周期和验证延展。</li>
</ul>
<p>这里谈到了断言的复用性，实际上断言的应用场景非常多，且它便捷的即插即用特性使得有多种商业断言 IP 可供植入到验证环境中。下面通过图3.11说明断言应用的场景及其垂直复用的特性。从应用场景来看，典型的断言场景包括：</p>
<ul>
<li>集成连接。例如，片上网络多个发起端和目标端之间的访问路径检查，或者系统集成中各个模块之间的连接关系。</li>
<li>总线协议。针对工业标准总线，有商业验证 IP 可以协助验证设计是否按照总线协议实施。</li>
<li>仲裁机制。仲裁机制中的各种模式通过检查来保证仲裁执行的合理。</li>
<li>数据一致性。对于存储单元，数据的一致性检查可以通过检查端口读写来预期数据的一致性。</li>
<li>数据进出。对于队列设计，也可以建立模型来检查断言。</li>
<li>状态机。检查状态机的跳转是否正常。</li>
<li>输入限定。基于假设的输入限定可以通过断言来判断输入是否符合预期，这对错误源排查也有帮助。</li>
<li>自定义断言。用来检查各个设计的细节，通常这些细节属于设计人员和验证人员关注的功能焦点。</li>
</ul>
<p><img src="/2022/05/06/29/%E6%96%AD%E8%A8%80%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.png" alt="断言的应用场景"></p>
<p>从复用性来看，<strong>断言可以实现从模块级到子系统级再到芯片系统级的垂直复用</strong>。从图3.11可以看出，从单元1在模块级验证时插入的断言“数据进出”和“状态机”，在子系统级和芯片系统级两个环境都可以保持监测检查状态。这一点要<strong>归功于断言可以作为非综合模块被植入到设计中，或者通过绑定的形式嵌入到设计中（不影响设计结构）。在子系统中，新的断言部分“子系统集成”又可以用来检查从单元1与从单元2之间的集成关系，该检查在芯片系统中也可以保留下来</strong>。</p>
<h1 id="2-静态检查"><a href="#2-静态检查" class="headerlink" title="2 静态检查"></a>2 静态检查</h1><p>与动态仿真相对应的是静态检查，它<strong>本身不需要仿真、波形激励，验证人员通过工具的辅助即可以发现设计中存在的问题</strong>。静态检查可细分出更多种类，它们关注的领域各不相同，我们将这些方法概括为：</p>
<ul>
<li>语法检查（syntax check）；</li>
<li>语义检查（linting check）；</li>
<li>跨时钟域检查（CDC,Cross-clock Domain Check）；</li>
<li>形式验证（formal verification）。</li>
</ul>
<h2 id="2-1-语法检查"><a href="#2-1-语法检查" class="headerlink" title="2.1 语法检查"></a>2.1 语法检查</h2><p>如大多数编译器（compiler）自带的功能一样，验证工具<strong>一旦需要建立模型（无论是针对动态仿真还是静态检查的模型），都需要编译器对目标语言提供语法检查</strong>。仿真编译器会帮助检查语法错误，例如<strong>拼写、声明、引用、例化、连接、定义等常见的语法错误</strong>。不同仿真工具对语言标准的解释也可能存在偏差，所以使用不同厂商工具提供的编译器时需注意以下几点：</p>
<ul>
<li>某些不常见的语法使用，在编译器A中可以通过，却不见得在编译器B中也可以通过，这种差别通常跟仿真器的特性和支持有关。如果在设计验证中使用了不同的工具，那么我们要做的应该是让代码（无论是设计代码还是验证代码）满足所有工具的要求，确保它们跟工具<br>之间保持良好的语法兼容。</li>
<li>语言本身有不同年份的标准，所以需在编译过程中注意加注不同的选项。假如编译器默认按照VHDL93标准来编译VHDL文件，那么当显式声明文件为VHDL87格式时，需要额外加注编译选项。</li>
<li>除了语法检查，编译器也提供其他选项来检查设计代码风格是否符合可综合规范。建议在编译时添加这些选项，以帮助检查设计中较明显的漏洞。</li>
<li>值得注意的是，目前 SystemVerilog2012中的标准并没有全部被编译器支持，而且不同工具的支持程度不尽相同。如果准备使用一个较“偏门”的语言特性，在实现它之前可以查看工具支持文档，或者查看编译结果来获知该特性是否被支持。</li>
</ul>
<p>对初步认识仿真工具的人而言，不同编译器对同一项语法错误给出的错误提示可能也不相同。这里我们给出的建议是：</p>
<ul>
<li>认真阅读错误信息。没错，请你认真阅读错误信息。</li>
<li>在认真阅读无果的情况下，可以根据错误信息的代码，通过工具命令结合错误代码来查看错误信息的具体解释。</li>
<li>如果经过前两个步骤仍然无法解决，请找一位有经验的工程师帮你一起检查错误，并且给你一些如何理解错误、查找语法错误点的方法。</li>
</ul>
<h2 id="2-2-语义检查"><a href="#2-2-语义检查" class="headerlink" title="2.2 语义检查"></a>2.2 语义检查</h2><p>和语法检查相比，语义检查是在<strong>设计可行性</strong>上做深入检查的（当然前提也是首先通过了语法检查）。语义检查是通过专用的工具来协助完成的，如0-In（Mentor）和Spyglass。</p>
<p>语义检查的范围包括：</p>
<ul>
<li>常见的设计错误；</li>
<li>影响<strong>覆盖率收敛</strong>的问题；</li>
<li>可能会产生X值以及受其影响的设计部分。</li>
</ul>
<p>进一步细化这些检查项，它们会具体检查以下设计方面：</p>
<ul>
<li>验证收敛性检查<ul>
<li>无法达到的逻辑部分</li>
<li>无法跳转到的状态机状态</li>
<li>无法完成的状态机跳转逻辑</li>
</ul>
</li>
<li>硅效用检查<ul>
<li>寄存器被固定赋值</li>
<li>寄存器未初始化</li>
<li><strong>X值的传播</strong></li>
</ul>
</li>
<li>功能问题检查<ul>
<li>状态机检查</li>
<li>总线检查</li>
<li>case语句检查</li>
<li>数学逻辑检查</li>
</ul>
</li>
</ul>
<p><strong>这些静态检查最大的便捷性在于，可以在早期发现一些功能实现以外的设计问题，而且也有助于完善设计代码，提高有效覆盖率以及RTL与网表的逻辑一致性</strong>（例如寄存器未初始化或者固定赋值）。语义检查最显著的两个优势在于：</p>
<ul>
<li>不需要验证环境。设计人员可以在发布设计版本前用语义工具检查修改设计中的问题，这对在仿真之前扫清基本障碍、保证设计质量很有帮助。</li>
<li>不需要写断言。这与接下来介绍的形式验证有关；<strong>语义检查无关乎设计从功能描述到实现的翻译准确度，所以不需要断言参与进来</strong>。</li>
</ul>
<h2 id="2-3-跨时钟域检查"><a href="#2-3-跨时钟域检查" class="headerlink" title="2.3 跨时钟域检查"></a>2.3 跨时钟域检查</h2><p>大多数复杂的设计都拥有不止一个时钟，<strong>多个时钟之间也常表现为异步的关系</strong>。<strong>设计中的不同功能模块如果被不同的时钟驱动，就会形成不同的时钟域（clock domain）</strong>。单一时钟域模块的设计方式和验证环境较为简单，而拥有多时钟域的硬件，其跨时钟域的逻辑通信就需要<strong>考虑同步问题</strong>。在这里，用来验证这些设计要求的过程称为跨时钟域检查。</p>
<p>需要同步是因为考虑到不同时钟域的信号采样问题，当时钟域A的信号进入时钟域B被采样时，<strong>每个周期都有相对时钟B不同的延迟，这种随机性可能导致建立时间或保持时间无法满足，进而导致不可预期的功能失败</strong>。</p>
<p>这种跨时钟域问题无法通过常规的验证方法来分析，例如动态仿真，也不能被静态时序分析（static timing analysis）判断出来。而这里通过静态的跨时钟域检查就可以分析这一问题。如图3.12所示，通过该方法，可以在早期的 RTL 阶段识别出跨时钟域的通信电路上是否有合适的同步处理，所以，跨时钟域检查（CDC）是为了保证所有信号都能得到正确的同步。目前支持CDC检查的商业工具有Spyglass和0-In（Mentor）等。</p>
<p><img src="/2022/05/06/29/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E6%A3%80%E6%9F%A5.png" alt="跨时钟域检查"></p>
<h2 id="2-4-形式验证"><a href="#2-4-形式验证" class="headerlink" title="2.4 形式验证"></a>2.4 形式验证</h2><p>形式验证分为两种方式：</p>
<ul>
<li><strong>等价检查</strong>（EC,Equivalence Check）。用来保证两个电路的行为是等价的，可用来检查不同抽象级的电路是否一致，例如RTL级和网表。</li>
<li><strong>属性检查</strong>（PC,Property Check），又称为模型检查（MC,Model Check）。电路的行为通过验证语言来描述其属性（property），<strong>随后通过静态方式证明在所有状态空间下都满足该条件，否则举出反例</strong>（counter example）证明设计行为不符合属性描述（property description）。</li>
</ul>
<p>我们这里介绍属性检查，即通过验证语言（PSL、SVA）来描述设计行为，用断言（assertion）结合静态工具进行空间穷举，证明设计行为同属性描述保持一致。属性检查的流程通常如图3.13所示。</p>
<p><img src="/2022/05/06/29/%E5%B1%9E%E6%80%A7%E6%A3%80%E6%9F%A5%E6%B5%81%E7%A8%8B.png" alt="属性检查流程"></p>
<p>在动态仿真验证中，我们是通过生成各种测试序列来访问设计中的状态（state）的，<strong>在理论上，所有可以跳转的设计状态总和被称为可及状态空间</strong>（reachable state space）。遍历可及状态空间的所有状态对动态仿真而言是非常大的挑战，这种通过访问状态、检查结果的方式，<strong>需要覆盖率反馈来衡量可及状态空间还有多少状态没有被访问</strong>。</p>
<p><strong>动态仿真验证的方式实际上很难穷举所有可能的序列去完全覆盖可及状态空间，而形式验证可以通过数学方式来穷举出所有的状态空间，彻底验证设计</strong>。从图3.14可以看到，在仿真过程中，通过随机和覆盖率反馈的形式，可以产生不同的测试序列来访问状态空间，直到发现新的缺陷。这是一种实用的测试办法，但另一方面，动态仿真验证无法确定设计中不存在缺陷，因为图中其他隐藏缺陷依然存在尚未被探索到的状态空间内。</p>
<p><img src="/2022/05/06/29/%E5%8F%AF%E5%8F%8A%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4.png" alt="可及状态空间"></p>
<p>形式验证可以通过数学的方法遍历状态空间，进而证明设计行为符合属性描述。<strong>在遍历过程中，一旦遇到反例，形式验证工具便会停下来，报出反例情景，让用户核对错误是否属实，再考虑修改设计或者进一步约束属性使其更精确地描述设计行为</strong>。从图3.15中可以看到，在大量的状态空间中，形式验证工具只需要针对某一项属性描述举出反例，即可报告给验证人员，而并不需要穷举所有的反例。待设计缺陷被确认、修正之后，验证人员可以继续通过工具来对设计属性进行检查。</p>
<p><img src="/2022/05/06/29/%E5%BD%A2%E5%BC%8F%E9%AA%8C%E8%AF%81%E5%9C%A8%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E4%B8%AD%E5%AF%BB%E6%89%BE%E5%8F%8D%E4%BE%8B.png" alt="形式验证在状态空间中寻找反例"></p>
<p>像上面所讲的将属性描述（由断言构成）与设计结合进行一致性检查的方法，自提出到现在已超过20年了，期间有不同的商业工具提供支持，如OneSpin、0-In和Jasper等。图3.16概括了这些工具的发展历程。</p>
<p><img src="/2022/05/06/29/%E5%BD%A2%E5%BC%8F%E9%AA%8C%E8%AF%81%E7%9A%84%E5%B7%A5%E5%85%B7%E5%92%8C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B.png" alt="形式验证的工具和语言的发展历程"></p>
<h1 id="3-开发环境"><a href="#3-开发环境" class="headerlink" title="3 开发环境"></a>3 开发环境</h1><p>介绍一下验证人员日常编码SV的开发环境。</p>
<h2 id="3-1-Vim开发环境"><a href="#3-1-Vim开发环境" class="headerlink" title="3.1 Vim开发环境"></a>3.1 Vim开发环境</h2><h2 id="3-2-商业SV开发环境——DVT"><a href="#3-2-商业SV开发环境——DVT" class="headerlink" title="3.2 商业SV开发环境——DVT"></a>3.2 商业SV开发环境——DVT</h2><p>在语言编辑和调试的基础上，DVT的测试平台语义检查器（testbench linter）可以通过静态代码分析，发现不合适的语句、代码风格、无用语句、性能问题以及与OVM&#x2F;UVM相悖的使用方式。它可以通过改进验证代码的可靠性和可维护性来协助验证人员更好地完成<br>验证任务。与之相比，普通的编译器往往只会检查代码是否符合语言规范，不会给出代码可靠性和可维护性的报告，也无法进一步给出建议以使代码与方法学保持一致。此外，DVT自带的文档生成器可以用来从代码中的注释自动生成HTML文档。这种方式使得设计验证人员花费更少的精力便可得到一份结构良好的设计和验证文档，文档的内容包含类和成员介绍、继承树、设计结构、UML类图和验证框架等。</p>
<h1 id="4-虚拟模型"><a href="#4-虚拟模型" class="headerlink" title="4 虚拟模型"></a>4 虚拟模型</h1><p>虚拟模型即<strong>高抽象级的硬件模型</strong>，软件模型可依赖虚拟模型在早期开发，并将反馈交给硬件设计。这种反馈在以往的瀑布模式开发周期中是无法实现的，因为软件的开发往往需要等到硬件设计制造完成之后才能展开。通过虚拟模型，硬件可以更早地获取软件反馈而对设计进行修改。这种硬件和软件更紧密的协作方式，可以体现更多的优势，比如利用虚拟模型获取的性能数据可以对硬件早期结构提供参考意见，或者判断硬件和软件的协同任务是否满足功耗目标。在目前多核的手机移动平台上，将不同的任务合理分配到多核上以取得更好性能的需求日益增长，这种软件层面的评估就可以在虚拟建模阶段完成。目前，我们<strong>通过多项虚拟建模的技术例如协同设计、协同仿真和验证，试图在早期发现设计缺陷，以便在相对容易实施的阶段完成这些缺陷的修改</strong>。如图3.17所示，通过这种将设计问题更早暴露出来的方式，可以达到芯片成功流片的目标，满足市场越来越紧迫的窗口需求。</p>
<p><img src="/2022/05/06/29/%E8%99%9A%E6%8B%9F%E5%BB%BA%E6%A8%A1%E7%9A%84%E8%A6%81%E7%B4%A0.png" alt="虚拟建模的要素"></p>
<p>广义的虚拟建模包括一系列的验证技术，如仿真（simulation）、模拟（emulation）和FPGA，而目前的现状是，验证人员往往综合使用这些方法获得更好的效果。在这里，我们<strong>将虚拟模型限定于仿真（simulation），而将模拟和 FPGA 归类为硬件加速技术</strong>，我们将在3.5节详细介绍硬件加速技术。那么，虚拟建模的优点有哪些呢？</p>
<ul>
<li>在早期通过软件测试发现硬件和软件的问题。这种方式可以提前进行软件开发，更早暴露软件和硬件之间的协作问题或功能边界定义不清晰的问题，在模块 RTL 阶段就发现和修改缺陷。</li>
<li>软件反馈进入硅前开发周期。软件和硬件的紧密协作使得软件也参与到了硬件结构定义和实现的工作中。</li>
<li>减少硬件协同软件的验证工作。虚拟模型使得硬件设计有源可寻，同时软件的早期进入也可以帮助硬件完成一些难以通过仿真完成的系统测试。</li>
<li>为用户建立硅前平台模型。早期的系统模型一旦经过软件测试，就可以为用户提供上层开发的环境。</li>
<li>硅后平台的参照模型。硅前平台模型有更多可见的内部结构，这些细节在物理芯片上是观察不到的。</li>
</ul>
<p>虚拟建模是一项不断完善和发展的技术，正被广泛运用到芯片设计验证领域。那么，主要的虚拟建模平台有哪些呢？目前工业界一致推广利用TLM（Transaction Level Models）建立抽象模型，而TLM也已经发展到了TLM 2.0标准。主要的EDA建模仿真工具支持基于TLM 2.0的SystemC和UVM，我们将支持SystemC建模的仿真工具分为下面两种：</p>
<ul>
<li>仿真器（simulator）。它们支持SystemC的编译和仿真。由于SystemC可以纵深硬件抽象度，所以模型既可以拥有TLM端口，也可以拥有硬件信号端口。如果模型在边界上规定了信号时序，那么可以将端口信号添加到波形窗口中查看，也可以通过断点的方式来调试SystemC模型。</li>
<li>专用的虚拟建模平台（virtual prototyping platforms）。这些平台专门服务于虚拟建模和仿真。从抽象级来看，它们的视野显著高于 RTL 仿真；从开发链来看，它们从更早期的产品定义阶段开始。这些虚拟建模平台主要的特性包括结构设计和评测、软硬件之间的权衡分析、早期的性能和功耗评估、软件集成测试、为 RTL 验证提供参考模型。不同 EDA 厂商提供的平台有 First Encounter（Cadence）、Vista（Mentor）和Virtualizer（Synopsys）等。</li>
</ul>
<p>那么在这些平台上，虚拟模型建立的方式是什么呢？实际上，虚拟模型的建立与RTL建模类似，只是抽象层次变高了，或者代码量变少了（但不见得变简单了，这要看逻辑实现的细节程度）。芯片中各子模块对应不同的软件驱动库、应用库，要尽可能在系统建模中囊括各子模块 TLM 模型，这样才会给软件提供更贴近实际的环境（即可以将硅后开发的软件先在虚拟平台上测试）。在虚拟建模平台上，可以通过可视化界面和自动化方式集成已备好的模块。在集成过程中，我们将模型分为两个类别：</p>
<ul>
<li>自建虚拟模型（即对照自定义硬件建立的虚拟模型）；</li>
<li>商业第三方IP（这些虚拟模型IP对应硬件IP模块，完善的商业IP交付包囊括多个设计验证部分，包括RTL、SystemC和验证平台等）。</li>
</ul>
<p>此外，虚拟模型可以作为参考模型参与到RTL仿真中，这种SystemC同RTL的协同仿真模式包括：</p>
<ul>
<li>协同设计（co-design）。将SystemC模型集成到现有的设计当中，作为暂时替代设计的一部分。<strong>对此种设计的要求是，虚拟模型的边界接口应有合适的时序与相邻模块完成信号交互</strong>。</li>
<li>协同验证（co-verification）。将虚拟模型作为参考模型集成在验证环境中，该方法也减轻了验证人员的负担。</li>
</ul>
<p>越来越多的公司应用虚拟建模来尽可能地提前软件开发时间，同时此种方法对现有工作方式提出了挑战，比如团队学习，如何在硬件设计流程引入该方法，如何衡量虚拟建模的长远价值和人力额外投入，如何将虚拟模型团队同设计验证团队整合，等等。这需要团队整体看到它的优势并愿意为之改变，将它的优势更好地发挥出来。</p>
<h1 id="5-硬件加速"><a href="#5-硬件加速" class="headerlink" title="5 硬件加速"></a>5 硬件加速</h1><p>动态仿真和静态检查方法各自具有优势，然而它们都不具备的一个优势是<strong>速度</strong>。尤其是在SoC的设计体量越来越大时，仿真速度成为制约验证进度的重要障碍。由于仿真速度的限制，一些真实的用例无法在RTL级仿真很快地呈现结果，这种困难在硅后软件测试发现问题反馈给硬件团队时更加明显，因为通常这意味着硬件团队需要将耗时（仿真时间）很长的软件进行分析，找到可能的问题点，拆分软件场景，进而在硬件仿真上尝试重现问题。</p>
<p>仿真速度的限制使得无法通过仿真在早期测试软件，这一任务一般交给其他两种方法：</p>
<ul>
<li>虚拟模型平台（virtual prototype platform）；</li>
<li>硬件加速（hardware acceleration）。</li>
</ul>
<p>虚拟模型平台的一项优势是可以<strong>在硬件设计之前建立硬件模型，并通过集成来生成虚拟模型平台</strong>，当然，这也意味着新的工作量和技能学习。</p>
<p>那么，硬件加速的流程是什么呢？<strong>一般需要等到硬件设计初步稳定，进而将其映射到可配置的平台上。设计的数字电路部分可以通过更高的时钟频率（受限的，无法达到真实芯片频率）来仿真，这种方式比RTL仿真速度已有质的提升</strong>，稍后我们比较速度的提升优势。</p>
<p>目前，业界主要的硬件加速方式分为两种，<strong>即FPGA和专用的模拟器（emulator）</strong>。实际上，专用模拟器仍然是基于FPGA的定制产品，只不过比起商用的FGPA（Xilinx、Altera）在硬件加速方面还有其他显著的优点：</p>
<ul>
<li>内部可编程单元网络的连接方式不同于商用FPGA，这使得它在综合布线效率上面显著优于FPGA，而且对内部可编程单元的利用率也高于FPGA。</li>
<li>外部连接的方式不同于FPGA，这使得它可以通过多路复用技术实现片上存储共享，而不再像FPGA一样需要定制的存储器。同时，通过扩大I&#x2F;O引脚数目扩展器件之间的通信带宽，确保模拟器之间的通信速度不成为瓶颈。</li>
<li>智能的数据采集和内置追踪存储器的特性，使被映射到模拟器平台的所有逻辑单元在理论上都是可见的。这种采集方式在一开始建立平台时就可以通过定义采集信号列表来修改内部走线，同时不降低模拟速度。</li>
</ul>
<p>模拟器的这些特点与FPGA可以显著地区分开，在实际工作中，F<strong>PGA和模拟器使用的场景也有所不同。FPGA原型验证主要是针对小型设计或单独的IP，而模拟器则用来面向更大、更复杂的SoC设计。</strong>FPGA主要为软件开发提供平台，而模拟器则是为了硬件和软件协同验证和整个系统的测试。最近10年，模拟平台技术日趋完，使用便利性越来越好，从而越来越多的公司开始考虑使用模拟器。这主要是基于以下因素：</p>
<ul>
<li>更快的平台建立时间；</li>
<li>更快的编译综合时间（从RTL到仿真运行）；</li>
<li>良好的调试条件，如信号可追踪、波形可保存、设置断点等；</li>
<li>模拟器的高存储量、资源可裁剪，同时支持多任务；</li>
<li>通过云端购买使用流量使用远程服务，而不再像FPGA需要一次性购买，降低了开发投入成本；</li>
<li>易于操作。</li>
</ul>
<p>FPGA与模拟器在各方面的对比展示于表3.1中。<br><img src="/2022/05/06/29/FPGA%E4%B8%8E%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="FPGA与模拟器的比较"></p>
<p>目前业界的硬件加速标准并未达成一致，主流的三家公司实现硬件加速的具体技术也各有特点。我们在上面提到的模拟器（emulator），通过将设计逻辑映射到可编程单元的方式，主要有Veloce（Mentor）和 ZeBu（Synopsys）。Veloce 通过定制的可编程单元（非常类似于FPGA）、不同的内部连接网络结构以及透明的可调试电路实现其模拟器功能。平台上的每一块模拟器芯片都可用来模拟一部分的设计逻辑，而整个芯片的功能则通过集成各个模拟器芯片实现片间快速通信。ZeBu不一样的地方在于它直接采用FPGA，而且将透明的可调式电路技术和其他特性实现到FPGA中，多个FPGA进一步组成完整的模拟器功能。Cadence公司的仿真加速器（simulation accelerator）Palladium显得与众不同，作为独立的加速器平台，其内部包含数量巨大的简单处理器，每一块处理器又可以仿真一部分设计逻辑，将运算结果在它们之间传递。看起来，这些处理器的运算速度低于我们的桌面处理器，但由于成千上万个小的处理器并行工作，实际的仿真速率远超独立处理器的表现。同时，这些独立的小型处理器支持透明化的调试方式。</p>
<p>模拟器的高速性能使得其有望同真实世界中的电路交流，但需要注意速率差异的问题。假设我们要设计一个USB器件，可能会将物理层的USB与模拟器相连，进而与计算机或其他器件相连。这时候，我们将模拟器与真实世界的应用器件连接，随之而来的问题是，真实世界的频率高于模拟器的频率。<strong>我们需要为它们之间的频率差异搭建降速同步的桥接（speed bridge），通过主动降低快速端的速度并缓存快速端的数据，适配两端的数据交换</strong>。</p>
<p>如果要将RTL验证平台移植到模拟平台上，<strong>可以将硬件部分迁移到模拟平台，同时将验证环境继续运行在仿真平台一侧，这种方式称为联合仿真（co-simulation）</strong>。硬件的激励由仿真平台或真实世界的接口给入。<strong>硬件加速受到的限制是，它们没有办法像RTL仿真一样透明地观察硬件信号和内部逻辑，也无法随时设置断点调试硬件</strong>。在联合仿真平台中，加速因子最大的受限因素在于仿真平台的运行速度，以及它与模拟平台之间通信的频率。</p>
<p>因此，在构建一个联合加速平台时，需要考虑的是：</p>
<ul>
<li>尽可能地将验证平台实现为可综合的，这样有助于它们被移植到模拟平台上，从而减少模拟平台与仿真平台的通信需求。</li>
<li>如果仍然有一些验证组件无法被移植到模拟平台上，那么需要考虑如何使仿真平台与模拟平台之间的通信速度变得更快，或者使通信次数更少。通过TLM通信方式提高每次通信的信息量从而减少它们之间需要同步的次数，是值得采用的加速方法。</li>
</ul>
<h1 id="6-效能验证"><a href="#6-效能验证" class="headerlink" title="6 效能验证"></a>6 效能验证</h1><p>在 PC 时代，少有人将处理器功耗提上验证的日程，因为大家对处理器性能的关注多于对功耗的考虑。我们十多前年使用2G的功能手机，“超长待机”一词渐渐作为广告主打语进入用户的视线，这得益于硬件本身的低功耗（对性能本身的要求不太突出）和大容量的电池。到了智能手机时代，随着对桌面办公和娱乐的移动化的需求增加，手持设备（手机）需要提供桌面机的性能，这催生了智能手机市场过去几年的蓬勃发展。软件对硬件性能日趋增长的要求，以及移动网络数据传输性能的不断提高，都在促进着硬件性能的革新。在移动时代，硬件提升性能的方式主要表现为以下几种：</p>
<ul>
<li>提升原有处理器性能、存储器空间、数据总线带宽或者采取多核处理方式。</li>
<li>增加额外的协处理单元或新的功能模块（如Video&#x2F;GPU单元）。</li>
<li>在后端允许的情况下提高工作时钟频率。</li>
<li>提升工艺制程。</li>
</ul>
<p>总体上看，随着性能的提升，能耗也会逐步提高，这在过去的PC时代不是一个显著问题，但移动时代越发要求硬件的性能提升，同时要求能耗也可以接受。</p>
<p>本节以移动芯片为例，讨论目前对性能（performance）和效能（power consumption）的权衡。在图3.18中，无线通信技术被标注上了1G、2G、3G和4G。香农定律预测，传输性能每8个月提升一倍；摩尔定律指出，晶体管的单位密度每18个月提升一倍，处理器的性能也因此大约提升一倍。预测指出，电池生产商每10年左右将能源密度提升一倍，而存储器的性能大约每12年提升一倍。那么，从不同器件的性能增长差异来看，这也揭示了移动硬件的技术缺口：</p>
<ul>
<li>处理器和存储器之间的带宽缺口。即处理器的性能同存储器的带宽缺口的差距逐步增大，进而存储性能无法满足运算性能。</li>
<li>效能缺口。传输和运算速率双双大幅提升，使得功耗迅速增长，但由于电池技术受限，使得功耗成为了瓶颈之一。</li>
<li>算法复杂度缺口。传输速率超过运算速率的涨幅，需要更多的处理器来并行完成越来越复杂的算法。</li>
</ul>
<p><img src="/2022/05/06/29/%E7%A7%BB%E5%8A%A8%E7%A1%AC%E4%BB%B6%E9%A2%86%E5%9F%9F%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BC%BA%E5%8F%A3.png" alt="移动硬件领域的技术缺口"></p>
<p>上面讲述的技术缺口与目前硬件提升性能的方式大致保持吻合，接下来主要就如何解决效能缺口入手，讨论目前主流的效能验证方式。</p>
<h2 id="6-1-功率和能量"><a href="#6-1-功率和能量" class="headerlink" title="6.1 功率和能量"></a>6.1 功率和能量</h2><p>首先我们引入基本的概念，功率和能量在日常器件效能讨论中经常会提起，它们是两个关联的术语。</p>
<p>功率&#x3D;能量&#x2F;时间（单位：瓦）</p>
<p>能量&#x3D;功率×时间（单位：焦）</p>
<p>有时候，我们设法降低功率，能耗随之降低，但这不是绝对的，有些任务在高速高功率情况下可以用更短时间完成，而且实际功耗要比在低速低功率情况下更少。例如，<strong>如果静态功耗可以忽略，一个任务需要固定的时钟周期数完成，那么无论时钟快慢，它消耗的能量是一样的；当静态功耗无法忽略时（例如目前最先进的工艺制程已大致在7nm），反倒是时钟更快、功率更高的情况下完成这项任务更高效</strong>。所以，效能的验证和评估实际上就是对能量利用效率的优化途径。</p>
<h2 id="6-2-静态功耗和动态功耗"><a href="#6-2-静态功耗和动态功耗" class="headerlink" title="6.2 静态功耗和动态功耗"></a>6.2 静态功耗和动态功耗</h2><p>从上面的例子我们知道，如果要考虑功耗，需要考虑两部分即<strong>静态功耗和动态功耗</strong>，总功耗如下：</p>
<p><em>总功耗&#x3D;开关功耗+短路功耗+静态功耗</em></p>
<p>这里<strong>开关功耗和短路功耗构成了动态功耗的部分</strong>。</p>
<p><em>开关功耗&#x3D;C·V·V·F</em></p>
<p>其中，C是负载电容，V是电压，F是频率。</p>
<p><em>短路功耗&#x3D;V·I（短路）</em></p>
<p>I（短路）为在开关切换过程中<strong>N极和P极同时有效时发生的短路电流</strong>。</p>
<p><em>静态功耗&#x3D;V·I（漏电）</em></p>
<p>静态功耗（或漏电功耗）则是晶体管在电路稳定时出现的漏电造成的功耗。</p>
<h2 id="6-3-节能技术"><a href="#6-3-节能技术" class="headerlink" title="6.3 节能技术"></a>6.3 节能技术</h2><p>移动芯片节能（省电）技术是全方位的改进流程，从工艺制程到电路、封装到模块设计、SoC 设计、系统和应用软件开发，等等，整个环节都需要有效利用能量。表3.2是从芯片硬件和软件方面所采用的节能技术（省去工艺制程）。</p>
<p><img src="/2022/05/06/29/%E7%A1%AC%E4%BB%B6%E5%92%8C%E8%BD%AF%E4%BB%B6%E9%87%87%E7%94%A8%E7%9A%84%E8%8A%82%E8%83%BD%E6%8A%80%E6%9C%AF.png" alt="硬件和软件采用的节能技术"></p>
<p>与之前介绍过的硬件设计流程类似，节能的设计流程（见图3.19）也是从规划到实施最后到集成的。面对越来越复杂的系统，实用的方式还是从系统设计开始，逐步分解到电路设计，我们先从硬件层面考虑如何实现低功耗设计。</p>
<p><img src="/2022/05/06/29/%E8%8A%82%E8%83%BD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B.png" alt="节能的设计流程"></p>
<h2 id="6-4-效能验证"><a href="#6-4-效能验证" class="headerlink" title="6.4 效能验证"></a>6.4 效能验证</h2><p>这里主要针对硅前设计阶段进行效能验证，涉及的流程分为两部分：</p>
<ul>
<li><strong>功能验证</strong>。主要采用PA（Power Aware）方式，包括UPF（Unified Power Format）和CPF（Comment Power Format）。通过与仿真器结合，模拟电源域的开关进行设计检查。</li>
<li><strong>功耗预测与优化</strong>。使用第三方功耗分析工具，结合仿真数据（FSDB&#x2F;VCD&#x2F;SAIF），进行功耗预测并给出分析结果。</li>
</ul>
<p>PA（Power Aware）效能设计流程</p>
<p>UPF&#x2F;CPF这两种功耗格式较为类似，可以将它们的应用阶段分为4个部分：</p>
<ul>
<li>规定功耗格式文件，指定电源掉电、触发隔离和状态保持等行为，以及它们的控制信号。</li>
<li>RTL仿真（门级仿真也可以支持）除了要保证功能正确，还要进行低功耗逻辑和断电控制功能验证，检查状态丢失、分离和保持。</li>
<li>逻辑功能检查和等价性检查（带有UPF&#x2F;CPF插入的单元）。</li>
<li>逻辑综合和DFT（带有UPF&#x2F;CPF插入的单元）。</li>
</ul>
<p>对于硅前验证阶段，验证人员接触到的主要是RTL仿真。我们一般采取的策略是：</p>
<ul>
<li>进行非效能的RTL仿真（不带PA）。</li>
<li>在RTL功能仿真通过的情况下，进行PA仿真。</li>
<li>在门级仿真阶段，如果时间允许，可以在后期进行门级PA仿真。</li>
</ul>
<h2 id="6-5-功耗预测与优化"><a href="#6-5-功耗预测与优化" class="headerlink" title="6.5 功耗预测与优化"></a>6.5 功耗预测与优化</h2><p>一般我们期望尽早获取功耗的估测信息，而这一期望与芯片开发过程相悖，因为往往在流片以后的软件开发阶段测量出来的功耗是更准确的。但是，<strong>等到流片之后才去测量功耗，低功耗设计的成本就很大了</strong>，这是因为一方面这使我们试错的成本增加，另一方面产品效能优化迭代的周期也变长了。所以，我们希望在硅前设计阶段甚至规划阶段（TLM虚拟模型）估测出芯片功耗，分析出可以降低功耗的设计方法。这里，我们将目光落在RTL和门级阶段，通过现有的功耗设计平台，在早期进行功耗估算、低功耗设计、电源效率提升等事务。</p>
<p>简而言之，目前使用这些工具都是为了查看、估算、分析和降低功耗，通过在 RTL级和门级功耗数据指标和报告，为设计和验证人员提供计算和跟踪功耗的方法。现有的功耗预测分析工具包括PowerArtist（Ansys）、Spyglass Power（Synopsys）、PrimeTime PX（Synopsys）和Redhawk（Ansys）等。我们通过对实际项目中不同工具的比较，提供如表3.3所示的建议。<br><img src="/2022/05/06/29/%E4%B8%8D%E5%90%8C%E5%8A%9F%E8%80%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="不同功耗分析工具的比较"></p>
<p>在硅前验证阶段，目前相对容易做到的是<strong>运用PA设计流程进行相应的RTL仿真和后端流程</strong>。通过仿真器进行 PA 仿真，在保证原有功能实现的情况下，进一步检查低功耗逻辑和断电控制功能。对于功耗预测与优化，有几点因素值得考虑：</p>
<ul>
<li>工具的评估和选择：不同的工具有不同的适应场景和性能。</li>
<li>如何将功耗分析与优化纳入项目流程：对于低功耗芯片设计，功耗分析的方向值得提上项目日程。</li>
<li>如何量化功耗优化成果：一方面需要考虑如何选取合适的测试场景来模拟芯片的实际应用，另一方面也需要<strong>选择合适的仿真时间窗口作为分析的数据来源</strong>。</li>
<li>对比分析不同代芯片的功耗，并给出节省功耗的建议：基于前几代芯片的实际功耗数据，利用功耗估测协助低功耗设计，再通过实际芯片的数据给出反馈，进一步修正估测数据。这种收敛方式有助于更准确的功耗预测。</li>
</ul>
<h1 id="7-性能验证"><a href="#7-性能验证" class="headerlink" title="7 性能验证"></a>7 性能验证</h1><p>在了解效能验证之后，我们来了解性能（performance）验证。性能验证中离不开大量的运算和数据传输。之前提到，<strong>硅前RTL验证的瓶颈之一在于仿真速度，且这一因素到了芯片级仿真阶段被进一步放大</strong>。在产品定义过程中，对系统的运算和数据传输都有要求，在产品实现阶段尽早地得出一些性能有关数据，不但可以帮助提前验证硬件性能是否满足要求，还可以在进度允许的情况下修改硬件设计完善其性能。这种<strong>将性能测试提前的方式也使硅前验证与硅后测试采用一致的测试用例，从而得出可比对的性能数据</strong>。</p>
<p>性能验证用来衡量一个系统在特定工作负载下的响应能力和稳定性，同时性能报告也可以用来分析和优化系统的质量标准，例如可靠性和资源使用能力。性能验证是实用的计算机科学工程方法，在软件工程测试中分类较多，如负载测试（load testing）、压力测试（stress testing）、浸泡测试（soak testing）、尖峰冲击测试（spike testing）、配置测试（configuration testing）和隔断测试（isolation testing）等。</p>
<p>在硅前验证阶段，目前性能验证还是一个新颖的概念，一方面是因为业界对这一测试还没有形成统一标准，另一方面是因为性能验证更多地是在衡量指标，与验证（判断设计是否与功能描述一致）本身的聚焦不太重合。但对一些性能要求严格的硬件设计，我们确实希望在更早期就得出一些数据，最好能够赶上给设计做出反馈并加以完善，以此降低开发成本。所以，这要求我们能够自己先定义出硅前性能验证的目标、环境和方法。</p>
<h2 id="7-1-设定目标"><a href="#7-1-设定目标" class="headerlink" title="7.1 设定目标"></a>7.1 设定目标</h2><p>目前我们对性能验证的考虑主要侧重在<strong>负载测试和压力测试方面</strong>，完成下面的目标：</p>
<ul>
<li>证明系统（或者子系统）的性能是否符合产品要求。</li>
<li>衡量哪一部分的子系统会成为整个系统或者某些特性要求的瓶颈。</li>
</ul>
<p>开始性能测试之前，首先问一问自己“为什么要进行性能验证”，因为只有朝着明确的性能目标前进，才能得出下面的关键测试数据：</p>
<ul>
<li>数据并发量（concurrency）&#x2F;吞吐量（throughput）。测试数据并发量是系统整体性能的考量，因为在某一个时间段，多个子系统会并行工作，共享一些网络和内存资源；测试吞吐量是围绕一条完整的数据通路测算出它的最大吞吐量或传输速率，例如测试USB的传输速率。</li>
<li><strong>响应时间</strong>。这集中体现在处理器访问寄存器和存储器的读写回路延迟，也适用于其他协处理器或者DMA（Direct Memory Access）。</li>
</ul>
<p>在性能验证计划中描述测试方式和场景是一个难点，性能指标应出现在功能描述文档中。在实际项目中，虽然我们不能很好地知道软件使用硬件的场景以及软件如何调度各个硬件模块，但可以先着眼于单个子系统的性能测试，或者通过测试单一的数据链路找到最薄弱的节点，这种方式可以将问题的复杂性降低到可理解并且可描述测试场景的难度。</p>
<h2 id="7-2-测试环境"><a href="#7-2-测试环境" class="headerlink" title="7.2 测试环境"></a>7.2 测试环境</h2><p>如果测试环境贴近用户实际使用的情况，我们得出的数据会更加真实有意义。然而在硅前硬件实现阶段，我们与用户之间存在不小的距离。退而求其次，我们希望<strong>和固件开发团队合作，找到一些典型的子系统应用场景，通过仿真来观察子系统的性能</strong>。为了将测试的成本降低，尽可能选择原有的验证环境，<strong>以动态的环境配置嵌入监视系统性能的组件</strong>。这些组件根据其特征分为：</p>
<ul>
<li><strong>在线监视</strong>（online monitoring）。一般将监视器（monitor）绑定到目标模块或总线上，动态监测目标的运算处理量或数据传输速度。</li>
<li><strong>线下分析</strong>（offline analysis）。将监视到的数据记录下来，通过线下的脚本分析，绘制出性能的波动曲线。</li>
</ul>
<h2 id="7-3-验证方法"><a href="#7-3-验证方法" class="headerlink" title="7.3 验证方法"></a>7.3 验证方法</h2><p>从性能验证流程来看，我们可以考虑参照微软的性能测试方法学流程（见图3.20），它包括以下步骤：</p>
<p><img src="/2022/05/06/29/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E5%AD%A6%E6%B5%81%E7%A8%8B.png" alt="性能测试方法学流程"></p>
<ol>
<li>构建验证环境：一般利用现有的功能验证环境，通过更新使其能够完成性能检测和分析的任务。</li>
<li>决定性能验收标准：在测试前限定反馈时间、吞吐量、资源利用率等验收标准。一般而言，对于硅前测试，我们可以测出反馈时间和吞吐量，而资源利用率是一个系统概念，较难测试。</li>
<li>制定计划和测试用例：需要与系统人员、固件人员一起列出重要的测试场景，同时建立可以衡量性能的标准。</li>
<li>配置测试环境：如果环境足够灵活，可以在回归测试（regression test）中打开或关闭性能检测功能，以此平衡性能测试可能带来的仿真效率降低。</li>
<li>开发用例和测试：开发测试用例，检测带验模块，收集性能检测数据。</li>
<li>分析结果、报告和再测试：分析测试数据，提交性能报告，如果硬件性能与计划的性能之间有缺口，做出硬件修改。再次测试，直到硬件性能符合预期、满足验收标准。</li>
</ol>
<p>如前面提到的，实际项目中的性能测试除了不规范和较难实现以外，还缺少明确的验收标准。这使得不同验证人员编写的测试用例与实际应用各有不同，检查性能的标准也不同。目前，我们通过下面一些形式实现性能验证：</p>
<ul>
<li>在芯片网络结构的端点处（network terminal）绑定总线协议的监测器，以此在网络核心处检测芯片整体的通信情况，计算网络的实时吞吐量，以及单个挂接的子系统的数据传输速率。</li>
<li>将一些 RTL 仿真较为耗时的测试用例迁移到硬件加速平台，利用模拟器来完成性能测试。</li>
<li>为测试用例提供一些宏定义，实现高密度数据传输，以此保证有足够的数据吞吐，来测试数据传输的峰值。</li>
</ul>
<h1 id="8-趋势展望"><a href="#8-趋势展望" class="headerlink" title="8 趋势展望"></a>8 趋势展望</h1><p>目前主要的验证方法包括<strong>动态仿真、形式验证和硬件加速</strong>。如何选择验证方法，是否可以构建一个可复用的验证平台实现不同验证方法的跨越，是接下来我们关心的问题。设计的尺寸和复杂度的不断增长，即使可以利用IP缩短设计时间，但是更多模块之间的互动场景也要求<strong>更充分地验证这些状态空间</strong>。目前仿真技术的瓶颈在于速度，总结这几年项目的切身感受，笔者认为在仿真中，除了需要 EDA 厂商提供加速方式以外，也需要项目自身结合实际情况使仿真实现轻量化，<br>以进一步为仿真提速。</p>
<p><strong>形式验证可以穷尽检验一些设计属性</strong>。对于合适尺寸的IP，只需要一些时间和运算资源，就可以穷尽检验出设计属性是否满足。例如一个32位的乘法器，动态验证可能需要几年的时间穷举出所有可能的情况，形式验证往往几分钟到数小时的时间就可以了。<strong>形式验证随着系统的复杂度提高、状态空间的急剧增长，运行速度也在不断下降</strong>。相比较而言，IP是适合形式验证的设计尺寸。</p>
<p>学术和工业领域对形式验证的算法研究非常活跃，但还需解决的问题是，使用者<strong>对形式验证语言依旧不精通</strong>。<strong>使用者需要保证属性描述精确地反映了设计的功能，同时属性描述的总和能够对应一个设计的所有功能，只有满足了这两点，才有足够信心确信形式验证的完备性</strong>。目前，我们可以通过 EDA 厂商提供的可复用的断言库来实现高层次的属性描述，弥补我们对断言描述本身的知识缺乏。此外，形式验证让我们“不那么放心”的一点是，<strong>它无法像仿真一样为我们提供一个动态的行为</strong>，而验证人员又需要“眼见为实”来亲自判断设计的实际行为是否正确。所以，如果采取形式验证，那么建议的一种方式是<strong>以动态仿真作为辅助手段完成基本的功能检查</strong>。</p>
<p>硬件加速的历史更悠久，可以回溯到20世纪80年代中期到90年代中后期。在RTL仿真还未被推出和广泛使用之前，占据验证市场的还是门级硬件模拟技术。随着 Verilog 和VHDL语言的推出及自动逻辑综合技术的应用，RTL仿真就逐渐取代了硬件加速技术。这一技术更迭的背后，关键因素还是速度，因为那一时期的设计还不足以复杂到仿真器性能无法满足的情况。而在20年后的今天，硬件加速技术显然又有着收复失地的趋势，三大主流工具商都提供各自的硬件加速解决方案。硬件加速的速度优势还是相当明显的。动态仿真的性能平均保持在1kHz，硬件模拟技术大致在1MHz，而FPGA在10MHz左右。无论硬件模拟还是 FPGA，都比动态仿真的速度提高不少。通过更快速的验证技术，我们才有可能抵消设计的复杂度增长和测试代码不断增大的体量。那么，硬件加速技术是不是未来的主流呢？仍然不是绝对的。目前硬件加速技术也有自己的不足，比如：</p>
<ul>
<li><strong>编译时间较长</strong>。硬件加速需要额外的逻辑综合和硬件映射的时间，然而综合、布局、布线和映射在动态仿真中是不必要的环节。</li>
<li><strong>调试手段少且慢</strong>。最新的硬件加速技术可实现记录、修改或等待信号等常用的调试手段，然而由于技术限制，添加或修改新的信号仍然需要再次编译，消耗大量时间。此外，受限于可用的存储量，我们<strong>无法记录所有层次的信号，只能选择性地记录某些信号在某一段时间内的行为</strong>。从调试流程上来看，硬件加速技术仍然无法达到动态仿真的易调试程度。这么看来，尽管在速度上硬件加速有显著的优势，但<strong>动态仿真和形式验证在调试层也有其优点</strong>。</li>
</ul>
<p>那么，实际工作中我们如何选择这些技术呢？一般地，我们倾向于以下方式：</p>
<ul>
<li><strong>在模块级或 IP 级验证中，更多使用动态仿真和形式验证</strong>，尽量将缺陷率曲线更快、更多地收敛在这一层次。</li>
<li>在芯片系统级验证过程中，使用动态仿真测试模块之间的集成关系。</li>
<li>对于耗时长的测试用例，如固件启动测试、性能测试、大规模数据存储测试等，在系统测试阶段使用硬件加速以更快地得到结果。</li>
</ul>
<p>从验证平台搭建和复用的角度出发，需要考虑如何实现一个可以横跨这三种技术的可复用平台。通过一个统一平台，自如地在这三种技术之间实现横向跨越，完成从模块级到子系统级再到芯片级验证的纵向复用，将是接下来实现技术融合和验证复用的方向。</p>
<p>为探讨这一方向，我们就下面两个问题展开论述：</p>
<ul>
<li>不同技术之间的验证平台横向跨越；</li>
<li>不同层次之间的验证平台纵向复用。</li>
</ul>
<h2 id="8-1-技术之间的横向跨越"><a href="#8-1-技术之间的横向跨越" class="headerlink" title="8.1 技术之间的横向跨越"></a>8.1 技术之间的横向跨越</h2><p>在解决横向跨越问题之前，需要理解为什么有这样的需求。从图3.21可以看到，这三种技术之间有着共通的技术桥接、共同的一些核心基础技术：</p>
<ul>
<li>我们的核心基础技术有验证 IP、覆盖率、调试和软件驱动测试。三种验证方法构建于这些基础上，如它们都需要提供调试接口，也需要提供各自的覆盖率来完成验证。</li>
<li><strong>形式验证和动态仿真之间，可以通过断言和 X-prop 技术来桥接，这两种验证方法都可以利用这些技术实施验证</strong>。</li>
<li>在动态仿真和硬件加速之间，可以通过软硬件协同验证的方式实现这两种技术的桥接。</li>
<li>对于断言VIP，可以利用它完成形式验证，或者植入到动态仿真环境中。一些可以综合的断言VIP，也可以移植到硬件加速平台中继续完成验证任务。</li>
</ul>
<p><img src="/2022/05/06/29/%E4%B8%8D%E5%90%8C%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB.png" alt="不同验证方法之间的联系"></p>
<p>那么，如何基于这些项目实际中的桥接设计出可以合并的数据库和通用的验证平台就成为了关键。但对于这两点，目前三大工具厂商还缺乏一种完整的解决方案。例如，验证的覆盖率数据库如何在三种技术中实现互通和合并？如何定义出合理的结构完成形式验证平台到动态仿真平台的复用？什么样的动态仿真平台才可以顺利移植到硬件加速平台上？这些都还是有待解决的问题。</p>
<h2 id="8-2-层次之间的纵向复用"><a href="#8-2-层次之间的纵向复用" class="headerlink" title="8.2 层次之间的纵向复用"></a>8.2 层次之间的纵向复用</h2><p>在不同验证层次之间进行复用，我们也会遇到实际的痛点。例如，随机约束的仿真方法（SystemVerilog,UVM&#x2F;OVM或Specman&#x2F;e）适合于模块级和子系统级验证，而定向测试方法（C&#x2F;C++）则适用于子系统级和芯片系统级的验证过程。在这里，我们看到子系统级验证有两种可能的验证方法，我们需要考虑是选择其中一种还是两者兼具？如何实现模块级随机测试到子系统级随机测试的复用？如何实现子系统级定向测试到芯片系统级的定向测试复用？又比如，通过何种方式实现从随机约束测试到定向测试的复用？只有完成层次之间的垂直复用，验证的时间成本和人力成本才会降低，验证效率才会进一步提高。</p>
<p>面对目前这三种主流验证技术，我们需要从验证效率出发，合理选择使用这些技术，实现技术之间的横向跨越和层次之间的垂直复用，在不断提速的SoC集成设计过程中保持加速，与设计实现共同飞跃。</p>
<h1 id="9-作者结束语"><a href="#9-作者结束语" class="headerlink" title="9 作者结束语"></a>9 作者结束语</h1><blockquote>
<p>关于验证方法，其实在笔者多年的技术世界观中，曾一度认为只有随机测试和形式验证才能拯救设计漏洞。但后来发现，每一种验证方法都有其在各自领域、特定验证场景中的优势。尤其是，SoC在最近几年已经完美地翻越了10亿门的篱笆，让传统的仿真在这样大的庞然大物面前如临大敌。如何解决验证的完备性与速度之间的冲突，已经成为选择验证方法的重要考量标准。项目进度的不断压缩，对硬件和软件联合仿真提出更严格的要求，也为虚拟模型和硬件加速等新兴技术开拓了市场。</p>
<p>本书的主要内容着眼于动态仿真技术。这项技术在过去的20年一直是验证领域的主流，也是读者在验证领域亲密接触的对象。在本书出版的同时，硬件加速技术正以更快的步伐走入验证世界，读者需要对这些验证方法做好准备。</p>
</blockquote>
]]></content>
      <categories>
        <category>IC验证</category>
      </categories>
      <tags>
        <tag>UVM</tag>
        <tag>System Verilog</tag>
        <tag>IC验证</tag>
      </tags>
  </entry>
  <entry>
    <title>芯片验证漫游指南4验证的计划</title>
    <url>/2022/05/08/19/</url>
    <content><![CDATA[<h1 id="1-计划概述"><a href="#1-计划概述" class="headerlink" title="1 计划概述"></a>1 计划概述</h1><p>在选择验证方法和构建验证环境之前，需要搞清楚验证计划是什么。在展开设计之前，设计人员和验证人员会阅读功能描述文档，以理解设计的各项功能为前提，考虑如何实现或验证各项功能。如果功能描述本身不清晰，则需要与系统人员沟通来修改功能描述文档；如果设计和验证双方人员对某一项功能理解有分歧，也需要与系统人员的解释保持统一。完成验证计划后，还需要对其进行修改吗？答案是肯定的。</p>
<p>因为在实际项目执行过程中功能描述文档和设计不断更新，直到流片前都有可能在进行更新，验证人员需要做好相应的验证计划更新。所以，验证计划的生命在设计被构建之前就诞生了，伴随着设计的周期，直到流片。验证计划从创建到执行分为以下几个阶段：</p>
<ol>
<li>创建验证计划；</li>
<li>选择验证方法；</li>
<li>人力资源调配；</li>
<li>构建验证平台和环境组件；</li>
<li>开发测试用例。</li>
</ol>
<p>创建一份验证计划是首要的任务，通过收集下列材料可以更好地组织出有价值的计划：</p>
<ul>
<li>结构功能描述；</li>
<li>设计的各种操作使用模式；</li>
<li>在正常输入和错误输入情形下设计的行为；</li>
<li>设计的接口；</li>
<li>在一些边界情况下设计的行为；</li>
<li>设计在实际使用中的场景描述。</li>
</ul>
<p>这些资料通常可以从硬件功能描述和系统文档中找到。同时，也可以从硅后测试、固件开发人员那里得到设计的实际使用配置情况。合理的验证计划可以为芯片开发带来很多好处：</p>
<ul>
<li>使得设计和验证人员对功能描述文档的理解和翻译保持一致。</li>
<li>将自然语言描述的功能通过可测试的语言来描述。</li>
<li>可以更合理地评估出工作量、人力安排和进度节点。</li>
<li>为验证人员提供清晰的验证目标、任务和进度安排。</li>
<li>为功能文档提供反馈，修改文档中不明确、有歧义的描述。</li>
</ul>
<p>从更宽泛的意义上来看，一份验证计划几乎囊括所有与验证相关的东西，其中不只包括要验证的设计功能，还包括验证方法、人力安排、进度评估，等等。验证计划的生命期很长，在实际环境中，很多因素会不断影响计划的更新，这些可能的因素包括：</p>
<ul>
<li>会有不同人员更新验证计划。一份充分的验证计划，需要系统、设计、验证、软件人员给出意见，共同参与制定。</li>
<li>需要更新上百上千的测试用例，并与计划中的待测功能映射。</li>
<li>考虑选择不同的验证方法。针对不同的设计，<strong>需要考虑选择动态仿真、形式验证或者硬件加速方法</strong>。如果采用两种以上的方法，还需要<strong>考虑如何实现技术平台上的兼容和跨越式复用</strong>。</li>
<li>如果有新的设计要求，需要更新计划，同时设法把对人力和进度的影响降低到最小。设计人员在设计的过程中仍然可能收到新的功能需求，一旦确定要添加新的功能，就需要考虑额外的人力和进度受到的影响。</li>
<li>如果有多个组参与验证，则需要考虑如何协调。对于大型的SoC 项目，一般会有多个功能组参与，甚至他们可能工作在不同的城市，这时，协调组与组之间的工作并综合出整体进度结果就很重要了。</li>
</ul>
<p>在早期制定一份验证计划，随着设计更新和验证进度跟踪，提高验证的质量，降低项目的风险。同时，验证计划对人力和时间进度的合理估计，也使得验证的流程和进度更加透明。</p>
<h1 id="2-计划的内容"><a href="#2-计划的内容" class="headerlink" title="2 计划的内容"></a>2 计划的内容</h1><p>在制定验证计划的具体过程中，我们将技术部分和项目部分都考虑进来。从技术角度而言，需要<strong>考虑的有验证的功能点、验证的层次、测试用例、验证方法和覆盖率要求</strong>。从项目管理角度，也需要考虑使用的工具、人力安排、进度安排和风险评估。</p>
<h2 id="2-1-技术的视角"><a href="#2-1-技术的视角" class="headerlink" title="2.1 技术的视角"></a>2.1 技术的视角</h2><h3 id="验证的功能"><a href="#验证的功能" class="headerlink" title="验证的功能"></a>验证的功能</h3><p>需要验证的功能点来自于功能描述文档，设计和验证人员在阅读文档的过程中，会将设计的功能、参数、性能从自然语言拆分转化为一个个可以单独验证的功能点，并用定性定量的语言描述这些功能。</p>
<p>我们将功能点按照优先级分为：</p>
<ul>
<li>基本功能：通常包括时钟、电源、复位、寄存器访问和基本特性，这些可以在模块级完成验证。</li>
<li>互动功能：一些需要同其他模块互动的特性，需要在更高层次的子系统级或芯片级完成验证。</li>
<li>次要功能：通常这些功能在项目后期完成验证，如性能验证、效能验证。即使它们没有通过验证要求，也不会对芯片造成致命影响。</li>
</ul>
<h3 id="验证的层次"><a href="#验证的层次" class="headerlink" title="验证的层次"></a>验证的层次</h3><p>结合验证的功能点，需要清楚该功能点是否可以在较低的层次完成验证。从验证效率和激励自由度来看，我们应该<strong>尽量在较低的层次验证更多的功能点。在较高的层次，如芯片级，应该侧重于系统集成测试</strong>。</p>
<h3 id="验证方法"><a href="#验证方法" class="headerlink" title="验证方法"></a>验证方法</h3><p>需要考虑采取<strong>何种验证方法，动态仿真、形式验证还是硬件加速？采取什么样的透明度，黑盒、白盒还是灰盒？采用定向测试还是随机约束激励</strong>？在第3章，我们对比了不同方法适用的场景。</p>
<h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><p>有了验证的目标，选择合适的层次和方法，在完成了验证平台搭建以后，我们就需要考虑如何利用验证平台给出适当的激励，检查测试结果。</p>
<h3 id="覆盖率要求"><a href="#覆盖率要求" class="headerlink" title="覆盖率要求"></a>覆盖率要求</h3><p>覆盖率是<strong>衡量激励生成种类和功能点验证的量化指标</strong>。无论通过何种验证方法，都需要采用覆盖率来确保给出了足够多的激励类型，并且设计的边界和内部穷历了可能的状态。除了给出合法的激励之外，<strong>也需要考虑给出一些错误的激励，测试设计的稳定性和纠错能力</strong>。</p>
<h2 id="2-2-项目的视角"><a href="#2-2-项目的视角" class="headerlink" title="2.2 项目的视角"></a>2.2 项目的视角</h2><h3 id="工具选择"><a href="#工具选择" class="headerlink" title="工具选择"></a>工具选择</h3><p>对项目而言，需要通过验证计划中选择的方法考虑选择相应的工具，包括：</p>
<ul>
<li>仿真工具；</li>
<li>形式验证工具；</li>
<li>验证IP；</li>
<li>断言IP；</li>
<li>调试器；</li>
<li>硬件加速器；</li>
<li>高层次验证语言（HVL,High-level Verification Language）。</li>
</ul>
<p>选定验证方法和工具后，接下来需要考虑安排具备合适技能的验证人员完成工作。</p>
<h3 id="人力安排"><a href="#人力安排" class="headerlink" title="人力安排"></a>人力安排</h3><h3 id="进度安排"><a href="#进度安排" class="headerlink" title="进度安排"></a>进度安排</h3><h3 id="风险评估"><a href="#风险评估" class="headerlink" title="风险评估"></a>风险评估</h3><p>在项目执行中，无论是设计人员、验证人员还是项目经理，都面临诸多不确定的因素：</p>
<ul>
<li>芯片结构不稳定因素。在项目执行后期，如果突然面临结构的变化，肯定给相关设计带来很大影响，而验证任务量和时间也需要改变。</li>
<li>工具的不稳定因素。在新的项目中，我们倾向于使用新的工具版本，因为它们会带来新的性能提升和特性；而新版本工具的使用需要适应期，并非一帆风顺。替换工具时面临的工具替换成本、环境流程更新、技术培训都要更大一些。</li>
<li>人力的不稳定因素。我们希望在项目中人员结构可以稳定，这样就不会出现模块的验证人员被临时替换、加大验证风险的问题。同时，如果一个人投入到两个以上的项目，那么他在不同项目中的精力分配也需要考虑进来。</li>
<li>模块交付时间的不稳定因素。验证的展开与设计的交付时间密不可分，HDL 设计的交付时间对验证进度的影响非常大。所以，在计划初期，验证经理应从设计团队那里获取清晰的交付时间，在此基础上做进度和人力安排。</li>
</ul>
<p>在清楚了一份验证计划中需要包含的各项因素之后，接下来就要考虑如何在项目初期准备这样一份关键计划，以及在项目执行过程中怎样针对不确定因素相应地更新计划，确保项目的进度受到的影响最小。</p>
<h1 id="3-计划的实现"><a href="#3-计划的实现" class="headerlink" title="3 计划的实现"></a>3 计划的实现</h1><p>一份细致的验证计划包括项目动向、更新内容和工程进度，面对人力资源总是紧张的窘境，只有清晰的计划才能够合理运用人力资源，保证时间和人力的平衡。在4.2节，我们列举了项目中诸多不稳定因素，它们使得验证计划需要时常保持更新，给出合理的安排，这样的过程就蕴含着从计划到实践再到反馈，最后到修改计划的周期。计划变更的周期在不断地发生，如图4.1所示。</p>
<p><img src="/2022/05/08/19/%E9%AA%8C%E8%AF%81%E8%AE%A1%E5%88%92%E7%9A%84%E5%91%A8%E6%9C%9F.png" alt="验证计划的周期"></p>
<p>在对设计进行验证以后，我们需要<strong>衡量验证的完备性</strong>，这时需要对<strong>覆盖率进行分析</strong>。当发现覆盖率无法满足要求时，要针对覆盖率漏洞更改验证计划并添加新的测试用例。通过这样的反馈环路，循序渐进地逼近功能验证的收敛目标。那么如何制定验证计划呢？通常按照如下步骤：</p>
<ol>
<li>邀请相关人员参加会议；</li>
<li>开会讨论；</li>
<li>确定测试场景；</li>
<li>创建验证环境。</li>
</ol>
<h2 id="3-1-邀请相关人员"><a href="#3-1-邀请相关人员" class="headerlink" title="3.1 邀请相关人员"></a>3.1 邀请相关人员</h2><p>邀请与系统设计和功能模块相关的人员参加会议，共同讨论。参加会议的人员一般包括：</p>
<ul>
<li>设计人员；</li>
<li>验证人员；</li>
<li>硅后测试人员；</li>
<li>软件开发人员；</li>
<li>系统人员；</li>
<li>验证经理（或项目经理）。</li>
</ul>
<p>这些人员在看待如何验证一个模块的问题上各有不同的角度。例如，系统人员关注功能描述是否被实现，测试场景是否可以覆盖到这些功能点；设计人员考虑具体的设计细节是否会被测试到；软件开发人员关心如何配置寄存器来使用某一项功能。我们将这些利益相关者看待验证模块的不同角度总结在表4.1。</p>
<p><img src="/2022/05/08/19/%E9%AA%8C%E8%AF%81%E8%AE%A1%E5%88%92%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BA%BA%E5%91%98.png" alt="验证计划的相关人员"></p>
<p>在实际工作中，我们不一定可以面面俱到地同时邀请到这么多的项目角色，而且，这么多不同的角色一起开会，沟通起来难免存在一些障碍和分歧。所以，实际的建议可以变成分阶段进行：</p>
<ol>
<li>验证经理、设计人员和验证人员一起开会，确定大致需要验证的功能点、进度和人力安排。</li>
<li>系统人员、设计人员和验证人员一起沟通对功能描述文档存在的分歧，确保理解一致。</li>
<li>设计人员、验证人员、硅后测试人员和软件人员一起为模块应用的实际场景添加测试用例。</li>
</ol>
<h2 id="3-2-开会讨论"><a href="#3-2-开会讨论" class="headerlink" title="3.2 开会讨论"></a>3.2 开会讨论</h2><p>在开会讨论前，作为会议的组织者，需要搞清楚开会的目的和议题分别是什么。</p>
<ul>
<li>验证计划的内容组成；</li>
<li>需要确定的验证功能点。</li>
</ul>
<p>同时，需要一份合适的验证计划模板指导会议讨论的内容。验证计划的模板（或组织结构）应包括下面的内容：</p>
<ul>
<li>设计功能简要描述；</li>
<li>硬件实现框图；</li>
<li>待验证的功能点；</li>
<li>验证环境搭建；</li>
<li>测试用例构成；</li>
<li>编译脚本和回归测试；</li>
<li>覆盖率分析。</li>
</ul>
<p>在计划模板中，会议前需要了解的是功能描述和硬件实现方案；开会中只需要讨论和确定哪些功能点是要验证的、哪些是不需要验证的。至于验证环境搭建和测试用例构成，则是验证工作展开以后更新到计划中。面对不同背景的项目人员，我们在会议中需要注意几个方面，以使会议最终可以取得预期的结果。这些值得注意的方面包括：</p>
<ul>
<li>由于与会人员具有不同的背景，在讨论中遇到分歧时，应换位思考，从对方的角度看待这个问题，给予理解。</li>
<li>需要覆盖设计在实际过程中软件的使用情况和在系统中的角色扮演，探明真实运用场景。</li>
<li>弄明白哪些功能是核心功能、哪些功能是次要功能。</li>
<li>确定所有需要验证的功能点，以及声明哪些功能点不需要验证、哪些场景是伪场景（不实际的运用）。</li>
</ul>
<p>只有不同系统层面的人相互沟通，充分交流不同视角和观点，我们对验证功能点及其在系统运用中的认识才会更加清晰。</p>
<h2 id="3-3-确定测试场景"><a href="#3-3-确定测试场景" class="headerlink" title="3.3 确定测试场景"></a>3.3 确定测试场景</h2><p>经过细致的讨论，可以确定哪些功能点需要测试，继而模拟实际场景给出激励。在考虑如何生成测试场景时，我们需要思考下面几个地方：</p>
<ul>
<li>针对某些功能点，我们如何给出特定的测试场景。这些场景是否同实际情况一致或者类似，比如我们给出的时钟信号频率是否同设计要求的频率一致，不同时钟之间的同步异步关系是否参照系统要求。</li>
<li>需要测试的场景，需要待验设计的哪些功能模块参与。这种情况一般在模块级测试中，往往需要较多的子模块参与进来，而随着测试的层次升高，我们需要唤醒使能的模块数量就逐渐减少了。我们在构建测试用例前，心中已经模拟出测试序列，明确了参与进来的模块，以及如何配置寄存器、等待某些状态信号完成下一步功能设置，直到最后完成整个功能测试。</li>
<li>如果一些场景涉及电源开关，要考虑是否在PA（Power Aware）场景中完成测试。</li>
<li>如果一些场景与性能有关，要考虑如何发送大规模的数据量实现压力数据传输场景。</li>
<li>针对不同的功能点，要考虑选择合适的验证层次，以及对应的验证方法。</li>
</ul>
<h2 id="3-4-创建验证环境"><a href="#3-4-创建验证环境" class="headerlink" title="3.4 创建验证环境"></a>3.4 创建验证环境</h2><p>确定测试场景和验证方法后，要<strong>构建验证环境产生激励来实现场景</strong>。构建环境时，<strong>针对设计模块的接口信号需要实现对应的激励发生组件，通过控制协调不同的激励组件来构建场景</strong>。在实现激励发生组件中，需要考虑接口信号是标准总线还是系统控制信号。如果有可以复用的验证资源，那么会节省构建平台的时间。有些时候，如果接口是标准总线，且没有可复用的验证资源，就需要自己实现总线激励模型。从成本的角度来看，只需要实现设计中所纳入的总线特性即可。例如，如果设计实现的是 AHB 总线协议，但是只支持单次的读写访问，那么我们在实现AHB激励组件时，不必要实现AHB协议的全部，而只需要实现单次读写协议，满足设计接口的协议要求即可。</p>
<p><strong>同时要考虑收集数据和对比结果，这就需要监视信号组件和检查组件的实现。监视信号组件的主要任务是监视设计的接口信号以及内部信号。如果是总线接口，那么需要在解析总线的情况下将观察到的数据打包整理；如果是控制信号或者其他信号，要按照信号的定义，在特定事件下捕捉有效信号。监视信号组件最终将分析整理好的数据发送给检查组件，由检查组件进行数据比较，给出比较信息和报告，最终判定测试是否成功</strong>。</p>
<h1 id="4-计划的进程评估"><a href="#4-计划的进程评估" class="headerlink" title="4 计划的进程评估"></a>4 计划的进程评估</h1><p>在验证过程中需要不断地更新验证进度，从各项参数综合评估验证的完备性。通过收集以下信息来评估验证计划的实施进程：</p>
<ul>
<li>回归测试通过率（regression pass rate）；</li>
<li>代码覆盖率（code coverage）；</li>
<li>断言覆盖率（assertion coverage）；</li>
<li>功能覆盖率（function coverage）；</li>
<li>缺陷曲线（bug curve）。</li>
</ul>
<p>接下来分别介绍这些信息的收集和分析过程。</p>
<h2 id="4-1-回归测试通过率"><a href="#4-1-回归测试通过率" class="headerlink" title="4.1 回归测试通过率"></a>4.1 回归测试通过率</h2><p>回归测试表是<strong>将测试设计所有功能点的用例合并</strong>为一个测试集。回归测试表的<strong>主要功能是在设计经过缺陷修复或性能提高后测试原有的所有功能点，确保设计正常工作</strong>。这种往复的测试方式不仅在于确保新的设计变化不影响之前的功能，也可以用来避免修改后的设计对别的模块造成的功能失效。所以，设计的维护不仅按照设计需求提供新的功能，也要保证新功能不影响原有的功能。不同的公司和团队之间，往往有着不同的回归测试工具和方法。这里需要注意的是工具和脚本的版本可能会对回归测试造成影响。例如，如果切换了仿真器的版本，那么可能出现新的问题需要调试，所以在项目后期阶段设计趋于稳定时，不建议切换工具或脚本的版本。另外一个重要的地方是，<strong>回归测试表中的测试用例需确保是可以重现激励场景</strong>的。这一点对于定向测试方法（例如C&#x2F;C++）是容易实现的，而<strong>对随机约束测试而言，要在测试中显示出每次测试使用的随机种子（random seed），只有通过这个特定的种子，才可以重新产生之前的激励，跟踪调试失败的用例</strong>。</p>
<p>我们将回归测试的流程归纳为图4.2。值得注意的是，<strong>在某一个层次的回归测试通过，接下来可以向上迁移到新的验证层次，展开新的回归测试流程；或者在设计需求发生变化时，重新从模块级开始递交测试表</strong>。</p>
<p><img src="/2022/05/08/19/%E5%9B%9E%E5%BD%92%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B.png" alt="回归测试流程"></p>
<p>不同层次的回归测试表，每个测试用例的仿真时间消耗也不一样。一般而言，模块级是最快的，到了芯片级，一个回归测试表如果包含数千规模的测试用例，往往需要若干天时间才能最终运行完毕得出结果。所以，不同层次、不同设计规模、不同测试场景复杂度，都会影响测试用例的仿真时间。递交测试表的重要因素就是仿真速度，由于考虑到递交测试表主要依靠计算资源和验证结构的性能表现，我们对验证平台的优化和运算资源都会在此时提出更高的要求。因为只有更快速地往复递交和得出结果，才能更快得知新的设计变动是否可靠。</p>
<h2 id="4-2-代码覆盖率"><a href="#4-2-代码覆盖率" class="headerlink" title="4.2 代码覆盖率"></a>4.2 代码覆盖率</h2><p>代码覆盖率是用来衡量RTL代码是否被充分运行的指标，目前的仿真器也都提供方法来收集代码覆盖率，并且进行合并和分析。通过回归测试表，我们可以产生基于测试用例的代码覆盖数据，并且在回归测试完成后，通过合并数据，生成总的数据来分析各个模块的覆盖率情况。常见的代码覆盖率包括：</p>
<ul>
<li>语句覆盖率（statement coverage）：指的是程序的每一行代码是否被执行过。</li>
<li>条件覆盖率（condition coverage）：指的是每个条件中的逻辑操作数被覆盖的情况。</li>
<li>决策覆盖率（branch coverage）：指的是在if,case,while,repeat,forever,for和loop语句中各个分支执行的情况。</li>
<li>事件覆盖率（event coverage）：用来记录某一个事件被触发的次数。</li>
<li>跳转覆盖率（toggle coverage）：用来记录某个设计边界信号数据位的0&#x2F;1跳转情况，如从0到1，或从1到0的跳转。</li>
<li>状态机覆盖率（finite stage machine coverage）：仿真器的覆盖率功能可以识别出设计中的状态机部分，记录各种状态被进入的次数，以及状态之间的跳转情况。</li>
</ul>
<p>值得注意的一点是，仿真器在收集覆盖率数据的时候会牺牲一些运行效率，这是因为它需要对代码保持“更多的关注”，所以资源消耗要更多一些。我们建议<strong>只在需要收集覆盖率时传入一些仿真命令触发覆盖率收集，而更多情况下不需要传入这些命令，也不需要编译带有支持覆盖率收集的仿真目标</strong>。在项目执行中，<strong>一般在模块级验证节点结束后开始收集模块级的代码覆盖率，在芯片级验证节点结束后收集芯片级的代码覆盖率。在两部分的数据收集都完成后，进行这两个级别的覆盖率数据融合，生成总的数据库</strong>。一般项目中有专人来负责收集和分析覆盖率，各个模块的覆盖率数据分发给相应的验证人员，等待他们分析、过滤或添加新的测试用例，再次递交测试收集新的数据；以此循环往复，提高总体的覆盖率。</p>
<p>通常，我们比较<strong>关注语句覆盖率、决策覆盖率和跳转覆盖率</strong>，各个模块在这三项覆盖率上有相应的指标。只有至少达到了90%以上的覆盖率，才有足够的信心来分析下面的两类覆盖率。</p>
<h2 id="4-3-断言覆盖率"><a href="#4-3-断言覆盖率" class="headerlink" title="4.3 断言覆盖率"></a>4.3 断言覆盖率</h2><p>断言描述本身支持覆盖率收集，一般通过仿真或者硬件加速的方式收集，也可以通过形式验证的工具收集。在常见的仿真中，仿真器记录断言的先决条件是否被触发，以及判断语句成功还是失败。根据选择的验证方法，我们可以将断言覆盖率分为：</p>
<ul>
<li><strong>基于动态仿真或者硬件加速的断言覆盖率</strong>；</li>
<li><strong>基于形式验证的静态断言覆盖率</strong>。</li>
</ul>
<h2 id="4-4-功能覆盖率"><a href="#4-4-功能覆盖率" class="headerlink" title="4.4 功能覆盖率"></a>4.4 功能覆盖率</h2><p>功能覆盖率衡量是否实现设计的各项功能，且是否按预想的行为执行。功能覆盖率关注设计的输入、输出和内部状态，通常以如下方式描述信号采样要求：</p>
<ul>
<li>对于输入，它检测数据端的输入和命令组合类型，以及控制信号与数据传输的组合情况。</li>
<li>对于输出，它检测是否有完整的数据传输类别，以及各种情况的反馈时序。</li>
<li>对于设计内部，需要检查的信号与验证计划中需要覆盖的功能点相对应。通过对信号的单一覆盖、交叉覆盖或时序覆盖来检查功能是否被触发，以及执行是否正确。</li>
</ul>
<h2 id="4-5-缺陷曲线"><a href="#4-5-缺陷曲线" class="headerlink" title="4.5 缺陷曲线"></a>4.5 缺陷曲线</h2><p>验证过程中会不断发现新的设计缺陷，使用缺陷记录表或已有的商业工具将这些缺陷记录下来，提交给设计人员。设计人员在分析缺陷、修复缺陷后，也会修改缺陷记录，并通知验证人员。验证人员递交原有的回归测试，必要时添加新的测试用例，直到所有的测试通过，才能宣布新修复的缺陷是成功的。在缺陷被记录的过程中，我们通过时间坐标和特定时段的缺陷数量绘制出缺陷率曲线。在1.4节中，我们指出了缺陷曲线对验证计划的影响。从图1.8我们看到，<strong>尽早地将缺陷曲线收敛，意味着后期发现缺陷的数量和可能性越小</strong>。有时要当心的是，如果到了验证后期发现了一个基本功能存在重大缺陷，那就是一个危险信号：意味着很可能在之前验证过程中遗漏了一些重要的测试场景。实际项目的经验重复告诉我们，一份详尽准确、不断更新维护的验证计划是迈向成功验证的基石。</p>
<h1 id="5-作者结束语"><a href="#5-作者结束语" class="headerlink" title="5 作者结束语"></a>5 作者结束语</h1><blockquote>
<p>验证计划的制定不只是需要验证师，还需要其他相关领域的同事共同参与。验证师与验证经理对同一份验证计划的关注角度也不相同。在验证前期，整理好的<strong>验证功能测试点会便于验证的回顾</strong>；在验证中期，<strong>验证环境的结构框图让代码变得更加清晰易懂</strong>；在验证尾期，验证师需要<strong>收集回归测试通过率、代码覆盖率、断言覆盖率、功能覆盖率和缺陷曲线</strong>。这些内容将综合构成验证的量化指标，也让验证经理更容易<strong>评估验证的完备性</strong>。</p>
</blockquote>
]]></content>
      <categories>
        <category>IC验证</category>
      </categories>
      <tags>
        <tag>UVM</tag>
        <tag>System Verilog</tag>
        <tag>IC验证</tag>
      </tags>
  </entry>
  <entry>
    <title>芯片验证漫游指南5验证的管理</title>
    <url>/2022/05/08/10/</url>
    <content><![CDATA[<h1 id="1-验证周期的检查清单"><a href="#1-验证周期的检查清单" class="headerlink" title="1 验证周期的检查清单"></a>1 验证周期的检查清单</h1><p>如果能很清晰地知道一份验证周期的检查清单，那么对每一个项目节点需要做什么、上一个节点跟下一个节点有什么联系、不同节点在整个项目周期有什么作用，就有一个全面的认识。这样，作为验证新手，相信会更好地扮演验证角色。</p>
<p>如果每位验证人员都能充分了解各个验证环节，那么就可以更好地贯彻各项验证任务、保持信息通畅，项目整体的风险毫无疑问降低了。执行验证任务的动力来源于整个团队，验证经理背负的压力也由所有验证人员共同分担了。</p>
<p>所以，无论你担任什么样的验证角色，在执行日常事务时，如果心中已经有一幅通往流片大门的地图，那么整个团队的目标会更加清晰，验证人员同验证经理之间的沟通会更顺畅。接下来，我们一起看一看，验证周期各个关键节点的划分和每个节点需要完成的事情有哪些（见图5.1）。</p>
<p><img src="/2022/05/08/10/%E9%AA%8C%E8%AF%81%E5%91%A8%E6%9C%9F%E7%9A%84%E5%90%84%E4%B8%AA%E8%8A%82%E7%82%B9.png" alt="验证周期的各个节点"></p>
<p>从项目的启动阶段开始，历经RTL验证、门级验证（GLS,Gate Level Simulation）到最终的流片（TO,TapeOut），我们将各个环节分为如下几个环节，各环节的验证任务清单见表5.1～表5.6。</p>
<ul>
<li>RTL0：芯片框架和模块功能定义完成，制定验证的策略。</li>
<li>RTL1：模块和子系统的功能信号定义完成，定制需要的存储模型。</li>
<li>RTL2：完成所有模块的设计，以及80%以上的模块和子系统的验证，核心功能全部完成验证。</li>
<li>RTL3：完成芯片系统的连线集成和验证，覆盖所有的功能验证点。</li>
<li>GLS：完成门级网表的验证。</li>
<li>TO：回顾验证的各项检查清单，最终流片。</li>
</ul>
<p>在这里，我们指出几个需要注意的前提：</p>
<ul>
<li>实际的芯片项目周期跨度要超过上面提到的验证周期，因为它往往会包含RTL0之前的产品可行性调查、项目立项和启动的过程。同时在TO后，仍然需要对硅后测试阶段提供支持，也需要对客户的集成使用提供支持，可能也要准备功能改进后的下一次流片（新的周期）。</li>
<li>不同公司的芯片项目对验证周期的划分和定义可能存在差别，但就芯片验证的一般流程来看，我们上面提到的各个环节是有普适性的。所以，通过进一步详细列举出上面各个环节需要完成的事项，我们对验证的生命周期会有一个全局的认识。</li>
<li>在上面列出的各个环节中，我们主要将注意力放在验证方面，系统定义、设计和后端的事项并没有在这里列出。</li>
</ul>
<p>RTL0的验证任务清单:</p>
<p><img src="/2022/05/08/10/RTL0%E7%9A%84%E9%AA%8C%E8%AF%81%E4%BB%BB%E5%8A%A1%E6%B8%85%E5%8D%95.png" alt="RTL0的验证任务清单"></p>
<p>RTL1的验证任务清单:</p>
<p><img src="/2022/05/08/10/RTL1%E7%9A%84%E9%AA%8C%E8%AF%81%E4%BB%BB%E5%8A%A1%E6%B8%85%E5%8D%95.png" alt="RTL1的验证任务清单"></p>
<p>RTL2的验证任务清单:</p>
<p><img src="/2022/05/08/10/RTL2%E7%9A%84%E9%AA%8C%E8%AF%81%E4%BB%BB%E5%8A%A1%E6%B8%85%E5%8D%95.png" alt="RTL2的验证任务清单"></p>
<p>RTL3的验证任务清单:</p>
<p><img src="/2022/05/08/10/RTL3%E7%9A%84%E9%AA%8C%E8%AF%81%E4%BB%BB%E5%8A%A1%E6%B8%85%E5%8D%95.png" alt="RTL3的验证任务清单"></p>
<p>GLS的验证任务清单:</p>
<p><img src="/2022/05/08/10/GLS%E7%9A%84%E9%AA%8C%E8%AF%81%E4%BB%BB%E5%8A%A1%E6%B8%85%E5%8D%95.png" alt="GLS的验证任务清单"></p>
<p>TO的验证任务清单:</p>
<p><img src="/2022/05/08/10/TO%E7%9A%84%E9%AA%8C%E8%AF%81%E4%BB%BB%E5%8A%A1%E6%B8%85%E5%8D%95.png" alt="TO的验证任务清单"></p>
<p>也许表5.1到表5.6的这一列验证任务清单对你而言还不是那么迫切，但要相信，随着经验和责任的增加，你会越来越意识到一幅验证周期的全视野地图多么重要。如果你需要管理一个验证项目，那么将这些任务清单放在枕边，可以让你在新的挑战面前睡得安稳一些。正所谓不打无准备之仗，“凡事预则立，不预则废”，多一些未雨绸缪，懂得一点“套路”，对一个新人来说不是什么坏事。</p>
<h1 id="2-验证管理的三要素"><a href="#2-验证管理的三要素" class="headerlink" title="2 验证管理的三要素"></a>2 验证管理的三要素</h1><h1 id="3-验证的收敛"><a href="#3-验证的收敛" class="headerlink" title="3 验证的收敛"></a>3 验证的收敛</h1><p><strong>随机验证的方式使回归（regression）测试更加有意义</strong>。一般地，我们基于两种目的提交回归测试表：</p>
<ul>
<li>随机验证环境每次仿真产生的激励序列不同，使得每次仿真均对覆盖率做出贡献，往复递交同样的测试变得有意义。</li>
<li>设计缺陷被发现后，回归测试序列需再次提交，以确保之前的功能点测试无误，同时设计缺陷也被修复。</li>
</ul>
<p>通常，回归测试指的是每次将所有测试用例提交到服务器上运行，并且检查测试结果。这种方法在时间和计算资源上对模块级的回归测试也许是可行的，而对于芯片级，这种方式每次消耗的时间和资源恐怕需要重新考虑。在实际项目中进行回归测试，需要考虑下面的因素：</p>
<ul>
<li>回归流程；</li>
<li>回归质量；</li>
<li>回归效率。</li>
</ul>
<h2 id="3-1-回归流程"><a href="#3-1-回归流程" class="headerlink" title="3.1 回归流程"></a>3.1 回归流程</h2><p>在芯片的开发周期中，通常是从模块级到子系统级再到芯片级，设计、集成和验证都按照这样的步骤。那么采取瀑布集成的方式是否可以完成快速的SoC芯片周期呢？恐怕很难。虽然我们之前列举了不同项目节点的内容，方便项目过程中参考，但实际的窘境是，由于紧张的节点安排，往往是“一波未平，一波又起”。例如，本应该在RTL2之前完成模块级验证工作、在RTL3完成芯片级验证，但实际情况往往是，在RTL2节点上可能只完成80%左右的模块验证工作，其余模块验证工作需和芯片验证工作一同完成。一方面，作为验证经理，需要顶着压力，在RTL2结束后开展芯片验证工作；另一方面需要同时追踪各个模块的验证进度。所以，回归流程没有一致的标准，更多的是要符合实际的项目需求，同时又要在节节落后的情况下保证最终流片能够按时完成。这看起来是一种与项目进度的妥协，但更多地需要验证经理清楚哪些任务是必须在节点前完成、哪些任务可以适当延迟，总体控制风险，如同走钢丝一样，平衡一词始终需要牢记心间。</p>
<p><img src="/2022/05/08/10/%E5%9B%9E%E5%BD%92%E6%B5%81%E7%A8%8B.png" alt="回归流程"></p>
<p>如图5.2所示，接下来让我们看看如何在快速的项目周期中做出合理的回归流程。</p>
<ul>
<li>在模块设计阶段，除了准备验证环境，在验证的基本功能完备之时就应创建一些基本测试用例，并形成一份基本功能回归列表。该列表在RTL2（模块周期）前必须全部通过。</li>
<li>同时，在保证基本功能回归列表时，一些高级、附加功能仍要尽可能多地在RTL2前完成验证。但这些功能可能有部分需要在RTL2和RTL3之间完成验证，所以按照优先级划分的高级功能回归列表也要作为模块验证完成的检查项。</li>
<li>由于在 RTL2节点时可以保证基本功能的正常工作，这一份回归测试表单也使得在RTL3开始时进行的芯片集成工作得到保证。完成集成后，各个模块之间的互动也可以初步完成测试。此时，各个模块同其他模块的通话依赖于这些基本功能的测试表单。</li>
<li>在RTL2与RTL3之间，完成模块级的高级功能验证后要反复提交回归测试列表，通过大规模的随机测试来检验设计的稳定性，并完成覆盖率收集。</li>
<li>模块功能验证必须在RTL3之前完成，芯片级验证则要在门级仿真之前完成，并尽可能减小落后于节点的差距。这样才会留给后端部门稳定的设计（出现更少新的缺陷）来做物理实现，为门级仿真尽早提供网表和时序反标文件（timing back-annotation）以便开展门级仿真。</li>
</ul>
<p>那么在以上流程中出现了缺陷该怎么办呢？应该遵循的原则是：</p>
<ul>
<li>选择更小的验证环境、给出更少的变量，实现更容易调试的环境。具体而言，在芯片级遇到缺陷，可以在模块级验证则优先在模块级验证，同时尽量缩小配置的变量数目，以此重现错误场景。这种方式更有利于错误定位和缺陷修正。缺陷修复后，可以在更小的验证环境中重复之前的测试，确保之前出错的场景通过。</li>
<li>缺陷完成修复后，仍要分别进行模块级验证和芯片级验证的回归测试表。确保除了缺陷修复之外不引入新的缺陷，所有之前测试通过的功能仍然可以正常工作。</li>
</ul>
<h2 id="3-2-回归质量"><a href="#3-2-回归质量" class="headerlink" title="3.2 回归质量"></a>3.2 回归质量</h2><p>在软件的迭代开发中，除了保证测试质量还要通过单元测试保证设计在每次提交之后（版本更新或缺陷修复）完成设计的自我检查，以便在提交给验证人员之前保证基本功能通过，减少明显设计错误带来的设计与验证人员之间的额外沟通和时间消耗。这种有效的方式越来越广泛地运用到芯片验证过程中。提高回归质量的策略在图5.3中给出。</p>
<p><img src="/2022/05/08/10/%E6%8F%90%E9%AB%98%E5%9B%9E%E5%BD%92%E8%B4%A8%E9%87%8F%E7%9A%84%E7%AD%96%E7%95%A5.png" alt="提高回归质量的策略"></p>
<p>每次完成芯片设计后，可以通过回归测试工具将设计、验证环境的编译、仿真、结果检查集成为一体，也可以通过一些简单的命令由设计者先查看基本功能是否正常工作。只有在保证基本功能回归列表测试完成以后，我们的版本管理工具才会允许设计文本的签入（check-in），同时通知验证人员设计的更新，由验证人员展开其他高级功能或者更高层次的验证工作。之前提到，如果验证人员发现了缺陷，在缺陷修复后，设计人员应先通过基本功能测试再递交给验证人员。验证人员需要做的是，检查之前错误的场景是否可以通过，同时创建专门针对该缺陷的基本测试来更有目的地完成验证。在这些激励确定性（determinacy）较明显的测试完成之后，我们也会给出更宽松的激励，对设计产生更丰富的测试场景。通过随机回归测试，我们可以在每次回归测试完成之后收集覆盖率，分析一些功能点覆盖漏洞，在下一次回归测试开始之前，有意地偏置（biasing）调整随机约束，使产生的激励更有可能填补那些功能点漏洞。</p>
<p>除了随机测试以外，我们<strong>也会通过形式验证的方式来完成验证</strong>。我们提供的多种属性检查分为基本功能属性和高级功能属性，这种简单的分类可以保证设计每次提交以后首先保证基本功能属性，而高级功能属性的验证由验证人员完成。同时，覆盖率也可以在形式验证中收集，并且和其他动态仿真的覆盖率数据实现合并和分析。随机测试的回归序列若要实现更高的覆盖率，就要运行多次。这种方式使得覆盖率收敛曲线随着回归往复的次数而提高，但是该方式非常消耗运算资源和时间。在通过回归方式完善功能覆盖率和检查设计功能时，建议将它们区别开来。比较合理的方式如下：</p>
<ul>
<li>在前期设计不稳定的情况下，主要定向提交一些测试用例来快速检查功能是否通过。</li>
<li>在设计比较稳定后，可以规划用时较短、测试场景较简单的用例，检查核心功能点是否通过。</li>
<li>在设计后期，应一方面实现复杂场景，另一方面大量提交回归测试表来完善功能覆盖率。</li>
</ul>
<h2 id="3-3-回归效率"><a href="#3-3-回归效率" class="headerlink" title="3.3 回归效率"></a>3.3 回归效率</h2><p>回归测试是一种确保设计功能通过的稳妥手段，方便操作管理，也可以提升覆盖率。在追求验证完备性的同时，回归测试的效率问题越来越受到重视。回归效率的现状考量基于以下几个方面：</p>
<ul>
<li>在模块验证阶段，随机测试方式使得倾向于反复提交测试表来产生各种可能场景，到了后期，覆盖率难以更多提升。那么<strong>如何精细控制随机约束，使每次回归测试总有新增覆盖率的收获，是要深入解决的问题</strong>。</li>
<li>在设计缺陷得到修复后，如何快速检查设计基本功能，保证设计版本提交的质量，进而转移到验证人员一侧，提升沟通效率，这也需要设计合适的回归表。</li>
<li>在芯片级验证阶段，由于测试用例时间明显加长，每次回归整个测试表（数以千计的测试用例）耗时极长。由于芯片级测试更多地是基于C的验证，在项目后期集成改动较小的情况下，反复回归的收益明显降低，而验证管理又需要这样的数据，这种矛盾也需要化解。</li>
</ul>
<p>基于以上考虑，在日常工作中，建议采取以下办法提升回归效率：</p>
<ul>
<li><strong>在可实现的情况下，考虑切分测试场景，将一个长的测试序列切分为多个序列，并为其创建多个测试用例</strong>。这么做的好处是避免过于冗长复杂的测试，划分为多个用例可以实现并行提交测试，用计算资源换来时间的节省。</li>
<li>对一些较难切分测试向量的场景，例如芯片级仿真需要首先完成上电、复位、时钟使能，同时芯片处理器需要完成初始化、搬运执行代码的过程，可以<strong>考虑通过快速跳转到特定状态来实现缩短测试时间的要求</strong>。</li>
<li>针对第二条所描述的特定状态，即一些需要通过长时间运行来到达某一状态的测试，我们建议分为两个阶段。第一阶段检查跳转到该状态的条件是否满足，进而检查状态跳转。一旦第一阶段被验证通过，我们就可以让其余用例省略第一阶段，即通过直接初始化到该特定状态来节省时间，例如强行置位硬件寄存器、状态位等方式，使设计快速跳转到某一状态，缩短验证时间。</li>
<li>尽可能给予充分的计算资源。目前用于仿真的普遍方式是，中心化的服务器群提供计算和数据存储资源，通过资源分配管理实现充足的并行运算资源，使回归测试表尽快执行完毕。</li>
</ul>
<p>从对回归测试的流程、质量和效率的论述可以发现，智慧合理的回归测试方式有利于设计的发布质量和快速稳定。</p>
<h1 id="4-让漏洞无处可逃"><a href="#4-让漏洞无处可逃" class="headerlink" title="4 让漏洞无处可逃"></a>4 让漏洞无处可逃</h1><p>3节提到如何快速有效地进行验证收敛，即利<strong>用回归测试表产生更多复杂场景和提高验证的覆盖率</strong>。在验证收敛的过程中，无论你是验证人员、设计人员还是系统人员，都不可避免地会遇到一个问题，那就是——检测出了漏洞，应该怎么办？<br>设计漏洞较易理解，因为一旦验证环境的参考模型与硬件设计的结果产出不一致，且最终分析得出设计并未完全遵循硬件功能描述时，那么设计漏洞便被发现了；而在验证的过程中，如果发现了硬件的问题，且最终回溯到硬件设计有遗漏并不完善的时候，硬件设计描述便产生了一个漏洞；容易被人忽视的是，发现验证环境的漏洞以后，经常是由发现者提交问题邮件、由环境构建者检查并最终确认和修改漏洞，这种局部的方式可能造成更多不知情的验证人员被该问题阻碍，或者新的项目仍然会重复之前的陷阱。所以，<strong>验证环境的漏洞（一般属于芯片级验证环境）也需要被记录</strong>；后期门级仿真中因综合时序不满足采样条件导致的门级验证失败，也需要将时序问题予以追踪，这种方式会提醒后期项目着重关注一些较长的或较难处理的时序路径，进行有针对性的优化。验证过程中还会遇到别的问题，如仿真工具问题、标准单元设计库问题、第三方IP问题，等等。</p>
<p>我们可以总结出，发现问题后进行跟踪的基本依据是：如果该问题明显影响项目进度，或者影响大范围的群体，或者对后续项目造成影响，就要记录这些问题并跟踪它们的解决情况。如果在项目实施中（这里专注在硅前验证阶段）发现了满足上述情况的问题，也要记录下来。在这里，我们将问题追踪分为下面的几种类型：</p>
<ul>
<li>系统功能定义问题；</li>
<li>硬件设计问题；</li>
<li>芯片验证环境问题；</li>
<li>综合时序问题；</li>
<li>硅前工具问题；</li>
<li>引用库和IP问题。</li>
</ul>
<p>对硅前问题进行分类后，接下来要将它们记录到合适的数据库中。该数据库不但要记录问题，还要起到分类、派发、查找、追溯、报告的作用。芯片设计项目除了在执行过程中参考软件项目的构建、分块、依赖路径、决策的方法，也在问题追踪上借鉴软件开发的方式。软件开发更早地使用标准化的问题追踪工具来执行项目，随着芯片开发的进度逐渐加快，一些商业的或免费的问题跟踪工具进入了芯<br>片开发的视野，例如以下这些问题追踪工具：：</p>
<ul>
<li>商业工具: Team Foundation Server（Microsoft）,JIRA,Rational ClearQuest（IBM）,HP Quality Center（Hewlett-Packard）。</li>
<li>开源工具： Bugzilla（Mozilla）,Redmine,Trac（Edgewall）,Mantis。</li>
</ul>
<p>这些问题追踪工具一般具备下面的功能：</p>
<ul>
<li>记录：需要记录的内容有问题标题、内容、出错场景、背景描述、发布版本、测试用例和相关文件等。</li>
<li>分类：归属于哪个项目、哪个环节（系统、设计、验证还是其他）、哪个模块以及问题严重性（致命、重要、中级、改进）。</li>
<li>派发：在跟踪系统中，问题一旦提交，它的生命周期即开始。接下来由管理层指定问题回顾和修复的人员，再转由下一位问题持有者完成所需做的环节，继续指定问题的下一位持有者。在后面的问题跟踪流程中将详细介绍这一问题。</li>
<li>查找：遇到漏洞时，除了与漏洞相关人员沟通之外，在提交问题之前还要利用问题追踪工具数据库提供的查询功能判断，该问题以前是否发生过、有无解决方法；我们可以很方便地利用问题独一无二的ID编码在工具搜索栏中快速调出该问题的背景和进度。</li>
<li>追溯：问题从被提出到被派发、解决、验证和最终关闭，在一个项目中走完它的生命周期，但不排除它可能在下一个项目中“复活”。造成问题复活的可能因素有很多，比如问题重新发现、原解决方案不再满足、新项目继承上一个项目时一些问题修复没有被集成进来仍然需要再次修复，等等。所以，问题追溯的好处在于，可以看到同一个“顽固”的问题是如何在不同的项目之间（尤其是多个并行项目中）产生的。</li>
<li>报告：谁最喜欢看报告？当然是管理层！他们时间有限，若不能深入前线听到枪响、嗅到火药味，那么对他们而言，看到一份数据健全、有内容的报告必不可少。问题追踪工具从项目周期开始统计出多个维度的数据，如常见的设计问题提交、修复、验证和关闭趋势图，从这张图可以看出项目执行的健康状况；又如硬件设计缺陷提交曲线图，若曲率到项目后期仍居高不下，可能意味着结构性的严重错误，由此进一步导致项目延期乃至调整硬件结构。</li>
</ul>
<p>了解问题追踪工具基本的功能之后，还要清楚如果在项目工作中发现问题，如何使用工具来提交、跟踪、修改和验证这个问题，状态之间的跳转通常在什么情况下发生。图5.4是针对硅前芯片开发流程的，实际上，问题跟踪周期要比这个状态更长，还包括了硅后测试周期。在这里我们集中在硅前芯片开发阶段，来依次解释各个状态的表征以及状态之间的跳转条件。</p>
<p><img src="/2022/05/08/10/%E9%97%AE%E9%A2%98%E8%BF%BD%E8%B8%AA%E6%B5%81%E7%A8%8B.png" alt="问题追踪流程"></p>
<p>新的问题：在项目执行中发现一个新的问题，当它带来的影响满足提交的基本依据时，就要在问题追踪工具中提交这个问题，填写相应的内容，这对应步骤1。接下来，提交者将问题派发给需要解决问题的所有者。如果所有者发现该问题不属于他的模块，那么他应将该问题派发给真正的问题所有者，即步骤2。问题所有者进行研究，确定属于系统结构、设计或者验证问题，然后他可能进入开始状态，修复问题，即步骤3；如果问题所有者分析发现他的模块并不会导致该问题，问题是由其他模块引起的，那么他可以将状态重新修改为新的问题，即步骤4。该问题之前已经被发现过，则将状态修改为重复状态，即步骤5，同时需要备注已经提交相同问题的 ID 号，用来追溯该问题。该问题如果不严重影响项目进度且不是致命问题时，要同管理层商讨。假如最终确定有软件方法或其他修补方法时，可考虑修改为延后状态，即步骤6，待后续项目进行时，可以重启该问题。如果问题所有者发现该问题实际上已经在新的发布版本中修正，他可以将状态修改为解决状态，即步骤7。</p>
<p>开始：当问题开始进入修复过程时，问题所有者经过研究并做出修正，同时将问题修改为解决状态，即步骤8。在这一状态中，问题所有者仍然有可能将状态修改为重复或者延后，即步骤9和步骤10。</p>
<p>解决：问题修复后，问题所有者将该问题派发给验证人员。例如，设计人员派发给验证人员要求测试漏洞是否修复成功，系统人员派发给设计人员要求检查功能描述是否与设计相符等，这一过程即是图5.4的步骤11。</p>
<p>验证：问题得到修复和验证后，问题再次派发给当初的问题提交者或管理人员，由他们将状态修改为关闭状态，即步骤12。</p>
<p>关闭：问题关闭之后，问题的提交者如果在回顾问题时发现问题没有完全解决或者再次遇到此问题时，他可以重启问题，即步骤13。</p>
<p>重启：问题得到重启后，问题所有者需再次进入问题，检查新的问题场景，经过研究后</p>
<ul>
<li>如果问题仍然需要再次修复，则进入开始状态，即步骤14。</li>
<li>如果问题的场景需要另外的软件配置，或者已经修复，则可转入解决状态，即步骤15。</li>
<li>如果问题受限于实际，暂时无法修复需要延迟，则需要步骤16。</li>
</ul>
<p>以上各个状态以及状态之间的跳转，符合一般芯片开发中的问题追踪流程。从流程的细节中可以发现，问题追踪管理的特点是：</p>
<ul>
<li>符合实际工程应用，状态之间的跳转合理。</li>
<li>问题一旦提交即有两方——提交者和所有者，且这种状态一直持续到问题的生命周期结束，即关闭状态。</li>
<li>追踪工具可以满足工程师和管理者的需求，让双方共同参与，深入记录第一线的资料（问题描述、解决方法、验证方案），同时提供整个项目的执行状态。</li>
<li>管理者并不需要在问题的生命周期内全程参与，他可以随时介入，但更多的状态跳转只需要由工程师执行。这样减轻了管理者的负担，为他们留出时间统揽全局。</li>
</ul>
<p>至此，我们将问题追踪的需求、分类、工具和流程介绍完毕。有了团队间的协作，接下来我们将进入“人”的环节，看一看如何在长、中、短期建设验证团队，使验证团队成为公司的宝贵财富。</p>
<h1 id="5-团队建设"><a href="#5-团队建设" class="headerlink" title="5 团队建设"></a>5 团队建设</h1><h1 id="6-验证师的培养"><a href="#6-验证师的培养" class="headerlink" title="6 验证师的培养"></a>6 验证师的培养</h1><h1 id="7-验证的专业化"><a href="#7-验证的专业化" class="headerlink" title="7 验证的专业化"></a>7 验证的专业化</h1><h1 id="8-作者结束语"><a href="#8-作者结束语" class="headerlink" title="8 作者结束语"></a>8 作者结束语</h1><blockquote>
<p>我们所处的时代对中国的IC行业而言可谓是黄金时代。在国家战略和市场需求的双重引导下，中国集成电路的产业规模持续扩大，发展质量不断提高，基础更加坚实。与快速发展的行业形势相比，国内的集成电路人才培养不容乐观。据估计，如果2020年芯片设计业达到4000亿元人民币产业规模，那么设计业的从业人数要从2017年的13万增长到2020年的28万，这中间存在着巨大的技术人才需求缺口。同时我们还要考虑到，“十年树木，百年树人”，人才培养并非朝夕之功。目前高校的集成电路类教育，面临着象牙塔教育与企业需求脱节的问题，给企业带来额外的时间和金钱上的培训成本。</p>
<p>笔者认为，结合目前国内的高等教育现状，较为可行的方式是将IC验证教育从研究生教育扩展到本科生教育。以本书的内容为例，它将验证的核心内容与虚拟的项目案例相结合，既有基础知识也有高阶知识，以培养人才的动手能力为目标，最终满足企业的用人需求。将芯片验证教育拓展到本科生教育，也可以减少本科生毕业后因就业不顺利而不得不放弃专业的尴尬现状。笔者相信，只要我们不断提升高校的IC教育质量，芯片验证的本科化教育一定能够为企业输送更多合格的IC人才，这也是本书希望推动的一件事情。</p>
</blockquote>
]]></content>
      <categories>
        <category>IC验证</category>
      </categories>
      <tags>
        <tag>UVM</tag>
        <tag>System Verilog</tag>
        <tag>IC验证</tag>
      </tags>
  </entry>
  <entry>
    <title>芯片验证漫游指南6验证的结构</title>
    <url>/2022/05/08/42/</url>
    <content><![CDATA[<h1 id="1-测试平台概述"><a href="#1-测试平台概述" class="headerlink" title="1 测试平台概述"></a>1 测试平台概述</h1><p>测试平台（testbench）是整个验证系统的总称，包括<strong>验证结构中的各组件、组件之间的连接关系、测试平台的配置和控制</strong>；从更系统的意义来讲，<strong>还包括编译仿真的流程、结果分析报告和覆盖率检查等</strong>。狭义上我们主要关注验证平台的结构和组件，它们<strong>产生设计所需的各种输入，并在此基础上进行设计功能的检查</strong>。我们首先给出经典的测试平台结构，如图6.1所示。可以看到：</p>
<ul>
<li>各个组件之间是相互独立的；</li>
<li>验证组件与设计之间需要连接；</li>
<li>验证组件之间需要进行通信；</li>
<li>验证环境需要时钟和复位信号的驱动。</li>
</ul>
<p><img src="/2022/05/08/42/%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="测试平台结构图"></p>
<p>从实现语言看，验证平台经过多年的需求变化，常用的语言有VHDL、Verilog、Open Vera、e、System C、C&#x2F;C++、SystemVerilog等。测试平台对不同语言的使用趋势可以从图3.5看到，近年来SystemVerilog的使用比例明显占据主导地位，我们会在日后的SystemVerilog部分介绍它的主要特性，通过对比不同的语言，体现它在验证领域的优势。此外，对 SystemC 和C&#x2F;C++在验证部分的应用，我们也会在验证方法的高级应用部分进行介绍。对于验证师而言，构建一个验证平台，除了对设计有充分了解之外，还要考虑在平台上给出更丰富完备的测试场景，并使验证组件针对丰富的激励可以做出细致的判断，最终分析设计的功能是否符合硬件描述。</p>
<p>接下来，我们将围绕<strong>设计实例MCDF进行介绍，包括它的结构、功能、时序描述</strong>。作为验证工作展开的第一步，我们有理由相信只有对设计结构足够了解，才能进行验证结构的规划和搭建。</p>
<h1 id="2-硬件设计描述"><a href="#2-硬件设计描述" class="headerlink" title="2 硬件设计描述"></a>2 硬件设计描述</h1><p>为了模拟实际情景，我们给出贯穿于SystemVerilog和UVM章节的硬件设计MCDF，并且遵循硬件设计描述的方式，<strong>介绍它的结构、功能、寄存器和时序</strong>。在以后的 SV 和 UVM部分中，我们也将围绕这个硬件设计来考虑测试平台的构成。日后对测试平台的构建论述，需要经常引用MCDF的功能描述，请读者注意这一点。同时，熟悉硬件描述的方式是进入验证领域的一项基本技能。那么，我们就从这个规模适中的设计开始了解。</p>
<h2 id="2-1-功能描述"><a href="#2-1-功能描述" class="headerlink" title="2.1 功能描述"></a>2.1 功能描述</h2><p>我们称该设计为<strong>多通道数据整形器</strong>（MCDF,Multi-Channel Data Formatter），它可以将多个通道的上行 uplink）数据经过<strong>内部的FIFO以数据包（data packet）的形式送出</strong>。上行数据和下行数据的<strong>接口协议不同</strong>，我们将在后面的接口描述和时序部分进一步讲解。多通道数据整形器有寄存器的读写接口，可以支持更多的控制功能。</p>
<h2 id="2-2-设计结构"><a href="#2-2-设计结构" class="headerlink" title="2.2 设计结构"></a>2.2 设计结构</h2><p>图6.2所示为MCDF的设计结构，主要分为如下几部分：</p>
<ul>
<li>上行数据的通道从端（<strong>Channel Slave</strong>）：负责接收上行数据，并存储到其FIFO中。</li>
<li>仲裁器（Arbiter）：选择从不同的 FIFO 中读取数据，将数据进一步传送至整形器（Formatter）。</li>
<li><strong>整形器</strong>（Formatter）：将数据按照一定的接口时序送至下行接收端。</li>
<li>控制寄存器（Control Registers）：<strong>有专用的寄存器读写接口，负责接收命令并修改MCDF的功能</strong>。</li>
</ul>
<p><img src="/2022/05/08/42/MCDF%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84.png" alt="MCDF的设计结构"></p>
<h2 id="2-3-接口描述"><a href="#2-3-接口描述" class="headerlink" title="2.3 接口描述"></a>2.3 接口描述</h2><h3 id="1-系统信号接口"><a href="#1-系统信号接口" class="headerlink" title="1.系统信号接口"></a>1.系统信号接口</h3><ul>
<li>CLK（0）：时钟信号。</li>
<li>RSTN（0）：复位信号，低位有效。</li>
</ul>
<h2 id="2-通道从端接口"><a href="#2-通道从端接口" class="headerlink" title="2.通道从端接口"></a>2.通道从端接口</h2><ul>
<li>CHx_DATA（31:0）：通道数据输入。</li>
<li>CHx_VALID（0）：通道数据有效标志信号，高位有效。</li>
<li>CHx_READY（0）：通道数据接收信号，高位表示接收成功。</li>
</ul>
<h3 id="3-整形器接口"><a href="#3-整形器接口" class="headerlink" title="3.整形器接口"></a>3.整形器接口</h3><ul>
<li>FMT_CHID（1:0）：整形数据包的通道ID号。</li>
<li>FMT_LENGTH（4:0）：整形数据包长度信号。</li>
<li>FMT_REQ（0）：整形数据包发送请求。</li>
<li>FMT_GRANT（0）：整形数据包被允许发送的接收标识。</li>
<li>FMT_DATA（31:0）：数据输出端口。</li>
<li>FMT_START（0）：数据包起始标识。</li>
<li>FMT_END（0）：数据包结束标识。</li>
</ul>
<h3 id="4-控制寄存器接口"><a href="#4-控制寄存器接口" class="headerlink" title="4.控制寄存器接口"></a>4.控制寄存器接口</h3><ul>
<li>CMD（1:0）：寄存器读写命令。</li>
<li>CMD_ADDR（7:0）：寄存器地址。</li>
<li>CMD_DATA_IN（31:0）：寄存器写入数据。</li>
<li>CMD_DATA_OUT（31:0）：寄存器读出数据。</li>
</ul>
<h2 id="2-4-接口时序"><a href="#2-4-接口时序" class="headerlink" title="2.4 接口时序"></a>2.4 接口时序</h2><p>通道从端接口时序见图6.3。当valid为高时，表示写入数据。该时钟周期ready为高，表示已经将数据写入；该时钟周期ready为低，需等到ready为高的时钟周期才可以将数据写入。</p>
<p><img src="/2022/05/08/42/%E9%80%9A%E9%81%93%E4%BB%8E%E7%AB%AF%E6%8E%A5%E5%8F%A3%E6%97%B6%E5%BA%8F.png" alt="通道从端接口时序"></p>
<p>整形器接口时序见图6.4。<strong>整形器是按照数据包的形式发送数据的，数据包的可选长度有4、8、16和32</strong>。整形器必须<strong>完整发送某一个通道的数据包后，才可以转而准备发送下一个数据包</strong>，在发送数据包期间，fmt_chid和fmt_length应保持不变，直到数据包发送完毕。</p>
<p><img src="/2022/05/08/42/%E6%95%B4%E5%BD%A2%E5%99%A8%E6%8E%A5%E5%8F%A3%E6%97%B6%E5%BA%8F.png" alt="整形器接口时序"></p>
<p>整形器准备发送数据包时，首先应该将fmt_req置为高，同时等待接收端的fmt_grant。当fmt_grant变为高时，应在下一个周期将fmt_req置为低。<strong>fmt_start也必须在接收到fmt_grant高有效的下一个时钟被置为高，且维持一个时钟周期</strong>。在fmt_start被置为高有效的同一个周期，数据开始传送，数据之间不允许有空闲周期，<strong>即应连续发送数据，直到发送完最后一个数据，fmt_end也应被置为高并保持一个时钟周期</strong>。</p>
<p>相邻数据包之间应至少有一个时钟周期的空闲，<strong>即fmt_end从高位被拉低以后，至少需经一个时钟周期fmt_req才可以被再次置为高</strong>。</p>
<p>控制寄存器接口时序见图6.5。在控制寄存器接口上，需要在每一个时钟解析cmd。<strong>当cmd为写指令时，需要把数据cmd_data_in写入到cmd_addr对应的寄存器中；当cmd为读指令时，即需要从 cmd_addr 对应的寄存器中读取数据，并在下一个周期，将数据驱动至cmd_data_out接口</strong>。</p>
<p><img src="/2022/05/08/42/%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8%E6%8E%A5%E5%8F%A3%E6%97%B6%E5%BA%8F.png" alt="控制寄存器接口时序"></p>
<h2 id="2-5-寄存器描述"><a href="#2-5-寄存器描述" class="headerlink" title="2.5 寄存器描述"></a>2.5 寄存器描述</h2><p>地址0x00 通道1控制寄存器32 bit读写寄存器：</p>
<ul>
<li>bit（0）：通道使能信号。1为打开，0为关闭。复位值为1。</li>
<li>bit（2:1）：优先级。0为最高，3为最低。复位值为3。</li>
<li>bit（5:3）：数据包长度，解码对应表为，0对应长度4,1对应长度8,2对应长度16,3对应长度32，其他数值（4～7）均暂时对应长度32。复位值为0。</li>
<li>bit（31:6）：保留位，无法写入。复位值为0。</li>
</ul>
<p>地址0x04通道2控制寄存器32 bit读写寄存器：同通道1控制寄存器描述。</p>
<p>地址0x08通道3控制寄存器32 bit读写寄存器：同通道1控制寄存器描述。</p>
<p>地址0x10通道1状态寄存器32 bit只读寄存器：</p>
<ul>
<li>bit（7:0）：上行数据从端 FIFO 的可写余量，同 FIFO 的数据余量保持同步变化。复位值为FIFO的深度数。</li>
<li>bit（31:8）：保留位，复位值为0。</li>
</ul>
<p>地址0x14 通道2状态寄存器32 bit只读寄存器：同通道1状态寄存器描述。</p>
<p>地址0x18 通道3状态寄存器32 bit只读寄存器：同通道1状态寄存器描述。</p>
<p>至此我们将MCDF的功能描述完毕，从下一节开始，我们将分析如何给出激励、检测以及比较数据，同时从验证效率的角度考虑，如何同时为各个模块构建模块验证平台，并最终组合为一个子系统验证平台，来完成MCDF的验证。</p>
<h1 id="3-激励发生器"><a href="#3-激励发生器" class="headerlink" title="3 激励发生器"></a>3 激励发生器</h1><p><strong>Stimulator（激励发生器）是验证环境的重要部件，在一些场合中也被称为 driver（驱动器）、BFM（Bus Function Model，总线功能模型）、behavioral（行为模型）或generator（发生器）</strong>。激励发生器的<strong>主要职责是模拟与DUT相邻设计的接口协议。与真正的相邻设计相比，激励发生器（Simulator）只关注如何模拟接口信号，使其能够以真实的接口协议来发送激励给DUT</strong>。激励发生器并不需要模拟相邻设计内部的功能细节，这使得实现一个激励发生器的工作相对设计而言更容易，也更方便维护。</p>
<p>从模拟接口协议的角度来看，激励发生器不应该违反协议，但不拘束于真实的硬件行为，还可以给出更多丰富的协议允许的激励场景。<strong>比真实硬件行为更丰富的激励，会使模块级的验证更加充分，因为不但验证了硬件普通的接口协议情景，还模拟出更多复杂的、在更高系统级别无法产生的场景，而这些场景只有在模块级验证中才能产生和检查。这些复杂的边界场景（corner scenario）往往有可能有触发到由于考虑不充分导致的设计缺陷</strong>。对于边界情景所触发的设计缺陷，我们一般遵循立即修正的原则，即便该场景可能在系统集成后很难触碰到，但无法保证它在这个项目或下个项目中不会被系统触发。在构建激励发生器时，核心的准备工作就是熟读并正确理解接口协议。如果激励发生器无法完全实现协议，那么可以想象，我们利用激励发生器生成的场景是不完备的，这直接导致接口覆盖率的不完整，存在较大的验证风险隐患。</p>
<p>如果接口协议是成熟的商业协议，建议使用第三方的商用接口IP，这很大程度上节省了二次开发的成本和对激励发生器调校的精力。如果是较复杂的协议，我们可能面对激励发生器协议实现上的缺陷，或者未完全实现协议，而这对验证的成功和效率都有消极的影响。即便出于节约经济成本的考虑，仍然不建议使用不成熟的激励发生器，至少接口的激励发生器应经过足够的时间来开发、自我验证（仍然利用第三方商用接口IP来进行自我验证）。</p>
<p>如果接口协议较为简单，或者是内部设计之间规定的非标准接口，那么应该查阅相邻设计的硬件描述文档，如6.2节中展现的一样，充分理解接口的时序。如果你不幸遇到了一个没有接口时序的设计，恐怕你要与 DUT 和相邻设计的设计者沟通，从他们那里获得相关信息来理解接口协议；这样做也可以帮助双方在项目前期排除有关接口协议的实现分歧。需要注意的是，对接口的理解不能完全遵循设计者的描述，更不能看设计接口的实现代码，因为这违反了设计参照的来源应从系统定义中来的原则。验证者需要做的是调查、收集有用信息，但不完全采纳设计者关于接口的设定。</p>
<p><strong>激励发生器的接口主要是与 DUT 之间的连接，此外，也应该有时钟和复位的输入，确保生成的数据与 DUT 的接口侧是同步的关系</strong>。较精细的激励发生器还可以有其他的配置接口用来控制接口的数据生成。最后，<strong>激励发生器具有存储接口数据生成历史的功能，用来在仿真运行时或结束后查看接口数据，方便统计和调试</strong>。</p>
<p>从激励发生器与 DUT 的连接关系来看，可以将其进一步分为两种：<strong>initiator（发起器）和responder（响应器）</strong>。就我们要验证的MCDF来看，<strong>与下行通道从端（channel slave）的连接或寄存器接口的连接，这两部分的激励发生器都属于initiator，它们的功能是主动发起接口数据传输；而与MCDF formatter接口的连接，该激励发生器则属于responder，它的职责是对接口的数据发送请求做出响应，本身并不主动发送数据</strong>。</p>
<p>接下来，我们从MCDF的接口协议和时序分析图6.6中三种激励发生器需要考虑的因素。</p>
<h3 id="1-Channel-initiator"><a href="#1-Channel-initiator" class="headerlink" title="1.Channel initiator"></a>1.Channel initiator</h3><ul>
<li>Channel从端接口协议上有握手信号，我们要遵照接口时序，确保chx_ready为低时，chx_data和chx_valid保持不变。</li>
<li>相邻数据之间没有数据包的限制，所以相邻数据之间的关系较弱。但也应考虑数据之间是否有空闲周期，以及整体数据的传输速率设定。</li>
<li>由于每一个数据从端都有对应的FIFO缓存数据，所以要<strong>考虑如何使FIFO的状态可遍历</strong>。例如，典型的 FIFO 状态分为 empty、full和中间状态（即有数据存储但未写满）。要使FIFO触发这些状态，就应该控制channel initiator的<strong>传输速率</strong>。</li>
</ul>
<p><img src="/2022/05/08/42/MCDF%E9%AA%8C%E8%AF%81%E7%8E%AF%E5%A2%83%E7%9A%84%E6%BF%80%E5%8A%B1%E5%8F%91%E7%94%9F%E5%99%A8%E7%BB%93%E6%9E%84.png" alt="MCDF验证环境的激励发生器结构"></p>
<h3 id="2-Register-initiator"><a href="#2-Register-initiator" class="headerlink" title="2.Register initiator"></a>2.Register initiator</h3><ul>
<li>寄存器接口上cmd的默认状态应该为idle，但cmd_addr、cmd_data_in并未指出默认值应为何值，所以可以考虑给出随机数值测试DUT的接口协议稳定性。</li>
<li>在寄存器读写传输上，可以考虑连续的写、读或读写交叉的方式测试寄存器模块的读写功能。</li>
<li>测试应覆盖读写寄存器的所有比特位。</li>
<li>需要测试只读状态寄存器的设定是否为不可写入，同时要测试<br>读出的数值是否为真实的硬件状态。</li>
</ul>
<h3 id="3-Formatter-responder"><a href="#3-Formatter-responder" class="headerlink" title="3.Formatter responder"></a>3.Formatter responder</h3><ul>
<li>作为三种接口协议中相对复杂的一个，首先要侧重formatter接口协议是否充分遍历。</li>
<li>需要详细理解协议的要求，除了按照协议给出fmt_grant的响应以外，还要检查协议的时序。</li>
<li>fmt_grant的置高，代表formatter的从端有足够的存储空间，可以容纳formatter要传输的长度为fmt_length的数据包。为了模拟真实场景，可以考虑让fmt_grant采取立即拉高或延时拉高，测试formatter接口的响应时序。</li>
</ul>
<p>至此，我们结合实际的MCDF，给出了激励发生器的连接关系以及实现时要注意的地方，在SystemVerilog和UVM的章节为大家提供可参考的代码实现。接下来，我们将进入Monitor（监测器），看一看如何放置监测器较为合理，它们的优劣势分别是什么？</p>
<h1 id="4-监测器"><a href="#4-监测器" class="headerlink" title="4 监测器"></a>4 监测器</h1><p><strong>Monitor（监测器）的主要功能是观察DUT的边界或内部信号，并将它们打包整理再传送给其他验证平台的组件</strong>如Checker（比较器）。从监测信号的角度来划分Monitor的功能，可以分为：</p>
<ul>
<li>观察DUT边界信号。对于系统信号如时钟，可以监测其频率变化；对于总线信号，可以监测总线的传输类型和数据内容，以及检查总线时序是否符合协议。</li>
<li>观察DUT内部信号。灰盒验证往往需要探视 DUT 内部信号，以指导激励发生器的激励发送，或者完成覆盖率收集，或者完成内部功能的检查。</li>
</ul>
<p>结合6.3节激励发生器的验证结构图布置，我们有如图6.7和图6.8所示的两种Monitor结构框图。</p>
<p><img src="/2022/05/08/42/MCDF%E9%AA%8C%E8%AF%81%E7%8E%AF%E5%A2%83%E7%9A%84%E7%9B%91%E6%B5%8B%E5%99%A8%E7%BB%93%E6%9E%84%E6%96%B9%E6%A1%881.png" alt="MCDF验证环境的监测器结构方案1"></p>
<p>从图6.7可以看出，在验证平台中置入一个全局性的Monitor，监视整个环境中的信号，包括：</p>
<ul>
<li>寄存器配置接口。</li>
<li>3个通道从端数据接口。</li>
<li>Formatter输出接口。</li>
<li>MCDF内部信号，包括Register、Arbiter和Formatter的关键信号。</li>
</ul>
<p>我们再看图6.8中分布式的monitor是如何实现的。可以发现，每一个monitor对应一个激励发生器，所以，我们需要如下的Monitor：</p>
<ul>
<li>3个Channel Monitor分别用来监测对应的channel initiator的接口。</li>
<li>Register monitor监测寄存器配置接口。</li>
<li>Formatter monitor监测formatter输出接口。</li>
<li>MCDF monitor监测register、arbiter和formatter的内部信号。</li>
</ul>
<p><img src="/2022/05/08/42/MCDF%E9%AA%8C%E8%AF%81%E7%8E%AF%E5%A2%83%E7%9A%84%E7%9B%91%E6%B5%8B%E5%99%A8%E7%BB%93%E6%9E%84%E6%96%B9%E6%A1%882.png" alt="MCDF验证环境的监测器结构方案2"></p>
<p>从功能的角度来看，无论是集为一体的monitor，还是相互分离、各司其职的monitor群，都可以完成监测全局的任务。那么，采用哪种方式好呢？我们试着从如下几个方面进行对比：</p>
<ul>
<li>独立性：我们倾向于采用后者，即将不同接口信号的采集交给相应的 monitor。因为各接口的功能之间没有相关性，易于切割。</li>
<li>复用性：仍然采用后者。如果 MCDF 的接口可能运用到别的验证环境中，那么相对独立的 monitor 可以更好地作为验证 IP 被其他验证环境所复用。基于这个考虑，我们将通道从端数据接口的采集分别对应到3个channel monitor，每一个monitor只需要负责监视一组总线。</li>
<li>可维护性：后者优于前者。设计的外部接口必定先于内部信号趋于稳定，那么，平行的 monitor 组更有利于验证者在验证后期定向维护 MCDF monitor，而不需考虑其他monitor。同样到了后期项目或者设计遇到修改时，更有可能修改的是内部逻辑，而非接口信号；这种情况下也只需更新MCDF monitor，而不必更新其余接口类型的monitor。</li>
<li>封装性：后者的优势在于与各激励发生器一一对应，形成验证环境的小单位，这些小单位之间的通信按照统一的方式实现，可以保持各自的独立性。这样，就可以各小单位（即一个激励发生器对应一个 monitor）封装为独立的组件，使其提供激励和监测的功能。</li>
</ul>
<p>从上面的分析可以得出，<strong>无论是 monitor 还是激励发生器，我们都倾向于将验证环境中的组件尽量做到功能单一，而非大而全，这种方式带来的好处，可以在以后的验证环境集成和垂直复用中得到印证</strong>。对于monitor的监测功能实现，我们遵循与激励发生器一样的要求，即验证人员应深入理解协议。这样，无论是按照协议采集数据还是检查 DUT 的接口是否按照协议实施，都是必需的。对于监测MCDF内部信号的要求，我们给出如下建议：</p>
<ul>
<li>若无特殊需要，<strong>应采取灰盒（而非白盒）验证的策略</strong>。</li>
<li>观察的内部信号应尽量少，且应是表示状态的信号。不建议采集中间变量信号的原因在于，这些信号的时序、逻辑甚至留存性都不稳定，这种不稳定对验证环境的收敛是有害的。</li>
<li><strong>能够通过接口信息计算的，尽量少去监测内部信号</strong>，因为这种方式有悖于假定设计有缺陷的验证思想。我们观测到的内部信号，有必要在被环境采纳之前确认它们的逻辑正确性，这一要求可以通过动态检查或断言触发的方式来实现。</li>
</ul>
<p>在数据监测、覆盖率收集、协议检查功能覆盖率驱动验证之外，在高级的验证环境中，monitor也可以通过对覆盖率加以分析，来反馈指导激励发生器的激励数据生成，这种方式称之为<strong>功能覆盖率驱动验证</strong>（function coverage driven verification）。接下来，我们将介绍验证组件的最后一个成员——checker（比较器），看一看checker的功能和一些需要注意的问题。</p>
<h1 id="5-比较器"><a href="#5-比较器" class="headerlink" title="5 比较器"></a>5 比较器</h1><p>无论是从实现难度还是从维护人力上看，<strong>checker（比较器）都是最需要时间投入的验证组件</strong>。之所以这么说，是因为<strong>checker肩负了模拟设计行为和功能检查的任务</strong>。更细致地看，checker的功能包括：</p>
<ul>
<li><strong>缓存</strong>从各个monitor收集到的数据。</li>
<li>将DUT输入接口侧的数据汇集给内置的reference mode（l 参考模型）。reference model在这里扮演了模拟硬件功能的角色，也是需要较多精力维护的部分，因为验证者要在熟悉硬件功能的情况下实现该模型，同时不参考真实硬件的逻辑。</li>
<li>通过数据比较的方法，检查实际收集到的DUT输出端接口数据是否与reference model产生的期望数据一致。</li>
<li>对于设计内部的关键功能模块，也有相对应的线程进行独立的检查。</li>
<li>在检查过程中，可以将检查成功的信息统一纳入到检查报告中，便于仿真后的追溯。</li>
</ul>
<p>如果检查失败，可以采取暂停仿真同时报告错误信息的方式进行在线调试。</p>
<p>关于checker细分的功能，我们需要记住几个关键词：<strong>数据缓存、参考模型和检查报告</strong>。我们在后期的代码实例中围绕这几个部分进行梳理。在实际项目中，各种 checker 的实现方式迥异，大致分为两类：</p>
<ul>
<li>线上比较（online check）：在仿真时收集数据和在线比较，并实时报告。</li>
<li>线下比较（offline check）：将仿真时收集到的数据记录在文件中，仿真结束后通过脚本或其他手段进行数据比较。</li>
</ul>
<p>在硬件设计发展初期，DUT的功能较为简单，采取定向测试（directed test）和线下比较的方式就不足为奇了。甚至，验证者没有数据处理脚本或参考模型，进行人为比较（manual check）的古老方式也是存在的。设计的功能愈加复杂，靠验证者每次进行烦琐检查的方式可靠性愈差。<strong>于是，我们将checker添加到验证环境中，用它分析DUT的边界激励，理解数据的输入，并按硬件功能来预测输出的数据内容。这种的过程发生在reference model 中，有时我们也将其称为预测predictor。</strong> 从 MCDF 的 checker 来看，对于数据的整形（formatter），寄存器模块可以控制数据包的长度，reference model也需要register monitor的观察数值进行数据包内容的预测。一般而言，reference model会内置一些缓存，分别存放从DUT输入端观察到的数据，以及经过功能转换的数据。同时，checker也有其他缓存来存放从输出端采集到的数据，即图6.9由formatter monitor存放到MCDF checker的formatter FIFO。</p>
<p><img src="/2022/05/08/42/MCDF%E9%AA%8C%E8%AF%81%E7%8E%AF%E5%A2%83%E7%9A%84%E6%AF%94%E8%BE%83%E5%99%A8%E7%BB%93%E6%9E%84.png" alt="MCDF验证环境的比较器结构"></p>
<p>由于 MCDF 有数据通路的功能，我们认为 reference model 存储的数据内容顺序和formatter FIFO中数据的顺序是一致的。这种顺序一致性有利于我们做前后的数据比较，一旦data checker发现两者的FIFO都有数据，就从两侧读出等量数据来做比较。如果数据比较成功，则将数据信息和比较信息打印到仿真窗口和记录文件中；如果数据比较失败，则暂停仿真，将比较失败的数据信息提供给验证人员。</p>
<p>在前面介绍的reference model、formatter FIFO（output data buffer）和data checker之外，我们考虑引入更多细致的检查功能，这些功能和各个模块相对应，分别是：</p>
<ul>
<li>channel checker；</li>
<li>arbiter checker；</li>
<li>register checker；</li>
<li>formatter checker。</li>
</ul>
<p>回顾上一节讲到的monitor的分布不难发现，checker、monitor和stimulator与MCDF内部的各模块有一一对应的关系。我们之前建议将monitor和stimulator各自对应组成一个个的小单元，那么 checker是否也适合与其对应呢？应该怎么放置呢？在回答这些问题之前不妨考虑一下，对checker进行分散搁置与集群搁置的特点是什么？</p>
<p>分散搁置的特点包括：</p>
<ul>
<li>各自检查对应模块的功能；</li>
<li>checker之间通信需要特殊连接；</li>
<li>报告信息较难统一；</li>
<li>对各个checker的使能控制因其分散变得复杂。</li>
</ul>
<p>集群搁置的特点包括：</p>
<ul>
<li>各自检查对应模块的功能；</li>
<li>checker各自相邻，可以共享monitor的输入，减少复杂的连接关系；</li>
<li>可以按照统一的报告形式，写入记录文件中；</li>
<li>集中管理各个checker，例如在前期使能各个模块的checker，在后期可以将其作为黑盒验证，只使能data checker。</li>
</ul>
<p>对于复杂的系统验证，我们倾向于集中管理stimulator和checker，因为它们都需要主动给出激励或判断结果，需要较多的协调处理。Monitor 则相对独立，它只是作为监测方，将自己兢兢业业观察到的数据一字不落地交给checker即可；至于checker怎么使用这些数据，monitor并不需要关心。我们接下来将再次分析DUT MCDF的结构，以及一个项目如何高效地完成实际的验证工作。这其中涉及验证师之间如何协作、验证进度与设计进度的关系。你也可以放开思路，考虑如果自己负责这个设计时将会如何展开验证工作。</p>
<h1 id="6-验证结构"><a href="#6-验证结构" class="headerlink" title="6 验证结构"></a>6 验证结构</h1><p>本节将模拟实际的工作，抛出一系列的问题，启迪你的思考。这里给出的建议不是最好的，但至少从工程项目的观点来看是合理的。如果你有更棒的主意，欢迎在路科验证的微信订阅号留言。</p>
<h2 id="6-1-项目背景"><a href="#6-1-项目背景" class="headerlink" title="6.1 项目背景"></a>6.1 项目背景</h2><p>现在，你是这个设计模块的负责人，需要考虑分配设计人员和验证人员。而笔者作为验证的老司机，对下面这些模块的实现难度做出了评估。</p>
<p>对MCDF设计的评估：</p>
<ul>
<li>channel slave（slave interface+FIFO）需要7个工作日；</li>
<li>arbiter 需要10个工作日；</li>
<li>formatter 需要5个工作日；</li>
<li>registers 需要4个工作日；</li>
<li>MCDF integration（模块集成）需要2个工作日。</li>
</ul>
<p>目前共有3位设计师：肖、吕、高，你需要安排他们在最短的时间内完成设计工作。你考虑的人力安排是什么呢？由于MCDF模块之间有独立性，我们可以同时安排3名设计师展开工作。一种较为合理的建议<br>是：</p>
<ul>
<li>肖：channel slave 7天+MCDF integration 2天&#x3D;9天；</li>
<li>吕：arbiter 10天&#x3D;10天；</li>
<li>高：formatter 5天+registers 4天&#x3D;9天。</li>
</ul>
<p>从设计完成的周期来看，一共需要10天（取设计者所用的最长时间）。那么，针对这份设计的进度安排，你又该怎么安排验证工作呢？</p>
<h2 id="6-2-MCDF验证进度安排"><a href="#6-2-MCDF验证进度安排" class="headerlink" title="6.2 MCDF验证进度安排"></a>6.2 MCDF验证进度安排</h2><p>在开展验证之前，首先恭喜你，运气还不错，你被分配了4位验证师：梅、尤、娄、董，比设计师还多呢。是啊，作为你的项目经理，笔者也知道验证的工作量要更重一些。那么，如果按照简单的人力比例，即验证人力与设计人力之比大致为1.5∶1的话，上述各个模块的验证人力需求大致如下：</p>
<ul>
<li>channel slave:11个工作日；</li>
<li>arbiter:15个工作日；</li>
<li>formatter:8个工作日；</li>
<li>registers:6个工作日；</li>
<li>MCDF integration的验证人力有待商榷，因为它不单单需要2×1.5个工作日，而是在MCDF集成以后，还需要各个模块在子系统完成集成验证。我们暂时按照30个工作日计算。</li>
</ul>
<p>接下来，如果将验证师按照上述的人力估计进行分配，就更加有趣了，我们来看一看只有三名设计师，意味着在formatter完成的前5天，我们只有3个模块在设计中。接下来，我们可以等待设计师高将registers模块完成，再递交给相应的验证师。这些计划都是按照天数计算的，我们将这个时间进度表绘制成图，如图6.10所示。</p>
<p><img src="/2022/05/08/42/MCDF%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E9%AA%8C%E8%AF%81%E8%BF%9B%E5%BA%A6%E8%AE%A1%E5%88%92%E8%A1%A8.png" alt="MCDF的设计和验证进度计划表"></p>
<p>我们来分析一下这张项目计划表：</p>
<ul>
<li>从设计人力利用上来看，尽力做到了从各个模块设计开始到交付用了最短的时间。</li>
<li>从验证一侧看，验证师梅、尤、娄的验证开展时间要略晚于设计部分。这是因为只有在设计的边界和功能有初步版本时，验证才可以开始进入。</li>
<li>在验证师梅、尤、娄开始搭建验证环境的过程中，验证师董看似没有事情可以安排，因为设计师高的另外一个设计register还没有开始准备，那么验证师需要等待吗？相信我，验证师一旦闲置下来，在任何一个项目中都会引起项目经理的疑问。验证师董可以在其余三位验证师搭建模块验证环境一段时间以后着手准备顶层验证环境。</li>
<li>完成初步验证环境集成后，验证师董可以在适当的时间开始验证模块 register。在完成模块验证后，验证师董可以进行最后阶段的验证环境持续集成。</li>
<li>在验证师董进行验证环境的持续集成前后，验证师梅、尤、娄可以在完成模块验证之后进入顶层验证，检查各自的模块是否工作，而所用到的checker均来自于他们的模块验证环境。同时，验证师董也应该进行最后的顶层验证，检查模块register的功能。</li>
<li>最后值得注意的是，MCDF作为一个整体子系统，我们不能忽视各个模块的协调使用。这项工作我们交给验证师娄，因为他还有一定的时间来完成这项任务。完成 MCDF整体验证的任务包括协调stimulator和checker 来创建激励场景和检查数据。数据检查用到的reference model、formatter FIFO和data checker需要由验证师娄来实现。</li>
</ul>
<p>在项目执行部分，我们围绕4位验证师如何从模块级验证环境开始搭建到顶层环境的集成。接下来SystemVerilog基础和应用部分将讲述这些内容，而MCDF模块的设计源代码，读者可以通过扫描二维码下载。从第7章开始，我们将进入SystemVerilog语言的基础部分，笔者将提炼语言的重要特性，同时结合实际应用，将SystemVerilog语言在验证环境中所需的知识点展示出来。也请读者在接下来的SV语言和UVM方法学中理解本书的指导方法，即，语言知识点为辅助，项目实际应用和思想为我们贯穿全书的核心基调。</p>
<h1 id="7-作者结束语"><a href="#7-作者结束语" class="headerlink" title="7 作者结束语"></a>7 作者结束语</h1><blockquote>
<p>无论接下来是学习SV还是学习UVM，在展开验证之前都需要仔细阅读硬件的设计描述，并要考虑验证结构的实施。对于子系统级别，还需要考虑如何划分模块和对应的模块验证环境，然后考虑如何复用模块验证环境，最终在子系统级别完成验证环境的集成和复用。</p>
<p>在动态仿真领域，读者需要了解的是，<strong>无论什么验证语言或方法学，都需要有激励发生器、监测器和比较器，也都需要有顶层的验证环境来封装它们</strong>。对于小组规模的验证场景，验证师之间还需要考虑整体验证进度的平稳推进、验证环境的统一化和系统层面的验证协作等。</p>
</blockquote>
]]></content>
      <categories>
        <category>IC验证</category>
      </categories>
      <tags>
        <tag>UVM</tag>
        <tag>System Verilog</tag>
        <tag>IC验证</tag>
      </tags>
  </entry>
  <entry>
    <title>路科V0P13P18SV数组-类-对象-包</title>
    <url>/2022/05/13/24/</url>
    <content><![CDATA[<h1 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h1><blockquote>
<ul>
<li>对于Verilog，数组用来做数据存储，比如 <code>reg [15:0] RAM [0:4095];   //存储数组</code></li>
<li>数组的索引名在数组右侧，左侧是每个数据的大小</li>
</ul>
</blockquote>
<h2 id="非组合型-unpacked-数组"><a href="#非组合型-unpacked-数组" class="headerlink" title="非组合型(unpacked)数组"></a>非组合型(unpacked)数组</h2><ul>
<li>非组合型(unpacked) : SV将以上Verilog的声明方式称为非组合型声明，即<strong>数组中的成员之间的存储是互相独立的</strong>。<ul>
<li>会消耗更多的存储空间，但是利于查找元素；</li>
<li>SV对Verilog的非组合数组进行了保留，并且允许在声明时指定类型，包括<code>event logic bit byte int longint shortreal real</code>等类型；</li>
<li>SV也保留了Verilog索引非组合型数组或切片的能力，利于数组和切片的拷贝和查找；</li>
<li>栗子： <code>int a1 [7:0][1023:0];   //非组合型数组</code>  <code>int a2 [1:8][1023:0];</code> <code>a1 = a2;  //拷贝整个数组</code>  <code>a2[3] = a1[3];  //拷贝数组的某个片段</code></li>
<li>声明非组合型数组的方式：<ul>
<li>指定元素个数 ： <code>logic [31:0] data[1024]; //从右到左读，1024个32位</code></li>
<li>指定元素索引值的范围： <code>logic [31:0] data[0:1023];</code></li>
</ul>
</li>
<li>初始化： 对于非组合数组，需要用<code>&#39;&#123;&#125;</code>对每个维度分别赋值：<ul>
<li><code>int d [0:1][0:3] = &#39;&#123;&#39;&#123;7, 3, 0, 5&#125;, &#39;&#123;1, 2, 3, 4&#125;&#125;;</code></li>
</ul>
</li>
<li>因为非组合型数组赋值繁琐，所以可以使用default关键字完成， <code>int a [0:7][0:1023] = &#39;&#123;default: 8&#39; h55&#125;;</code></li>
<li>非组合型数组的数据成员和数组本身都可以为其赋值， <code>byte a [0:3][0:3]; a[1][0] = 8&#39; h5;  // 为单个元素赋值  a[3] = &#39;&#123;&#39;hF, &#39;hA, &#39;hC, &#39;hE&#125;;  //给切片赋值</code></li>
<li>非组合型的赋值和拷贝，必须两边的维度完全一模一样；</li>
<li>非组合型数组和组合型数组之间，不能直接赋值！</li>
</ul>
</li>
</ul>
<h2 id="组合型-packed-数组"><a href="#组合型-packed-数组" class="headerlink" title="组合型(packed)数组"></a>组合型(packed)数组</h2><ul>
<li>组合型(packed) : SV将Verilog的向量作为组合型数组的声明方式<ul>
<li>栗子： <code>wire [3:0] select;  // 4比特的组合型数组</code>  <code>reg [63:0] data;  //64比特的组合型数组</code>  <code>logic [3:0][7:0] data;  // 2维组合型数组，注意，每个元素是data[0][7:0]，索引在左侧，位宽在右侧，从左到右边读，4个8位，第二维4个，第一维8个</code></li>
<li>组合型数组更节省空间！规范了数据的存储方式，所以不需要关心编译器或者操作系统的区别；</li>
<li>组合型除了可以用数组的声明，还可以定义结构体的存储方式：</li>
<li><code>typedef struct &#123; logic [7:0] crc; logic [63:0] data; &#125; data_word;  data_word [7:0] darray;</code></li>
<li>组合型数组和其他数组片段也可以灵活选择，用来拷贝或者赋值：<ul>
<li><code>logic [3:0][7:0] data; wire [31:0] out = data;  wire sign = data[3][7];  wire[3:0] nib = data[0][3:0];  byte high_byte;  assign high_byte = data[3];  //8bit数组片段   logic [15:0] word;  assign word = data[1:0];</code></li>
</ul>
</li>
<li>初始化 ： 组合型数组的初始化，和向量的初始化一致，对所有元素统一赋值：<ul>
<li><code>logic [3:0][7:0] a = 32&#39;h0; //向量赋值</code></li>
<li><code>logic [3:0][7:0] a = &#123;16&#39;hz, 16&#39;h0&#125;; //连接运算符</code></li>
<li><code>logic [3:0][7:0] a = &#123;16&#123;2&#39;b01&#125;&#125;; //复制运算符</code></li>
</ul>
</li>
<li>组合型的赋值： <code>logic [1:0][1:0][7:0] a;  a[1][1][0] = 1&#39;b0;  a = 32&#39;hF1A3C5E7;  //整个数组赋值  a[1][0][3:0] = 4&#39;hF;  //切片赋值   a[0] = 16&#39; hFACE;  // 给切片赋值   a = &#123;16&#39; bz, 16&#39; b0&#125;; //通过连接运算符赋值</code></li>
<li><strong>组合型数组会被视为向量，所以两边操作数大小维度不同时也可以做赋值，非组合型不可以</strong>！</li>
<li>会将右侧的数据截取或者扩展，<strong>扩展时，是高位填充为0</strong>！</li>
</ul>
</li>
</ul>
<h2 id="sv中的foreach"><a href="#sv中的foreach" class="headerlink" title="sv中的foreach"></a>sv中的foreach</h2><ul>
<li>foreach: 循环，对一维或者多维数组进行循环索引，不需要指定数组的维度大小！<ul>
<li>栗子： <code>int sum [1:8][1:3]; foreach(sum[i, j]) &#123; sum[i][j] = i + j; &#125; &#125;; //对数组进行初始化</code></li>
<li>foreach中的变量作用域只在循环中，且只读，无法修改；</li>
</ul>
</li>
</ul>
<h2 id="一些系统函数"><a href="#一些系统函数" class="headerlink" title="一些系统函数"></a>一些系统函数</h2><ul>
<li><code>$dimensions(array_name)</code> : 获取数组的维度大小；</li>
<li><code>$left(array_name, dimension)</code> : 返回指定维度的最左索引值；</li>
<li>栗子：<ul>
<li><code>logic [1:2][7:0] word [0:3][4:1];</code>   最高的二维是4乘4,非组合，最低的二维为2乘8,组合型；</li>
<li><code>$left(word, 1)</code> 返回的是0；</li>
<li><code>$left(word, 2)</code> 返回的是4；</li>
<li><code>$left(word, 3)</code> 返回的是1；</li>
<li><code>$left(word, 4)</code> 返回的是7；</li>
</ul>
</li>
<li>类似，还有<code>$right $low $high</code></li>
<li><code>$size(array_name, dimension)</code> : 返回指定维度的尺寸大小；</li>
<li><code>$increment(array_name, dimension)</code> : 如果指定维度的最左索引值大于最右索引值，返回1,否则-1；</li>
<li><code>$bits(expression)</code> : 返回数组存储的比特数目；</li>
</ul>
<h1 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h1><h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><ul>
<li>动态数组在声明时，需要<code>[]</code>， 在编译时不会指定尺寸，在运行时才会确定；</li>
<li>动态数组开始时为空，需要<code>new[]</code>来分配空间；<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dyn[], d2[];</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    dyn = <span class="keyword">new</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">foreach</span> (dyn[j]) dyn[j] = j;</span><br><span class="line">    d2 = dyn;</span><br><span class="line">    d2[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">$display</span>(dyn[<span class="number">0</span>], d2[<span class="number">0</span>]);</span><br><span class="line">    dyn = <span class="keyword">new</span>[<span class="number">20</span>](dyn); <span class="comment">//分配20个整数并进行赋值</span></span><br><span class="line">    dyn = <span class="keyword">new</span>[<span class="number">100</span>];  <span class="comment">//分配100个新的整数</span></span><br><span class="line"></span><br><span class="line">    dyn<span class="variable">.delete</span>(); <span class="comment">// 删除所有元素</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
<li>内置方法<code>size()</code>可以返回动态数组的大小。</li>
<li><code>delete()</code>清空动态数组，使它尺寸变为0；</li>
<li>动态数组在声明时也可以初始化<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] mask[] = &#x27;&#123;<span class="number">8&#x27;b0000_0000</span>, <span class="number">8&#x27;b0000_0001</span>, <span class="number">8&#x27;b0000_0010</span>, <span class="number">8&#x27;b0000_0011</span>, <span class="number">8&#x27;b0000_0100</span>, <span class="number">8&#x27;b0000_0101</span>, <span class="number">8&#x27;b0000_0110</span>, <span class="number">8&#x27;b0000_0111</span>&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ul>
<li>sv引入了队列类型，它<strong>结合了数组和链表</strong>；</li>
<li><strong>可以在队列的任何位置添加或者删除数据成员</strong>；</li>
<li>也可以索引访问队列的任何成员；</li>
<li>通过<code>[$]</code>声明队列， 队列的索引值从0到$;</li>
<li>可以通过队列的内建方法<code>push_back(val)</code>、<code>push_front(val)</code>、<code>pop_back()</code>、<code>pop_front()</code>来操作；</li>
<li>在指定位置插入成员，可以使用<code>insert(val, pos)</code>；</li>
<li>可以使用<code>delete(pos)</code>删除指定位置的元素；</li>
<li>可以使用<code>&#123;&#125;</code>连接运算符对队列进行拼接；</li>
</ul>
<p>栗子：</p>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>, </span><br><span class="line">    q2[$] = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;,    <span class="comment">// 队列常量不需要&#x27;</span></span><br><span class="line">    q[$] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    q<span class="variable">.insert</span>(<span class="number">1</span>, j);</span><br><span class="line">    q<span class="variable">.delete</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    q<span class="variable">.push_front</span>(<span class="number">6</span>);</span><br><span class="line">    j = q<span class="variable">.pop_back</span>();</span><br><span class="line">    q<span class="variable">.push_back</span>(<span class="number">8</span>);</span><br><span class="line">    j = q<span class="variable">.pop_front</span>();</span><br><span class="line">    <span class="keyword">foreach</span> (q[i])</span><br><span class="line">        <span class="built_in">$display</span>(q[i]);</span><br><span class="line">    q<span class="variable">.delete</span>();</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="关联数组"><a href="#关联数组" class="headerlink" title="关联数组"></a>关联数组</h2><ul>
<li>处理器在访问存储时是随机或者散乱的，所有测试中，处理器也许只会访问几百个存储地址，其他的初始化为0,浪费了仿真时的存储空间。</li>
<li>SV中的关联数组，存放散列的数据成员，关联数组的索引类型，<strong>除了为整型之外还可以是字符串或者其他类型</strong>，而且关联数组存储的数据成员也可以是任意类型！</li>
</ul>
<p>栗子：</p>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> assoc[<span class="keyword">byte</span>], idx = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        assoc[idx] = idx;</span><br><span class="line">        idx = idx &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">while</span> (idx != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (assoc[i])</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;assoc[%h] = %h&quot;</span>, i, assoc[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (assoc<span class="variable">.first</span>(idx))</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;assoc[%h] = %h&quot;</span>, idx, assoc[idx]);</span><br><span class="line">        <span class="keyword">while</span> (assoc<span class="variable">.next</span>(idx));</span><br><span class="line">    <span class="keyword">void</span>&#x27;(assoc<span class="variable">.first</span>(idx));</span><br><span class="line">    <span class="keyword">void</span>&#x27;(assoc<span class="variable">.delete</span>(idx));</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;The array now has %0d elements&quot;</span>, assoc<span class="variable">.num</span>());</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>栗子2：输入文件</p>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> switch[<span class="keyword">string</span>], min_address, max_address, i, file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">string</span> s;</span><br><span class="line">    file = <span class="built_in">$fopen</span>(<span class="string">&quot;switch.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">$feof</span>(file)) <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$fscanf</span>(file, <span class="string">&quot;%d %s&quot;</span>, i, s);</span><br><span class="line">        switch[s] = i;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">$fclose</span>(file);</span><br><span class="line"></span><br><span class="line">    min_address =  switch[<span class="string">&quot;min_address&quot;</span>];</span><br><span class="line">    <span class="keyword">if</span> (switch<span class="variable">.exists</span>(<span class="string">&quot;max_address&quot;</span>))</span><br><span class="line">        max_address = switch[<span class="string">&quot;max_address&quot;</span>];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        max_address = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (switch[s])</span><br><span class="line">     <span class="built_in">$display</span>(<span class="string">&quot;switch[%s] = %0d&quot;</span>, s, switch[s]);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>以上三种数组：动态数组、队列、关联数组，都是大小可变的数组，下面，讨论他们的公共方法！</p>
<h2 id="缩减方法"><a href="#缩减方法" class="headerlink" title="缩减方法"></a>缩减方法</h2><ul>
<li>缩减方法指的是把一个数组缩减为一个值</li>
<li>最常见的是sum对数组元素求和；</li>
<li>还有and、or、or(异或)</li>
</ul>
<p>栗子：</p>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b[$] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> w;</span><br><span class="line">w = b<span class="variable">.sum</span>();  <span class="comment">//求和</span></span><br><span class="line">w = b<span class="variable">.product</span>();  <span class="comment">//求积</span></span><br><span class="line">w = b<span class="variable">.and</span>();  <span class="comment">//求元素依次按位与</span></span><br></pre></td></tr></table></figure>

<h2 id="定位方法"><a href="#定位方法" class="headerlink" title="定位方法"></a>定位方法</h2><ul>
<li>对于非合并数组，可以使用数组定位方法，<strong>返回值是一个队列，而不是数据成员</strong>；</li>
<li>包括min、max、unique</li>
<li><code>d.find_  with(expression)</code></li>
</ul>
<p>栗子：</p>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> f[<span class="number">6</span>] = &#x27;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;  <span class="comment">//定长数组</span></span><br><span class="line"><span class="keyword">int</span> d[] = &#x27;&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;  <span class="comment">//动态数组</span></span><br><span class="line"><span class="keyword">int</span> q[$] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;, tq[$];  <span class="comment">//队列</span></span><br><span class="line">tq = q<span class="variable">.min</span>();  <span class="comment">//&#123;1&#125;</span></span><br><span class="line">tq = d<span class="variable">.max</span>();</span><br><span class="line">tq= f<span class="variable">.union</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[] = &#x27;&#123;<span class="number">9</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">8</span>&#125;, tq[$];</span><br><span class="line">tq = d<span class="variable">.find</span> <span class="keyword">with</span> (item &gt; <span class="number">3</span>); <span class="comment">//找出所有大于3的元素</span></span><br><span class="line">tq<span class="variable">.delete</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (d[i])</span><br><span class="line">    <span class="keyword">if</span>(d[i] &gt; <span class="number">3</span>)</span><br><span class="line">        tq<span class="variable">.push_back</span>(d[i]);</span><br><span class="line"></span><br><span class="line">tq = d<span class="variable">.find_index</span> <span class="keyword">with</span> (item &gt;<span class="number">3</span>);</span><br><span class="line">tq = d<span class="variable">.find_first</span> <span class="keyword">with</span> (item &gt;<span class="number">3</span>);</span><br><span class="line">tq = d<span class="variable">.find_first_index</span> <span class="keyword">with</span> (item &gt;<span class="number">3</span>);</span><br><span class="line">tq = d<span class="variable">.find_last</span> <span class="keyword">with</span> (item &gt;<span class="number">3</span>);</span><br><span class="line">tq = d<span class="variable">.find_last_index</span> <span class="keyword">with</span> (item &gt;<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h2 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h2><ul>
<li>通过排序方法，改变数组中元素的顺序，对他们进行正向、逆向、或者乱序的排序；</li>
<li>reverse : 反转</li>
<li>sort ： 从小到大</li>
<li>rsort</li>
<li>shuffle</li>
</ul>
<h1 id="类的封装"><a href="#类的封装" class="headerlink" title="类的封装"></a>类的封装</h1><ul>
<li>类是一种可以包含数据和方法(function、task)的类型；</li>
<li>例如一个数据包，可以定义为一个类，类中可以包含指令、地址、队列ID、时间戳和数据等成员；</li>
</ul>
<h2 id="类的概述"><a href="#类的概述" class="headerlink" title="类的概述"></a>类的概述</h2><ul>
<li>软件的类和硬件的module都可以理解为容器，但是类对于构建验证环境更加灵活！</li>
<li>OOP可以使用户能够创建复杂的数据类型，并且将他们和能够使用这些数据类型的程序结合在一起；</li>
<li>用户可以在更加抽象的层次建立测试平台和系统级模型，通过<strong>调用函数来执行一个动作</strong>而不是简单的改变信号的电平；</li>
<li>验证环境的stimulator、monitor、checker以及其他验证组件都可以按照OOP方式来构建；</li>
<li>SV在类的定义中，只需要构建函数new，不需要定义析构函数</li>
<li>new函数的作用：<ul>
<li>例化对象时开辟内存空间；</li>
<li>对对象的成员变量初始化；</li>
<li>执行完之后，返回对象实例的句柄；</li>
</ul>
</li>
</ul>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet:</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] command;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">40</span>:<span class="number">0</span>] address;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">4</span>:<span class="number">0</span>] master_id;</span><br><span class="line">    <span class="keyword">integer</span> time_requested;</span><br><span class="line">    <span class="keyword">integer</span> time_issued;</span><br><span class="line">    <span class="keyword">integer</span> status;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;ERR_OVERFLOE=<span class="number">10</span>, ERR_UNDERFLOW=<span class="number">1123</span>&#125; PCKT_TYPE;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">integer</span> buffer_size=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">integer</span> header_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>():</span><br><span class="line">        command = <span class="number">4&#x27;d0</span>;</span><br><span class="line">        address = <span class="number">41&#x27;b0</span>;</span><br><span class="line">        master_id = <span class="number">5&#x27;bx</span>;</span><br><span class="line">        header_size = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> clean():</span><br><span class="line">        command = <span class="number">0</span>;</span><br><span class="line">        address = <span class="number">0</span>;</span><br><span class="line">        master_id = <span class="number">5&#x27;bx</span>;</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> issue_request(<span class="keyword">int</span> delay):</span><br><span class="line">        <span class="comment">//向总线发送请求</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">integer</span> current_status():</span><br><span class="line">        current_status = status;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">Packet p;   <span class="comment">//p是一个句柄指针，而不是对象，new之前是悬空状态</span></span><br><span class="line">p = <span class="keyword">new</span>();</span><br></pre></td></tr></table></figure>

<h3 id="class和struct的区别："><a href="#class和struct的区别：" class="headerlink" title="class和struct的区别："></a>class和struct的区别：</h3><ul>
<li>结构体可以包含数据成员，但是不能有成员方法，也无法进行例化；</li>
</ul>
<h3 id="static和其他："><a href="#static和其他：" class="headerlink" title="static和其他："></a>static和其他：</h3><blockquote>
<ul>
<li>句柄：指向对象的指针；</li>
<li>原型：程序的声明部分，包括程序名、返回类型和参数列表；</li>
<li>类在定义时，如果没有构建函数，系统会自动定义一个空的构建函数；</li>
<li>对象需要先声明再例化，或者同时进行；</li>
<li><strong>类的成员变量和方法默认都是动态的，即每个对象的变量和方法都会相应的开辟新的内存空间</strong>；</li>
<li><strong>如果多个对象要共享一个成员变量或者方法，可以使用static关键字修饰</strong>！</li>
<li>对于静态成员变量，在类没有例化的时候，就可以访问到，使用<code>p.val</code>或者<code>Packet::val</code></li>
<li>注意：静态方法不能访问动态成员变量，否则报错！</li>
</ul>
</blockquote>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><ul>
<li>this是用来明确索引当前所在对象的成员（变量、参数、方法）；</li>
<li><strong>this只能用在类的非静态</strong>成员方法、约束、和覆盖中。</li>
<li>this的使用可以明确所指向变量的作用域,避免变量指向不清晰的问题；</li>
</ul>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Demo:</span><br><span class="line">    <span class="keyword">integer</span> x;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">integer</span> x):</span><br><span class="line">        <span class="keyword">this</span><span class="variable">.x</span> = x;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>


<h1 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h1><h2 id="句柄的传递"><a href="#句柄的传递" class="headerlink" title="句柄的传递"></a>句柄的传递</h2><ul>
<li>区分类和对象之后，还要区分对象和句柄。对象创建之后，在内存的位置就不会改变了，但是指向该空间的句柄可以有不止一个；</li>
</ul>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line">Transaction t1, t2;  <span class="comment">//声明句柄</span></span><br><span class="line">t1 = <span class="keyword">new</span>(); <span class="comment">//例化对象，并返回句柄给t1</span></span><br><span class="line">t2 = t1;  <span class="comment">// t1和t2指向同一个对象了</span></span><br><span class="line">t1 = <span class="keyword">new</span>(); <span class="comment">//例化了第二个对象，返回句柄给t1,现在t1和t2指向不同对象了</span></span><br></pre></td></tr></table></figure>

<h2 id="赋值和拷贝"><a href="#赋值和拷贝" class="headerlink" title="赋值和拷贝"></a>赋值和拷贝</h2><ul>
<li>声明变量和创建对象是两个过程<ul>
<li><code>Packet p1; p1 = new();</code></li>
</ul>
</li>
<li>如果将p1赋值给p2，那么还是只有一个对象，但是有两个句柄；</li>
<li>p1和p2指向不同的对象，在创建p2时，从p1拷贝其成员变量，这种方式称为浅拷贝</li>
</ul>
<p>栗子：</p>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line">Packet p1, p2;</span><br><span class="line">p1 = <span class="keyword">new</span>;</span><br><span class="line">p2 = <span class="keyword">new</span> p1;  <span class="comment">//拷贝一个对象</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果两个句柄指向同一个对象，那么一个句柄修改了成员变量，另一个也会受影响；</li>
<li>如果想要拷贝一个对象，则可以使用<code>p2 = new p1;</code>的形式；</li>
</ul>
<h3 id="深入理解浅拷贝"><a href="#深入理解浅拷贝" class="headerlink" title="深入理解浅拷贝"></a>深入理解浅拷贝</h3><p>栗子：</p>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> rgb:</span><br><span class="line">    <span class="keyword">byte</span> red;</span><br><span class="line">    <span class="keyword">byte</span> green;</span><br><span class="line">    <span class="keyword">byte</span> blue;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> pixel:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    rgb color;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">pixel dot = <span class="keyword">new</span>;</span><br><span class="line">pixel dot2 = <span class="keyword">new</span> dot;      <span class="comment">//浅拷贝</span></span><br><span class="line">pixel dot3 = dot<span class="variable">.copy</span>();   <span class="comment">//深拷贝</span></span><br></pre></td></tr></table></figure>
<ul>
<li>SV中，对象的拷贝，只针对成员变量；</li>
<li><strong>如果对象中还有别的句柄，那么在new拷贝对象时，只能对color句柄拷贝，而不会对它指向的对象再做拷贝，称为浅拷贝</strong>！</li>
<li><strong>pixel dot2 &#x3D; new dot;      &#x2F;&#x2F;浅拷贝</strong></li>
<li><strong>pixel dot3 &#x3D; dot.copy();   &#x2F;&#x2F;深拷贝</strong></li>
<li>SV的new只能浅拷贝，需要深拷贝时，需要用户自己定义copy函数！</li>
<li><strong>类的成员在默认情况下，是公共属性的</strong>，表示对于类自身和外部都可以访问该成员变量和成员函数；</li>
<li>可以隐藏和封装，限制外部访问；<ul>
<li><strong>local：只有该类可以访问该成员，子类和外部都不能访问；</strong></li>
<li><strong>protected：该类和子类都可以访问该成员，但是外部不能访问；</strong></li>
<li>通过接口函数完成local的修改，开发者只需要维护接口函数即可；</li>
</ul>
</li>
</ul>
<p>栗子：</p>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet:</span><br><span class="line">    <span class="keyword">local</span> <span class="keyword">integer</span> i;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">integer</span> compare(Packet other):</span><br><span class="line">        compare = (<span class="keyword">this</span><span class="variable">.i</span> == other<span class="variable">.i</span>);</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> clock</span><br><span class="line">    <span class="keyword">local</span> <span class="keyword">bit</span> is_summer = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">local</span> <span class="keyword">int</span> nclock = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">int</span> get_clock();</span><br><span class="line">        <span class="keyword">if</span>(!is_summer) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span><span class="variable">.nclock</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span><span class="variable">.nclock</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">bit</span> set_summer(<span class="keyword">bit</span> s);</span><br><span class="line">        <span class="keyword">this</span><span class="variable">.is_summer</span> = s;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>


<h1 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h1><h2 id="继承和子类"><a href="#继承和子类" class="headerlink" title="继承和子类"></a>继承和子类</h2><ul>
<li>比如，在Packet类扩展一个新的类LinkPacket；</li>
<li>通过extends关键字，LinkedPacket继承父类Packet，所有的方法和成员变量；所以，LinkedPacket对象中也包含Packet类的成员；</li>
<li><strong>所以，父类的句柄也可以指向子类的对象！</strong></li>
<li><strong>如果子类中声明了与父类同名的成员，那么子类对他的同名成员的访问都指向子类，父类的成员被隐藏了！</strong> —&gt; 成员覆盖！</li>
<li></li>
</ul>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> LinkPacket <span class="keyword">extends</span> Packet;</span><br><span class="line">    LinkPacket next;</span><br><span class="line">    <span class="keyword">function</span> LinkPacket get_next();</span><br><span class="line">        get_next = next;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">LinkPacket lp = <span class="keyword">new</span>;</span><br><span class="line">Packet p = lp;</span><br></pre></td></tr></table></figure>

<p><strong>成员覆盖的栗子</strong>：</p>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line">    <span class="keyword">integer</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">integer</span> get();</span><br><span class="line">        get = i;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> LinkedPacket <span class="keyword">extends</span> Packet;</span><br><span class="line">    <span class="keyword">integer</span> i=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">integer</span> get();</span><br><span class="line">        get = -i;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">LinkedPacket lp = <span class="keyword">new</span>;</span><br><span class="line">Packet p = lp;</span><br><span class="line">j = p<span class="variable">.i</span>;        <span class="comment">//j=1,是用的父类的</span></span><br><span class="line">j = p<span class="variable">.get</span>();    <span class="comment">//j=1,还是父类的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果使用lp去访问，得到的也都是子类的，这才是覆盖！！！</span></span><br></pre></td></tr></table></figure>


<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><ul>
<li><code>super</code> ： 用来访问当前对象的父类的成员；</li>
<li>尤其当子类的成员和父类的成员同名时，需要使用super来指定访问父类的成员，而不是默认的子类成员；</li>
</ul>
<p>super的栗子：</p>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line">    <span class="keyword">integer</span> value;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">integer</span> delay();</span><br><span class="line">        delay = value * value;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> LinkedPacket <span class="keyword">extends</span> Packet;</span><br><span class="line">    <span class="keyword">integer</span> value;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">integer</span> delay();</span><br><span class="line">        delay = <span class="keyword">super</span><span class="variable">.delay</span>() + value * <span class="keyword">super</span><span class="variable">.value</span>;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<h2 id="验证环境中的案例"><a href="#验证环境中的案例" class="headerlink" title="验证环境中的案例"></a>验证环境中的案例</h2><blockquote>
<p>已经有了generator和driver两个组件，第一个单纯产生激励数据，第二个单纯使用激励数据发送时序激励；</p>
<p>这种单一职责划分，使得各个组件的任务十分明确；</p>
<p>如果要将数据发送到DUT，需要以下的基本元素和数据的处理方法，我们把他们封装在Transaction类中；</p>
<p>如果为了测试DUT的稳定性，需要加入一些错误的数据测试DUT的反馈，但是<strong>又想尽量复用原有的环境和各种已经定义好的类，则可以使用继承的方法</strong>，创建一个类BadTr</p>
</blockquote>
<p><img src="/2022/05/13/24/%E9%AA%8C%E8%AF%81%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E4%BE%8B%E5%AD%90.png" alt="验证环境中的例子"></p>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Transaction;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] src, dst, data[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] crc;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> calc_crc();</span><br><span class="line">        crc = src ^ dst ^ data<span class="variable">.xor</span>;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> display(<span class="keyword">input</span> <span class="keyword">string</span> prefix=<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;%sTr: src=%h, dst=%h, crc=%h&quot;</span>, prefix, src, dst, crc);</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> BadTr <span class="keyword">extends</span> Transaction;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> bad_crc;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> calc_crc;</span><br><span class="line">        <span class="keyword">super</span><span class="variable">.calc_crc</span>();</span><br><span class="line">        <span class="keyword">if</span> (bad_crc)</span><br><span class="line">            crc = ~crc;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> display(<span class="keyword">input</span> <span class="keyword">string</span> prefix=<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="built_in">$write</span>(<span class="string">&quot;%sBadTr bad_crc=%b, &quot;</span>, prefix, bad_crc);</span><br><span class="line">        <span class="keyword">super</span><span class="variable">.display</span>();</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span> : BadTr</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="包的使用"><a href="#包的使用" class="headerlink" title="包的使用"></a>包的使用</h1><p>两个模块同名会出现错误或者后面的覆盖了前面的，</p>
<ul>
<li>大型项目中，容易出现模块重名；</li>
<li>对于重名的硬件模块，可以将他们放到<strong>不同编译的库</strong>中；</li>
<li>对于重名的软件类、方法，可以放入<strong>不同的包</strong>中；</li>
<li><strong>使用不同的验证IP时，不知道是否会有重名的类，所以使用包package将关联的方法和类放入同一个逻辑集合</strong>；</li>
<li><strong>package还可以在多个模块或者类之间共享用户定义的类型</strong>；</li>
<li>用户自定义的类型，比如类、方法、变量、结构体、枚举都可以在<code>package .. endpackage</code>中定义；</li>
<li>在module、class、interface中，都可以使用包中定义或者声明的内容；</li>
<li>通过域索引符，<code>::</code>可以直接使用<ul>
<li><code>definitions::parameter</code></li>
</ul>
</li>
<li>可以通过import指定索引一些需要的包中定义的类型到指定的域中，或者使用<code>*</code>把包中的类型都导出：</li>
</ul>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> M;</span><br><span class="line">    <span class="keyword">import</span> definitions::instruction_t;</span><br><span class="line">    instruction_t inst;</span><br><span class="line">    <span class="keyword">import</span> definitions::*;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<ul>
<li>建议在不同包中的类名，命名时要加上包的前缀。</li>
</ul>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> definitions;</span><br><span class="line">    <span class="keyword">parameter</span> VERSION = <span class="string">&quot;1.1&quot;</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;ADD, SUB, MUL&#125; opcodes_t;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] a, b;</span><br><span class="line">        opcodes_t opcode;</span><br><span class="line">    &#125; instruction_t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">automatic</span> [<span class="number">31</span>:<span class="number">0</span>] multiplier(<span class="keyword">input</span>[<span class="number">31</span>:<span class="number">0</span>] a, b);</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endpackage</span></span><br></pre></td></tr></table></figure>

<h2 id="包和库的区分"><a href="#包和库的区分" class="headerlink" title="包和库的区分"></a>包和库的区分</h2><ul>
<li>package容器可以对类型做一个隔离作用；</li>
<li>package的意义是把软件中的类、方法、变量封装在各自不同的域中，与全局域做好隔离；</li>
<li>lib库是编译的产物，硬件的module、interface、program都会编译到库中，如果不指定编译库的话，会编译到默认的库中；</li>
<li>lib库可以容纳硬件类型，也能容纳软件类型（类、方法和包等）</li>
<li>package包只能容纳软件类型，比如类、方法和参数；</li>
</ul>
]]></content>
      <categories>
        <category>路科V0</category>
      </categories>
      <tags>
        <tag>UVM</tag>
        <tag>System Verilog</tag>
        <tag>IC验证</tag>
      </tags>
  </entry>
  <entry>
    <title>路科V0P19P22随机变量-随机约束-约束控制-任务和函数</title>
    <url>/2022/05/13/17/</url>
    <content><![CDATA[<h1 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h1><ul>
<li>随着设计越来越大，要产生完整的激励来测试设计的功能变得越来越困难；</li>
<li>定向激励的测试方法已经无法满足检查功能完整性的要求；</li>
<li>Soc集成度提高带来的模块之间交互的复杂性也指数提高，验证工程师无法预测用户使用过程中发生什么样的情况；</li>
</ul>
<h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><ul>
<li><strong>随机-约束</strong>： 构成目前动态仿真验证的主流方法；</li>
<li><strong>随机约束测试</strong>：CRT， constrained-random test，即能够产生感兴趣的、想不到的测试向量，<strong>通过回归测试、替换随机种子的方式来提高单位测试用例的覆盖率收集效率</strong>；</li>
<li>随机测试带来的负担是验证环境的复杂度提高，不再只需要发送激励的组件，还包括监测器、比较器等；</li>
<li>对环境复杂度还包括环境的复用和测试的复用，带来组件封装要求，使得代码量增大；</li>
</ul>
<h2 id="产生一个随机数"><a href="#产生一个随机数" class="headerlink" title="产生一个随机数"></a>产生一个随机数</h2><blockquote>
<p>利用系统函数产生一个随机数</p>
</blockquote>
<ul>
<li><code>randomize</code>函数产生随机数，如果随机成功，返回1,否则0；</li>
<li>通过系统函数<code>std::randomize()</code>对一些变量完成随机化，即产生随机数并赋值给这些向量；</li>
<li>还有一些其他的系统函数：<ul>
<li><code>$urandom()</code> 产生一个32位无符号的随机数；</li>
<li><code>$urandom_range(max_val, minval=0)</code>， 可以生成介于maxval和minval之间的随机数；</li>
</ul>
</li>
</ul>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> stim;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">15</span>:<span class="number">0</span>] addr;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] data;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">bit</span> get_stim();</span><br><span class="line">        <span class="keyword">bit</span> success, rd_wr;</span><br><span class="line">        success = randomize(add, data, rd_wr);</span><br><span class="line">        <span class="keyword">return</span> rd_wr;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h2 id="系统有机的组织随机变量"><a href="#系统有机的组织随机变量" class="headerlink" title="系统有机的组织随机变量"></a>系统有机的组织随机变量</h2><ul>
<li>比起独立的产生随机数，在向DUT产生随机激励时，为了符合协议、满足测试需求，还需要添加一些约束；</li>
<li>这些约束会使得变量朝着希望他们变化的方向去随机；</li>
<li>这些约束也会对变量和变量之间的关系生效；</li>
<li>需要一个载体去容纳变量和他们之间的约束；</li>
<li><strong>这个载体是类，类的成员变量可以声明“随机”属性，用rand或者randc表示</strong>；</li>
</ul>
<h2 id="随机变量-1"><a href="#随机变量-1" class="headerlink" title="随机变量"></a>随机变量</h2><ul>
<li>任何类中的整型（bit、byte、int）变量都可以声明为rand、randc；</li>
<li>定长数组、动态数组、关联数组和队列都可以声明为rand、randc；</li>
<li>可以对动态数组和队列的长度加以约束；</li>
<li><strong>指向对象的句柄，也可以声明为rand，不能randc，随机时该句柄指向的对象中的随机变量会一起被随机化</strong>；</li>
<li>非组合型结构体可以声明为rand，非组合型的成员也可以声明为rand、randc；</li>
</ul>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] len;</span><br><span class="line"><span class="keyword">rand</span> <span class="keyword">integer</span> data[];</span><br><span class="line"><span class="keyword">constraint</span> db &#123;data<span class="variable">.size</span> == len;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">randc</span> <span class="keyword">int</span> addr = <span class="number">1</span> + constant;</span><br><span class="line">    <span class="keyword">int</span> crc;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">byte</span> data [] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">&#125; header;</span><br><span class="line"><span class="keyword">rand</span> header h1;</span><br></pre></td></tr></table></figure>

<h2 id="rand和randc"><a href="#rand和randc" class="headerlink" title="rand和randc"></a>rand和randc</h2><ul>
<li>rand： 表示在可生成范围内，每个值得可能性是相同的–&gt;每次都是有放回！！<ul>
<li><code>rand bit [7:0] y;</code></li>
</ul>
</li>
<li>randc: 它的值会随机，并且遍历可取值范围，–&gt;无放回！！</li>
</ul>
<h1 id="随机约束"><a href="#随机约束" class="headerlink" title="随机约束"></a>随机约束</h1><h2 id="带有随机约束的简单类"><a href="#带有随机约束的简单类" class="headerlink" title="带有随机约束的简单类"></a>带有随机约束的简单类</h2><figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] src, dst, data[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">randc</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] kind;</span><br><span class="line">    <span class="comment">// src的约束</span></span><br><span class="line">    <span class="keyword">constraint</span> c &#123;src &gt; <span class="number">10</span>; src &lt; <span class="number">15</span>;&#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">Packet p;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    p = <span class="keyword">new</span>();</span><br><span class="line">    <span class="keyword">if</span> (!p<span class="variable">.randomize</span>())</span><br><span class="line">        <span class="built_in">$finish</span>;</span><br><span class="line">    transmit(p);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="约束块"><a href="#约束块" class="headerlink" title="约束块"></a>约束块</h2><ul>
<li>有用的激励不仅会约束随机变量，变量之间也存在互相约束关系；</li>
<li>没有约束的随机变量会包含很多无效的和非法的值，会使得有效激励变得低效；</li>
<li>类需要<strong>用一个或者多个约束块来描述变量之间的关系</strong>；</li>
<li><strong>约束块支持整型通过<code>inside</code>操作符来设置可取值的范围</strong>；</li>
</ul>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rand</span> <span class="keyword">integer</span> x,y,z;</span><br><span class="line"><span class="keyword">constraint</span> c1 &#123;x <span class="keyword">inside</span> &#123;<span class="number">3</span>, <span class="number">5</span>, [<span class="number">9</span>:<span class="number">15</span>], [<span class="number">24</span>:<span class="number">32</span>], [y:<span class="number">2</span>*y], z&#125;;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">rand</span> <span class="keyword">integer</span> a,b,c;</span><br><span class="line"><span class="keyword">constraint</span> c2 &#123;a <span class="keyword">inside</span> &#123;b, c&#125;;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">integer</span> fives[<span class="number">4</span>] = &#x27;&#123;<span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>&#125;;</span><br><span class="line"><span class="keyword">rand</span> <span class="keyword">integer</span> v;</span><br><span class="line"><span class="keyword">constraint</span> c3 &#123;v <span class="keyword">inside</span> &#123;fives&#125;;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="权重分布"><a href="#权重分布" class="headerlink" title="权重分布"></a>权重分布</h2><ul>
<li>除了成员集合设置，约束块也支持设置可取值的同事为其设置随机时的权重；</li>
<li><strong><code>:=</code> : 表示每个值的权重都是相同的；</strong></li>
<li><strong><code>:/</code> : 表示权重会平均分配到每一个值；</strong></li>
</ul>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line">x <span class="keyword">dist</span> &#123; [<span class="number">100</span>:<span class="number">102</span>] := <span class="number">1</span>, <span class="number">200</span> := <span class="number">2</span>, <span class="number">300</span> := <span class="number">5</span>&#125;;   <span class="comment">// 权重分布：1 1 1 2 5</span></span><br><span class="line">x <span class="keyword">dist</span> &#123; [<span class="number">100</span>:<span class="number">102</span>] :/ <span class="number">1</span>, <span class="number">200</span> := <span class="number">2</span>, <span class="number">300</span> := <span class="number">5</span>&#125;;   <span class="comment">// 权重分布：1/3 1/3 1/3 2 5</span></span><br></pre></td></tr></table></figure>

<h2 id="唯一标识"><a href="#唯一标识" class="headerlink" title="唯一标识"></a>唯一标识</h2><ul>
<li><code>unique</code> : 可以用来约束一组变量，使得其随机后变量之间不会有相同的数值；</li>
</ul>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rand</span> <span class="keyword">byte</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">rand</span> <span class="keyword">byte</span> b;</span><br><span class="line"><span class="keyword">rand</span> <span class="keyword">byte</span> excluded;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constraint</span> u &#123;<span class="keyword">unique</span> &#123;b, a[<span class="number">2</span>:<span class="number">3</span>], excluded&#125;;&#125;</span><br><span class="line"><span class="keyword">constraint</span> exclusion &#123;excluded == <span class="number">5</span>;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="条件约束"><a href="#条件约束" class="headerlink" title="条件约束"></a>条件约束</h2><ul>
<li>可以使用<code>if-else</code>或者<code>-&gt;</code>操作符表示条件约束；</li>
</ul>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constraint</span> c1 &#123;</span><br><span class="line">    mode == little -&gt; len &lt; <span class="number">10</span>;</span><br><span class="line">    mode == big -&gt; len &gt; <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] a, b;</span><br><span class="line"><span class="keyword">constraint</span> c2 &#123;(a==<span class="number">0</span>) -&gt; (b==<span class="number">1</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constraint</span> c3 &#123;</span><br><span class="line">    <span class="keyword">if</span> (mode == little)</span><br><span class="line">        len &lt; <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mode == big)</span><br><span class="line">        len &gt; <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="迭代约束"><a href="#迭代约束" class="headerlink" title="迭代约束"></a>迭代约束</h2><ul>
<li><code>foreach</code>可以用来迭代约束数组中的元素，这些数组可以是定长数组、动态数组、关联数组或者队列；</li>
</ul>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> C;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">byte</span> A[];</span><br><span class="line">    <span class="keyword">constraint</span> c1 &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (A[i])</span><br><span class="line">            A[i] <span class="keyword">inside</span> &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constraint</span> c2 &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (A[j])</span><br><span class="line">            A[j] &gt; <span class="number">2</span>*j;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<ul>
<li>也可以用数组的缩减方法进行迭代约束</li>
</ul>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> C;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] A[];</span><br><span class="line">    <span class="keyword">constraint</span> c1 &#123;A<span class="variable">.size</span>() == <span class="number">5</span>;&#125;</span><br><span class="line">    <span class="keyword">constraint</span> c2 &#123;A<span class="variable">.sum</span>() &lt; <span class="number">1000</span>;&#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><ul>
<li>有时候，在一些表达式中不能简单的描述约束，比如计算一个组合数组中的’1’；</li>
<li>可以写成一个函数，然后约束调用这个函数；</li>
</ul>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> count_ones (<span class="keyword">bit</span> [<span class="number">9</span>:<span class="number">0</span>] w);</span><br><span class="line">    <span class="keyword">for</span> (count_onts=<span class="number">0</span>; w!=<span class="number">0</span>; w = w&gt;&gt;<span class="number">1</span>)</span><br><span class="line">        count_ones += w &amp; <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constraint</span> C1 &#123;length == count_ones(v);&#125;</span><br></pre></td></tr></table></figure>

<h2 id="软约束-和-硬约束"><a href="#软约束-和-硬约束" class="headerlink" title="软约束 和 硬约束"></a>软约束 和 硬约束</h2><ul>
<li>为了防止约束冲突时执行失败，分为软约束和硬约束；</li>
<li><code>soft</code> : soft描述的约束是软，没有soft是硬；</li>
<li>如果用户在使用时，制订了外部约束对同一个变量做了二次约束，或者用户定义了子类，也对同一个变量做了二次约束，<strong>那么硬约束可以覆盖软约束</strong>，不会导致随机失败；</li>
</ul>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">constraint</span> deflt &#123;<span class="keyword">soft</span> length <span class="keyword">inside</span> &#123;<span class="number">32</span>, <span class="number">1024</span>&#125;;&#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">Packet p = <span class="keyword">new</span>();</span><br><span class="line">p<span class="variable">.randomize</span>() <span class="keyword">with</span> &#123;length == <span class="number">1512</span>;&#125;        <span class="comment">// 覆盖了内部的软约束，执行成功</span></span><br></pre></td></tr></table></figure>



<h1 id="约束控制"><a href="#约束控制" class="headerlink" title="约束控制"></a>约束控制</h1><h2 id="随机方法"><a href="#随机方法" class="headerlink" title="随机方法"></a>随机方法</h2><ul>
<li>类的声明中的随机变量，需要伴随类的句柄的调用randomize()，这是SV的内建方法<code>virtual function int randomize();</code></li>
<li>随机化成功返回1,否则0；</li>
<li>随机化之前需要先对对象完成例化，例化时没有随机的过程；</li>
</ul>
<h2 id="内嵌约束"><a href="#内嵌约束" class="headerlink" title="内嵌约束"></a>内嵌约束</h2><ul>
<li>在调用<code>randomize()</code>时伴随<code>with</code>，称为内嵌约束；</li>
</ul>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> C;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">integer</span> x;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> F(C obj, <span class="keyword">integer</span> y);</span><br><span class="line">    F = obj<span class="variable">.randomize</span>() <span class="keyword">with</span> (x) &#123;x &lt; y;&#125;;      <span class="comment">//这种方式对x的指向明确了，不在参数列表中，所以是C的x</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>

<h2 id="local域指向"><a href="#local域指向" class="headerlink" title="local域指向"></a>local域指向</h2><ul>
<li>同名的变量处于不同的域中，可能出现指向模糊，可以使用上文的方法；</li>
<li>也可以使用<code>local::</code>域索引到方式；</li>
</ul>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> C;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">integer</span> x;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> F(C obj, <span class="keyword">integer</span> x);</span><br><span class="line">    F = obj<span class="variable">.randomize</span>() <span class="keyword">with</span>&#123;x &lt; <span class="keyword">local</span>::x;&#125;;      <span class="comment">//第一个x是C的，第二个local的x是参数</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>

<h2 id="随机控制"><a href="#随机控制" class="headerlink" title="随机控制"></a>随机控制</h2><ul>
<li><code>rand_mode</code>可以用来使能或者禁止成员变量的随机属性；<ul>
<li>当随机模式被禁止时，就相当于一个普通变量了；</li>
<li>可以禁止某个变量的随机模式，也可以对整个对象调用<code>rand_mode</code>进行控制；</li>
</ul>
</li>
<li><code>constraint_mode()</code>用来关闭或者使能约束块；</li>
</ul>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> object[<span class="variable">.random_variable</span>]::rand_mode(<span class="keyword">bit</span> on_off);</span><br><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> object<span class="variable">.rand_variable</span>::rand_mode();</span><br></pre></td></tr></table></figure>

<h2 id="内嵌变量控制"><a href="#内嵌变量控制" class="headerlink" title="内嵌变量控制"></a>内嵌变量控制</h2><ul>
<li>一个有意思的点，如果在<code>randomize()</code>中有参数，则只会对这个参数进行随机化，别的就算是rand也不随机化了；</li>
</ul>
<h1 id="任务和函数"><a href="#任务和函数" class="headerlink" title="任务和函数"></a>任务和函数</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>function和task都是提高代码复用性和整洁度；</li>
<li>function：<ul>
<li>首要目的在于为运算表达式提供返回值，便于简化原有代码，提高维护性；</li>
<li>void函数无返回值；</li>
<li><strong>一个function只能有一个返回值</strong>，所以函数可以作为表达式的操作数，因为就一个值；</li>
<li>函数的参数方向可以声明为：input、output、inout、ref</li>
<li><strong>函数可以调用函数，但是必须立即返回，不能阻塞等待</strong>！</li>
<li><strong>函数返回方式有两种，一个是return直接返回，一个是将值或者表达式赋给函数的同名变量</strong>；</li>
<li>区别在于return会立即返回，但是赋值同名变量之后，后续的代码还会执行下去；</li>
<li>可以对有返回值的函数进行类型转换，<code>void&#39;(func1)</code>,这时候用不到函数的返回值；</li>
</ul>
</li>
<li>task：<ul>
<li>同样的参数列表指名四个方向；</li>
<li>task无返回值！</li>
<li>task可以用来消耗仿真时间，内置一些阻塞语句；</li>
<li>可以使用return立刻结束task；</li>
<li>task可以调用task和function，但是function只能调用function，不能调用task；</li>
</ul>
</li>
</ul>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">logic</span> red;</span><br><span class="line"><span class="keyword">parameter</span> red_tics = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">    red = on;</span><br><span class="line">    light(red, red_tics);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> light(<span class="keyword">output</span> color, <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] tics);</span><br><span class="line">    <span class="keyword">repeat</span>(tics) @(<span class="keyword">posedge</span> clock);</span><br><span class="line">    color = off;</span><br><span class="line"><span class="keyword">endtask</span>: light</span><br></pre></td></tr></table></figure>

<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><ul>
<li>input ： 在方法调用时，<strong>属于值传递</strong>，在传递的过程中，外部变量的值<strong>经过拷贝</strong>，赋值给输入参数；</li>
<li>output、inout都是值传递，发生在方法调用和返回时；</li>
<li><strong>ref参数不会传递值拷贝，而是将变量指针传递到方法中，所以方法内部的操作会影响到外部的变量；</strong></li>
<li><strong>为了避免外部传入的ref参数被方法修改，可以添加const修饰符</strong>；</li>
<li>SV允许在声明输入参数时，指定参数的默认值；</li>
<li>除了按照参数位置传递参数，SV也允许像module例化一样，<strong>用参数名字映射的方式传递参数</strong>；</li>
</ul>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> read(<span class="keyword">int</span> j=<span class="number">0</span>, <span class="keyword">int</span> k, <span class="keyword">int</span> data=<span class="number">1</span>);</span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line">read(,<span class="number">5</span>);  <span class="comment">// 即0 5 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> func(<span class="keyword">int</span> j=<span class="number">1</span>, <span class="keyword">string</span> s= <span class="string">&quot;no&quot;</span>);</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">func(<span class="variable">.j</span>(<span class="number">2</span>), <span class="variable">.s</span>(<span class="string">&quot;yes&quot;</span>));  <span class="comment">// 即2 yes</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>路科V0</category>
      </categories>
      <tags>
        <tag>UVM</tag>
        <tag>System Verilog</tag>
        <tag>IC验证</tag>
      </tags>
  </entry>
  <entry>
    <title>路科V0P1P2P4验证概览</title>
    <url>/2022/05/09/13/</url>
    <content><![CDATA[<h1 id="什么是验证"><a href="#什么是验证" class="headerlink" title="什么是验证"></a>什么是验证</h1><p><img src="/2022/05/09/13/%E4%BB%80%E4%B9%88%E6%98%AF%E9%AA%8C%E8%AF%81.png" alt="什么是验证"></p>
<p>什么是验证?</p>
<p><img src="/2022/05/09/13/%E4%BB%80%E4%B9%88%E6%98%AF%E9%AA%8C%E8%AF%812.png" alt="什么是验证2"></p>
<p>测试平台：</p>
<p><img src="/2022/05/09/13/%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0.png" alt="什么是测试平台"></p>
<h1 id="验证的任务和目标"><a href="#验证的任务和目标" class="headerlink" title="验证的任务和目标"></a>验证的任务和目标</h1><p>验证的目标：</p>
<p><img src="/2022/05/09/13/%E9%AA%8C%E8%AF%81%E7%9A%84%E7%9B%AE%E6%A0%87.png" alt="验证的目标"></p>
<h1 id="验证的周期"><a href="#验证的周期" class="headerlink" title="验证的周期"></a>验证的周期</h1><p><img src="/2022/05/09/13/%E9%AA%8C%E8%AF%81%E5%91%A8%E6%9C%9F.png" alt="验证周期"></p>
]]></content>
      <categories>
        <category>路科V0</category>
      </categories>
      <tags>
        <tag>UVM</tag>
        <tag>System Verilog</tag>
        <tag>IC验证</tag>
      </tags>
  </entry>
  <entry>
    <title>路科V0P1SV学习</title>
    <url>/2022/05/09/06/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.bilibili.com/video/BV1k7411H7Jo?spm_id_from=333.337.search-card.all.click">Bilibili</a></p>
</blockquote>
<p>几个必备技术要求：</p>
<ul>
<li>动态验证技术<ul>
<li>代码覆盖率</li>
<li>功能覆盖率</li>
<li>断言</li>
<li>随机约束</li>
</ul>
</li>
<li>静态验证技术<ul>
<li>人工的形式验证（属性检查）</li>
<li>自动的形式验证</li>
</ul>
</li>
<li>硬件加速技术<ul>
<li>Emulation以及FPGA原型开发</li>
</ul>
</li>
</ul>
<p>背景要求：</p>
<ul>
<li>课程：<ul>
<li>数字电路</li>
<li>Verilog</li>
<li>C&#x2F;C++</li>
</ul>
</li>
</ul>
<p><img src="/2022/05/09/06/%E5%8A%A8%E6%80%81%E9%AA%8C%E8%AF%81%E6%8A%80%E6%9C%AF.png" alt="动态验证技术"></p>
<p><img src="/2022/05/09/06/%E9%9D%99%E6%80%81%E9%AA%8C%E8%AF%81%E6%8A%80%E6%9C%AF.png" alt="静态验证技术"></p>
<p><img src="/2022/05/09/06/%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F.png" alt="硬件加速"></p>
<p><img src="/2022/05/09/06/QuestaSim%E4%BB%BF%E7%9C%9F%E5%99%A8.png" alt="QuestaSim仿真器"></p>
<p><img src="/2022/05/09/06/%E5%A4%A7%E8%B1%A1%E8%A3%85%E8%BF%9B%E5%86%B0%E7%AE%B1lab.png" alt="大象装进冰箱lab"></p>
<p><img src="/2022/05/09/06/%E8%B5%84%E6%96%99%E4%B9%A6.png" alt="资料书"></p>
<p><img src="/2022/05/09/06/DVT%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.png" alt="DVT集成开发环境"></p>
<p><img src="/2022/05/09/06/%E5%85%B6%E4%BB%96%E8%AF%BE%E7%A8%8B.png" alt="其他课程"></p>
]]></content>
      <categories>
        <category>路科V0</category>
      </categories>
      <tags>
        <tag>UVM</tag>
        <tag>System Verilog</tag>
        <tag>IC验证</tag>
      </tags>
  </entry>
  <entry>
    <title>路科V0P23P25线程控制-线程同步-线程通信</title>
    <url>/2022/05/15/03/</url>
    <content><![CDATA[<h1 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h1><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><ul>
<li>线程是独立运行的程序；</li>
<li>需要被<strong>触发</strong>，可以结束或者不结束；</li>
<li>在module中的initial和always，都可以看做<strong>独立的线程</strong>，会在仿真0时刻开始，选择结束或者不结束；</li>
<li>硬件模型中，由于都是always语句块，所以可以看成是多个独立运行的线程，<strong>他们一直占用着仿真资源，因为不会结束</strong>；</li>
<li>验证环境中需要由initial语句块去创建，在仿真过程中，验证环境中的对象可以<strong>创建和销毁</strong>，因此验证环境中的资源是动态的。</li>
<li>验证环境中的initial语句块有两种分组方式，begin..end和fork..join<ul>
<li><strong>begin..end ： 顺序方式执行</strong></li>
<li><strong>fork..join ： 并发方式执行</strong></li>
<li><strong>与fork..join类似的，还有fork..join_any和fork..join_none</strong></li>
</ul>
</li>
<li>线程的执行轨迹是树状结构，任何线程都有父线程；</li>
<li>父线程可以开辟若干个子线程，父线程可以暂停或者终止子线程；</li>
<li>子线程终止时，父线程可以继续执行；</li>
<li><strong>父线程终止时，它的所有子线程都会终止</strong>；</li>
</ul>
<h2 id="并行线程"><a href="#并行线程" class="headerlink" title="并行线程"></a>并行线程</h2><ul>
<li>fork..join : 等待所有子线程结束，才会继续执行后面的；</li>
<li>fork..join_any : 只要有一个子线程结束(最短的先结束)，就会继续执行后面的；</li>
<li>fork..join_none : 不需要等待任何子线程结束，就可以继续执行后面的；</li>
<li><strong>注意</strong> ： 虽然无需等待，但是fork..join_any和fork..join_none执行后面的时候，前面的子线程还在执行；</li>
<li><strong>如果要等待这些子线程都完成，或者停止这些子线程，可以使用<code>wait fork</code>或者<code>disable fork</code>；</strong></li>
</ul>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fork</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;First Block\n&quot;</span>);</span><br><span class="line">        # <span class="number">20</span>ns;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;Second Block\n&quot;</span>);</span><br><span class="line">        @eventA;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">join</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> do_test;</span><br><span class="line">    <span class="keyword">fork</span></span><br><span class="line">        exec1();</span><br><span class="line">        exec2();</span><br><span class="line">    <span class="keyword">join_any</span></span><br><span class="line">    <span class="keyword">fork</span></span><br><span class="line">        exec3();</span><br><span class="line">        exec4();</span><br><span class="line">    <span class="keyword">join_none</span></span><br><span class="line">    <span class="keyword">wait</span> <span class="keyword">fork</span>   <span class="comment">//等待所有子线程结束</span></span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure>

<h2 id="时序控制"><a href="#时序控制" class="headerlink" title="时序控制"></a>时序控制</h2><ul>
<li>SV中可以通过延迟控制或者事件等待来完成时序控制；</li>
<li>延迟控制通过<code>#</code>完成；   <code>#10 rega = regb;</code></li>
<li>事件控制（event）通过<code>@</code>完成；<ul>
<li><code>@r rega = regb;</code></li>
<li><code>@(posedge clock) rega = regb;</code></li>
</ul>
</li>
<li><code>wait</code>语句可以与事件或者表达式结合，来完成时序控制；<ul>
<li><code>real AOR[];  initial wait(AOR.size() &gt; 0) ...;</code></li>
</ul>
</li>
</ul>
<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>测试平台中所有线程都需要同步并交换数据；</li>
<li>一个线程等待另外一个，比如验证环境需要等待所有激励结束，比较结束才能结束仿真；</li>
<li>比如监测器需要将数据发送到检查器，检查器又需要从不同的缓存获取数据进行比较；</li>
</ul>
<h2 id="线程同步的第一个类型：event事件"><a href="#线程同步的第一个类型：event事件" class="headerlink" title="线程同步的第一个类型：event事件"></a>线程同步的第一个类型：event事件</h2><ul>
<li>可以通过event声明一个event变量，并且触发它；</li>
<li>这个event变量可以用来控制多个线程间的同步；一端触发，另一端阻塞等待；</li>
<li>通过<code>-&gt;</code>操作符触发事件；</li>
<li>其他等待该事件的线程可以通过<code>@</code>操作符或者<code>wait()</code>来检查event的触发状态；</li>
<li><code>wait_order()</code>方法： <strong>可以使线程保持等待，直到在参数列表中的事件event按照从左到右的顺序依次完成</strong>；</li>
<li>如果参数列表中的事件被触发，但是没有按照要求顺序，也会失败；</li>
</ul>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">event</span> done, blast;</span><br><span class="line"><span class="keyword">event</span> done_too = done;</span><br><span class="line"><span class="keyword">task</span> trigger(<span class="keyword">event</span> ev);</span><br><span class="line">    -&gt; ev;</span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fork</span></span><br><span class="line">    @ done_too;</span><br><span class="line">    #<span class="number">1</span> trigger(done);</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fork</span></span><br><span class="line">    -&gt;blast;</span><br><span class="line">    <span class="keyword">wait</span>(blast<span class="variable">.triggered</span>);</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// wait_order</span></span><br><span class="line"><span class="keyword">wait_order</span>(a,b,c) <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;Error: events out of order&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">bit</span> success;</span><br><span class="line"><span class="keyword">wait_order</span>(a,b,c) </span><br><span class="line">    success = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    success = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h2 id="线程同步的第二个类型：旗语semaphore"><a href="#线程同步的第二个类型：旗语semaphore" class="headerlink" title="线程同步的第二个类型：旗语semaphore"></a>线程同步的第二个类型：旗语semaphore</h2><ul>
<li>旗语可以看做打开共享资源大门的钥匙；用于访问控制保护；</li>
<li>创建旗语时，<strong>会为其分配固定的钥匙数量</strong>；</li>
<li>使用旗语时，必须先获得钥匙，才能继续执行；</li>
<li>旗语的钥匙数量可以有多个，等待旗语钥匙的线程也可以有多个；</li>
<li><strong>旗语通常用于互斥，对共享资源的访问控制，以及基本的同步</strong>；</li>
</ul>
<h3 id="旗语的创建"><a href="#旗语的创建" class="headerlink" title="旗语的创建"></a>旗语的创建</h3><ul>
<li>创建旗语，并为他分配钥匙的方式：<ul>
<li><code>semaphore sm;</code>   <code>sm = new();</code></li>
</ul>
</li>
<li>创建一个固定钥匙数量的旗语，<code>new(N)</code></li>
<li>从旗语那里获取一个或者多个钥匙（<strong>阻塞型</strong>）： <code>get(N=1)</code></li>
<li>将一个或者多个钥匙返回到旗语中： <code>put(N=1)</code></li>
<li><strong>尝试获取一个或者多个钥匙，而不阻塞</strong>： <code>try_get(N=1)</code></li>
<li>new函数默认为0,但是可以put超过开始的数量值；</li>
<li>new()返回旗语的句柄；</li>
<li>put() : 如果其他进程在等待旗语，则应该在该进程有足够数量钥匙的情况下返回；</li>
<li>get() : 如果指定数量的钥匙可用，则方法返回并继续执行，如果不足，进程阻塞直到钥匙数目充足；</li>
<li>旗语的等待队列是FIFO的，先排队的先获得；</li>
<li>try_get() : 如果指定数目可用，返回正数并继续执行，否则，返回0；</li>
</ul>
<h1 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h1><blockquote>
<p>除了event、semaphore之外，还有mailbox信箱</p>
<p>信箱可以放置任何类型，可以设置尺寸大小，防止存储数据过多占用资源，信箱也是FIFO的</p>
</blockquote>
<h2 id="信箱的内建方法"><a href="#信箱的内建方法" class="headerlink" title="信箱的内建方法"></a>信箱的内建方法</h2><ul>
<li>new() : 创建信箱，默认尺寸bound为0，表示不限制大小，否则限制为最大值N；</li>
<li>put() : 将信息写入信箱，如果信箱已满，则put被挂起，直到可以有新的空间；</li>
<li>try_put() : 尝试写入信箱，不发生阻塞；如果满，不阻塞，返回0,否则成功返回1；</li>
<li>get() : 从信箱中获取信息，并取出</li>
<li>peek() : 获取信息，但是不取出，只是拷贝，如果信箱为空，peek会挂起，直到有消息；</li>
<li>try_get()  try_peek() : 非阻塞取出</li>
<li>num() : 获取信箱信息的数目；</li>
</ul>
<h2 id="参数化信箱"><a href="#参数化信箱" class="headerlink" title="参数化信箱"></a>参数化信箱</h2><ul>
<li>虽然信箱可以存放各种数据类型，但是为了之后用的方便，在声明时最好指定存储类型；</li>
<li>这种参数化信箱的方式可以在编译时就能检查出类型不匹配的情况；</li>
</ul>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> mailbox <span class="variable">#(string)</span> s_box;</span><br><span class="line">s_box sm = <span class="keyword">new</span>;</span><br><span class="line"><span class="keyword">string</span> s;</span><br><span class="line">sm<span class="variable">.put</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">sm<span class="variable">.get</span>(s);</span><br></pre></td></tr></table></figure>

<h2 id="信箱和队列的区别"><a href="#信箱和队列的区别" class="headerlink" title="信箱和队列的区别"></a>信箱和队列的区别</h2><ul>
<li>信箱必须通过new例化，但是队列只需要声明即可；</li>
<li>信箱的存取方法put()和get()是阻塞方法，但是队列的存取方法，push_back()和pop_front()方法是非阻塞的，会立即返回；</li>
<li>在传递形参时，如果是input方向，信箱类型传递到是句柄，而队列类型则是完成的队列内容的拷贝；</li>
</ul>
<h2 id="线程通信的比较"><a href="#线程通信的比较" class="headerlink" title="线程通信的比较"></a>线程通信的比较</h2><ul>
<li>event ： 最小信息量触发，即单一通知功能，可以用来做事件的触发，也可以多个事件组合起来用作线程同步；</li>
<li>semaphore : 共享资源的卫士，如果多线程对某一共享资源做访问，则可以使用这个要素；</li>
<li>mailbox ： 精小的SV原生FIFO，<strong>在线程之间做数据通信或者内部数据缓存</strong>时考虑使用这个元素；</li>
</ul>
]]></content>
      <categories>
        <category>路科V0</category>
      </categories>
      <tags>
        <tag>UVM</tag>
        <tag>System Verilog</tag>
        <tag>IC验证</tag>
      </tags>
  </entry>
  <entry>
    <title>路科V0P26P29-MCDT测试结构-实现激励发生器-监测器和检查器-顶层环境和测试用例</title>
    <url>/2022/05/15/47/</url>
    <content><![CDATA[<h1 id="MCDT测试结构"><a href="#MCDT测试结构" class="headerlink" title="MCDT测试结构"></a>MCDT测试结构</h1><h2 id="MCDT测试平台结构"><a href="#MCDT测试平台结构" class="headerlink" title="MCDT测试平台结构"></a>MCDT测试平台结构</h2><p><img src="/2022/05/15/47/MCDT%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0%E7%BB%93%E6%9E%84.png" alt="MCDT测试平台结构"></p>
<ul>
<li>要区分哪部分是硬件、哪部分是软件<ul>
<li>HW ： 待测的设计</li>
<li>SW ： 测试环境</li>
<li>软硬件之间交互通过interface</li>
</ul>
</li>
<li><strong>要清楚验证环境的各个组件之间的位置层次关系和它们之间是否有数据通信</strong>！<ul>
<li>验证组件之间的通信都是基于事务级的传送；</li>
<li>验证组件和硬件的通信必须依赖接口，通过硬件时序才能实现；</li>
</ul>
</li>
<li>理解仿真如何开始运转，各个验证组件如何工作，最后仿真如何结束</li>
</ul>
<h3 id="一些要注意的细节："><a href="#一些要注意的细节：" class="headerlink" title="一些要注意的细节："></a>一些要注意的细节：</h3><ul>
<li>channel initiator 和 channel monitor一一对应；</li>
<li>initiator和monitor被封装在了agent中；</li>
<li>由于arbiter不需要与下行握手，所以只外置了mcdt monitor而不需要mcdt responder；</li>
<li>所有的monitor都将监测到的数据送到mcdt checker；</li>
<li>MCDT checker内部例化了若干FIFO，是为了接收从MCDT的输入端和输出端的数据；</li>
<li>由于checker输入端和输出端FIFO中存放的数据类型一致，也为数据比较带来了方便；</li>
</ul>
<h2 id="激励发生器"><a href="#激励发生器" class="headerlink" title="激励发生器"></a>激励发生器</h2><p><img src="/2022/05/15/47/%E6%BF%80%E5%8A%B1%E5%8F%91%E7%94%9F%E5%99%A8.png" alt="激励发生器"></p>
<p><img src="/2022/05/15/47/%E6%BF%80%E5%8A%B1%E5%8F%91%E7%94%9F%E5%99%A82.png" alt="激励发生器2"></p>
<h2 id="监测器"><a href="#监测器" class="headerlink" title="监测器"></a>监测器</h2><p><img src="/2022/05/15/47/%E7%9B%91%E6%B5%8B%E5%99%A8.png" alt="监测器"></p>
<h2 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h2><p><img src="/2022/05/15/47/%E6%AF%94%E8%BE%83%E5%99%A8.png" alt="比较器"></p>
<p><img src="/2022/05/15/47/%E6%AF%94%E8%BE%83%E5%99%A82.png" alt="比较器2"></p>
<h1 id="实现激励发生器"><a href="#实现激励发生器" class="headerlink" title="实现激励发生器"></a>实现激励发生器</h1><h2 id="实现-channel-stimulator"><a href="#实现-channel-stimulator" class="headerlink" title="实现 channel stimulator"></a>实现 channel stimulator</h2><ul>
<li>数据事务：<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> chnl_trans;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span>[<span class="number">31</span>:<span class="number">0</span>] data[];</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">int</span> ch_id;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">int</span> pkt_id;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">int</span> data_nidles;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">int</span> pkt_nidles;</span><br><span class="line">    <span class="keyword">bit</span> rsp;</span><br><span class="line">    <span class="keyword">local</span> <span class="keyword">static</span> <span class="keyword">int</span> obj_id=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constraint</span> cstr &#123;</span><br><span class="line">        <span class="keyword">soft</span> data<span class="variable">.size</span> <span class="keyword">inside</span> &#123;[<span class="number">4</span>:<span class="number">8</span>]&#125;;</span><br><span class="line">        <span class="keyword">foreach</span> (data[i])</span><br><span class="line">            data[i] == <span class="number">&#x27;hC000_0000</span> + (<span class="keyword">this</span><span class="variable">.ch_id</span> &lt;&lt; <span class="number">24</span>) + (<span class="keyword">this</span><span class="variable">.pkt_id</span> &lt;&lt; <span class="number">8</span>) + i;</span><br><span class="line">        <span class="keyword">soft</span> ch_id == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">soft</span> pkt_id == <span class="number">0</span>;</span><br><span class="line">        data_nidles <span class="keyword">inside</span> &#123;[<span class="number">0</span>:<span class="number">2</span>]&#125;;</span><br><span class="line">        pkt_nidles <span class="keyword">inside</span> &#123;[<span class="number">1</span>:<span class="number">10</span>]&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>();</span><br><span class="line">        <span class="keyword">this</span><span class="variable">.obj_id</span>++;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> chnl_trans clone();</span><br><span class="line">        chnl_trans c = <span class="keyword">new</span>();</span><br><span class="line">        c<span class="variable">.data</span> = <span class="keyword">this</span><span class="variable">.data</span>;</span><br><span class="line">        c<span class="variable">.ch_id</span> = <span class="keyword">this</span><span class="variable">.ch_id</span>;</span><br><span class="line">        c<span class="variable">.pkt_id</span> = <span class="keyword">this</span><span class="variable">.pkt_id</span>;</span><br><span class="line">        c<span class="variable">.data_nidles</span> = <span class="keyword">this</span><span class="variable">.data_nidles</span>;</span><br><span class="line">        c<span class="variable">.pkt_nidles</span> = <span class="keyword">this</span><span class="variable">.pkt_nidles</span>;</span><br><span class="line">        c<span class="variable">.rsp</span> = <span class="keyword">this</span><span class="variable">.rsp</span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span>: chnl_trans</span><br></pre></td></tr></table></figure></li>
<li>驱动激励的组件：<ul>
<li><strong>chnl_initiator的作用是从chnl_generator中获取chnl_trans的数据，并将其驱动到接口chnl_interface上面</strong>；</li>
</ul>
</li>
</ul>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> chnl_initiator;</span><br><span class="line">    <span class="keyword">local</span> <span class="keyword">string</span> name;</span><br><span class="line">    <span class="keyword">local</span> <span class="keyword">virtual</span> chnl_intf intf;</span><br><span class="line">    mailbox <span class="variable">#(chnl_trans)</span> req_mb;</span><br><span class="line">    mailbox <span class="variable">#(chnl_trans)</span> rsp_mb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;chnl_initiator&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span><span class="variable">.name</span> = name;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//从外部获得虚拟指针，并赋值给自己的虚接口成员变量</span></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> set_interface(<span class="keyword">virtual</span> chnl_intf intf);</span><br><span class="line">        <span class="keyword">if</span>(intf == <span class="literal">null</span>)</span><br><span class="line">            <span class="built_in">$error</span>(<span class="string">&quot;interface handle is NULL, please check if target interface has been intrantiated&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">this</span><span class="variable">.intf</span> = intf;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> run();</span><br><span class="line">        <span class="keyword">this</span><span class="variable">.driver</span>();</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> drive();</span><br><span class="line">        chnl_trans req, rsp;</span><br><span class="line">        @(<span class="keyword">posedge</span> intf<span class="variable">.rstn</span>); <span class="comment">//系统复位信号</span></span><br><span class="line">        <span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">this</span><span class="variable">.req_mb</span><span class="variable">.get</span>(req); <span class="comment">// 获取激励</span></span><br><span class="line">            <span class="keyword">this</span><span class="variable">.chnl_write</span>(req); <span class="comment">// 写出到接口</span></span><br><span class="line">            rsp = req<span class="variable">.clone</span>(); <span class="comment">//发送完毕之后克隆一份</span></span><br><span class="line">            rsp<span class="variable">.rsp</span> = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">this</span><span class="variable">.rsp_mb</span><span class="variable">.put</span>(rsp);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> chnl_write(<span class="keyword">input</span> chnl_trans t);</span><br><span class="line">        <span class="keyword">foreach</span>(t<span class="variable">.data</span>[i]) <span class="keyword">begin</span></span><br><span class="line">            @(<span class="keyword">posedge</span> intf<span class="variable">.clk</span>);</span><br><span class="line">            intf<span class="variable">.ch_valid</span> &lt;= <span class="number">1</span>; <span class="comment">//在时钟上升沿置为有效</span></span><br><span class="line">            intf<span class="variable">.ch_data</span> &lt;= t<span class="variable">.data</span>[i];</span><br><span class="line">            @(<span class="keyword">negedge</span> intf<span class="variable">.clk</span>);</span><br><span class="line">            <span class="keyword">wait</span>(intf<span class="variable">.ch_ready</span> == <span class="number">&#x27;b1</span>);</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;%0t: channel initiator [%s] sent data %x&quot;</span>, <span class="built_in">$time</span>, name, t<span class="variable">.data</span>[i]);</span><br><span class="line">            <span class="keyword">repeat</span>(t<span class="variable">.data_nidles</span>) chnl_idle(); <span class="comment">//插入空闲周期</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">repeat</span>(t<span class="variable">.pkt_nidles</span>) chnl_idle();</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> chnl_idle();</span><br><span class="line">        @(<span class="keyword">posedge</span> intf<span class="variable">.clk</span>);</span><br><span class="line">        intf<span class="variable">.ch_valid</span> &lt;= <span class="number">0</span>;</span><br><span class="line">        intf<span class="variable">.ch_data</span> &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span>: chnl_initiator</span><br></pre></td></tr></table></figure>
<ul>
<li>chnl_generator</li>
</ul>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> chnl_generator;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">int</span> pkt_id = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">int</span> ch_id = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">int</span> data_nidles = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">int</span> pkt_nidles = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">int</span> data_size = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">int</span> ntrans = <span class="number">10</span>;</span><br><span class="line">    mailbox <span class="variable">#(chnl_trans)</span> req_mb;</span><br><span class="line">    mainbox <span class="variable">#(chnl_trans)</span> rsp_mb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constraint</span> cstr &#123;</span><br><span class="line">        <span class="keyword">soft</span> ch_id == -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">soft</span> pkt_id == -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">soft</span> data_size == -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">soft</span> data_nidles == -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">soft</span> pkt_nidles == -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">soft</span> ntrans == <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>();</span><br><span class="line">        <span class="keyword">this</span><span class="variable">.req_mb</span> = <span class="keyword">new</span>();</span><br><span class="line">        <span class="keyword">this</span><span class="variable">.rsp_mb</span> = <span class="keyword">new</span>();</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用了多次创建数据事务，并且发送给chnl_initiator的任务send_trans</span></span><br><span class="line">    <span class="keyword">task</span> run();</span><br><span class="line">        <span class="keyword">repeat</span>(ntrans) send_trans;</span><br><span class="line">        run_stop_flags<span class="variable">.put</span>();</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成transaction并put进入maibox</span></span><br><span class="line">    <span class="keyword">task</span> send_trans();</span><br><span class="line">        chnl_trans req, rsp;</span><br><span class="line">        req = <span class="keyword">new</span>();</span><br><span class="line">        <span class="keyword">assert</span>(req<span class="variable">.randomize</span> <span class="keyword">with</span> &#123;</span><br><span class="line">            <span class="keyword">local</span>::ch_id &gt;=<span class="number">0</span> -&gt; ch_id == <span class="keyword">local</span>::ch_id;</span><br><span class="line">            <span class="keyword">local</span>::pkt_id &gt;=<span class="number">0</span> -&gt; pkt_id == <span class="keyword">local</span>::pkt_id;</span><br><span class="line">            <span class="keyword">local</span>::data_nidles &gt;=<span class="number">0</span> -&gt; data_nidles == <span class="keyword">local</span>::data_nidles;</span><br><span class="line">            <span class="keyword">local</span>::pkt_nidles &gt;=<span class="number">0</span> -&gt; pkt_nidles == <span class="keyword">local</span>::pkt_nidles;</span><br><span class="line">            <span class="keyword">local</span>::data_size &gt;=<span class="number">0</span> -&gt; data_size == <span class="keyword">local</span>::data_size;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">$fatal</span>(<span class="string">&quot;[RNDFAIL] channel packet randomization failure!&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span><span class="variable">.pkt_id</span>++;</span><br><span class="line">        <span class="keyword">this</span><span class="variable">.req_mb</span><span class="variable">.put</span>(req);</span><br><span class="line">        <span class="keyword">this</span><span class="variable">.rsp_mb</span><span class="variable">.get</span>(rsp);</span><br><span class="line">        <span class="keyword">assert</span>(rsp<span class="variable">.rsp</span>)</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">$error</span>(<span class="string">&quot;[RSPERR] %0t error response received!&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span>: chnl_generator</span><br></pre></td></tr></table></figure>


<h1 id="监测器和检查器"><a href="#监测器和检查器" class="headerlink" title="监测器和检查器"></a>监测器和检查器</h1><h2 id="监测器-1"><a href="#监测器-1" class="headerlink" title="监测器"></a>监测器</h2><blockquote>
<p>用户自定义结构体<code>mon_data_t</code>用来存放监测到的数据，被<code>chnl_monitor</code>和<code>mcdt_monitor</code>使用</p>
</blockquote>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="comment">// chnl_monitor</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">packed</span> &#123;</span><br><span class="line">    <span class="keyword">bit</span>[<span class="number">31</span>:<span class="number">0</span>] data;</span><br><span class="line">    <span class="keyword">bit</span>[<span class="number">1</span>:<span class="number">0</span>] id;</span><br><span class="line">&#125; mon_data_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> chnl_monitor;</span><br><span class="line">    <span class="keyword">local</span> <span class="keyword">string</span> name;</span><br><span class="line">    <span class="keyword">local</span> <span class="keyword">virtual</span> chnl_intf intf;</span><br><span class="line">    mailbox <span class="variable">#(mon_data_t)</span> mon_mb;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;chnl_monitor&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span><span class="variable">.name</span> = name;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> set_interface(<span class="keyword">virtual</span> chnl_intf intf);</span><br><span class="line">        <span class="keyword">if</span>(intf == <span class="literal">null</span>)</span><br><span class="line">            <span class="built_in">$error</span>(<span class="string">&quot;interface handle is NULL, please check if target interface has been intrantiated&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">this</span><span class="variable">.intf</span> = intf;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> run();</span><br><span class="line">        <span class="keyword">this</span><span class="variable">.mon_trans</span>();</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line">    <span class="comment">// 三个等号判断四值逻辑变量是否相等</span></span><br><span class="line">    <span class="keyword">task</span> mon_trans();</span><br><span class="line">        mon_data_t m;</span><br><span class="line">        <span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">            @(<span class="keyword">posedge</span> intf<span class="variable">.clk</span> <span class="keyword">iff</span> (intf<span class="variable">.ch_valid</span>===<span class="number">&#x27;b1</span> &amp;&amp; intf<span class="variable">.ch_ready</span> ===<span class="number">&#x27;b1</span>));</span><br><span class="line">            m<span class="variable">.data</span> = intf<span class="variable">.ch_data</span>;</span><br><span class="line">            mon_mb<span class="variable">.put</span>(m);</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;%0t %s channel monitor data %8x&quot;</span>, <span class="built_in">$time</span>, <span class="keyword">this</span><span class="variable">.name</span>, m<span class="variable">.data</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span>: chnl_monitor</span><br></pre></td></tr></table></figure>

<p>再实现一个mcdt_monitor</p>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mcdt_monitor</span></span><br><span class="line"><span class="keyword">class</span> mcdt_monitor;</span><br><span class="line">    <span class="keyword">local</span> <span class="keyword">string</span> name;</span><br><span class="line">    <span class="keyword">local</span> <span class="keyword">virtual</span> mcdt_intf intf;</span><br><span class="line">    mailbox <span class="variable">#(mon_data_t)</span> mon_mb;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;mcdt_monitor&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span><span class="variable">.name</span> = name;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> set_interface(<span class="keyword">virtual</span> mcdt_intf intf);</span><br><span class="line">        <span class="keyword">if</span>(intf == <span class="literal">null</span>)</span><br><span class="line">            <span class="built_in">$error</span>(<span class="string">&quot;interface handle is NULL, please check if target interface has been intrantiated&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">this</span><span class="variable">.intf</span> = intf;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> run();</span><br><span class="line">        <span class="keyword">this</span><span class="variable">.mon_trans</span>();</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> mon_trans();</span><br><span class="line">        mon_data_t m;</span><br><span class="line">        <span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">            @(<span class="keyword">posedge</span> intf<span class="variable">.clk</span> <span class="keyword">iff</span> intf<span class="variable">.mcdt_val</span>===<span class="number">&#x27;b1</span>);</span><br><span class="line">            m<span class="variable">.data</span> = intf<span class="variable">.mcdt_data</span>;</span><br><span class="line">            m<span class="variable">.id</span> = intf<span class="variable">.mcdt_id</span>;</span><br><span class="line">            mon_mb<span class="variable">.put</span>(m);</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;%0t %s mcdt monitor data %8x and id %0d&quot;</span>, <span class="built_in">$time</span>, <span class="keyword">this</span><span class="variable">.name</span>, m<span class="variable">.data</span>, m<span class="variable">.id</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span>: mcdt_monitor</span><br></pre></td></tr></table></figure>


<h2 id="检查器"><a href="#检查器" class="headerlink" title="检查器"></a>检查器</h2><figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mcdt_checker</span></span><br><span class="line"><span class="keyword">class</span> mcdt_checker;</span><br><span class="line">    <span class="keyword">local</span> <span class="keyword">string</span> name;</span><br><span class="line">    <span class="keyword">local</span> <span class="keyword">int</span> error_count;</span><br><span class="line">    <span class="keyword">local</span> <span class="keyword">int</span> cmp_count;</span><br><span class="line">    mailbox <span class="variable">#(mon_data_t)</span> in_mbs[<span class="number">3</span>];</span><br><span class="line">    mainbox <span class="variable">#(mon_data_t)</span> out_mb;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;mcdt_checker&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span><span class="variable">.name</span> = name;</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">this</span><span class="variable">.in_mbs</span>[i])</span><br><span class="line">            <span class="keyword">this</span><span class="variable">.in_mbs</span>[i] = <span class="keyword">new</span>();</span><br><span class="line">        <span class="keyword">this</span><span class="variable">.out_mb</span> = <span class="keyword">new</span>();</span><br><span class="line">        <span class="keyword">this</span><span class="variable">.error_count</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span><span class="variable">.cmp_count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> run();</span><br><span class="line">        <span class="keyword">this</span><span class="variable">.do_compare</span>();</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次从输出端out_mb中取出一个数据，然后通过id判断从哪个输入端获取数据，比较</span></span><br><span class="line">    <span class="keyword">task</span> do_compare();</span><br><span class="line">        mon_data_t im, om;</span><br><span class="line">        <span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">            out_mb<span class="variable">.get</span>(m);</span><br><span class="line">            <span class="keyword">case</span>(om<span class="variable">.id</span>)</span><br><span class="line">                <span class="number">0</span>: in_mbs[<span class="number">0</span>]<span class="variable">.get</span>(im);</span><br><span class="line">                <span class="number">1</span>: in_mbs[<span class="number">1</span>]<span class="variable">.get</span>(im);</span><br><span class="line">                <span class="number">2</span>: in_mbs[<span class="number">2</span>]<span class="variable">.get</span>(im);</span><br><span class="line">                <span class="keyword">default</span>: <span class="built_in">$fatal</span>(<span class="string">&quot;id %0d is not available&quot;</span>, om<span class="variable">.id</span>);</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">            <span class="keyword">if</span>(om<span class="variable">.data</span> != im<span class="variable">.id</span>) <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">this</span><span class="variable">.error_count</span>++;</span><br><span class="line">                <span class="built_in">$error</span>(<span class="string">&quot;[CMPFAIL] Compared failed! mcdt out data %8x ch_id %0d is not equal with channel in data %8x&quot;</span>, om<span class="variable">.data</span>, om<span class="variable">.id</span>, im<span class="variable">.data</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">&quot;[CMPSUCD] Compared success! mcdt out data %8x ch_id %0d is equal with channel in data %8x&quot;</span>, om<span class="variable">.data</span>, om<span class="variable">.id</span>, im<span class="variable">.data</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">this</span><span class="variable">.cmp_count</span>++;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span>: mcdt_checker</span><br></pre></td></tr></table></figure>


<h1 id="顶层环境和测试用例"><a href="#顶层环境和测试用例" class="headerlink" title="顶层环境和测试用例"></a>顶层环境和测试用例</h1><h2 id="实现顶层环境1-agent"><a href="#实现顶层环境1-agent" class="headerlink" title="实现顶层环境1-agent"></a>实现顶层环境1-agent</h2><figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> chnl_agent;</span><br><span class="line">    <span class="keyword">local</span> <span class="keyword">string</span> name;</span><br><span class="line">    chnl_initiator init;</span><br><span class="line">    chnl_monitor mon;</span><br><span class="line">    <span class="keyword">virtual</span> chnl_intf vif;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;chnl_agent&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span><span class="variable">.name</span> = name;</span><br><span class="line">        <span class="keyword">this</span><span class="variable">.init</span> = <span class="keyword">new</span>(&#123;name, <span class="string">&quot;.init&quot;</span>&#125;);</span><br><span class="line">        <span class="keyword">this</span><span class="variable">.mon</span> = <span class="keyword">new</span>(&#123;name, <span class="string">&quot;.mon&quot;</span>&#125;);</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自身获得虚接口，然后传递给ini和mon</span></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> set_interface(<span class="keyword">virtual</span> chnl_intf vif);</span><br><span class="line">        <span class="keyword">this</span><span class="variable">.vif</span> = vif;</span><br><span class="line">        init<span class="variable">.set_interface</span>(vif);</span><br><span class="line">        mon<span class="variable">.set_interface</span>(vif);</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> run();</span><br><span class="line">        <span class="keyword">fork</span>:</span><br><span class="line">            init<span class="variable">.run</span>();</span><br><span class="line">            mon<span class="variable">.run</span>();</span><br><span class="line">        <span class="keyword">join</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span>: chnl_agent</span><br></pre></td></tr></table></figure>

<h2 id="实现顶层环境2-mcdt-root-test"><a href="#实现顶层环境2-mcdt-root-test" class="headerlink" title="实现顶层环境2-mcdt_root_test"></a>实现顶层环境2-mcdt_root_test</h2><figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mcdt_root_test</span></span><br><span class="line"><span class="comment">// 包含3个gen，3个agent，1个checker</span></span><br><span class="line"><span class="keyword">class</span> mcdt_root_test;</span><br><span class="line">    chnl_generator gen[<span class="number">3</span>];</span><br><span class="line">    chnl_agent agents[<span class="number">3</span>];</span><br><span class="line">    mcdt_monitor mcdt_mon;</span><br><span class="line">    mcdt_checker chker;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">string</span> name;</span><br><span class="line">    <span class="keyword">event</span> gen_stop_e;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;mcdt_root_test&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span><span class="variable">.name</span> = name;</span><br><span class="line">        <span class="keyword">this</span><span class="variable">.chker</span> = <span class="keyword">new</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span>(agents[i]) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">this</span><span class="variable">.agents</span>[i] = <span class="keyword">new</span>(<span class="built_in">$sformatf</span>(<span class="string">&quot;agent%0d&quot;</span>, i));</span><br><span class="line">            <span class="keyword">this</span><span class="variable">.gen</span>[i] = <span class="keyword">new</span>();</span><br><span class="line">            <span class="keyword">this</span><span class="variable">.agents</span>[i]<span class="variable">.init</span><span class="variable">.req_mb</span> = <span class="keyword">this</span><span class="variable">.gen</span>[i]<span class="variable">.req_mb</span>;</span><br><span class="line">            <span class="keyword">this</span><span class="variable">.agents</span>[i]<span class="variable">.init</span><span class="variable">.rsp_mb</span> = <span class="keyword">this</span><span class="variable">.gen</span>[i]<span class="variable">.rsp_mb</span>;</span><br><span class="line">            <span class="keyword">this</span><span class="variable">.agents</span>[i]<span class="variable">.mon</span><span class="variable">.mon_mb</span> = <span class="keyword">this</span><span class="variable">.chker</span><span class="variable">.in_mbs</span>[i];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span><span class="variable">.mcdt_mon</span> = <span class="keyword">new</span>();</span><br><span class="line">        <span class="keyword">this</span><span class="variable">.mcdt_mon</span><span class="variable">.mon_mb</span> = <span class="keyword">this</span><span class="variable">.chker</span><span class="variable">.out_mb</span>;</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;%s instantiated and connected objects&quot;</span>, <span class="keyword">this</span><span class="variable">.name</span>);</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">task</span> gen_stop_callback();</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待三个gen都发送完激励数据后，交还钥匙给旗语run_stop_flags</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">task</span> run_stop_callback();</span><br><span class="line">        $diplay(<span class="string">&quot;run_stop_callback enterred&quot;</span>);</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;%s: wait for all generators have generated and tranferred transcations&quot;</span>, <span class="keyword">this</span><span class="variable">.name</span>);</span><br><span class="line">        run_stop_flags<span class="variable">.get</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">$finish</span>();</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">task</span> run();</span><br><span class="line">        <span class="keyword">this</span><span class="variable">.do_config</span>(); <span class="comment">//决定产生多少个怎样的随机数据</span></span><br><span class="line">        <span class="keyword">fork</span></span><br><span class="line">            agents[<span class="number">0</span>]<span class="variable">.run</span>();</span><br><span class="line">            agents[<span class="number">1</span>]<span class="variable">.run</span>();</span><br><span class="line">            agents[<span class="number">2</span>]<span class="variable">.run</span>();</span><br><span class="line">            mcdt_mon<span class="variable">.run</span>();</span><br><span class="line">            chker<span class="variable">.run</span>();</span><br><span class="line">        <span class="keyword">join_none</span></span><br><span class="line">        <span class="keyword">fork</span> : gen_threads</span><br><span class="line">            gen[<span class="number">0</span>]<span class="variable">.run</span>();</span><br><span class="line">            gen[<span class="number">1</span>]<span class="variable">.run</span>();</span><br><span class="line">            gen[<span class="number">2</span>]<span class="variable">.run</span>();</span><br><span class="line">        <span class="keyword">join</span></span><br><span class="line">        run_stop_callback();</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> set_interface(<span class="keyword">virtual</span> chnl_intf ch0_vif,</span><br><span class="line">    <span class="keyword">virtual</span> chnl_intf ch1_vif,</span><br><span class="line">    <span class="keyword">virtual</span> chnl_intf ch2_vif,</span><br><span class="line">    <span class="keyword">virtual</span> mcdt_intf mcdt_vif);</span><br><span class="line">        agents[<span class="number">0</span>]<span class="variable">.set_interface</span>(ch0_vif);</span><br><span class="line">        agents[<span class="number">1</span>]<span class="variable">.set_interface</span>(ch1_vif);</span><br><span class="line">        agents[<span class="number">2</span>]<span class="variable">.set_interface</span>(ch2_vif);</span><br><span class="line">        mcdt_mon<span class="variable">.set_interface</span>(mcdt_vif);</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> do_config();</span><br><span class="line">        <span class="comment">// 在这里配置gen的参数,用一个子类的方法去实现他</span></span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span>: mcdt_root_test</span><br></pre></td></tr></table></figure>


<h2 id="实现测试用例"><a href="#实现测试用例" class="headerlink" title="实现测试用例"></a>实现测试用例</h2><figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> mcdt_basic_test <span class="keyword">extends</span> mcdt_root_test;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;mcdt_basic_test&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span><span class="variable">.new</span>(name);</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> do_config();</span><br><span class="line">        <span class="keyword">super</span><span class="variable">.do_config</span>();</span><br><span class="line">        <span class="keyword">assert</span>(gen[<span class="number">0</span>]<span class="variable">.randomize</span>() <span class="keyword">with</span> &#123;ntrans==<span class="number">100</span>; data_nidles==<span class="number">0</span>; pkt_nidles==<span class="number">0</span>; data_size==<span class="number">8</span>;&#125;)</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">$fatal</span>(<span class="string">&quot;[RNDFAIL] gen[0] randomize failed&quot;</span>);</span><br><span class="line">        <span class="keyword">assert</span>(gen[<span class="number">1</span>]<span class="variable">.randomize</span>() <span class="keyword">with</span> &#123;ntrans==<span class="number">50</span>; data_nidles <span class="keyword">inside</span> &#123;[<span class="number">1</span>:<span class="number">2</span>]&#125;; pkt_nidles <span class="keyword">inside</span> &#123;[<span class="number">3</span>:<span class="number">5</span>]&#125;; data_size==<span class="number">6</span>;&#125;)</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">$fatal</span>(<span class="string">&quot;[RNDFAIL] gen[1] randomize failed&quot;</span>);</span><br><span class="line">        <span class="keyword">assert</span>(gen[<span class="number">2</span>]<span class="variable">.randomize</span>() <span class="keyword">with</span> &#123;ntrans==<span class="number">80</span>; data_nidles <span class="keyword">inside</span> &#123;[<span class="number">0</span>:<span class="number">1</span>]&#125;; pkt_nidles <span class="keyword">inside</span> &#123;[<span class="number">1</span>:<span class="number">2</span>]&#125;; data_size==<span class="number">32</span>;&#125;)</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">$fatal</span>(<span class="string">&quot;[RNDFAIL] gen[2] randomize failed&quot;</span>);</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span>: mcdt_basic_test</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/15/47/%E5%AE%8C%E6%95%B4%E9%AA%8C%E8%AF%81%E7%8E%AF%E5%A2%83%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="完整验证环境结构图"></p>
]]></content>
      <categories>
        <category>路科V0</category>
      </categories>
      <tags>
        <tag>UVM</tag>
        <tag>System Verilog</tag>
        <tag>IC验证</tag>
      </tags>
  </entry>
  <entry>
    <title>路科V0P30P33-覆盖率-代码覆盖率-功能覆盖率-从功能描述到覆盖率</title>
    <url>/2022/05/17/18/</url>
    <content><![CDATA[<h1 id="覆盖率"><a href="#覆盖率" class="headerlink" title="覆盖率"></a>覆盖率</h1><ul>
<li>随机测试比定向测试多了很多的可能性，但是需要考虑，什么时候结束验证呢？涉及到<strong>覆盖率</strong>指标的问题。<ul>
<li>是否所有设计的功能在验证计划中都已经验证了？</li>
<li>是否代码中的某些部分从未执行过？</li>
</ul>
</li>
<li>覆盖率 用来<strong>衡量设计验证完备性</strong>的通用词语；</li>
<li><strong>覆盖率工具</strong>会在仿真过程中收集信息，然后进行后续处理并得到<strong>覆盖率报告</strong>。</li>
<li>通过覆盖率报告找到覆盖率之外的盲区，然后修改现有的测试用例或者创建新的测试来填补这些盲区；</li>
<li>一直迭代进行，直到覆盖率满足要求；</li>
</ul>
<p>覆盖率反馈回路 ：</p>
<p><img src="/2022/05/17/18/%E8%A6%86%E7%9B%96%E7%8E%87%E5%8F%8D%E9%A6%88%E5%9B%9E%E8%B7%AF.png" alt="覆盖率反馈回路"></p>
<h2 id="优化验证效率"><a href="#优化验证效率" class="headerlink" title="优化验证效率"></a>优化验证效率</h2><ul>
<li>通过覆盖率量化验证之后，可以在更复杂的情况下捕捉一些功能特性是否被覆盖：<ul>
<li>在测试X特性时，Y特性是否同时被使能和测试？功能之间存在关联</li>
<li>是否可以精简已有的测试来加速仿真？并取得同样的覆盖率。冗余问题</li>
<li>观察覆盖率在达到一定数值之后，是否停滞不再上升？</li>
</ul>
</li>
<li>覆盖率是用来<strong>衡量验证精度和完备性</strong>的数据指标；</li>
<li>可以告诉用户哪些结构在仿真时被触发，哪些没有；</li>
</ul>
<h2 id="覆盖率分类"><a href="#覆盖率分类" class="headerlink" title="覆盖率分类"></a>覆盖率分类</h2><ul>
<li>代码覆盖率</li>
<li>功能覆盖率</li>
<li>断言覆盖率</li>
</ul>
<p><img src="/2022/05/17/18/%E8%A6%86%E7%9B%96%E7%8E%87%E5%88%86%E7%B1%BB.png" alt="覆盖率分类"></p>
<p>按照覆盖率生成的方法，分为两类：</p>
<ul>
<li>隐形生成：<ul>
<li>代码覆盖率，仿真工具可以自动分析RTL设计代码的执行结果得到代码覆盖率</li>
</ul>
</li>
<li>显性生成：<ul>
<li>断言覆盖率</li>
<li>功能覆盖率，需要依照功能描述去定义的覆盖率；</li>
</ul>
</li>
</ul>
<p>按照覆盖率溯源，分两类：</p>
<ul>
<li>从功能描述而来：<ul>
<li>功能覆盖率</li>
</ul>
</li>
<li>从设计实现而来<ul>
<li>代码覆盖率</li>
<li>断言覆盖率</li>
</ul>
</li>
</ul>
<h1 id="代码覆盖率"><a href="#代码覆盖率" class="headerlink" title="代码覆盖率"></a>代码覆盖率</h1><ul>
<li>包含未知错误的设计的问题在于它看起来很好，但是绝对不可能知道被验证的设计在功能上是完全正确的；</li>
<li>即使所有测试平台都成功仿真，但是只要有部分RTL代码未执行，都可能触发功能错误，因此需要代码覆盖率！</li>
<li>代码覆盖率的优势在于可以由仿真工具自动收集；</li>
<li>一般只关注设计的代码覆盖率，不关注测试平台的代码覆盖率；</li>
</ul>
<h2 id="行覆盖率（statement-x2F-line）"><a href="#行覆盖率（statement-x2F-line）" class="headerlink" title="行覆盖率（statement&#x2F;line）"></a>行覆盖率（statement&#x2F;line）</h2><ul>
<li>衡量源码哪些行被执行，哪些行没有；</li>
<li>每一行执行的最小次数也可以设置为一个指标；</li>
<li>代码覆盖率可以指出在缺乏激励的情况下，某些赋值的代码行没有被执行的情况，也可以指出一些漏洞影响或者无用代码的影响下，一些代码行也无法被执行的情况；</li>
<li>对于无用代码，即永远不会执行的代码，可以从覆盖率中过滤掉；</li>
<li>行覆盖率也叫做块覆盖率，块是在灾星单个语句时语句序列；</li>
<li>比如，只要if为true，就会执行名为acked的块，因此这个块的执行等同于四个单独语句的执行；</li>
</ul>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (data == <span class="number">1&#x27;b1</span>) <span class="keyword">begin</span>: acked</span><br><span class="line">    as &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    data &lt;= <span class="number">16&#x27;hzzzz</span>;</span><br><span class="line">    bus_rq &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    state &lt;= IDLE;</span><br><span class="line"><span class="keyword">end</span>: acked</span><br></pre></td></tr></table></figure>

<h2 id="分支覆盖率（branch）"><a href="#分支覆盖率（branch）" class="headerlink" title="分支覆盖率（branch）"></a>分支覆盖率（branch）</h2><ul>
<li>分支覆盖率是用来对条件语句<code>if/else  case  ?:</code>，指出其执行的分支轨迹；</li>
</ul>
<h2 id="条件覆盖率（condition-x2F-expression）"><a href="#条件覆盖率（condition-x2F-expression）" class="headerlink" title="条件覆盖率（condition&#x2F;expression）"></a>条件覆盖率（condition&#x2F;expression）</h2><ul>
<li>条件覆盖率用来衡量一些布尔表达式的各个条件真伪判断的执行轨迹；</li>
<li>比如下面的if中两个条件是否各自衡量为true、false；</li>
<li><code>if (parity == ODD || parity == EVEN) begin</code></li>
</ul>
<h2 id="状态机覆盖率（FSM）"><a href="#状态机覆盖率（FSM）" class="headerlink" title="状态机覆盖率（FSM）"></a>状态机覆盖率（FSM）</h2><ul>
<li><strong>仿真工具可以自动识别状态机，因此在收集覆盖率时，可以将覆盖率状态的执行情况监测到</strong>；</li>
<li>可以反映到每个状态的进入次数、状态之间的跳转次数、以及多个状态的跳转顺序等；</li>
<li>因为FSM中的每个状态<strong>通常使用case语句中的选项进行编码</strong>，所以任务没有访问到的状态都可以通过未覆盖的语句清楚的识别到；</li>
</ul>
<h2 id="跳转覆盖率（toggle）"><a href="#跳转覆盖率（toggle）" class="headerlink" title="跳转覆盖率（toggle）"></a>跳转覆盖率（toggle）</h2><ul>
<li>用来衡量寄存器跳转次数（0-&gt;1, 1-&gt;0）；</li>
<li>一般项目会要求模块的端口实现至少一次1到0和一次0到1的跳转；，以保证模块的集成和模块之间的互动；</li>
<li>也有项目要求所有的寄存器和端口一样，满足跳转的最小次数；</li>
<li>端口跳转覆盖率常用来测试IP模块之间的基本连接性，比如检查一些输入端口是否没有连接，已经连接的端口的比特位数是否不匹配，一些已连接的输入是否被给定的固定值等；</li>
</ul>
<h2 id="代码覆盖率100-的含义"><a href="#代码覆盖率100-的含义" class="headerlink" title="代码覆盖率100%的含义"></a>代码覆盖率100%的含义</h2><ul>
<li>表明整个设计都已执行；</li>
<li><strong>表示验证环境运行设计源码的彻底程度，但是没有提供有关验证组件的正确性和完整性的指示</strong>；</li>
<li>代码覆盖率应该用于帮助识别验证未执行的边界情况或者依赖于设计实现的特性；</li>
<li>对于未覆盖的场景，考虑更新和添加测试；</li>
</ul>
<h1 id="功能覆盖率"><a href="#功能覆盖率" class="headerlink" title="功能覆盖率"></a>功能覆盖率</h1><ul>
<li>功能验证的目标，在于确定设计有关的功能描述是否都实现了；</li>
<li>可能存在的不期望的情况：<ul>
<li>哪些功能没有被实现；</li>
<li>实现错误；</li>
<li>哪些没有要求的功能也实现了；</li>
</ul>
</li>
</ul>
<h2 id="覆盖组（covergroup）"><a href="#覆盖组（covergroup）" class="headerlink" title="覆盖组（covergroup）"></a>覆盖组（covergroup）</h2><ul>
<li>覆盖组和类相似，在一次定义之后可以多次例化；</li>
<li><strong>覆盖组含有覆盖点（cover point）、选项（option）、形式参数（argument）和可选触发（trigger event）</strong>；</li>
<li>一个覆盖组包含的一个或者多个数据点，都是在<strong>同一时间采集</strong>；</li>
<li><strong>覆盖组可以定义在类里，也可以定义在模块或者程序中</strong>；</li>
<li>覆盖组可以采集任何可见变量，比如程序或模块变量、接口信号、或者设计中的任何信号；</li>
<li>在类中的覆盖组也可以采集类的成员变量；</li>
<li><strong>覆盖组应该定义在适当的抽象层次上</strong>；</li>
<li>对任何事务的采样都必须<strong>等到数据被待测设计接收到</strong>以后；</li>
<li>一个<strong>类也可以包含多个覆盖组</strong>，每个覆盖组可以根据需要将它们使能或者禁止；</li>
<li>内部可以定义多个coverpoint，<strong>如果不在covergroup声明时指定采样事件，那么默认该覆盖组只能依赖于另一个手动采样函数sample()</strong>;</li>
</ul>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;red, green, blue&#125; color;</span><br><span class="line"><span class="keyword">bit</span>[<span class="number">3</span>:<span class="number">0</span>] pixel_adr, pixel_offset, pixel_hue;</span><br><span class="line"><span class="keyword">covergroup</span> g2 @(<span class="keyword">posedge</span> clk);</span><br><span class="line">    Hue: <span class="keyword">coverpoint</span> pixel_hue;</span><br><span class="line">    Offset: <span class="keyword">coverpoint</span> pixel_offset;</span><br><span class="line">    AxC: <span class="keyword">cross</span> color, pixel_adr;    <span class="comment">// cross 2变量</span></span><br><span class="line">    all: <span class="keyword">cross</span> color, Hue, Offset;  <span class="comment">// cross 1变量和2个coverpoint</span></span><br><span class="line"><span class="keyword">endgroup</span></span><br><span class="line"></span><br><span class="line">g2 cg_inst = <span class="keyword">new</span>();</span><br></pre></td></tr></table></figure>

<p>其他：</p>
<ul>
<li>更多的时候，将覆盖组定义在类中，从而去覆盖类的成员变量；</li>
<li>在类中声明covergroup的方式称为<strong>嵌入式覆盖组声明</strong>，以下栗子声明一个覆盖组cov1和它的实例c1;</li>
</ul>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> xyz;</span><br><span class="line">    <span class="keyword">bit</span>[<span class="number">3</span>:<span class="number">0</span>] m_x;</span><br><span class="line">    <span class="keyword">int</span> m_y;</span><br><span class="line">    <span class="keyword">bit</span> m_z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">covergroup</span> cov1 @m_z;</span><br><span class="line">        <span class="keyword">coverpoint</span> m_x;</span><br><span class="line">        <span class="keyword">coverpoint</span> m_y;</span><br><span class="line">    <span class="keyword">endgroup</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>();</span><br><span class="line">        cov1 c1 = <span class="keyword">new</span>();</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<h2 id="覆盖点（coverpoint）"><a href="#覆盖点（coverpoint）" class="headerlink" title="覆盖点（coverpoint）"></a>覆盖点（coverpoint）</h2><ul>
<li>一个covergroup可以包含一个或者多个coverpoint，一个coverpoint可以用来采样数据或者数据的变化；</li>
<li><strong>一个coverpoint可以对应多个bin（仓）</strong>；</li>
<li>这些bin可以显性指定，也可以隐性指定；</li>
<li>coverpoint对数据的采样发生在covergroup采样的时候；</li>
<li>建议给不同的覆盖点不同的名字，以便于查看；</li>
<li>有名字的coverpoint可以用来进一步处理，比如<strong>在交叉覆盖率中使用某个coverpoint</strong>；</li>
<li>可以通过iff在一些情况下禁止coverpoint采集</li>
</ul>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">covergroup</span> g4;</span><br><span class="line">    <span class="keyword">coverpoint</span> s0 <span class="keyword">iff</span>(!reset);</span><br><span class="line"><span class="keyword">endgroup</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">covergroup</span> cg (<span class="keyword">ref</span> <span class="keyword">int</span> x, <span class="keyword">ref</span> <span class="keyword">int</span> y, <span class="keyword">input</span> <span class="keyword">int</span> c);</span><br><span class="line">    <span class="keyword">coverpoint</span> x;</span><br><span class="line">    b: <span class="keyword">coverpoint</span> y;</span><br><span class="line">    cx: <span class="keyword">coverpoint</span> x;</span><br><span class="line">    d: <span class="keyword">coverpoint</span> y[<span class="number">31</span>:<span class="number">24</span>];</span><br><span class="line">    <span class="keyword">cross</span> x, y;     <span class="comment">// 创建交叉覆盖率</span></span><br><span class="line"><span class="keyword">endgroup</span></span><br></pre></td></tr></table></figure>

<h2 id="仓：值覆盖"><a href="#仓：值覆盖" class="headerlink" title="仓：值覆盖"></a>仓：值覆盖</h2><ul>
<li>关键字bins可以用来将每个感兴趣的数值均对应一个独立的bin，或者将所有值对应到同一个bin；</li>
<li>iff语句也可以用在bin的定义，表示条件为false，在采集该bin的时候，该bin的采样数目不会增长；</li>
<li>bins除了可以覆盖数值，还可以覆盖数值的变化<ul>
<li><code>value1 =&gt; value2;</code> </li>
<li>语法：<code>trans_item[* repeat_range]</code></li>
<li><code>3[* 5]</code>  表示3&#x3D;&gt;3&#x3D;&gt;3&#x3D;&gt;3&#x3D;&gt;3</li>
<li><code>3[* 3:5]</code> 表示(3&#x3D;&gt;3&#x3D;&gt;3),(3&#x3D;&gt;3&#x3D;&gt;3&#x3D;&gt;3)或者(3&#x3D;&gt;3&#x3D;&gt;3&#x3D;&gt;3&#x3D;&gt;3)</li>
</ul>
</li>
<li>如果coverpoint没有指定任何bin，则sv会为他自动生成bin，遵循原则：<ul>
<li>如果变量是枚举类型，则bin的数量是枚举类型的基数（所有枚举值得和）；</li>
<li><strong>如果变量是整型（位宽为M），则bin的类型是<code>2^M</code>和<code>auto_bin_max</code>的较小值</strong>；</li>
</ul>
</li>
</ul>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">9</span>:<span class="number">0</span>] v_a;</span><br><span class="line"><span class="keyword">covergroup</span> cg @(<span class="keyword">posedge</span> clk);</span><br><span class="line">    <span class="keyword">coverpoint</span> v_a &#123;</span><br><span class="line">        <span class="keyword">bins</span> a = &#123;[<span class="number">0</span>:<span class="number">63</span>], <span class="number">65</span>&#125;;  <span class="comment">// a是变量，表示在以下条件的话采样</span></span><br><span class="line">        <span class="keyword">bins</span> b[] = &#123;[<span class="number">127</span>:<span class="number">150</span>], [<span class="number">148</span>:<span class="number">191</span>]&#125;;  <span class="comment">//b[]是个数组，表示满足以下条件的话分别采集一次</span></span><br><span class="line">        <span class="keyword">bins</span> c[] = &#123;<span class="number">200</span>, <span class="number">201</span>, <span class="number">202</span>&#125;;</span><br><span class="line">        <span class="keyword">bins</span> d = &#123;[<span class="number">1000</span>:$]&#125;;</span><br><span class="line">        <span class="keyword">bins</span> others[] = <span class="keyword">default</span>;    <span class="comment">// default表示其他的值都采样一次</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">endgroup</span></span><br></pre></td></tr></table></figure>

<h2 id="仓：-忽略类型和非法类型"><a href="#仓：-忽略类型和非法类型" class="headerlink" title="仓： 忽略类型和非法类型"></a>仓： 忽略类型和非法类型</h2><ul>
<li><code>ingnore_bins</code>用来将其排除在有效统计的bin集合之外</li>
<li><code>illegal_bins</code>用来指出采样的数值为非法，<strong>如果illegal_bins被采样到，那么仿真会报错</strong>！</li>
</ul>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">covergroup</span> cg23;</span><br><span class="line">    <span class="keyword">coverpoint</span> a &#123;</span><br><span class="line">        <span class="keyword">ignore_bins</span> ignore_vals = &#123;<span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        <span class="keyword">ignore_bins</span> ignore_trans = (<span class="number">1</span>=&gt;<span class="number">3</span>=&gt;<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">endgroup</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">covergroup</span> cg3;</span><br><span class="line">    <span class="keyword">coverpoint</span> b &#123;</span><br><span class="line">        <span class="keyword">illegal_bins</span> bad_vals = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">illegal_bins</span> bad_trans = (<span class="number">4</span>=&gt;<span class="number">5</span>=&gt;<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">endgroup</span></span><br></pre></td></tr></table></figure>

<h2 id="交叉覆盖率-cross"><a href="#交叉覆盖率-cross" class="headerlink" title="交叉覆盖率 cross"></a>交叉覆盖率 cross</h2><ul>
<li>covergroup可以在两个或者更多的coverpoint或者变量之间定义交叉覆盖率；</li>
<li>在对a和b产生交叉覆盖率之前，系统会先为他们隐性生成对应的coverpoint和bin，每个coverpoint都有16个自动产生的bin；</li>
<li>两个coverpoint交叉产生256个bin；</li>
<li>注意：<strong>被声明为default、ignore、illegal的bin不会被交叉覆盖率计算</strong>；</li>
<li><strong>交叉覆盖率只允许在同一个covergroup中定义的覆盖点参与运算</strong>。</li>
</ul>
<figure class="highlight sv"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] a, b;</span><br><span class="line"><span class="keyword">covergroup</span> cov @(<span class="keyword">posedge</span> clk);</span><br><span class="line">    aXb : <span class="keyword">cross</span> a, b;</span><br><span class="line"><span class="keyword">endgroup</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] a_var;</span><br><span class="line"><span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] b_var;</span><br><span class="line"><span class="keyword">covergroup</span> cov3 @(<span class="keyword">posedge</span> clk);</span><br><span class="line">    A : <span class="keyword">coverpoint</span> a_var &#123;<span class="keyword">bins</span> yy[] = &#123;[<span class="number">0</span>:<span class="number">9</span>]&#125;;&#125;</span><br><span class="line">    CC : <span class="keyword">cross</span> b_var, A;</span><br><span class="line"><span class="keyword">endgroup</span></span><br></pre></td></tr></table></figure>


<h1 id="从功能描述到覆盖率"><a href="#从功能描述到覆盖率" class="headerlink" title="从功能描述到覆盖率"></a>从功能描述到覆盖率</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/2022/05/17/18/%E6%A6%82%E8%BF%B01.png" alt="概述1"></p>
<p><img src="/2022/05/17/18/%E6%A6%82%E8%BF%B02.png" alt="概述2"></p>
<h2 id="提取接口功能点"><a href="#提取接口功能点" class="headerlink" title="提取接口功能点"></a>提取接口功能点</h2><p><img src="/2022/05/17/18/%E6%8F%90%E5%8F%96%E6%8E%A5%E5%8F%A3%E5%8A%9F%E8%83%BD%E7%82%B9.png" alt="提取接口功能点"></p>
<h2 id="提取内部功能点"><a href="#提取内部功能点" class="headerlink" title="提取内部功能点"></a>提取内部功能点</h2><p><img src="/2022/05/17/18/%E6%8F%90%E5%8F%96%E5%86%85%E9%83%A8%E5%8A%9F%E8%83%BD%E7%82%B9.png" alt="提取内部功能点"></p>
<p><img src="/2022/05/17/18/%E6%8F%90%E5%8F%96%E5%86%85%E9%83%A8%E5%8A%9F%E8%83%BD%E7%82%B92.png" alt="提取内部功能点2"></p>
<h2 id="提取结构功能点"><a href="#提取结构功能点" class="headerlink" title="提取结构功能点"></a>提取结构功能点</h2><p><img src="/2022/05/17/18/%E6%8F%90%E5%8F%96%E7%BB%93%E6%9E%84%E5%8A%9F%E8%83%BD%E7%82%B9.png" alt="提取结构功能点"></p>
<h2 id="标记功能点"><a href="#标记功能点" class="headerlink" title="标记功能点"></a>标记功能点</h2><p><img src="/2022/05/17/18/%E6%A0%87%E8%AE%B0%E5%8A%9F%E8%83%BD%E7%82%B9.png" alt="标记功能点"></p>
<h2 id="验证分层"><a href="#验证分层" class="headerlink" title="验证分层"></a>验证分层</h2><p><img src="/2022/05/17/18/%E9%AA%8C%E8%AF%81%E5%88%86%E5%B1%82.png" alt="验证分层"></p>
<h2 id="优先级划分"><a href="#优先级划分" class="headerlink" title="优先级划分"></a>优先级划分</h2><p><img src="/2022/05/17/18/%E4%BC%98%E5%85%88%E7%BA%A7%E5%88%92%E5%88%86.png" alt="优先级划分"></p>
<p><img src="/2022/05/17/18/%E4%BC%98%E5%85%88%E7%BA%A7%E5%88%92%E5%88%862.png" alt="优先级划分2"></p>
<h2 id="从随机测试到功能覆盖率"><a href="#从随机测试到功能覆盖率" class="headerlink" title="从随机测试到功能覆盖率"></a>从随机测试到功能覆盖率</h2><p><img src="/2022/05/17/18/%E4%BB%8E%E9%9A%8F%E6%9C%BA%E6%B5%8B%E8%AF%95%E5%88%B0%E5%8A%9F%E8%83%BD%E8%A6%86%E7%9B%96%E7%8E%87.png" alt="从随机测试到功能覆盖率"></p>
<h2 id="覆盖率实现的考量"><a href="#覆盖率实现的考量" class="headerlink" title="覆盖率实现的考量"></a>覆盖率实现的考量</h2><p><img src="/2022/05/17/18/%E8%A6%86%E7%9B%96%E7%8E%87%E5%AE%9E%E7%8E%B0%E7%9A%84%E8%80%83%E9%87%8F.png" alt="覆盖率实现的考量"></p>
<h2 id="MCDT功能测试清单"><a href="#MCDT功能测试清单" class="headerlink" title="MCDT功能测试清单"></a>MCDT功能测试清单</h2><p><img src="/2022/05/17/18/MCDT%E6%B5%8B%E8%AF%95%E6%B8%85%E5%8D%95.png" alt="MCDT功能测试清单"></p>
<p><img src="/2022/05/17/18/MCDT%E6%B5%8B%E8%AF%95%E6%B8%85%E5%8D%952.png" alt="MCDT功能测试清单2"></p>
]]></content>
      <categories>
        <category>路科V0</category>
      </categories>
      <tags>
        <tag>UVM</tag>
        <tag>System Verilog</tag>
        <tag>IC验证</tag>
      </tags>
  </entry>
  <entry>
    <title>路科V0P5P9SV入门</title>
    <url>/2022/05/09/23/</url>
    <content><![CDATA[<h1 id="SV以及UVM概述"><a href="#SV以及UVM概述" class="headerlink" title="SV以及UVM概述"></a>SV以及UVM概述</h1><p><img src="/2022/05/09/23/SV%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7.png" alt="SV语言核心特性"></p>
<p>UVM类库地图 ：</p>
<p><img src="/2022/05/09/23/UVM%E7%B1%BB%E5%BA%93%E5%9C%B0%E5%9B%BE.png" alt="UVM类库地图"></p>
<p>UVM常用的十大类：</p>
<p><img src="/2022/05/09/23/UVM%E5%8D%81%E5%A4%A7%E7%B1%BB.png" alt="UVM十大类"></p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ul>
<li>Verilog的数据类型：<br><img src="/2022/05/09/23/verilog%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt="verilog的数据类型"><ul>
<li>线网类型：</li>
<li><img src="/2022/05/09/23/verilog%E7%9A%84%E7%BA%BF%E7%BD%91%E7%B1%BB%E5%9E%8B.png" alt="线网类型"></li>
<li>变量类型：</li>
<li><img src="/2022/05/09/23/verilog%E7%9A%84%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B.png" alt="变量类型"></li>
</ul>
</li>
<li>SV新添加的数据类型：<ul>
<li><img src="/2022/05/09/23/SV%E6%96%B0%E6%B7%BB%E5%8A%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt="SV新添加的数据类型"><ul>
<li><img src="/2022/05/09/23/%E5%9B%9B%E5%80%BC%E9%80%BB%E8%BE%91%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt="四值逻辑数据类型"></li>
<li><img src="/2022/05/09/23/%E5%9B%9B%E5%80%BC%E9%80%BB%E8%BE%91%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B2.png" alt="四值逻辑数据类型2"></li>
<li><img src="/2022/05/09/23/%E5%9B%9B%E5%80%BC%E9%80%BB%E8%BE%91%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B3.png" alt="四值逻辑数据类型3"></li>
</ul>
</li>
<li><img src="/2022/05/09/23/%E4%BA%8C%E5%80%BC%E9%80%BB%E8%BE%91%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt="二值逻辑数据类型"></li>
<li><img src="/2022/05/09/23/%E4%BA%8C%E5%80%BC%E9%80%BB%E8%BE%91%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B2.png" alt="二值逻辑数据类型2"></li>
<li><img src="/2022/05/09/23/%E6%9C%89%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B.png" alt="有符号类型和无符号类型"></li>
<li><img src="/2022/05/09/23/%E6%9C%89%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B2.png" alt="有符号类型和无符号类型2"></li>
<li><img src="/2022/05/09/23/%E4%BB%BF%E7%9C%9F%E8%A1%8C%E4%B8%BA.png" alt="仿真行为"></li>
<li><img src="/2022/05/09/23/%E4%BB%BF%E7%9C%9F%E8%A1%8C%E4%B8%BA2.png" alt="仿真行为2"></li>
<li><img src="/2022/05/09/23/%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B.png" alt="其他类型"></li>
</ul>
</li>
</ul>
<h1 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h1><p>SV的自定义类型：</p>
<ul>
<li><img src="/2022/05/09/23/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B.png" alt="自定义类型"></li>
<li><img src="/2022/05/09/23/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B2.png" alt="自定义类型2"></li>
<li><img src="/2022/05/09/23/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B3.png" alt="自定义类型3"></li>
</ul>
<p>枚举类型：</p>
<ul>
<li><img src="/2022/05/09/23/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B.png" alt="枚举类型"></li>
<li>verilog实现枚举 <ul>
<li><img src="/2022/05/09/23/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E5%AE%9E%E4%BE%8B.png" alt="枚举类型实例"></li>
</ul>
</li>
<li>SV实现枚举：<ul>
<li><img src="/2022/05/09/23/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E5%AE%9E%E4%BE%8B2.png" alt="枚举类型实例2"></li>
</ul>
</li>
<li>定义枚举值：<ul>
<li><img src="/2022/05/09/23/%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E5%80%BC.png" alt="定义枚举值"></li>
</ul>
</li>
<li>自定义枚举类型：<ul>
<li><img src="/2022/05/09/23/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B.png" alt="自定义枚举类型"></li>
</ul>
</li>
<li>枚举类型赋值：<ul>
<li><img src="/2022/05/09/23/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E8%B5%8B%E5%80%BC.png" alt="枚举类型赋值"></li>
</ul>
</li>
</ul>
<p>结构体类型：</p>
<ul>
<li><img src="/2022/05/09/23/%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B.png" alt="结构体类型"></li>
<li><img src="/2022/05/09/23/%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B2.png" alt="结构体类型2"></li>
<li><img src="/2022/05/09/23/%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B3.png" alt="结构体类型3"></li>
<li><img src="/2022/05/09/23/%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B4.png" alt="结构体类型4"></li>
</ul>
<h1 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h1><p>SV中的字符串类型：</p>
<ul>
<li><img src="/2022/05/09/23/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B.png" alt="字符串类型"></li>
<li><img src="/2022/05/09/23/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B2.png" alt="字符串类型2"></li>
</ul>
<p>字符串类型的常见使用方式：</p>
<ul>
<li><img src="/2022/05/09/23/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F.png" alt="字符串类型常见使用方式"></li>
<li><img src="/2022/05/09/23/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%86%85%E5%BB%BA%E6%96%B9%E6%B3%95.png" alt="字符串的内建方法"></li>
<li><img src="/2022/05/09/23/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F2.png" alt="字符串类型常见使用方式2"></li>
<li><img src="/2022/05/09/23/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F3.png" alt="字符串类型常见使用方式3"></li>
</ul>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><ul>
<li><img src="/2022/05/09/23/%E6%8E%A5%E5%8F%A3.png" alt="接口"></li>
<li><img src="/2022/05/09/23/%E6%8E%A5%E5%8F%A32.png" alt="接口2"></li>
<li><img src="/2022/05/09/23/%E6%8E%A5%E5%8F%A33.png" alt="接口3"></li>
<li>verilog无接口代码：<ul>
<li><img src="/2022/05/09/23/verilog%E6%97%A0%E6%8E%A5%E5%8F%A3.png" alt="verilog无接口"></li>
</ul>
</li>
<li>接口的优势：<ul>
<li><img src="/2022/05/09/23/%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BC%98%E5%8A%BF.png" alt="接口的优势"></li>
</ul>
</li>
<li>SV接口代码：<ul>
<li><img src="/2022/05/09/23/SV%E6%9C%89%E6%8E%A5%E5%8F%A3.png" alt="SV有接口"></li>
</ul>
</li>
<li>接口的内容：<ul>
<li><img src="/2022/05/09/23/%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%86%85%E5%AE%B9.png" alt="接口的内容"></li>
<li><img src="/2022/05/09/23/%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%86%85%E5%AE%B92.png" alt="接口的内容2"></li>
</ul>
</li>
<li>接口的声明：<ul>
<li><img src="/2022/05/09/23/%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A3%B0%E6%98%8E.png" alt="接口的声明"></li>
</ul>
</li>
<li>接口的例化：<ul>
<li><img src="/2022/05/09/23/%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BE%8B%E5%8C%96.png" alt="接口的例化"></li>
<li><img src="/2022/05/09/23/%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BE%8B%E5%8C%962.png" alt="接口的例化2"></li>
<li><img src="/2022/05/09/23/%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BE%8B%E5%8C%963.png" alt="接口的例化3"></li>
</ul>
</li>
<li>modport:<ul>
<li><img src="/2022/05/09/23/modport.png" alt="modport"></li>
<li><img src="/2022/05/09/23/modport2.png" alt="modport2"></li>
</ul>
</li>
<li>接口在验证中的应用：<ul>
<li><img src="/2022/05/09/23/%E6%8E%A5%E5%8F%A3%E5%9C%A8%E9%AA%8C%E8%AF%81%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.png" alt="接口在验证中的应用"></li>
</ul>
</li>
<li>总结：<ul>
<li><img src="/2022/05/09/23/%E6%80%BB%E7%BB%93.png" alt="总结"></li>
<li><img src="/2022/05/09/23/%E6%80%BB%E7%BB%932.png" alt="总结2"></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>路科V0</category>
      </categories>
      <tags>
        <tag>UVM</tag>
        <tag>System Verilog</tag>
        <tag>IC验证</tag>
      </tags>
  </entry>
  <entry>
    <title>路科V0SVP10P12验证环境</title>
    <url>/2022/05/10/00/</url>
    <content><![CDATA[<h1 id="验证环境结构"><a href="#验证环境结构" class="headerlink" title="验证环境结构"></a>验证环境结构</h1><ul>
<li>测试平台testbench是整个验证系统的总称；</li>
<li>包括验证结构中的<strong>各个组件、组件之间的连接关系、测试平台的配置和控制</strong></li>
<li>还包括编译仿真的流程、结果分析报告和覆盖率量化等；</li>
<li><strong>主要关注验证平台的结构和组件部分，他们产生设计需要的各种输入，也会在此基础上进行设计功能检查</strong>；</li>
<li><img src="/2022/05/10/00/testbench%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="testbench结构图"><ul>
<li>各个验证组件相互独立</li>
<li>各个验证组件和设计需要互相连接</li>
<li>各个验证组件也需要进行通信（线程通信方式）</li>
<li>验证环境也需要时钟和复位信号的驱动</li>
</ul>
</li>
<li>设计由多个层次构成，无论是物理分区FPGA&#x2F;ASIC，还是逻辑分区合成单元&#x2F;核心子系统；</li>
<li>验证也可以按照不同级别安排目标：<ul>
<li><img src="/2022/05/10/00/%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%84%E7%9A%84%E5%B1%82%E6%AC%A1.png" alt="验证结构的层次"></li>
<li>每个验证级别都有最合适的验证目标</li>
<li>较小的模块更容易验证，他们提供了更大的可控性和可观察性；</li>
<li>较小的模块容易设置条件和状态组合，观察反应是否符合预期；</li>
<li>而他们组成的子系统，以较低的可控性和可观察性为代价；</li>
<li>任何层次的待验设计，都应该有稳定的接口和预期功能；</li>
<li>理想情况，每个子系统和模块都要有硬件描述文档；</li>
<li>如果接口和功能变化，则会影响testbench随之变化，会影响项目进度；</li>
<li><strong>对设计稳定性的要求，一般是先接口稳定下来，再功能稳定下来</strong>；</li>
</ul>
</li>
</ul>
<h1 id="硬件设计描述"><a href="#硬件设计描述" class="headerlink" title="硬件设计描述"></a>硬件设计描述</h1><h2 id="MCDF简介："><a href="#MCDF简介：" class="headerlink" title="MCDF简介："></a>MCDF简介：</h2><ul>
<li>遵循硬件设计描述的方式，介绍它的<strong>结构、功能、寄存器、和时序</strong>；</li>
<li>多通道数据整形器，可以将上行多个通道数据经过内部的<strong>FIFO</strong>，最终以数据包的形式送出；</li>
<li><strong>上行数据和下行数据的接口协议不同</strong>；</li>
<li>多通道数据整形器也有寄存器的读写接口，支持更多的控制功能；</li>
</ul>
<h2 id="MCDF的结构："><a href="#MCDF的结构：" class="headerlink" title="MCDF的结构："></a>MCDF的结构：</h2><p><img src="/2022/05/10/00/MCDF%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84.png" alt="MCDF的设计结构"></p>
<ul>
<li>通道模块(可以同时接收3路通道的输入数据)<ul>
<li>slave</li>
<li>FIFO</li>
<li>但是由于带宽限制，每个时钟周期只有一路数据可以通过仲裁模块，到达整形器模块！</li>
</ul>
</li>
<li>寄存器模块<ul>
<li>控制通道开关</li>
<li>控制仲裁器的选择</li>
<li>控制整形器打包带长度</li>
<li>获取每个通道的FIFO余量</li>
</ul>
</li>
<li>仲裁模块</li>
<li>整形模块<ul>
<li>将指定通道的数据重新打包，以新的总线形式发送出去</li>
</ul>
</li>
</ul>
<h2 id="MCDF的接口描述："><a href="#MCDF的接口描述：" class="headerlink" title="MCDF的接口描述："></a>MCDF的接口描述：</h2><p><img src="/2022/05/10/00/MCDF%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%BF%A1%E5%8F%B7.png" alt="MCDF的接口信号"></p>
<p><img src="/2022/05/10/00/MCDF%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%BF%A1%E5%8F%B72.png" alt="MCDF的接口信号2"></p>
<p><img src="/2022/05/10/00/MCDF%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%BF%A1%E5%8F%B73.png" alt="MCDF的接口信号3"></p>
<h2 id="MCDF的接口时序："><a href="#MCDF的接口时序：" class="headerlink" title="MCDF的接口时序："></a>MCDF的接口时序：</h2><p><img src="/2022/05/10/00/MCDF%E7%9A%84%E6%8E%A5%E5%8F%A3%E6%97%B6%E5%BA%8F.png" alt="MCDF的接口时序"></p>
<ul>
<li>如果当前周期的valid和ready同时为高，则表示可以发送数据；</li>
</ul>
<p><img src="/2022/05/10/00/MCDF%E7%9A%84%E6%8E%A5%E5%8F%A3%E6%97%B6%E5%BA%8F2.png" alt="MCDF的接口时序2"></p>
<ul>
<li>读写寄存器时，需要给地址端口和指令端口对应的值</li>
<li>读取的寄存器数值将在下一个时钟周期由寄存器模块输出</li>
</ul>
<p><img src="/2022/05/10/00/MCDF%E7%9A%84%E6%8E%A5%E5%8F%A3%E6%97%B6%E5%BA%8F3.png" alt="MCDF的接口时序3"></p>
<ul>
<li>当整形器要发送某一个通道的数据时，会拉高req信号，同时也更新chid和长度length信息，等待下行模块接收信号grant为高，其下个周期req应该拉低，同时，start拉高，这时候发送第一个有效数据，发送数据应该连续，发送这段数据的最后一个时，end拉高，start和end的间隔内，data发送完毕！</li>
</ul>
<h2 id="MCDF的寄存器描述："><a href="#MCDF的寄存器描述：" class="headerlink" title="MCDF的寄存器描述："></a>MCDF的寄存器描述：</h2><p><img src="/2022/05/10/00/MCDF%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E6%8F%8F%E8%BF%B0.png" alt="MCDF的寄存器描述"></p>
<p><img src="/2022/05/10/00/MCDF%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E6%8F%8F%E8%BF%B02.png" alt="MCDF的寄存器描述2"></p>
<h2 id="MCDF-mini版结构"><a href="#MCDF-mini版结构" class="headerlink" title="MCDF mini版结构"></a>MCDF mini版结构</h2><p>移除了寄存器模块和整流模块！</p>
<p>功能变成了由多个通道输入，然后仲裁器选择一个通道进行输出。。</p>
<p><img src="/2022/05/10/00/MCDFmini%E7%89%88%E7%BB%93%E6%9E%84.png" alt="MCDFmini版结构"></p>
<h1 id="验证环境组件"><a href="#验证环境组件" class="headerlink" title="验证环境组件"></a>验证环境组件</h1><h3 id="激励发生器"><a href="#激励发生器" class="headerlink" title="激励发生器"></a>激励发生器</h3><ul>
<li>stimulator（激励发生器）：也称为驱动器driver、总线功能模型BFS、行为模型behavioral 或者 发生器generator。</li>
<li>stimulator的主要职责是模拟与DUT相邻设计的接口协议，只需要关注如何模拟接口信号，使它能够以真实接口协议发送激励给DUT</li>
<li><img src="/2022/05/10/00/%E6%BF%80%E5%8A%B1%E5%8F%91%E7%94%9F%E5%99%A8.png" alt="激励发生器"></li>
<li><img src="/2022/05/10/00/%E6%BF%80%E5%8A%B1%E5%8F%91%E7%94%9F%E5%99%A82.png" alt="激励发生器2"></li>
</ul>
<h4 id="激励器组件结构"><a href="#激励器组件结构" class="headerlink" title="激励器组件结构"></a>激励器组件结构</h4><p><img src="/2022/05/10/00/%E6%BF%80%E5%8A%B1%E5%99%A8%E7%BB%84%E4%BB%B6%E7%BB%93%E6%9E%84%E6%A1%86%E5%9B%BE.png" alt="激励器组件结构框图"></p>
<ul>
<li>按照stimulator和DUT的连接关系，激励发生器分为两种：initiator发起器 和 responder响应器</li>
<li>由于channel从端口协议上有握手信号，所以需要遵照接口时序，当chx_ready为低时，保证chx_data和chx_valid保持不变。</li>
<li>channel initiator 组件：<ul>
<li><img src="/2022/05/10/00/channel_initiator_%E7%BB%84%E4%BB%B6.png" alt="channelinitiator组件"></li>
</ul>
</li>
</ul>
<h3 id="监测器"><a href="#监测器" class="headerlink" title="监测器"></a>监测器</h3><ul>
<li>monitor（监测器）：主要功能是<strong>用来观察DUT的边界或者内部信号，并且经过打包整理传送给其他验证平台的组件</strong>，比如checker比较器。</li>
<li>安装监测信号灯层次划分monitor的功能，分为观测DUT边界信号和观测DUT内部信号。<ul>
<li><img src="/2022/05/10/00/monitor%E5%88%86%E7%B1%BB.png" alt="monitor分类"></li>
</ul>
</li>
</ul>
<h4 id="监测器的组件结构"><a href="#监测器的组件结构" class="headerlink" title="监测器的组件结构"></a>监测器的组件结构</h4><p><img src="/2022/05/10/00/%E6%A3%80%E6%B5%8B%E5%99%A8%E7%9A%84%E7%BB%84%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="监测器的组件结构"></p>
<p>另外一些要求和建议：</p>
<p><img src="/2022/05/10/00/%E5%8F%A6%E5%A4%96%E4%B8%80%E4%BA%9B%E8%A6%81%E6%B1%82%E5%92%8C%E5%BB%BA%E8%AE%AE.png" alt="另外一些要求和建议"></p>
<p><img src="/2022/05/10/00/%E5%8F%A6%E5%A4%96%E4%B8%80%E4%BA%9B%E8%A6%81%E6%B1%82%E5%92%8C%E5%BB%BA%E8%AE%AE2.png" alt="另外一些要求和建议2"></p>
<h3 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h3><ul>
<li>checker（比较器）：投入时间最多的组件，肩负了模拟设计行为和功能检查的任务，而且缓存各个monitor收集到的数据；</li>
<li>将DUT输入接口侧的数据汇集给内置的reference model，reference model扮演了模拟硬件功能的角色。</li>
<li>checker将实际收集到的DUT输出数据和reference model产生的数据进行对比；</li>
<li>对于内部设计的关键功能模块，应该有相应的线程进行独立的检查；</li>
<li>检查过程中，可以将检查成功的信息统一纳入检查报告中，便于仿真后的追溯，如果检查失败，也可以暂停仿真同时报告错误，在线调试。<ul>
<li>线上比较：在仿真时收集数据，在线比较，并实时报告。</li>
<li>线下比较：仿真时收集的数据记录在文件中，仿真结束后，通过脚本或者其他手段，进行数据比较。</li>
</ul>
</li>
<li><img src="/2022/05/10/00/checker.png" alt="checker"></li>
</ul>
<h4 id="比较器组件结构"><a href="#比较器组件结构" class="headerlink" title="比较器组件结构"></a>比较器组件结构</h4><p><img src="/2022/05/10/00/%E6%AF%94%E8%BE%83%E5%99%A8%E7%BB%84%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="比较器组件结构"></p>
<h4 id="比较器实现的建议"><a href="#比较器实现的建议" class="headerlink" title="比较器实现的建议"></a>比较器实现的建议</h4><p><img src="/2022/05/10/00/%E6%AF%94%E8%BE%83%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%BB%BA%E8%AE%AE.png" alt="比较器实现的建议"></p>
<p><img src="/2022/05/10/00/%E6%AF%94%E8%BE%83%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%BB%BA%E8%AE%AE2.png" alt="比较器实现的建议2"></p>
]]></content>
      <categories>
        <category>路科V0</category>
      </categories>
      <tags>
        <tag>UVM</tag>
        <tag>System Verilog</tag>
        <tag>IC验证</tag>
      </tags>
  </entry>
  <entry>
    <title>路科V0SV和Verilog的对比总结</title>
    <url>/2022/05/10/55/</url>
    <content><![CDATA[<p><img src="/2022/05/10/55/%E8%B7%AF%E7%A7%91.png" alt="路科"></p>
<h2 id="Verilog："><a href="#Verilog：" class="headerlink" title="Verilog："></a>Verilog：</h2><h3 id="变量类型-veriables"><a href="#变量类型-veriables" class="headerlink" title="变量类型 veriables"></a>变量类型 veriables</h3><h4 id="四值逻辑"><a href="#四值逻辑" class="headerlink" title="四值逻辑"></a>四值逻辑</h4><h5 id="0"><a href="#0" class="headerlink" title="0"></a>0</h5><h5 id="1"><a href="#1" class="headerlink" title="1"></a>1</h5><h5 id="X"><a href="#X" class="headerlink" title="X"></a>X</h5><h6 id="用来捕获设计错误，比如寄存器未初始化"><a href="#用来捕获设计错误，比如寄存器未初始化" class="headerlink" title="用来捕获设计错误，比如寄存器未初始化"></a>用来捕获设计错误，比如寄存器未初始化</h6><h5 id="Z"><a href="#Z" class="headerlink" title="Z"></a>Z</h5><h6 id="用来表示未连接或者三态的设计逻辑"><a href="#用来表示未连接或者三态的设计逻辑" class="headerlink" title="用来表示未连接或者三态的设计逻辑"></a>用来表示未连接或者三态的设计逻辑</h6><p>但是在系统级或者事务级，Z和X很少使用</p>
<h4 id="reg"><a href="#reg" class="headerlink" title="reg"></a>reg</h4><h5 id="用来描述-逻辑，-integer-用来描述循环变量和计算"><a href="#用来描述-逻辑，-integer-用来描述循环变量和计算" class="headerlink" title="用来描述 逻辑， integer 用来描述循环变量和计算"></a>用来描述 逻辑， integer 用来描述循环变量和计算</h5><h5 id="reg并不一定要被综合为register，它只是用来与线网类型相对，表示存储数据的变量"><a href="#reg并不一定要被综合为register，它只是用来与线网类型相对，表示存储数据的变量" class="headerlink" title="reg并不一定要被综合为register，它只是用来与线网类型相对，表示存储数据的变量"></a>reg并不一定要被综合为register，它只是用来与线网类型相对，表示存储数据的变量</h5><h4 id="integer"><a href="#integer" class="headerlink" title="integer"></a>integer</h4><h5 id="和time类似，像有相同位数的reg一样运转，"><a href="#和time类似，像有相同位数的reg一样运转，" class="headerlink" title="和time类似，像有相同位数的reg一样运转，"></a>和time类似，像有相同位数的reg一样运转，</h5><p>表达式的integer值作为 有符号数 处理， reg 和 time 作为无符号数处理</p>
<h4 id="time"><a href="#time" class="headerlink" title="time"></a>time</h4><h5 id="和realtime类似，-用来保存测试装置的仿真时间"><a href="#和realtime类似，-用来保存测试装置的仿真时间" class="headerlink" title="和realtime类似， 用来保存测试装置的仿真时间"></a>和realtime类似， 用来保存测试装置的仿真时间</h5><h4 id="real"><a href="#real" class="headerlink" title="real"></a>real</h4><h5 id="在系统模型中使用"><a href="#在系统模型中使用" class="headerlink" title="在系统模型中使用"></a>在系统模型中使用</h5><h4 id="realtime"><a href="#realtime" class="headerlink" title="realtime"></a>realtime</h4><h4 id="变量类型是保存在initial-always-task-function中赋的值"><a href="#变量类型是保存在initial-always-task-function中赋的值" class="headerlink" title="变量类型是保存在initial always task function中赋的值"></a>变量类型是保存在initial always task function中赋的值</h4><h4 id="只能用-过程赋值-来完成"><a href="#只能用-过程赋值-来完成" class="headerlink" title="只能用 过程赋值 来完成"></a>只能用 过程赋值 来完成</h4><h3 id="线网类型-nets"><a href="#线网类型-nets" class="headerlink" title="线网类型 nets"></a>线网类型 nets</h3><h4 id="四值逻辑-1"><a href="#四值逻辑-1" class="headerlink" title="四值逻辑"></a>四值逻辑</h4><h5 id="0-1"><a href="#0-1" class="headerlink" title="0"></a>0</h5><h5 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h5><h5 id="X-1"><a href="#X-1" class="headerlink" title="X"></a>X</h5><h5 id="Z-1"><a href="#Z-1" class="headerlink" title="Z"></a>Z</h5><h4 id="wire"><a href="#wire" class="headerlink" title="wire"></a>wire</h4><h4 id="wor"><a href="#wor" class="headerlink" title="wor"></a>wor</h4><h4 id="wand"><a href="#wand" class="headerlink" title="wand"></a>wand</h4><h4 id="用于建模连接线路，值由-线网驱动器决定"><a href="#用于建模连接线路，值由-线网驱动器决定" class="headerlink" title="用于建模连接线路，值由 线网驱动器决定"></a>用于建模连接线路，值由 线网驱动器决定</h4><h4 id="线网驱动器：可以是门或者模块的实例，也可以是连续赋值的输出"><a href="#线网驱动器：可以是门或者模块的实例，也可以是连续赋值的输出" class="headerlink" title="线网驱动器：可以是门或者模块的实例，也可以是连续赋值的输出"></a>线网驱动器：可以是门或者模块的实例，也可以是连续赋值的输出</h4><h2 id="SV"><a href="#SV" class="headerlink" title="SV :"></a>SV :</h2><p> 在与C交互时，可以使用二值逻辑使接口参数更加简单，<br>因为构建验证驱动组件时，不关注硬件底层逻辑X，Z</p>
<h3 id="硬件信号"><a href="#硬件信号" class="headerlink" title="硬件信号"></a>硬件信号</h3><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><h5 id="变量-var"><a href="#变量-var" class="headerlink" title="变量 var"></a>变量 var</h5><h5 id="线网类型-wire"><a href="#线网类型-wire" class="headerlink" title="线网类型 wire"></a>线网类型 wire</h5><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><h5 id="四值逻辑-logic"><a href="#四值逻辑-logic" class="headerlink" title="四值逻辑 logic"></a>四值逻辑 logic</h5><p>构成的vector都是无符号类型</p>
<h6 id="用来表示通用的存储硬件数据"><a href="#用来表示通用的存储硬件数据" class="headerlink" title="用来表示通用的存储硬件数据"></a>用来表示通用的存储硬件数据</h6><p>####### logic resetN;    &#x2F;&#x2F; 1位宽的四值逻辑</p>
<p>####### logic  [63:0] data;     &#x2F;&#x2F; 64位宽的变量</p>
<p>####### logic [0:7} array [0:255];    &#x2F;&#x2F; 由8位向量元素构成的数组</p>
<h6 id="虽然只表示数据类型，但是在声明时，会默认表示为变量var，用户可以显式声明其类型"><a href="#虽然只表示数据类型，但是在声明时，会默认表示为变量var，用户可以显式声明其类型" class="headerlink" title="虽然只表示数据类型，但是在声明时，会默认表示为变量var，用户可以显式声明其类型"></a>虽然只表示数据类型，但是在声明时，会默认表示为变量var，用户可以显式声明其类型</h6><p>####### var logic [63:0] addr;    &#x2F;&#x2F; 64位宽的变量类型</p>
<p>####### wire logic [63:0] data;    &#x2F;&#x2F; 64位宽的线网类型</p>
<h5 id="二值逻辑-bit"><a href="#二值逻辑-bit" class="headerlink" title="二值逻辑 bit"></a>二值逻辑 bit</h5><h6 id="帮助更高级抽象的建模，比如，事务级模型"><a href="#帮助更高级抽象的建模，比如，事务级模型" class="headerlink" title="帮助更高级抽象的建模，比如，事务级模型"></a>帮助更高级抽象的建模，比如，事务级模型</h6><p>####### bit ： 1位二值逻辑变量</p>
<p>构成的vector是无符号类型</p>
<p>####### byte ： 8位二值逻辑，类似于C语言中的char</p>
<p>####### shortint ： 16位，类似short</p>
<p>####### int : 32位，类似int</p>
<p>####### longint : 64位，类似longlong</p>
<h6 id="bit类型默认也是变量类型，"><a href="#bit类型默认也是变量类型，" class="headerlink" title="bit类型默认也是变量类型，"></a>bit类型默认也是变量类型，</h6><p>除了bit的其他二值逻辑类型的verctor，默认都是有符号类型</p>
<h6 id="可以使用unsighed表示无符号类型，-比如-byte-unsigned"><a href="#可以使用unsighed表示无符号类型，-比如-byte-unsigned" class="headerlink" title="可以使用unsighed表示无符号类型， 比如 byte unsigned"></a>可以使用unsighed表示无符号类型， 比如 byte unsigned</h6><p>####### 表示的范围从[-128, 127]， 变为了[0, 255]</p>
<h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h3><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><h5 id="可以用更少的代码表示更多的功能"><a href="#可以用更少的代码表示更多的功能" class="headerlink" title="可以用更少的代码表示更多的功能"></a>可以用更少的代码表示更多的功能</h5><h5 id="代码可读性更好"><a href="#代码可读性更好" class="headerlink" title="代码可读性更好"></a>代码可读性更好</h5><h5 id="通过typedef创建用户自定义类型"><a href="#通过typedef创建用户自定义类型" class="headerlink" title="通过typedef创建用户自定义类型"></a>通过typedef创建用户自定义类型</h5><h5 id="通过enum创建枚举"><a href="#通过enum创建枚举" class="headerlink" title="通过enum创建枚举"></a>通过enum创建枚举</h5><h5 id="通过struct创建结构体类型"><a href="#通过struct创建结构体类型" class="headerlink" title="通过struct创建结构体类型"></a>通过struct创建结构体类型</h5><h5 id="Verilog无法使用户扩展变量和线网类型"><a href="#Verilog无法使用户扩展变量和线网类型" class="headerlink" title="Verilog无法使用户扩展变量和线网类型"></a>Verilog无法使用户扩展变量和线网类型</h5><h5 id="SV提供的自定义类型使用户构建更高层次抽象的数据类型"><a href="#SV提供的自定义类型使用户构建更高层次抽象的数据类型" class="headerlink" title="SV提供的自定义类型使用户构建更高层次抽象的数据类型"></a>SV提供的自定义类型使用户构建更高层次抽象的数据类型</h5><h5 id="比如：-typedef-int-unsigned-uint-uint-a-b"><a href="#比如：-typedef-int-unsigned-uint-uint-a-b" class="headerlink" title="比如： typedef int unsigned uint;  uint a, b;"></a>比如： typedef int unsigned uint;  uint a, b;</h5><h5 id="一般对自定义类型加个-t后缀"><a href="#一般对自定义类型加个-t后缀" class="headerlink" title="一般对自定义类型加个_t后缀"></a>一般对自定义类型加个_t后缀</h5><h4 id="enum枚举"><a href="#enum枚举" class="headerlink" title="enum枚举"></a>enum枚举</h4><h5 id="每个值都要一个用户自定义的名字，比如枚举类型RGB"><a href="#每个值都要一个用户自定义的名字，比如枚举类型RGB" class="headerlink" title="每个值都要一个用户自定义的名字，比如枚举类型RGB"></a>每个值都要一个用户自定义的名字，比如枚举类型RGB</h5><h6 id="enum-red-green-blue-RGB"><a href="#enum-red-green-blue-RGB" class="headerlink" title="enum {red, green, blue} RGB;"></a>enum {red, green, blue} RGB;</h6><h5 id="Verilog没有枚举，为了提供描述变量的范围，使用参数来表示可取值的范围，或者宏定义定义各个合法值的名称"><a href="#Verilog没有枚举，为了提供描述变量的范围，使用参数来表示可取值的范围，或者宏定义定义各个合法值的名称" class="headerlink" title="Verilog没有枚举，为了提供描述变量的范围，使用参数来表示可取值的范围，或者宏定义定义各个合法值的名称"></a>Verilog没有枚举，为了提供描述变量的范围，使用参数来表示可取值的范围，或者宏定义定义各个合法值的名称</h5><h5 id="定义枚举值"><a href="#定义枚举值" class="headerlink" title="定义枚举值"></a>定义枚举值</h5><h6 id="默认为int，32位二值逻辑"><a href="#默认为int，32位二值逻辑" class="headerlink" title="默认为int，32位二值逻辑"></a>默认为int，32位二值逻辑</h6><h6 id="但是，SV也允许指明数据类型，比如：-enum-bit-TRUE-FALSE-Boolean-enum-logic-1-0-WAITE-LOAD-READY-state"><a href="#但是，SV也允许指明数据类型，比如：-enum-bit-TRUE-FALSE-Boolean-enum-logic-1-0-WAITE-LOAD-READY-state" class="headerlink" title="但是，SV也允许指明数据类型，比如： enum bit {TRUE, FALSE} Boolean;  enum logic [1:0] {WAITE, LOAD, READY} state;"></a>但是，SV也允许指明数据类型，比如： enum bit {TRUE, FALSE} Boolean;  enum logic [1:0] {WAITE, LOAD, READY} state;</h6><h6 id="如果枚举类型被赋值，那么所赋值应该在其数据范围内-enum-logic-2-0-WAITE-x3D-3’b001-Load-x3D-3’b010-READY-x3D-3’b100-state"><a href="#如果枚举类型被赋值，那么所赋值应该在其数据范围内-enum-logic-2-0-WAITE-x3D-3’b001-Load-x3D-3’b010-READY-x3D-3’b100-state" class="headerlink" title="如果枚举类型被赋值，那么所赋值应该在其数据范围内   enum logic [2:0] {WAITE &#x3D; 3’b001, Load &#x3D; 3’b010, READY &#x3D; 3’b100} state;"></a>如果枚举类型被赋值，那么所赋值应该在其数据范围内   enum logic [2:0] {WAITE &#x3D; 3’b001, Load &#x3D; 3’b010, READY &#x3D; 3’b100} state;</h6><h6 id="如果枚举变量是四值逻辑，那么赋值为X或者Z也是合法的-enum-logic-ON-x3D-1’b1-OFF-x3D-1’bz-out"><a href="#如果枚举变量是四值逻辑，那么赋值为X或者Z也是合法的-enum-logic-ON-x3D-1’b1-OFF-x3D-1’bz-out" class="headerlink" title="如果枚举变量是四值逻辑，那么赋值为X或者Z也是合法的   enum logic {ON&#x3D;1’b1, OFF&#x3D;1’bz} out;"></a>如果枚举变量是四值逻辑，那么赋值为X或者Z也是合法的   enum logic {ON&#x3D;1’b1, OFF&#x3D;1’bz} out;</h6><h5 id="自定义枚举类型"><a href="#自定义枚举类型" class="headerlink" title="自定义枚举类型"></a>自定义枚举类型</h5><h6 id="如果枚举类型没有伴随typedef，那么该枚举类型是个匿名枚举类型"><a href="#如果枚举类型没有伴随typedef，那么该枚举类型是个匿名枚举类型" class="headerlink" title="如果枚举类型没有伴随typedef，那么该枚举类型是个匿名枚举类型"></a>如果枚举类型没有伴随typedef，那么该枚举类型是个匿名枚举类型</h6><h6 id="将它typedef为自定义类型，就可以用同一个枚举类型来声明多个变量或者线网-typedef-enum-WAITE-LOAD-READY-state-t-state-t-state-next-state"><a href="#将它typedef为自定义类型，就可以用同一个枚举类型来声明多个变量或者线网-typedef-enum-WAITE-LOAD-READY-state-t-state-t-state-next-state" class="headerlink" title="将它typedef为自定义类型，就可以用同一个枚举类型来声明多个变量或者线网    typedef enum {WAITE, LOAD, READY} state_t;   state_t state next_state;"></a>将它typedef为自定义类型，就可以用同一个枚举类型来声明多个变量或者线网    typedef enum {WAITE, LOAD, READY} state_t;   state_t state next_state;</h6><h5 id="枚举类型赋值"><a href="#枚举类型赋值" class="headerlink" title="枚举类型赋值"></a>枚举类型赋值</h5><h6 id="赋值要求很严格，-x3D-两端必须是相同的枚举类型；"><a href="#赋值要求很严格，-x3D-两端必须是相同的枚举类型；" class="headerlink" title="赋值要求很严格，&#x3D;两端必须是相同的枚举类型；"></a>赋值要求很严格，&#x3D;两端必须是相同的枚举类型；</h6><p>int foo; states_t state;<br>foo &#x3D; state + 1; &#x2F;&#x2F; 可以   <br>state &#x3D; foo +1; &#x2F;&#x2F; 不可以 <br>state &#x3D; states_t’(foo+1); &#x2F;&#x2F; 可以</p>
<p>state++; &#x2F;&#x2F;不可以<br>state&#x3D; state + 1; &#x2F;&#x2F;不可以<br>state &#x3D; states_t’(state+1);  &#x2F;&#x2F; 可以</p>
<h4 id="struct-结构体"><a href="#struct-结构体" class="headerlink" title="struct 结构体"></a>struct 结构体</h4><h5 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h5><h6 id="经常遇到数据表示逻辑相关的数据信号组，比如总线协议的所有控制信号，或者在状态控制器中用到的所有信号，verilog不方便"><a href="#经常遇到数据表示逻辑相关的数据信号组，比如总线协议的所有控制信号，或者在状态控制器中用到的所有信号，verilog不方便" class="headerlink" title="经常遇到数据表示逻辑相关的数据信号组，比如总线协议的所有控制信号，或者在状态控制器中用到的所有信号，verilog不方便"></a>经常遇到数据表示逻辑相关的数据信号组，比如总线协议的所有控制信号，或者在状态控制器中用到的所有信号，verilog不方便</h6><h6 id="SV的结构体，成员可以是任意变量类型，包括自定义和其他常量类型"><a href="#SV的结构体，成员可以是任意变量类型，包括自定义和其他常量类型" class="headerlink" title="SV的结构体，成员可以是任意变量类型，包括自定义和其他常量类型"></a>SV的结构体，成员可以是任意变量类型，包括自定义和其他常量类型</h6><h6 id="struct"><a href="#struct" class="headerlink" title="struct {"></a>struct {</h6><p>  int a,b;<br>  opcode_t opcode;<br>  logic [23:0] address;<br>  bit error;<br>} Instruction_Word;</p>
<h5 id="结构体是变量的合集，所以结构体的变量一可以索引到其内部，用-符号，和C一样"><a href="#结构体是变量的合集，所以结构体的变量一可以索引到其内部，用-符号，和C一样" class="headerlink" title="结构体是变量的合集，所以结构体的变量一可以索引到其内部，用.符号，和C一样"></a>结构体是变量的合集，所以结构体的变量一可以索引到其内部，用.符号，和C一样</h5><p>Instruction_Word.address &#x3D; 32’hF000001E;</p>
<h5 id="结构体类型默认为变量类型，用户也可以显式声明为var或者wire"><a href="#结构体类型默认为变量类型，用户也可以显式声明为var或者wire" class="headerlink" title="结构体类型默认为变量类型，用户也可以显式声明为var或者wire"></a>结构体类型默认为变量类型，用户也可以显式声明为var或者wire</h5><h5 id="结构体也可以typedef为自定义类型，然后使用"><a href="#结构体也可以typedef为自定义类型，然后使用" class="headerlink" title="结构体也可以typedef为自定义类型，然后使用"></a>结构体也可以typedef为自定义类型，然后使用</h5><p>typedef struct {<br>  …;<br>  …;<br>} instruction_word_t;<br>instruction_word_t IM;</p>
<h5 id="可以通过索引到成员，依次赋值"><a href="#可以通过索引到成员，依次赋值" class="headerlink" title="可以通过索引到成员，依次赋值"></a>可以通过索引到成员，依次赋值</h5><h5 id="也可以通过分号’和花括号-实现整体赋值"><a href="#也可以通过分号’和花括号-实现整体赋值" class="headerlink" title="也可以通过分号’和花括号{}实现整体赋值"></a>也可以通过分号’和花括号{}实现整体赋值</h5><h6 id="IW-x3D-‘-100-3-8’hFF-0"><a href="#IW-x3D-‘-100-3-8’hFF-0" class="headerlink" title="IW &#x3D; ‘{100, 3, 8’hFF, 0};"></a>IW &#x3D; ‘{100, 3, 8’hFF, 0};</h6><p>IW &#x3D; ‘{address:0, opcode:8’hFF, a:100, b:5};</p>
<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><h4 id="优势-2"><a href="#优势-2" class="headerlink" title="优势"></a>优势</h4><h5 id="Verilog没有string，SV引入string容纳可变长度的字符串"><a href="#Verilog没有string，SV引入string容纳可变长度的字符串" class="headerlink" title="Verilog没有string，SV引入string容纳可变长度的字符串"></a>Verilog没有string，SV引入string容纳可变长度的字符串</h5><h5 id="string类型的存储单元为byte类型，即char"><a href="#string类型的存储单元为byte类型，即char" class="headerlink" title="string类型的存储单元为byte类型，即char"></a>string类型的存储单元为byte类型，即char</h5><h5 id="在string变量长度为N时，索引是0到N-1"><a href="#在string变量长度为N时，索引是0到N-1" class="headerlink" title="在string变量长度为N时，索引是0到N-1"></a>在string变量长度为N时，索引是0到N-1</h5><h4 id="和C的差别"><a href="#和C的差别" class="headerlink" title="和C的差别"></a>和C的差别</h4><h5 id="字符串结尾没有-0"><a href="#字符串结尾没有-0" class="headerlink" title="字符串结尾没有\0"></a>字符串结尾没有\0</h5><h5 id="内存动态分配，用户不需要担心内存管理"><a href="#内存动态分配，用户不需要担心内存管理" class="headerlink" title="内存动态分配，用户不需要担心内存管理"></a>内存动态分配，用户不需要担心内存管理</h5><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="typedef-logic-15-0-r-t"><a href="#typedef-logic-15-0-r-t" class="headerlink" title="typedef logic [15:0] r_t;"></a>typedef logic [15:0] r_t;</h5><p>r_t r;<br>integer i &#x3D; 1;<br>string b &#x3D; “”;<br>string a &#x3D; {“Hi”, b};<br>r &#x3D; r_t’(a);<br>b &#x3D; string’(r);<br>b &#x3D; “Hi”;<br>b &#x3D; {5{“Hi”}};<br>a &#x3D; {i{“Hi”}};    &#x2F;&#x2F;可以，非常量复制<br>a &#x3D; {a, b};<br>a &#x3D; {“Hi”, b};<br>b &#x3D; {“Hi”, “”};<br>a[0] &#x3D; “h”;</p>
<h5 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h5><h6 id="str-len-返回string的长度"><a href="#str-len-返回string的长度" class="headerlink" title="str.len()   返回string的长度"></a>str.len()   返回string的长度</h6><h6 id="str-putc-i-c-将第i个字符替换为字符c，等同于-str-i-x3D-c"><a href="#str-putc-i-c-将第i个字符替换为字符c，等同于-str-i-x3D-c" class="headerlink" title="str.putc(i, c)    将第i个字符替换为字符c，等同于 str[i] &#x3D; c"></a>str.putc(i, c)    将第i个字符替换为字符c，等同于 str[i] &#x3D; c</h6><h6 id="str-getc-i-返回第i个字符"><a href="#str-getc-i-返回第i个字符" class="headerlink" title="str.getc(i)    返回第i个字符"></a>str.getc(i)    返回第i个字符</h6><h6 id="str-substr-i-j-返回第i个字符到第j个字符"><a href="#str-substr-i-j-返回第i个字符到第j个字符" class="headerlink" title="str.substr(i, j)    返回第i个字符到第j个字符"></a>str.substr(i, j)    返回第i个字符到第j个字符</h6><h6 id="另外，SV有其他的系统函数"><a href="#另外，SV有其他的系统函数" class="headerlink" title="另外，SV有其他的系统函数"></a>另外，SV有其他的系统函数</h6><p>####### $sformatf()   用来生成一个格式化的字符串</p>
<p>####### $display()    打印输出</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="优势-3"><a href="#优势-3" class="headerlink" title="优势"></a>优势</h4><h5 id="Verilog通过模块之间的端口连接，进行模块间的通信，但是大型设计，端口连接很容易出错，所以，SV扩展了接口interface"><a href="#Verilog通过模块之间的端口连接，进行模块间的通信，但是大型设计，端口连接很容易出错，所以，SV扩展了接口interface" class="headerlink" title="Verilog通过模块之间的端口连接，进行模块间的通信，但是大型设计，端口连接很容易出错，所以，SV扩展了接口interface"></a>Verilog通过模块之间的端口连接，进行模块间的通信，但是大型设计，端口连接很容易出错，所以，SV扩展了接口interface</h5><h5 id="接口提供了面向抽象级建模的方式"><a href="#接口提供了面向抽象级建模的方式" class="headerlink" title="接口提供了面向抽象级建模的方式"></a>接口提供了面向抽象级建模的方式</h5><h5 id="可以简化建模和验证大型复杂的设计"><a href="#可以简化建模和验证大型复杂的设计" class="headerlink" title="可以简化建模和验证大型复杂的设计"></a>可以简化建模和验证大型复杂的设计</h5><h5 id="尤其是标准总线端口，Verilog需要在多个模块重复声明，通信协议也是多次定义，变更之后的更改也很麻烦"><a href="#尤其是标准总线端口，Verilog需要在多个模块重复声明，通信协议也是多次定义，变更之后的更改也很麻烦" class="headerlink" title="尤其是标准总线端口，Verilog需要在多个模块重复声明，通信协议也是多次定义，变更之后的更改也很麻烦"></a>尤其是标准总线端口，Verilog需要在多个模块重复声明，通信协议也是多次定义，变更之后的更改也很麻烦</h5><h5 id="接口允许多个信号被整合到一起，用于表示单一的抽象端口"><a href="#接口允许多个信号被整合到一起，用于表示单一的抽象端口" class="headerlink" title="接口允许多个信号被整合到一起，用于表示单一的抽象端口"></a>接口允许多个信号被整合到一起，用于表示单一的抽象端口</h5><h5 id="多个模块可以使用同一个接口，避免分散端口信号连接"><a href="#多个模块可以使用同一个接口，避免分散端口信号连接" class="headerlink" title="多个模块可以使用同一个接口，避免分散端口信号连接"></a>多个模块可以使用同一个接口，避免分散端口信号连接</h5><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="interface-main-bus"><a href="#interface-main-bus" class="headerlink" title="interface main_bus;"></a>interface main_bus;</h5><p>   …;<br>   …;<br>endinterface</p>
<p>main_bus bus();   &#x2F;&#x2F; 接口实例</p>
<h5 id="接口不止可以包含-变量或者线网，还可以封装模块之间通信的协议"><a href="#接口不止可以包含-变量或者线网，还可以封装模块之间通信的协议" class="headerlink" title="接口不止可以包含 变量或者线网，还可以封装模块之间通信的协议"></a>接口不止可以包含 变量或者线网，还可以封装模块之间通信的协议</h5><h5 id="还可以嵌入与协议有关的断言检查、功能覆盖率收集等模块"><a href="#还可以嵌入与协议有关的断言检查、功能覆盖率收集等模块" class="headerlink" title="还可以嵌入与协议有关的断言检查、功能覆盖率收集等模块"></a>还可以嵌入与协议有关的断言检查、功能覆盖率收集等模块</h5><h5 id="接口不同于模块的地方在于，接口不允许包含设计层次，即接口无法例化模块，但是接口可以例化接口"><a href="#接口不同于模块的地方在于，接口不允许包含设计层次，即接口无法例化模块，但是接口可以例化接口" class="headerlink" title="接口不同于模块的地方在于，接口不允许包含设计层次，即接口无法例化模块，但是接口可以例化接口"></a>接口不同于模块的地方在于，接口不允许包含设计层次，即接口无法例化模块，但是接口可以例化接口</h5><h5 id="可以在接口的声明modport，来约束不同模块连接时信号灯方向"><a href="#可以在接口的声明modport，来约束不同模块连接时信号灯方向" class="headerlink" title="可以在接口的声明modport，来约束不同模块连接时信号灯方向"></a>可以在接口的声明modport，来约束不同模块连接时信号灯方向</h5><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><h5 id="接口定义和模块定义类似"><a href="#接口定义和模块定义类似" class="headerlink" title="接口定义和模块定义类似"></a>接口定义和模块定义类似</h5><h5 id="也可以有端口，例如外部接入的时钟或者复位信号；"><a href="#也可以有端口，例如外部接入的时钟或者复位信号；" class="headerlink" title="也可以有端口，例如外部接入的时钟或者复位信号；"></a>也可以有端口，例如外部接入的时钟或者复位信号；</h5><p>interface main_bus (input logic clock, resetN, test_mode);</p>
<h4 id="例化"><a href="#例化" class="headerlink" title="例化"></a>例化</h4><h5 id="接口的例化方式和模块的例化方式一致"><a href="#接口的例化方式和模块的例化方式一致" class="headerlink" title="接口的例化方式和模块的例化方式一致"></a>接口的例化方式和模块的例化方式一致</h5><h5 id="模块的端口如果声明为input、output、inout，那么在例化时可以不连接"><a href="#模块的端口如果声明为input、output、inout，那么在例化时可以不连接" class="headerlink" title="模块的端口如果声明为input、output、inout，那么在例化时可以不连接"></a>模块的端口如果声明为input、output、inout，那么在例化时可以不连接</h5><h5 id="模块的端口如果声明为interface，那么在例化时必须连接到一个接口的实例，或者另一个接口端口"><a href="#模块的端口如果声明为interface，那么在例化时必须连接到一个接口的实例，或者另一个接口端口" class="headerlink" title="模块的端口如果声明为interface，那么在例化时必须连接到一个接口的实例，或者另一个接口端口"></a>模块的端口如果声明为interface，那么在例化时必须连接到一个接口的实例，或者另一个接口端口</h5><h5 id="如果一个模块拥有一个接口类型的端口，那么索引这个接口中的信号，需要通过-操作符，"><a href="#如果一个模块拥有一个接口类型的端口，那么索引这个接口中的信号，需要通过-操作符，" class="headerlink" title="如果一个模块拥有一个接口类型的端口，那么索引这个接口中的信号，需要通过.操作符，"></a>如果一个模块拥有一个接口类型的端口，那么索引这个接口中的信号，需要通过.操作符，</h5><p>bus.resetN</p>
<h4 id="modport"><a href="#modport" class="headerlink" title="modport"></a>modport</h4><h5 id="接口的线网信号或者变量，对于连接到这个接口的不同模块可能有不同的连接方向，所以引入modport表示不同模块看到同一组信号时的视角方向"><a href="#接口的线网信号或者变量，对于连接到这个接口的不同模块可能有不同的连接方向，所以引入modport表示不同模块看到同一组信号时的视角方向" class="headerlink" title="接口的线网信号或者变量，对于连接到这个接口的不同模块可能有不同的连接方向，所以引入modport表示不同模块看到同一组信号时的视角方向"></a>接口的线网信号或者变量，对于连接到这个接口的不同模块可能有不同的连接方向，所以引入modport表示不同模块看到同一组信号时的视角方向</h5><h5 id="在接口中声明modport，需要指名modport中各个信号灯方向"><a href="#在接口中声明modport，需要指名modport中各个信号灯方向" class="headerlink" title="在接口中声明modport，需要指名modport中各个信号灯方向"></a>在接口中声明modport，需要指名modport中各个信号灯方向</h5><h5 id="当一个模块在例化时，可以选择连接到interface端口中具体的某一个modport"><a href="#当一个模块在例化时，可以选择连接到interface端口中具体的某一个modport" class="headerlink" title="当一个模块在例化时，可以选择连接到interface端口中具体的某一个modport"></a>当一个模块在例化时，可以选择连接到interface端口中具体的某一个modport</h5><h5 id="这种方式可以降低连接方向错误的可能，避免信号多驱动的情况"><a href="#这种方式可以降低连接方向错误的可能，避免信号多驱动的情况" class="headerlink" title="这种方式可以降低连接方向错误的可能，避免信号多驱动的情况"></a>这种方式可以降低连接方向错误的可能，避免信号多驱动的情况</h5><h5 id="interface-chip-bus-…"><a href="#interface-chip-bus-…" class="headerlink" title="interface chip_bus(…);"></a>interface chip_bus(…);</h5><pre><code>modport master(...);
</code></pre>
<p>   modport slave(…);<br>endinterface</p>
<p>module primary(interface pins); &#x2F;&#x2F;通用接口端口<br>…<br>endmodule</p>
<p>module secondary (chip_bus pins);   &#x2F;&#x2F; 特定接口端口<br>…<br>endmodule</p>
<p>module chip (…);<br>   chip_bus bus(..);    &#x2F;&#x2F; 接口实例<br>   primary i1 (bus.master);    &#x2F;&#x2F; 使用master modport方式<br>    secondary i2(bus.slave);   &#x2F;&#x2F; 使用slave modport方式<br>endmodule</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><h5 id="利用接口，可以将测试平台和DUT连接在一起"><a href="#利用接口，可以将测试平台和DUT连接在一起" class="headerlink" title="利用接口，可以将测试平台和DUT连接在一起"></a>利用接口，可以将测试平台和DUT连接在一起</h5><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h5 id="接口对于设计复用很有利"><a href="#接口对于设计复用很有利" class="headerlink" title="接口对于设计复用很有利"></a>接口对于设计复用很有利</h5><h5 id="接口减少了模块之间错误连接的可能性"><a href="#接口减少了模块之间错误连接的可能性" class="headerlink" title="接口减少了模块之间错误连接的可能性"></a>接口减少了模块之间错误连接的可能性</h5><h5 id="如果添加了新的信号，只需要在接口中声明，不需要在每个模块中声明"><a href="#如果添加了新的信号，只需要在接口中声明，不需要在每个模块中声明" class="headerlink" title="如果添加了新的信号，只需要在接口中声明，不需要在每个模块中声明"></a>如果添加了新的信号，只需要在接口中声明，不需要在每个模块中声明</h5><h5 id="由于接口可以将有关信号都集合在一起，可以在使用这些信号时，需要添加接口实例名"><a href="#由于接口可以将有关信号都集合在一起，可以在使用这些信号时，需要添加接口实例名" class="headerlink" title="由于接口可以将有关信号都集合在一起，可以在使用这些信号时，需要添加接口实例名"></a>由于接口可以将有关信号都集合在一起，可以在使用这些信号时，需要添加接口实例名</h5><h5 id="一种接口往往将有关信号集合在一起，因此，对于拥有多组不相关信号的设计而言，需要多个接口才能完成与其他模块的连接"><a href="#一种接口往往将有关信号集合在一起，因此，对于拥有多组不相关信号的设计而言，需要多个接口才能完成与其他模块的连接" class="headerlink" title="一种接口往往将有关信号集合在一起，因此，对于拥有多组不相关信号的设计而言，需要多个接口才能完成与其他模块的连接"></a>一种接口往往将有关信号集合在一起，因此，对于拥有多组不相关信号的设计而言，需要多个接口才能完成与其他模块的连接</h5><h3 id="其他注意点："><a href="#其他注意点：" class="headerlink" title="其他注意点："></a>其他注意点：</h3><h4 id="四值逻辑，比如reg、logic、integer，在仿真开始时的初始值为X"><a href="#四值逻辑，比如reg、logic、integer，在仿真开始时的初始值为X" class="headerlink" title="四值逻辑，比如reg、logic、integer，在仿真开始时的初始值为X"></a>四值逻辑，比如reg、logic、integer，在仿真开始时的初始值为X</h4><h4 id="二值逻辑bit在仿真开始的初值为0"><a href="#二值逻辑bit在仿真开始的初值为0" class="headerlink" title="二值逻辑bit在仿真开始的初值为0"></a>二值逻辑bit在仿真开始的初值为0</h4><h4 id="如果四值逻辑和二值逻辑发生转换，则把X和Z都转为0"><a href="#如果四值逻辑和二值逻辑发生转换，则把X和Z都转为0" class="headerlink" title="如果四值逻辑和二值逻辑发生转换，则把X和Z都转为0"></a>如果四值逻辑和二值逻辑发生转换，则把X和Z都转为0</h4><h4 id="二值逻辑也可以实现可综合电路，但是由于没有X、Z，可能出现仿真行为和综合电路的结果不一致的情况"><a href="#二值逻辑也可以实现可综合电路，但是由于没有X、Z，可能出现仿真行为和综合电路的结果不一致的情况" class="headerlink" title="二值逻辑也可以实现可综合电路，但是由于没有X、Z，可能出现仿真行为和综合电路的结果不一致的情况"></a>二值逻辑也可以实现可综合电路，但是由于没有X、Z，可能出现仿真行为和综合电路的结果不一致的情况</h4><h4 id="SV中还新增了void类型，用于在函数定义时表示无返回值，同C"><a href="#SV中还新增了void类型，用于在函数定义时表示无返回值，同C" class="headerlink" title="SV中还新增了void类型，用于在函数定义时表示无返回值，同C"></a>SV中还新增了void类型，用于在函数定义时表示无返回值，同C</h4><h4 id="SV中添加了shortreal表示32位单精度浮点数，同float；"><a href="#SV中添加了shortreal表示32位单精度浮点数，同float；" class="headerlink" title="SV中添加了shortreal表示32位单精度浮点数，同float；"></a>SV中添加了shortreal表示32位单精度浮点数，同float；</h4><p>而verilog中的real表示双精度浮点型，同double</p>
]]></content>
      <categories>
        <category>路科V0</category>
      </categories>
      <tags>
        <tag>UVM</tag>
        <tag>System Verilog</tag>
        <tag>IC验证</tag>
      </tags>
  </entry>
  <entry>
    <title>链表00--链表理论基础</title>
    <url>/2022/09/28/02/</url>
    <content><![CDATA[<h1 id="链表理论基础"><a href="#链表理论基础" class="headerlink" title="链表理论基础"></a>链表理论基础</h1><blockquote>
<p>链表是一种<mark><strong>通过指针串联在一起的线性结构</strong></mark>，每一个节点由两部分组成，<strong>一个是数据域一个是指针域</strong>（存放指向下一个节点的指针），<u><em>最后一个节点的指针域指向null</em></u>（空指针的意思）。</p>
</blockquote>
<p>链接的入口节点称为链表的头结点也就是head。</p>
<p>如图所示：</p>
<p><img src="/2022/09/28/02/%E9%93%BE%E8%A1%A8.JPG" alt="链表"></p>
<h2 id="链表的几种类型"><a href="#链表的几种类型" class="headerlink" title="链表的几种类型"></a>链表的几种类型</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><blockquote>
<p>如上文所示，就是单链表。</p>
</blockquote>
<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><ul>
<li>单链表中的指针域只能指向节点的下一个节点。</li>
<li>双链表：每一个节点<u>有两个指针域，一个指向下一个节点，一个指向上一个节点</u>。</li>
<li>双链表<mark>既可以向前查询也可以向后查询。</mark></li>
</ul>
<p>如图所示：</p>
<p><img src="/2022/09/28/02/%E5%8F%8C%E9%93%BE%E8%A1%A8.JPG" alt="双链表"></p>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>循环链表，顾名思义，就是链表首尾相连。</p>
<p><strong>循环链表可以用来解决约瑟夫环问题</strong>。</p>
<p><img src="/2022/09/28/02/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.JPG" alt="循环链表"></p>
<h2 id="链表的存储方式"><a href="#链表的存储方式" class="headerlink" title="链表的存储方式"></a>链表的存储方式</h2><ul>
<li>数组是在内存中是连续分布的，但是<strong>链表在内存中可不是连续分布</strong>的。</li>
<li>链表是<em>通过指针域的指针链接在内存中各个节点</em>。</li>
<li>所以链表中的节点在内存中不是连续分布的，而是散乱分布在内存中的某地址上，<em>分配机制取决于操作系统的内存管理</em>。</li>
</ul>
<h2 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h2><p>链表节点的定义，很多同学在面试的时候都写不好。这是因为平时在刷leetcode的时候，链表的节点都默认定义好了，直接用就行了，所以同学们都没有注意到链表的节点是如何定义的。</p>
<p>而在面试的时候，一旦要自己手写链表，就写的错漏百出。</p>
<p>给出C&#x2F;C++的定义链表节点方式，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;  <span class="comment">// 节点上存储的元素</span></span><br><span class="line">    ListNode *next;  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;  <span class="comment">// 节点的构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不定义构造函数行不行? —&gt; 答案是可以的，C++默认生成一个构造函数。</p>
<p>但是<strong>这个构造函数不会初始化任何成员变量</strong>，下面举两个例子：</p>
</blockquote>
<p>通过自己定义构造函数初始化节点：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>使用默认构造函数初始化节点：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">head-&gt;val = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p><strong>所以如果不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值！</strong></p>
<h2 id="链表的操作"><a href="#链表的操作" class="headerlink" title="链表的操作"></a>链表的操作</h2><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>删除D节点，如图所示：</p>
<p><img src="/2022/09/28/02/%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9.JPG" alt="删除节点"></p>
<ul>
<li><mark><strong>只要将C节点的next指针，指向E节点就可以了。</strong></mark></li>
<li>那么，D节点不是依然存留在内存里么？只不过是没有在这个链表里而已。</li>
<li>是这样的，在C++里最好是再手动释放这个D节点，释放这块内存。其他语言例如Java、Python，就有自己的内存回收机制，就不用自己手动释放了。</li>
</ul>
<h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><p><img src="/2022/09/28/02/%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9.JPG" alt="添加节点"></p>
<ul>
<li>链表的<mark><strong>增添和删除都是O(1)操作</strong></mark>，也不会影响到其他节点。</li>
<li>但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作， <strong>查找的时间复杂度是O(n)。</strong></li>
</ul>
<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p><strong>链表和数组的特性对比：</strong></p>
<p><img src="/2022/09/28/02/%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94.JPG" alt="性能对比"></p>
<p>另：</p>
<p>python的链表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>Leetcode</tag>
        <tag>代码随想录</tag>
        <tag>理论基础</tag>
      </tags>
  </entry>
  <entry>
    <title>链表01--移除链表元素</title>
    <url>/2022/09/29/03/</url>
    <content><![CDATA[<h2 id="203-Remove-Linked-List-Elements"><a href="#203-Remove-Linked-List-Elements" class="headerlink" title="203 Remove Linked List Elements"></a>203 Remove Linked List Elements</h2><blockquote>
<p>Given the <code>head</code> of a linked list and an integer <code>val</code>, remove all the nodes of the linked list that has <code>Node.val == val</code>, and return the new <code>head</code>.</p>
</blockquote>
<blockquote>
<p>示例1：</p>
<p>输入：head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6</p>
<p>输出：[1,2,3,4,5]</p>
<p>示例2：</p>
<p>输入：head &#x3D; [], val &#x3D; 1</p>
<p>输出：[]</p>
<p>示例3：</p>
<p>输入：head &#x3D; [7,7,7,7], val &#x3D; 7</p>
<p>输出：[]</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><img src="/2022/09/29/03/%E6%80%9D%E8%B7%AF.JPG" alt="思路"></p>
<p>然后，对于C、CPP，要注意从内存中删除不要的节点，清理内存之后：</p>
<p><img src="/2022/09/29/03/%E6%80%9D%E8%B7%AF2.JPG" alt="思路2"></p>
<p>上面的移除操作，就是让节点next指针直接指向下下一个节点。</p>
<p>那么因为单链表的特殊性，只能指向下一个节点，刚刚删除的是链表的中第二个，和第四个节点，那么如果删除的是头结点又该怎么办呢？</p>
<p>这里就涉及如下链表操作的两种方式：</p>
<ul>
<li>直接使用原来的链表来进行删除操作。</li>
<li>设置一个虚拟头结点在进行删除操作。</li>
</ul>
<h3 id="直接使用原来的链表来进行移除"><a href="#直接使用原来的链表来进行移除" class="headerlink" title="直接使用原来的链表来进行移除"></a>直接使用原来的链表来进行移除</h3><p>如果要移除非头节点，需要next指针指向下一个节点，但是，<strong>当需要移除头节点时，因为没有更前面的节点，所以操作发生了变化！</strong></p>
<p>移除头节点的操作，只需要<strong>head后移一位</strong>；</p>
<p><u>但是会导致代码逻辑更复杂！</u></p>
<h3 id="设置一个虚拟头结点在进行删除操作"><a href="#设置一个虚拟头结点在进行删除操作" class="headerlink" title="设置一个虚拟头结点在进行删除操作"></a>设置一个虚拟头结点在进行删除操作</h3><p><mark>设置一个虚拟头结点，原链表的所有节点就都可以按照统一的方式进行移除了。</mark></p>
<p>来看看如何设置一个虚拟头。依然还是在这个链表中，移除元素1。</p>
<p><img src="/2022/09/29/03/dummy.JPG" alt="dummy"></p>
<p>最后，return头结点的时候，别忘了 <mark>return dummyNode-&gt;next;</mark>， 这才是新的头结点。</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="使用原来的链表"><a href="#使用原来的链表" class="headerlink" title="使用原来的链表"></a>使用原来的链表</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 删除头结点</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">NULL</span> &amp;&amp; head-&gt;val == val) &#123; <span class="comment">// 注意这里不是if</span></span><br><span class="line">            ListNode* tmp = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除非头结点</span></span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> &amp;&amp; cur-&gt;next!= <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                ListNode* tmp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="设置虚拟头节点"><a href="#设置虚拟头节点" class="headerlink" title="设置虚拟头节点"></a>设置虚拟头节点</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>); <span class="comment">// 设置一个虚拟头结点</span></span><br><span class="line">        dummyHead-&gt;next = head; <span class="comment">// 将虚拟头结点指向head，这样方面后面做删除操作</span></span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                ListNode* tmp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再来个C语言版本比较一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeElements</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">ListNode</span>;</span></span><br><span class="line">    ListNode *shead;</span><br><span class="line">    shead = (ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">    shead-&gt;next = head;</span><br><span class="line">    ListNode *cur = shead;</span><br><span class="line">    <span class="keyword">while</span>(cur-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;next-&gt;val == val)&#123;</span><br><span class="line">            ListNode *tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    head = shead-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(shead);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>Leetcode</tag>
        <tag>代码随想录</tag>
        <tag>移除链表元素</tag>
      </tags>
  </entry>
</search>
