<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><title>分类: 嵌入式 - DustOfStars</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#f7f7f7"><meta name="application-name" content="DustOfStars"><meta name="msapplication-TileImage" content="/img/favicon.png"><meta name="msapplication-TileColor" content="#f7f7f7"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="DustOfStars"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Go ahead, and believe in yourself."><meta property="og:type" content="blog"><meta property="og:title" content="DustOfStars"><meta property="og:url" content="https://dustofstars.github.io/"><meta property="og:site_name" content="DustOfStars"><meta property="og:description" content="Go ahead, and believe in yourself."><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://dustofstars.github.io/img/og_image.png"><meta property="article:author" content="Gavin"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://dustofstars.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://dustofstars.github.io"},"headline":"DustOfStars","image":["https://dustofstars.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Gavin"},"publisher":{"@type":"Organization","name":"DustOfStars","logo":{"@type":"ImageObject","url":"https://dustofstars.github.io/img/logo.png"}},"description":"Go ahead, and believe in yourself."}</script><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-72437521-5" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-72437521-5');</script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0">
<style>.not-gallery-item { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .not-gallery-item > span { position: relative; z-index: 10; }  .not-gallery-item img, .not-gallery-item .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .not-gallery-item img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .not-gallery-item-fallback { color: inherit; } .not-gallery-item-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="DustOfStars" type="application/atom+xml">
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="DustOfStars" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Discuss on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus/discussions"><i class="fas fa-comments"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">嵌入式</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-03-29T07:52:43.000Z" title="3/29/2023, 7:52:43 AM">2023-03-29</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><span> / </span><a class="link-muted" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/">代码解读</a><span> / </span><a class="link-muted" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/%E4%B8%AD%E6%96%AD/">中断</a></span><span class="level-item">4 分钟读完 (大约584个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/%E4%B8%AD%E6%96%AD/kw38%E7%82%B9%E7%81%AF%E5%A4%A7%E5%B8%882-gpio%E4%B8%AD%E6%96%AD/">kw38点灯大师2_GPIO中断</a></p><div class="content"><h1 id="kw38点灯大师2-GPIO中断"><a href="#kw38点灯大师2-GPIO中断" class="headerlink" title="kw38点灯大师2_GPIO中断"></a>kw38点灯大师2_GPIO中断</h1><blockquote>
<p>frdmkw38_gpio_led_output   工程
frdmkw38_gpio_input_interrupt   工程</p>
</blockquote>
<p><img src="/./kw38%E7%82%B9%E7%81%AF%E5%A4%A7%E5%B8%882/gpio%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6LED.gif" alt="light"></p>
<h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* Define the init structure for the output LED pin*/</span></span><br><span class="line">    <span class="type">gpio_pin_config_t</span> led_config = {</span><br><span class="line">        kGPIO_DigitalOutput,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Define the init structure for the input switch pin */</span></span><br><span class="line">    <span class="type">gpio_pin_config_t</span> sw_config = {</span><br><span class="line">        kGPIO_DigitalInput,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Board pin, clock, debug console init */</span></span><br><span class="line">    BOARD_InitPins();</span><br><span class="line">    BOARD_BootClockRUN();</span><br><span class="line">    BOARD_InitDebugConsole();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Print a note to terminal. */</span></span><br><span class="line">    PRINTF(<span class="string">"\r\n GPIO Driver example\r\n"</span>);</span><br><span class="line">    PRINTF(<span class="string">"\r\n The LED is blinking.\r\n"</span>);</span><br><span class="line">    PRINTF(<span class="string">"\r\n 按压开关 %s 来开关和切换LED.\r\n"</span>, BOARD_SW_NAME);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Init input switch GPIO. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (defined(FSL_FEATURE_PORT_HAS_NO_INTERRUPT) &amp;&amp; FSL_FEATURE_PORT_HAS_NO_INTERRUPT)</span></span><br><span class="line">    GPIO_SetPinInterruptConfig(BOARD_SW2_GPIO, BOARD_SW2_GPIO_PIN, kGPIO_InterruptFallingEdge);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    PORT_SetPinInterruptConfig(BOARD_SW2_PORT, BOARD_SW2_GPIO_PIN, kPORT_InterruptFallingEdge);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    EnableIRQ(BOARD_SW2_IRQ);</span><br><span class="line">    GPIO_PinInit(BOARD_SW2_GPIO, BOARD_SW2_GPIO_PIN, &amp;sw_config);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Init output LED GPIO. */</span></span><br><span class="line">    GPIO_PinInit(BOARD_LED_GPIO0, BOARD_LED_GPIO_PIN0, &amp;led_config);</span><br><span class="line">    GPIO_PinInit(BOARD_LED_GPIO1, BOARD_LED_GPIO_PIN1, &amp;led_config);</span><br><span class="line">    GPIO_PinInit(BOARD_LED_GPIO2, BOARD_LED_GPIO_PIN2, &amp;led_config);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (g_ButtonPress)</span><br><span class="line">        {</span><br><span class="line">            temp ++;</span><br><span class="line">            PRINTF(<span class="string">" %s is pressed, it is time: %d \r\n"</span>, BOARD_SW_NAME, temp);</span><br><span class="line">            <span class="keyword">switch</span>(temp%<span class="number">3</span>)</span><br><span class="line">            {</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                PRINTF(<span class="string">" case 0, BLUE LED ON"</span>);</span><br><span class="line">                LED_RED_OFF();</span><br><span class="line">                LED_GREEN_OFF();</span><br><span class="line">                LED_BLUE_ON();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                PRINTF(<span class="string">" case 1, GREEN LED ON"</span>);</span><br><span class="line">                LED_RED_OFF();</span><br><span class="line">                LED_GREEN_ON();</span><br><span class="line">                LED_BLUE_OFF();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                PRINTF(<span class="string">" case 2, RED LED ON"</span>);</span><br><span class="line">                LED_RED_ON();</span><br><span class="line">                LED_GREEN_OFF();</span><br><span class="line">                LED_BLUE_OFF();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"><span class="comment">//            /* Toggle LED. */</span></span><br><span class="line"><span class="comment">//            GPIO_PortToggle(BOARD_LED_GPIO, 1U &lt;&lt; BOARD_LED_GPIO_PIN);</span></span><br><span class="line"><span class="comment">//            /* Reset state of button. */</span></span><br><span class="line">            g_ButtonPress = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h2 id="中断处理函数"><a href="#中断处理函数" class="headerlink" title="中断处理函数"></a>中断处理函数</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BOARD_SW2_IRQ_HANDLER</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* Clear external interrupt flag. */</span></span><br><span class="line">    GPIO_PortClearInterruptFlags(BOARD_SW2_GPIO, <span class="number">1U</span> &lt;&lt; BOARD_SW2_GPIO_PIN);</span><br><span class="line">    <span class="comment">/* Change state of button. */</span></span><br><span class="line">    g_ButtonPress = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">/* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping</span></span><br><span class="line"><span class="comment">  exception return operation might vector to incorrect interrupt */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined __CORTEX_M &amp;&amp; (__CORTEX_M == 4U)</span></span><br><span class="line">    __DSB();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="预定义"><a href="#预定义" class="headerlink" title="预定义"></a>预定义</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BOARD_LED_GPIO0 BOARD_LED_RED_GPIO</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOARD_LED_GPIO_PIN0 BOARD_LED_RED_GPIO_PIN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOARD_LED_GPIO1 BOARD_LED_GREEN_GPIO</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOARD_LED_GPIO_PIN1 BOARD_LED_GREEN_GPIO_PIN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOARD_LED_GPIO2 BOARD_LED_BLUE_GPIO</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOARD_LED_GPIO_PIN2 BOARD_LED_BLUE_GPIO_PIN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOARD_SW_NAME BOARD_SW2_NAME</span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="总结GPIO中断的流程"><a href="#总结GPIO中断的流程" class="headerlink" title="总结GPIO中断的流程"></a>总结GPIO中断的流程</h1><ol>
<li>变量flag <code>volatile bool g_ButtonPress = false;</code>  指示是否按下开关</li>
<li>中断处理函数 <code>void BOARD_SW2_IRQ_HANDLER()</code><ol>
<li>先清空外部中断，<code>GPIO_PortClearInterruptFlags(BOARD_SW2_GPIO, 1U &lt;&lt; BOARD_SW2_GPIO_PIN);</code></li>
<li>再对flag置一，表示中断已经发生；</li>
<li>之后，它会进入到main的while循环里面的<code>if(g_ButtonPress)</code>;</li>
</ol>
</li>
<li>main函数里面初始化板子之后，要初始化SW的GPIO；<ol>
<li>中断config设置  <code>GPIO_SetPinInterruptConfig(BOARD_SW2_GPIO, BOARD_SW2_GPIO_PIN, kGPIO_InterruptFallingEdge);</code>;</li>
<li>GPIO_PinInit   <code>GPIO_PinInit(BOARD_SW2_GPIO, BOARD_SW2_GPIO_PIN, &amp;sw_config);</code></li>
</ol>
</li>
<li>然后 <code>EnableIRQ(BOARD_SW2_IRQ);</code></li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-03-24T04:01:45.000Z" title="3/24/2023, 4:01:45 AM">2023-03-24</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><span> / </span><a class="link-muted" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/">代码解读</a></span><span class="level-item">17 分钟读完 (大约2555个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/kw38-helloworld/">kw38_helloworld</a></p><div class="content"><h1 id="kw38-helloworld"><a href="#kw38-helloworld" class="headerlink" title="kw38_helloworld"></a>kw38_helloworld</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Init board hardware. */</span></span><br><span class="line">    BOARD_InitPins();</span><br><span class="line">    BOARD_BootClockRUN();</span><br><span class="line">    BOARD_InitDebugConsole();</span><br><span class="line"></span><br><span class="line">    PRINTF(<span class="string">"hello world.\r\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        ch = GETCHAR();</span><br><span class="line">        PUTCHAR(ch);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="main功能"><a href="#main功能" class="headerlink" title="main功能"></a>main功能</h2><p>这段代码是一个简单的hello world程序，它的作用是在终端输出”hello world.”，并且可以接收终端输入的字符并将其输出。</p>
<p>在main函数中，首先调用了BOARD_InitPins()函数来初始化板子的引脚，然后调用了BOARD_BootClockRUN()函数来初始化时钟，最后调用了BOARD_InitDebugConsole()函数来初始化调试控制台。</p>
<p>接下来，使用PRINTF函数在终端输出”hello world.”，然后进入一个死循环，不断地接收终端输入的字符并将其输出，直到程序结束。</p>
<p>其中，GETCHAR函数用于接收终端输入的字符，PUTCHAR函数用于将字符输出到终端。</p>
<h2 id="main的函数调用"><a href="#main的函数调用" class="headerlink" title="main的函数调用"></a>main的函数调用</h2><p>这段代码调用了三个函数，分别是BOARD_InitPins()、BOARD_BootClockRUN()和BOARD_InitDebugConsole()。</p>
<ul>
<li>BOARD_InitPins()函数用于初始化板子的引脚，</li>
<li>BOARD_BootClockRUN()函数用于初始化时钟，</li>
<li>BOARD_InitDebugConsole()函数用于初始化调试控制台。</li>
</ul>
<p>在这个程序中，这三个函数的作用是为了确保程序能够正常运行，因为程序需要使用板子的引脚、时钟和调试控制台。</p>
<h2 id="main的包含头文件"><a href="#main的包含头文件" class="headerlink" title="main的包含头文件"></a>main的包含头文件</h2><p>这段代码include了以下几个文件：</p>
<ul>
<li>fsl_device_registers.h：包含了芯片的寄存器定义，用于访问芯片的寄存器。</li>
<li>fsl_debug_console.h：包含了调试控制台的相关函数，用于在终端输出和输入字符。</li>
<li>board.h：包含了板子的相关函数和宏定义，用于初始化板子的引脚和时钟。</li>
<li>pin_mux.h：包含了引脚的配置信息，用于初始化板子的引脚。</li>
<li>stdbool.h：包含了bool类型的定义，用于定义布尔类型的变量。</li>
<li>clock_config.h：包含了时钟的配置信息，用于初始化时钟。</li>
</ul>
<p>其中，fsl_device_registers.h、fsl_debug_console.h、board.h和pin_mux.h是MCUXpresso SDK提供的库文件，而stdbool.h和clock_config.h是标准C库文件。这些文件的作用是为了确保程序能够正常运行，因为程序需要使用芯片的寄存器、调试控制台、板子的引脚和时钟。</p>
<h2 id="pin-mux-h"><a href="#pin-mux-h" class="headerlink" title="pin_mux.h"></a>pin_mux.h</h2><p>这是一个头文件，用于使用 MCUXpresso 配置工具为微控制器配置引脚复用和电气特性。</p>
<p>它提供了一个函数来初始化微控制器使用的引脚，可以在启动期间调用。 该文件定义了用于配置引脚电气特性的宏常量 <code>SOPT5_LPUART0ODE_0b0</code>、<code>SOPT5_LPUART0RXSRC_0b0</code> 和 <code>SOPT5_LPUART0TXSRC_0b00</code>。 </p>
<p>头文件由包含保护 (<code>#ifndef _PIN_MUX_H_</code>) 保护，确保它在编译单元中仅包含一次。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SOPT5_LPUART0ODE_0b0 0x00u    <span class="comment">/*LPUART0开漏禁用*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOPT5_LPUART0RXSRC_0b0 0x00u  <span class="comment">/*LPUART0接收数据源选择：LPUART_RX pin */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOPT5_LPUART0TXSRC_0b00 0x00u <span class="comment">/*LPUART0发送数据源选择：LPUART_TX pin */</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>声明了两个函数：</p>
<ul>
<li>void BOARD_InitPins(void);  配置引脚routing和可选引脚电气特性</li>
<li>void BOARD_InitBootPins(void);  初始化启动引脚；</li>
</ul>
<h2 id="pin-mux-c"><a href="#pin-mux-c" class="headerlink" title="pin_mux.c"></a>pin_mux.c</h2><h3 id="void-BOARD-IninPins-void"><a href="#void-BOARD-IninPins-void" class="headerlink" title="void BOARD_IninPins(void)"></a>void BOARD_IninPins(void)</h3><p>这段代码是来自项目中的“pin_mux.c”文件，该文件包含了MKW38A512微控制器的引脚配置函数。</p>
<p>所选代码块是函数“BOARD_InitPins()”，它配置了LPUART0外设的引脚路由和电气特性。</p>
<p>具体来说，它将</p>
<ol>
<li>使能PortC的时钟；</li>
<li>42号和43号引脚的引脚复用设置为LPUART0_RX和LPUART0_TX。</li>
<li>将LPUART0传输数据源设置为LPUART0_TX引脚，将LPUART0接收数据源设置为LPUART_RX引脚，并在LPUART0上禁用了开漏特性。</li>
</ol>
<p>该函数由“BOARD_InitBootPins()”调用，在引导过程中调用以初始化引脚。</p>
<h2 id="clock-config-c"><a href="#clock-config-c" class="headerlink" title="clock_config.c"></a>clock_config.c</h2><h3 id="void-BOARD-BootClockRUN-void"><a href="#void-BOARD-BootClockRUN-void" class="headerlink" title="void BOARD_BootClockRUN(void)"></a>void BOARD_BootClockRUN(void)</h3><p>这段代码是MKW38A512芯片的时钟配置代码，主要包括两个函数：BOARD_BootClockRUN和BOARD_BootClockVLPR。</p>
<p>这两个函数分别用于配置系统在RUN模式和VLPR模式下的时钟。在这两个函数中，主要使用了MCUXpresso Config Tools提供的时钟驱动函数来配置系统时钟。具体来说，这两个函数的主要步骤如下：</p>
<ol>
<li>BOARD_RfOscInit函数：<strong>初始化射频晶振，用于提供系统时钟的参考时钟</strong>。</li>
<li>CLOCK_SetSimSafeDivs函数：设置<strong>系统时钟分频器的初始值</strong>，以确保在时钟模式切换时，核心时钟、总线时钟、flexbus时钟和flash时钟都在允许的范围内。</li>
<li>BOARD_InitOsc0函数：初始化MCG OSC，用于提供系统时钟的参考时钟。</li>
<li>CLOCK_BootToFeeMode函数：<strong>将MCG模式设置为FEE模式</strong>，即FLL Engaged External模式，此时FLL时钟和外部参考时钟都被使能。</li>
<li>CLOCK_SetInternalRefClkConfig函数：配置<strong>内部参考时钟MCGIRCLK</strong>。</li>
<li>CLOCK_SetSimConfig函数：设置<strong>SIM模块的时钟配置</strong>。</li>
<li>SystemCoreClock变量：设置当前系统核心时钟的频率。</li>
</ol>
<p>其中，BOARD_BootClockRUN函数用于配置系统在RUN模式下的时钟，而BOARD_BootClockVLPR函数用于配置系统在VLPR模式下的时钟。</p>
<p>在这两个函数中，<strong>主要的区别在于MCG模式的设置不同，以及时钟分频器的设置不同</strong>。</p>
<ul>
<li>在RUN模式下，MCG模式被设置为<strong>FEE</strong>模式，时钟分频器的初始值为1，2，2，5，</li>
<li>而在VLPR模式下，MCG模式被设置为<strong>BLPI</strong>模式，时钟分频器的初始值为1，5，1，</li>
</ul>
<h2 id="board-c"><a href="#board-c" class="headerlink" title="board.c"></a>board.c</h2><h3 id="void-BOARD-InitDebugConsole-void"><a href="#void-BOARD-InitDebugConsole-void" class="headerlink" title="void BOARD_InitDebugConsole(void)"></a>void BOARD_InitDebugConsole(void)</h3><p>这段代码是初始化调试控制台的函数。在这个函数中，首先设置了<strong>LPUART0的时钟源为OSCERCLK</strong>，然后初始化了调试控制台。</p>
<p>调试控制台的初始化使用了MCUXpresso SDK提供的DbgConsole_Init函数，该函数需要传入调试控制台的实例、波特率、类型和时钟源频率等参数。在这个函数中，调试控制台的实例为BOARD_DEBUG_UART_INSTANCE，波特率为BOARD_DEBUG_UART_BAUDRATE，类型为BOARD_DEBUG_UART_TYPE，时钟源频率为uartClkSrcFreq。</p>
<h2 id="fsl-debug-console-c"><a href="#fsl-debug-console-c" class="headerlink" title="fsl_debug_console.c"></a>fsl_debug_console.c</h2><h3 id="int-DbgConsole-Printf-const-char-formatString-…"><a href="#int-DbgConsole-Printf-const-char-formatString-…" class="headerlink" title="int DbgConsole_Printf(const char *formatString, …)"></a>int DbgConsole_Printf(const char *formatString, …)</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* See fsl_debug_console.h for documentation of this function. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">DbgConsole_Printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *formatString, ...)</span></span><br><span class="line">{</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="type">int</span> logLength = <span class="number">0</span>, dbgResult = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> printBuf[DEBUG_CONSOLE_PRINTF_MAX_LOG_LEN] = {<span class="string">'\0'</span>};</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != g_serialHandle)</span><br><span class="line">    {</span><br><span class="line">        va_start(ap, formatString);</span><br><span class="line">        <span class="comment">/* format print log first */</span></span><br><span class="line">        logLength = StrFormatPrintf(formatString, ap, printBuf, DbgConsole_PrintCallback);</span><br><span class="line">        <span class="comment">/* print log */</span></span><br><span class="line">        dbgResult = DbgConsole_SendDataReliable((<span class="type">uint8_t</span> *)printBuf, (<span class="type">size_t</span>)logLength);</span><br><span class="line"></span><br><span class="line">        va_end(ap);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dbgResult;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这段代码是fsl_debug_console.c文件的一部分。该文件包含了调试控制台模块的实现。调试控制台模块提供了一组函数来初始化、去初始化、打印和从调试控制台读取数据。</p>
<p>所选代码是DbgConsole_Printf函数的实现。该函数用于将格式化数据打印到调试控制台。</p>
<blockquote>
<p>该函数接受<strong>一个格式字符串</strong>和<strong>一个可变数量的参数</strong>。格式字符串指定输出字符串的格式，参数是要格式化和打印的值。</p>
</blockquote>
<p>该函数首先使用StrFormatPrintf函数格式化输出字符串。该函数将格式字符串、可变参数和回调函数作为输入。<strong>回调函数用于输出格式化数据</strong>。在这种情况下，回调函数是DbgConsole_PrintCallback。</p>
<p>格式化输出字符串后，该函数使用DbgConsole_SendDataReliable函数将数据发送到调试控制台。该函数可靠地发送数据，这意味着它将重试发送数据，直到成功发送为止。</p>
<p>后缀代码包含了DbgConsole_Putchar和DbgConsole_Scanf函数的实现。DbgConsole_Putchar函数用于<strong>将单个字符打印到调试控制台</strong>。该函数只需调用DbgConsole_SendDataReliable函数并传递要打印的字符即可。</p>
<p>DbgConsole_Scanf函数用于从调试控制台读取格式化数据。该函数接受一个格式字符串和一个可变数量的参数。格式字符串指定输入数据的格式，参数是指向存储输入数据的变量的指针。</p>
<p>该函数首先使用DbgConsole_ReadLine<strong>函数读取一行输入</strong>。然后使用StrFormatScanf函数格式化输入数据，并将格式化数据存储在由参数指向的变量中。</p>
<p>总的来说，这些函数提供了一种方便的方式来与调试控制台交互，并打印和读取格式化数据。</p>
<h2 id="关于引脚的四种输出情况"><a href="#关于引脚的四种输出情况" class="headerlink" title="关于引脚的四种输出情况"></a>关于引脚的四种输出情况</h2><p>上拉 (Pull-up) 和下拉 (Pull-down) 是指在数字电路中使用电阻将输入或输出引脚连接到电源或地，以确保在没有输入信号的情况下，引脚保持在一个已知状态。具体来说，上拉是指将引脚连接到电源（通常是高电平），下拉是指将引脚连接到地（通常是低电平）。在某些情况下，还可以使用弱上拉或弱下拉，即使用较大阻值的电阻。</p>
<p>开漏 (Open-Drain) 和推挽 (Push-Pull) 是指输出引脚的驱动方式。<strong>开漏输出只能将引脚拉到低电平，而不能将其拉到高电平，而推挽输出可以将引脚驱动到高电平或低电平。</strong>在使用开漏输出时，还需要在输出引脚和电源之间连接一个上拉电阻，以确保输出引脚能够被拉到高电平。</p>
<p>开漏输出通常用于需要将多个设备连接到同一个总线上的情况，而推挽输出则更适用于需要直接驱动其他器件的情况。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-03-21T08:47:42.000Z" title="3/21/2023, 8:47:42 AM">2023-03-21</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><span> / </span><a class="link-muted" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/">代码解读</a></span><span class="level-item">17 分钟读完 (大约2570个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%B5%8C%E5%85%A5%E5%BC%8Fcommon/">嵌入式common</a></p><div class="content"><h1 id="startup-c是做什么的？"><a href="#startup-c是做什么的？" class="headerlink" title="startup.c是做什么的？"></a>startup.c是做什么的？</h1><p>startup.c通常是指嵌入式系统中的启动代码，它的主要作用是<strong>初始化系统并启动应用程序</strong>。</p>
<p>在启动过程中，会进行一些初始化操作，如设置堆栈、复制数据段、清零BSS段、设置中断向量表等。此外，startup.c还会加载应用程序，将控制转移到应用程序的入口处，开始执行应用程序的功能。</p>
<p>因此，startup.c非常重要，涉及到整个系统的启动和运行。不同的嵌入式平台和芯片厂商会有不同的startup.c代码，但它们的基本逻辑和流程是类似的。</p>
<h1 id="启动文件为什么会比main先启动？"><a href="#启动文件为什么会比main先启动？" class="headerlink" title="启动文件为什么会比main先启动？"></a>启动文件为什么会比main先启动？</h1><p>这个问题总结起来就是CPU启动时根据外部boot引脚状态从(<strong>起始地址+0x4</strong>)地址加载数据，赋值给PC(<strong>执行程序寄存器，r15</strong>)，而编译器将<code>startup.s</code>文件中的<strong>ResetHander函数的地址编译到(起始地址+0x4)内部</strong>，所以startup.s被先调用。</p>
<p>详细的解释需要参考Cortex-M系列的知识，下面来详细说明。首先参考STM32F1x的手册2.4启动配置这句话</p>
<img src="https://pic1.zhimg.com/50/v2-2e5c249ab76e390a9e582c37e4b0aba3_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="1213" data-rawheight="119" class="origin_image zh-lightbox-thumb" width="1213" data-original="https://pic1.zhimg.com/v2-2e5c249ab76e390a9e582c37e4b0aba3_r.jpg?source=1940ef5c">

<p>那么就可以理解从0x04地址执行代码，这是由芯片设计时规定的，至于如何实现就是集成电路相关的知识了，这里不在说明，那么就是第二个问题，ResetHander如何被编译到0x04偏移地址的，这就涉及中断向量表的知识，下面来自于&lt;Cortex-M3权威指南&gt;关于异常的说明章节。</p>
<img src="https://pic1.zhimg.com/50/v2-f20a9e9511c6df3a64db9be45b2a8710_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="1289" data-rawheight="534" data-default-watermark-src="https://pic1.zhimg.com/50/v2-30a6353a8582f2c2b3aa1298f3ac59c3_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="1289" data-original="https://pica.zhimg.com/v2-f20a9e9511c6df3a64db9be45b2a8710_r.jpg?source=1940ef5c">

<p>从上面可以看出，<strong>在0x04偏移地址中定位的就是复位向量</strong>，而在代码startup.s中，就可以看到</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__Vectors       DCD     __initial_sp               ; Top of Stack</span><br><span class="line">                DCD     Reset_Handler              ; Reset Handler</span><br><span class="line">                DCD     NMI_Handler                ; NMI Handler</span><br><span class="line">                ...</span><br><span class="line">__Vectors_End</span><br></pre></td></tr></tbody></table></figure>

<p>也就是说由内核特性和STM芯片的定义，<strong>上电时的入口地址一定是Reset_Handler</strong>，而Reset_Handler就放置在在启动文件startup.s中，这就是启动文件startup.s比main先调用的总的原因.</p>
<p>简略回答： startup比main更先调用，确实和编译器设置有关，但更多的是程序本来如此。</p>
<p>详细回答：背景知识程序的生成步骤一般分成四步 preprocess(.c) -&gt; compile(.S) -&gt; assemble (.o) -&gt; link，具体可阅读 The Four Stages of Compiling a C Program 。</p>
<p>Linker Script的基本知识： Simple Linker Script Example具体例子下面的截图是Atmel SAMD10D14AM的souce code，第一张是 Linker Script (samd10d14am_flash.ld)，第二张是 Startup file (startup_samd10.c)。接下来解释highlight部分的含义。</p>
<img src="https://picx.zhimg.com/50/v2-52138c1fa6536fabc081b364d8044619_720w.jpg?source=1940ef5c" data-size="normal" data-rawwidth="868" data-rawheight="477" data-default-watermark-src="https://pica.zhimg.com/50/v2-4afd7ce25c84fe1b9b95b959264292aa_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="868" data-original="https://pic1.zhimg.com/v2-52138c1fa6536fabc081b364d8044619_r.jpg?source=1940ef5c">
Linker Script

<img src="https://pic1.zhimg.com/50/v2-a571c5379d301d831a96446f8c56c10a_720w.jpg?source=1940ef5c" data-size="normal" data-rawwidth="790" data-rawheight="482" data-default-watermark-src="https://picx.zhimg.com/50/v2-4a734839eec7f0c9f8fb2cebee129d8e_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="790" data-original="https://picx.zhimg.com/v2-a571c5379d301d831a96446f8c56c10a_r.jpg?source=1940ef5c">
Vector Table

<p>Vectors就是所谓Exception Table。对于ARM处理器Cortex M系列，<strong>Table的第一条是Stack Pointer的地址，第二条就是最重要的ISR for reset的地址</strong>。</p>
<p>左边的Linker Script指定把 section(“.vector”) 放在生成程序的.text代码段，一般也就是flash的起始地址。从keyword MEMORY的定义来看，flash rom的起始地址是0x00000000，大小是0x00000800 (16K)，刚好符合官方文档的描述 <a target="_blank" rel="noopener" href="https://web.eecs.umich.edu/~prabal/teaching/resources/eecs373/ARM_Cortex_AppNote179.pdf">https://web.eecs.umich.edu/~prabal/teaching/resources/eecs373/ARM_Cortex_AppNote179.pdf</a> </p>
<blockquote>
<p>1.1 Nested Vectored Interrupt Controller (NVIC)The initial stack pointer and the address of the reset handler must be located at 0x0 and 0x4 respectively. These values are then loaded into the appropriate CPU registers at reset.</p>
</blockquote>
<p><em><strong>Reset_Handler()这个ISR就是CPU power on或者reset后的第一个routine，里面会先做一些简单初始化，比如Intialize the C libray（这样我们才能在后头的代码里直接用strcpy()等常见函数），最后跳往我们最熟悉的main()。</strong></em></p>
<p>其余的ISR都是optional，可以留白，会自动被Dummy_Handler填充，因为keyword weak。结论启动文件startup比main()先启动，是因为程序的启动顺序就是这样的，**CPU power on / reset -&gt; Reset_Handler() -&gt; main()**。</p>
<h1 id="BSS段是做什么的？"><a href="#BSS段是做什么的？" class="headerlink" title="BSS段是做什么的？"></a>BSS段是做什么的？</h1><p>BSS段（Block Started by Symbol）是指<strong>程序中未被初始化的全局变量和静态变量所占用的一段内存空间</strong>。在程序加载运行时，操作系统会自动分配一块内存空间用于存放BSS段。</p>
<p><strong>BSS段中的变量被默认初始化为0</strong>，因此，在程序编写中不需要为它们显式地赋初值。BSS段对于节省内存空间和程序运行效率都有很大的帮助。这是因为，程序中的未初始化变量会在BSS段中被统一地设置为0，而不需要在程序中存储这些变量的具体值。这样，在程序执行过程中，<strong>BSS段所占空间可以被多次重用并动态分配，从而使得程序的内存利用率更高</strong>。</p>
<h1 id="RAM中的各个段"><a href="#RAM中的各个段" class="headerlink" title="RAM中的各个段"></a>RAM中的各个段</h1><h2 id="RAM内存"><a href="#RAM内存" class="headerlink" title="RAM内存"></a>RAM内存</h2><p>RAM内存包括：</p>
<ul>
<li>代码段（text）</li>
<li>数据段(data)</li>
<li>bss段</li>
<li>堆栈段（head stack）</li>
</ul>
<p><img src="/./%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9A%84common%E7%9F%A5%E8%AF%86/RAM%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.png" alt="RAM内存分区.png"></p>
<h2 id="编译器编译结果分析"><a href="#编译器编译结果分析" class="headerlink" title="编译器编译结果分析"></a>编译器编译结果分析</h2><p><img src="/./%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9A%84common%E7%9F%A5%E8%AF%86/%E7%BC%96%E8%AF%91%E7%BB%93%E6%9E%9C.png" alt="编译结果.png"></p>
<p>编译结果有代码段（text）、数据段(data)、bss段。</p>
<ul>
<li>代码段（.text）是可<strong>执行指令的集合</strong>；</li>
<li>数据段 (.data) 表示<strong>已经初始化不为0的存放在静态区的数据（全局 or 静态）</strong>。</li>
<li>.bss段 表示未初始化的或为0的存放在静态区的数据（全局 or 静态）。</li>
</ul>
<p>从可执行程序的角度来说，如果一个数据未被初始化，就不需要为其分配空间，所以.data 和.bss 的区别就是： <strong>.bss 并不占用可执行文件的大小，仅仅记录需要用多少空间来存储这些未初始化的数据，而不分配实际空间</strong>。</p>
<p>所以代码段（text）、数据段(data)这两者相加共同构成可执行文件的大小，dec也就是文件大小(hex也是文件大小，只不过是16进制表示的)。</p>
<h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><h3 id="堆-heap"><a href="#堆-heap" class="headerlink" title="堆 heap"></a>堆 heap</h3><p><strong>堆保存函数内部动态分配（malloc 或 new）的内存，是另外一种用来保存程序信息的数据结构。</strong>
堆是先进先出（FIFO）数据结构。堆的地址空间是向上增加，即当堆上保存的数据越多，堆的地址越高。动态内存分配。
注意：<strong>堆内存需要程序员手动管理内存，通常适用于较大的内存分配，如频繁的分配较小的内存，容易导致内存碎片化</strong>。</p>
<h3 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈 stack"></a>栈 stack</h3><p><strong>栈保存函数的局部变量（不包括 static 修饰的变量），参数以及返回值</strong>。是一种后进先出（LIFO）的数据结构。
在调用函数或过程后，系统会清除栈上保存的局部变量、函数调用信息及其他信息。
栈的另外一个重要特征是，它的地址空间 向下减少，即当栈上保存的数据越多，栈的地址越低。<strong>静态内存分配</strong>。</p>
<blockquote>
<p><em><strong>注意：由于栈的空间通常比较小，一般 linux 程序只有几 M，故局部变量，函数入参应该避免出现超大栈内存使用，比如超大结构体，数组等，避免出现 stack overflow。</strong></em></p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th>段名</th>
<th>存储属性</th>
<th>内存分配</th>
</tr>
</thead>
<tbody><tr>
<td>代码段<br>.text</td>
<td>存放可执行程序的指令，存储态和运行态都有</td>
<td>静态</td>
</tr>
<tr>
<td>数据段<br>.data</td>
<td>存放已初始化（非零初始化的全局变量和静态局部变量）的数据，存储态和运行态都有</td>
<td>静态</td>
</tr>
<tr>
<td>bss段<br>.bss</td>
<td>存放未初始化（未初始化或者0初始化的全局变量和静态局部变量）的数据，存储态和运行态都有</td>
<td>静态</td>
</tr>
<tr>
<td>堆<br>heap</td>
<td>动态分配内存，需要通过malloc手动申请，free手动释放，适合大块内存。容易造成内存泄漏和内存碎片。运行态才有</td>
<td>动态</td>
</tr>
<tr>
<td>栈<br>stack</td>
<td>存放函数局部变量和参数以及返回值，函数返回后，由操作系统立即回收。栈空间不大，使用不当容易栈溢出。运行态才有</td>
<td>静态</td>
</tr>
</tbody></table>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;<span class="comment">//初始化的全局变量:保存在数据段</span></span><br><span class="line"><span class="type">char</span> *p1;<span class="comment">//未初始化的全局变量:保存在BSS段</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> b;<span class="comment">//未初始化的局部变量:保存在栈上</span></span><br><span class="line">    <span class="type">char</span> s[] = <span class="string">"abc"</span>;</span><br><span class="line">    <span class="comment">/* "abc"为字符串常量保存在常量区；数组保存在栈上，</span></span><br><span class="line"><span class="comment">    并将常量区的"abc\0"复制到该数组中。这个数组可以随意修改而不会有任何隐患，</span></span><br><span class="line"><span class="comment">    而"123"这个字符串依然会保留在静态区中。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">char</span> *p2;<span class="comment">//p2保存在栈上</span></span><br><span class="line">    <span class="type">char</span> *p3 = <span class="string">"123456"</span>;<span class="comment">//p3保存在栈上，"123456\0"保存在data区的read-only部分</span></span><br><span class="line">    <span class="comment">//注意：如果令p3[1] = 9; 则程序崩溃，指针可以访问但不允许改变常量区的内容</span></span><br><span class="line">    <span class="comment">/* 声明了一个指针p3并指向"123456\0"在静态区中的地址，事实上，p3应该声明为</span></span><br><span class="line"><span class="comment">    char const *，以免可以通过p3[i]='\n'这一类的语法去修改这个字符串的内容。如果这样做了，在支持“常量区”的系统中可能会导致异常，在“合并相同字符串”的编译方法下会导致其它地方的字符串常量古怪地发生变化。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> c = <span class="number">0</span>;<span class="comment">//初始化的静态局部变量:保存在数据区（数据段）</span></span><br><span class="line"> </span><br><span class="line">    p1 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">10</span>);<span class="comment">//分配的10字节区域保存在堆上</span></span><br><span class="line">    p2 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">20</span>);<span class="comment">//分配的20字节区域保存在堆上</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">strcpy</span>(p1, <span class="string">"123456"</span>);</span><br><span class="line">    <span class="comment">//"123456\0"放在常量区，编译器可能会将它与p3所指向"123456"优化成一个地方</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-03-21T06:22:40.000Z" title="3/21/2023, 6:22:40 AM">2023-03-21</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><span> / </span><a class="link-muted" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/">代码解读</a></span><span class="level-item">23 分钟读完 (大约3511个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8Bfsl-gpio/">代码解读之fsl_gpio</a></p><div class="content"><h1 id="读fsl-gpio-c-和-fsl-gpio-h-代码"><a href="#读fsl-gpio-c-和-fsl-gpio-h-代码" class="headerlink" title="读fsl_gpio.c 和 fsl_gpio.h 代码"></a>读fsl_gpio.c 和 fsl_gpio.h 代码</h1><blockquote>
<p>使用kw38的win mcuxpresso版本 <code>SDK_2_6_615_FRDM-KW38_mcuxpresso_win</code></p>
</blockquote>
<h1 id="fsl-gpio-h"><a href="#fsl-gpio-h" class="headerlink" title="fsl_gpio.h"></a>fsl_gpio.h</h1><blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _FSL_GPIO_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _FSL_GPIO_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"fsl_common.h"</span></span></span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="Part1-gpio-pin-direction-t-和-gpio-checker-attribute-t"><a href="#Part1-gpio-pin-direction-t-和-gpio-checker-attribute-t" class="headerlink" title="Part1 gpio_pin_direction_t 和 gpio_checker_attribute_t"></a>Part1 gpio_pin_direction_t 和 gpio_checker_attribute_t</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">gpio_pin_direction</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    kGPIO_DigitalInput  = <span class="number">0U</span>, <span class="comment">/*!&lt; Set current pin as digital input*/</span></span><br><span class="line">    kGPIO_DigitalOutput = <span class="number">1U</span>, <span class="comment">/*!&lt; Set current pin as digital output*/</span></span><br><span class="line">} <span class="type">gpio_pin_direction_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">gpio_checker_attribute</span>{</span></span><br><span class="line">}<span class="type">gpio_checker_attribute_t</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><code>gpio_pin_direction_t</code> 确定Pin引脚方向，输入为0，输出为1。</p>
<p>GPIO 检查器属性用于某些具有 GPIO 属性检查器功能的 NXP 微控制器。此功能用于安全目的，<strong>根据访问属性检查是否允许访问 GPIO 引脚</strong>。</p>
<p><code>gpio_checker_attribute_t</code> 枚举定义了可以检查的可能属性。这些属性指定不同权限级别（用户非安全、用户安全和特权安全）的读取和写入权限。</p>
<p>另外还有一个属性值<code>kGPIO_IgnoreAttributeCheck</code>，表示忽略属性检查。</p>
<p>GPIO 检查器属性与 <code>GPIO_CheckAttribute()</code> 函数结合使用，<strong>以根据操作的属性检查是否允许 GPIO 引脚上的特定操作</strong>。</p>
<h3 id="Part2-gpio-pin-config-t-和-gpio-interrupt-config-t"><a href="#Part2-gpio-pin-config-t-和-gpio-interrupt-config-t" class="headerlink" title="Part2 gpio_pin_config_t 和 gpio_interrupt_config_t"></a>Part2 gpio_pin_config_t 和 gpio_interrupt_config_t</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">gpio_pin_config</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">gpio_pin_direction_t</span> pinDirection;</span><br><span class="line">    <span class="type">uint8_t</span> outputLogic; <span class="comment">/*!&lt; Set a default output logic, which has no use in input */</span></span><br><span class="line">} <span class="type">gpio_pin_config_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">gpio_interrupt_config</span>{</span></span><br><span class="line">} <span class="type">gpio_interrupt_config_t</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>这是一个 C 语言代码片段，它定义了两个数据结构和一个枚举类型，用于在微控制器上配置通用输入/输出 (GPIO) 引脚。</p>
<ol>
<li><code>gpio_pin_config_t</code> 定义了 GPIO 引脚的配置参数，包括它的方向（输入或输出）和<strong>它的默认输出逻辑（如果它是一个输出引脚）</strong>。</li>
<li>第二个数据结构 <code>gpio_interrupt_config_t</code> 是有条件地定义的，具体取决于微控制器是否支持其 GPIO 引脚上的中断。如果是，则此结构定义中断生成条件的配置参数。</li>
<li>枚举类型 <code>gpio_interrupt_config_t</code> 定义了中断生成条件的可能值，例如在上升沿、下降沿、任一边沿或逻辑电平为高或低时启用中断。</li>
</ol>
<h2 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h2><h3 id="GPIO配置"><a href="#GPIO配置" class="headerlink" title="GPIO配置"></a>GPIO配置</h3><h3 id="Part1-GPIO-PinInit"><a href="#Part1-GPIO-PinInit" class="headerlink" title="Part1 GPIO_PinInit()"></a>Part1 GPIO_PinInit()</h3><p>这是名为 <code>GPIO_PinInit()</code> 的函数的代码片段，它是用于处理微控制器上的通用输入/输出 (GPIO) 引脚的更大驱动程序的一部分。该驱动程序提供一组函数<strong>来配置、读取和写入 GPIO 引脚</strong>。</p>
<p>函数 <code>GPIO_PinInit()</code> <strong>初始化板使用的 GPIO 引脚</strong>。它采用三个参数：</p>
<ul>
<li>GPIO 外设的基地址 GPIO peripheral base pointer (GPIOA, GPIOB, GPIOC, and so on.)</li>
<li>GPIO 端口的引脚号 GPIO port pin number</li>
<li>以及指向定义 GPIO 引脚配置的 gpio_pin_config_t 结构的指针 GPIO pin configuration pointer</li>
</ul>
<p>gpio_pin_config_t 结构包含两个字段：</p>
<ul>
<li>pinDirection：GPIO引脚的方向，可以设置为kGPIO_DigitalInput或kGPIO_DigitalOutput。</li>
<li>outputLogic：GPIO引脚的输出逻辑电平，仅在引脚配置为数字输出时适用。它可以设置为 0 或 1。</li>
</ul>
<p>函数 <code>GPIO_PinInit()</code> 使用 <code>gpio_pin_config_t</code> 结构中定义的配置初始化 GPIO 引脚。</p>
<h3 id="GPIO输入操作"><a href="#GPIO输入操作" class="headerlink" title="GPIO输入操作"></a>GPIO输入操作</h3><h3 id="Part2-静态函数-GPIO-PinWrite"><a href="#Part2-静态函数-GPIO-PinWrite" class="headerlink" title="Part2 静态函数 GPIO_PinWrite()"></a>Part2 静态函数 GPIO_PinWrite()</h3><p>这是名为 <code>GPIO_PinWrite()</code> 的函数的代码片段。</p>
<p>函数<code>GPIO_PinWrite()</code>将一个GPIO引脚的输出电平设置为逻辑1或逻辑0。它需要三个参数：</p>
<ul>
<li>GPIO外设的基址、</li>
<li>GPIO端口的引脚号、</li>
<li>GPIO引脚的输出电平.</li>
</ul>
<p>输出参数可以设置为 0 或 1 以指定 GPIO 引脚的输出逻辑电平。<strong>如果输出为 0，则相应的引脚输出设置为逻辑低电平，否则，如果输出为 1，则相应的引脚输出设置为逻辑高电平</strong>。</p>
<p>函数 GPIO_PinWrite() 使用<strong>按位操作</strong>来设置 GPIO 引脚的输出电平。如果输出参数为0，则使用左移操作清除GPIO端口输出清除寄存器（<strong>GPIOx_PCOR</strong>）中的相应位。否则，如果输出参数为 1，则使用左移操作设置 GPIO 端口输出设置寄存器 (<strong>GPIOx_PSOR</strong>) 中的相应位。</p>
<p>此代码是用 C 编程语言编写的，并假定微控制器具有 GPIO 寄存器的特定实现，例如分别用于清除和设置 GPIO 输出引脚的 PCOR 和 PSOR 寄存器。</p>
<h3 id="Part3-静态函数-GPIO-PortSet"><a href="#Part3-静态函数-GPIO-PortSet" class="headerlink" title="Part3 静态函数 GPIO_PortSet()"></a>Part3 静态函数 GPIO_PortSet()</h3><p>这是名为 GPIO_PortSet() 的函数的代码片段.</p>
<p>函数 <code>GPIO_PortSet()</code> <strong>将多个 GPIO 引脚的输出电平设置为逻辑 1</strong>。它有两个参数：</p>
<ul>
<li>GPIO 外设的基址, base GPIO peripheral base pointer (GPIOA, GPIOB, GPIOC, and so on.)</li>
<li>指定要设置哪些 GPIO 引脚的掩码。GPIO pin number macro</li>
</ul>
<p><strong>掩码参数是一个位掩码，指示要设置的引脚。掩码参数的每一位对应一个特定的 GPIO 引脚。如果某位设置为 1，则相应的 GPIO 引脚输出设置为逻辑高电平</strong>。</p>
<p>函数 <code>GPIO_PortSet()</code> 通过使用<strong>按位或</strong>运算写入 GPIO 端口输出设置寄存器 (<strong>GPIOx_PSOR</strong>)，将指定 GPIO 引脚的输出电平设置为逻辑 1。在执行按位或操作之前，将掩码参数的值左移以与 GPIO 端口输出设置寄存器的位位置对齐。</p>
<p>此代码是用 C 编程语言编写的，并假定微控制器具有 GPIO 寄存器的特定实现，例如用于设置 GPIO 输出引脚的 PSOR 寄存器。</p>
<h3 id="Part4-静态函数-GPIO-PortClear"><a href="#Part4-静态函数-GPIO-PortClear" class="headerlink" title="Part4 静态函数 GPIO_PortClear()"></a>Part4 静态函数 GPIO_PortClear()</h3><p>这是名为 <code>GPIO_PortClear()</code> 的函数的代码片段.</p>
<p>函数 <code>GPIO_PortClear()</code> <strong>将多个 GPIO 引脚的输出电平设置为逻辑 0</strong>。它有两个参数：</p>
<ul>
<li>GPIO 外设的基址</li>
<li>和指定要清除哪些 GPIO 引脚的掩码。</li>
</ul>
<p>掩码参数是一个位掩码，指示要清除哪些引脚。掩码参数的每一位对应一个特定的 GPIO 引脚。如果某位设置为0，则相应的 GPIO 引脚输出设置为逻辑低电平。</p>
<p>函数 <code>GPIO_PortClear()</code> 通过使用按位或运算写入 GPIO 端口输出清除寄存器 (<strong>GPIOx_PCOR</strong>)，将指定 GPIO 引脚的输出电平设置为逻辑 0。在执行按位或操作之前，将掩码参数的值左移以与 GPIO 端口输出清除寄存器的位位置对齐。</p>
<p>此代码是用 C 编程语言编写的，并假定微控制器具有 GPIO 寄存器的特定实现，例如用于清除 GPIO 输出引脚的 PCOR 寄存器。</p>
<h3 id="Part5-静态函数-GPIO-PortToggle"><a href="#Part5-静态函数-GPIO-PortToggle" class="headerlink" title="Part5 静态函数 GPIO_PortToggle()"></a>Part5 静态函数 GPIO_PortToggle()</h3><p>这是名为 <code>GPIO_PortToggle()</code> 的函数的代码片段。</p>
<p>函数 <code>GPIO_PortToggle()</code> <strong>反转多个 GPIO 引脚的当前输出逻辑</strong>。它有两个参数：</p>
<ul>
<li>GPIO 外设的基地址</li>
<li>和一个掩码，它指定要切换的 GPIO 引脚。</li>
</ul>
<p>掩码参数是一个位掩码，指示要切换的引脚。掩码参数的每一位对应一个特定的 GPIO 引脚。如果某位设置为 1，则相应的 GPIO 引脚输出逻辑反转，即如果设置为逻辑 1，则变为逻辑 0，反之亦然。</p>
<p>函数 <code>GPIO_PortToggle()</code> 通过使用<strong>按位或</strong>运算写入 GPIO 端口<strong>输出切换寄存器 (GPIOx_PTOR)</strong> 来反转指定 GPIO 引脚的输出逻辑。在执行按位或操作之前，掩码参数的值左移以与 GPIO 端口输出切换寄存器的位位置对齐。</p>
<p>此代码是用 C 编程语言编写的，并假定微控制器具有 GPIO 寄存器的特定实现，例如用于切换 GPIO 输出引脚的 PTOR 寄存器。</p>
<h3 id="GPIO输入操作-1"><a href="#GPIO输入操作-1" class="headerlink" title="GPIO输入操作"></a>GPIO输入操作</h3><h3 id="Part6-静态函数-GPIO-PinRead"><a href="#Part6-静态函数-GPIO-PinRead" class="headerlink" title="Part6 静态函数 GPIO_PinRead()"></a>Part6 静态函数 GPIO_PinRead()</h3><p>这是一个名为 <code>GPIO_PinRead()</code> 的函数的代码片段。</p>
<p>函数 <code>GPIO_PinRead()</code> <strong>读取单个 GPIO 引脚的当前输入值</strong>。它需要两个参数：GPIO外设的基地址和要读取的GPIO引脚的引脚号。</p>
<p>函数 <code>GPIO_PinRead()</code> 通过使用<strong>移位和与操作</strong>从 GPIO 端口输入数据寄存器 (<strong>GPIOx_PDIR</strong>) 读取来读取指定 GPIO 引脚的输入值。按位移位操作将 GPIO 端口输入数据寄存器的值右对齐，以与指定 GPIO 引脚的位位置对齐。 <em><strong>AND 运算会屏蔽除对应于指定 GPIO 引脚的位之外的所有位</strong></em>。</p>
<p>该函数将指定 GPIO 引脚的输入值作为single-bit值（0 或 1）返回。</p>
<p>此代码是用 C 编程语言编写的，并假定微控制器具有 GPIO 寄存器的特定实现，例如用于读取 GPIO 输入引脚的 PDIR 寄存器。</p>
<h3 id="GPIO中断"><a href="#GPIO中断" class="headerlink" title="GPIO中断"></a>GPIO中断</h3><h3 id="GPIO-PortGetInterruptFlags-和-GPIO-PortClearInterruptFlags"><a href="#GPIO-PortGetInterruptFlags-和-GPIO-PortClearInterruptFlags" class="headerlink" title="GPIO_PortGetInterruptFlags() 和 GPIO_PortClearInterruptFlags()"></a>GPIO_PortGetInterruptFlags() 和 GPIO_PortClearInterruptFlags()</h3><p>此代码提供了一个 API，用于配置和处理 GPIO 引脚上的中断。</p>
<p>前两个函数 <code>GPIO_PortGetInterruptFlags()</code> 和 <code>GPIO_PortClearInterruptFlags()</code> <strong>分别用于读取和清除 GPIO 端口中多个引脚的中断状态标志</strong>。 </p>
<p>base参数是指GPIO peripheral的基地址，mask参数是用来指定要对哪个GPIO引脚进行读或清除操作。</p>
<p>此语句似乎描述了与数字系统中的 DMA 请求或电平敏感中断相关联的标志的行为。</p>
<p>如果某个引脚被配置为生成 DMA 请求，则当<strong>请求的 DMA 传输完成时，相应的标志将自动清除</strong>。这意味着该标志指示 DMA 传输的状态，并在传输完成时重置。</p>
<p>另一方面，如果引脚未配置为生成 DMA 请求，则相应的标志将保持设置状态，<strong>直到将逻辑 1 写入该标志</strong>。这意味着该标志可用于指示与 DMA 无关的事件的发生，例如中断或数据传输。</p>
<p>最后，如果引脚被配置为电平敏感中断并且中断信号保持有效，则标志立即再次设置。此行为允许系统响应连续信号，例如按钮按下或传感器读数，而不会错过任何事件。</p>
<h3 id="GPIO-SetPinInterruptConfig-和-GPIO-GetPinsDMARequestFlags-GPIO-SetMultipleInterruptPinsConfig"><a href="#GPIO-SetPinInterruptConfig-和-GPIO-GetPinsDMARequestFlags-GPIO-SetMultipleInterruptPinsConfig" class="headerlink" title="GPIO_SetPinInterruptConfig() 和 GPIO_GetPinsDMARequestFlags() GPIO_SetMultipleInterruptPinsConfig()"></a>GPIO_SetPinInterruptConfig() 和 GPIO_GetPinsDMARequestFlags() GPIO_SetMultipleInterruptPinsConfig()</h3><p>其余函数是有条件的，取决于 GPIO 端口是否支持中断。如果支持中断，则 <code>GPIO_SetPinInterruptConfig()</code> 函数用于设置单个引脚的中断配置。 pin 参数指定 GPIO 引脚号，而 config 参数用于指定中断配置。</p>
<p><code>GPIO_SetPinInterruptConfig()</code> 函数用于<strong>读取多个引脚的 DMA 请求标志</strong>。 <code>GPIO_SetMultipleInterruptPinsConfig()</code> 函数<strong>用于同时设置多个引脚的中断配置</strong>。 mask 参数用于指定要为其设置中断配置的 GPIO 引脚，而 config 参数指定中断配置。</p>
<p><em>中断配置选项包括设置中断/DMA 请求、触发中断/DMA 请求的边沿类型、触发中断的逻辑电平以及输出触发模式</em>。</p>
<h3 id="GPIO-CheckAttributeBytes"><a href="#GPIO-CheckAttributeBytes" class="headerlink" title="GPIO_CheckAttributeBytes()"></a>GPIO_CheckAttributeBytes()</h3><p>此代码片段定义了一个名为 <code>GPIO_CheckAttributeBytes()</code> 的函数。该函数有两个参数：一个指向 GPIO 外设（基）的指针和一个名为 attribute 的 gpio_checker_attribute_t 参数。</p>
<p>该函数检查 GPIO 模块是否具有设备特定数量的数据端口，以及它是否支持属性检查器。如果满足这些条件，该函数将继续检查成功访问指定 GPIO 引脚（掩码）的 GPIO 编程模型所需的字节级属性。</p>
<p>属性参数是一个枚举，表示 GACR 中 4 个数据字节的属性控制值。字节级属性是使用小端数据约定定义的。</p>
<h3 id="fgpio-driver-快速GPIO"><a href="#fgpio-driver-快速GPIO" class="headerlink" title="fgpio_driver  快速GPIO"></a>fgpio_driver  快速GPIO</h3><h3 id="FGPIO-PortInit"><a href="#FGPIO-PortInit" class="headerlink" title="FGPIO_PortInit()"></a>FGPIO_PortInit()</h3><blockquote>
<p>此代码片段介绍了 FGPIO 功能，该功能仅在某些 Kinetis MCU 上受支持。 FGPIO 寄存器是 <code>IOPORT</code> 接口的别名，通过 IOPORT 接口的访问与任何指令获取并行发生，并在一个周期内完成。此内存映射称为 <code>FGPIO</code>。</p>
</blockquote>
<p>然后代码定义了一个名为 <code>FGPIO_PortInit()</code> 的函数，该函数将指向 FGPIO 外设（基）的指针作为其参数。此函数<strong>通过关闭其时钟来初始化 FGPIO 外设</strong>。</p>
<p><code>FGPIO_Type</code> 可能是表示 FGPIO 外设的结构的类型定义。特定的 FGPIO 外设用后缀（FGPIOA、FGPIOB、FGPIOC 等）表示，并且可能具有不同的配置和引脚映射。</p>
<p>还有一个条件预处理器指令，用于检查 <code>FSL_FEATURE_SOC_FGPIO_COUNT</code> 功能是否已定义和支持。如果不支持，则不会编译指令中的代码。</p>
<p>同样，还有另一个条件预处理器指令检查 <code>FSL_FEATURE_PCC_HAS_FGPIO_CLOCK_GATE_CONTROL</code> 功能是否已定义和支持。如果不支持，则不会编译指令中的代码。</p>
<p>总的来说，这段代码设置了 FGPIO 功能并提供了一个函数来初始化 FGPIO 外设。但是，如果没有关于如何使用此代码以及 FGPIO_Type 结构是什么样子的更多上下文，则很难提供更详细的分析。</p>
<h1 id="fsl-gpio-c"><a href="#fsl-gpio-c" class="headerlink" title="fsl_gpio.c"></a>fsl_gpio.c</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PORT_Type *<span class="type">const</span> s_portBases[] = PORT_BASE_PTRS;</span><br><span class="line"><span class="type">static</span> GPIO_Type *<span class="type">const</span> s_gpioBases[] = GPIO_BASE_PTRS;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">GPIO_GetInstance</span><span class="params">(GPIO_Type *base)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint32_t</span> instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Find the instance index from base address mappings. */</span></span><br><span class="line">    <span class="keyword">for</span> (instance = <span class="number">0</span>; instance &lt; ARRAY_SIZE(s_gpioBases); instance++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (s_gpioBases[instance] == base)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    assert(instance &lt; ARRAY_SIZE(s_gpioBases));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_PinInit</span><span class="params">(GPIO_Type *base, <span class="type">uint32_t</span> pin, <span class="type">const</span> <span class="type">gpio_pin_config_t</span> *config)</span></span><br><span class="line">{</span><br><span class="line">    assert(<span class="literal">NULL</span> != config);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> u32flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (config-&gt;pinDirection == kGPIO_DigitalInput)</span><br><span class="line">    {</span><br><span class="line">        base-&gt;PDDR &amp;= ~(u32flag &lt;&lt; pin);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        GPIO_PinWrite(base, pin, config-&gt;outputLogic);</span><br><span class="line">        base-&gt;PDDR |= (u32flag &lt;&lt; pin);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">GPIO_PortGetInterruptFlags</span><span class="params">(GPIO_Type *base)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint8_t</span> instance;</span><br><span class="line">    PORT_Type *portBase;</span><br><span class="line">    instance = (<span class="type">uint8_t</span>)GPIO_GetInstance(base);</span><br><span class="line">    portBase = s_portBases[instance];</span><br><span class="line">    <span class="keyword">return</span> portBase-&gt;ISFR;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_PortClearInterruptFlags</span><span class="params">(GPIO_Type *base, <span class="type">uint32_t</span> mask)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint8_t</span> instance;</span><br><span class="line">    PORT_Type *portBase;</span><br><span class="line">    instance       = (<span class="type">uint8_t</span>)GPIO_GetInstance(base);</span><br><span class="line">    portBase       = s_portBases[instance];</span><br><span class="line">    portBase-&gt;ISFR = mask;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_CheckAttributeBytes</span><span class="params">(GPIO_Type *base, <span class="type">gpio_checker_attribute_t</span> attribute)</span></span><br><span class="line">{</span><br><span class="line">    base-&gt;GACR = ((<span class="type">uint32_t</span>)attribute &lt;&lt; GPIO_GACR_ACB0_SHIFT) | ((<span class="type">uint32_t</span>)attribute &lt;&lt; GPIO_GACR_ACB1_SHIFT) |</span><br><span class="line">                 ((<span class="type">uint32_t</span>)attribute &lt;&lt; GPIO_GACR_ACB2_SHIFT) | ((<span class="type">uint32_t</span>)attribute &lt;&lt; GPIO_GACR_ACB3_SHIFT);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-03-20T07:58:38.000Z" title="3/20/2023, 7:58:38 AM">2023-03-20</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><span> / </span><a class="link-muted" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/">代码解读</a></span><span class="level-item">1 小时读完 (大约8100个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8Bgpio-adapter/">代码解读之GPIO_Adapter</a></p><div class="content"><h1 id="读fsl-adapter-gpio-c-和-h-代码"><a href="#读fsl-adapter-gpio-c-和-h-代码" class="headerlink" title="读fsl_adapter_gpio.c 和 .h 代码"></a>读fsl_adapter_gpio.c 和 .h 代码</h1><h2 id="1-fsl-adapter-gpio-c"><a href="#1-fsl-adapter-gpio-c" class="headerlink" title="1. fsl_adapter_gpio.c"></a>1. fsl_adapter_gpio.c</h2><p>这个代码是一个包含头文件并定义与MCU中的GPIO（通用输入/输出）功能相关的一些宏的 C 源文件。它是为 NXP 公司制造的特定MCU编写的。</p>
<p>该文件包含以下头文件：</p>
<ul>
<li>fsl_device_registers.h：包含设备特定的寄存器定义。</li>
<li>fsl_gpio.h：提供用于GPIO操作的API函数。</li>
<li>fsl_port.h：提供用于PORT（端口控制和中断）操作的API函数。</li>
<li>fsl_adapter_gpio.h：提供用于GPIO操作的适配器功能。
该文件还定义了一个组件ID，<code>tools</code>使用它。</li>
</ul>
<p>该代码定义了两个宏：</p>
<ul>
<li>HAL_GPIO_CLZ(x)：计算32位数字x中前导零的数量，该数量用于确定GPIO引脚的bit位置。此宏的实现取决于用于编译代码的工具链。</li>
<li>HAL_GPIO_BSR(x)：根据GPIO引脚掩码的值计算GPIO引脚的bit位置。此宏使用 HAL_GPIO_CLZ(x) 宏计算掩码中前导零的数量，然后从31中减去结果（因为GPIO引脚编号是从LSB到MSB进行计数）。</li>
</ul>
<h3 id="1-1-结构体hal-gpio-pin-t-和-hal-gpio-state-t"><a href="#1-1-结构体hal-gpio-pin-t-和-hal-gpio-state-t" class="headerlink" title="1.1 结构体hal_gpio_pin_t 和 hal_gpio_state_t"></a>1.1 结构体<code>hal_gpio_pin_t</code> 和 <code>hal_gpio_state_t</code></h3><p>这些结构体定义了单片机中GPIO引脚的引脚配置和状态。</p>
<p><code>hal_gpio_pin_t</code>结构体用于配置GPIO引脚的属性，具有以下字段：</p>
<ul>
<li>port：一个整数值（0-7），指定引脚的PORT编号。</li>
<li>reserved：值为0的位域，用于填充。</li>
<li>pin：一个整数值（0-31），指定指定PORT内的引脚编号。</li>
<li>direction：一个整数值（0或1），<strong>指定引脚的方向（输入或输出）</strong>。</li>
<li>trigger：一个整数值（0-7），<strong>指定在引脚上启用中断时的触发条件</strong>。</li>
<li>reserved2：值为0的位域，用于填充。</li>
</ul>
<p><code>hal_gpio_state_t</code>结构体用于存储GPIO引脚的状态，具有以下字段：</p>
<ul>
<li>next：指向链表中下一个元素的指针。</li>
<li>callback：<strong>指向回调函数的函数指针，当引脚上的中断被触发时将执行该函数</strong>。</li>
<li>callbackParam：指向<strong>将传递给回调函数的数据的指针</strong>。</li>
<li>direction：一个整数值（0或1），指定引脚的方向（输入或输出）。</li>
<li>level：一个整数值（0或1），指定引脚的当前逻辑电平。</li>
<li>port：一个整数值（0-7），指定引脚的PORT编号。</li>
<li>pin：一个整数值（0-31），指定指定PORT内的引脚编号。</li>
<li>trigger：一个整数值（0-7），指定在引脚上启用中断时的触发条件。</li>
</ul>
<h3 id="1-2-静态变量-static-GPIO-Type-const-s-GpioPort-和-static-hal-gpio-state-t-s-GpioHead"><a href="#1-2-静态变量-static-GPIO-Type-const-s-GpioPort-和-static-hal-gpio-state-t-s-GpioHead" class="headerlink" title="1.2 静态变量 static GPIO_Type *const s_GpioPort[] 和 static hal_gpio_state_t *s_GpioHead;"></a>1.2 静态变量 static GPIO_Type <code>*const s_GpioPort[]</code> 和 static hal_gpio_state_t <code>*s_GpioHead</code>;</h3><p>这个部分定义了函数的原型，这些函数将在源文件中使用，但在这种情况下没有原型。</p>
<p>该部分还定义了一些静态变量：</p>
<ul>
<li><p>s_GpioPort：<u>指向GPIO_Type结构体指针的数组。每个指针对应微控制器中的一个GPIO端口</u>。</p>
</li>
<li><p>s_GpioHead：指向<code>hal_gpio_state_t</code>结构体链表的头部的指针。<strong>此链表用于跟踪MCU中所有GPIO引脚的状态</strong>。</p>
</li>
</ul>
<h3 id="1-3-函数-static-void-HAL-GpioInterruptHandle-uint8-t-port"><a href="#1-3-函数-static-void-HAL-GpioInterruptHandle-uint8-t-port" class="headerlink" title="1.3 函数 static void HAL_GpioInterruptHandle(uint8_t port)"></a>1.3 函数 static void HAL_GpioInterruptHandle(uint8_t port)</h3><p>这段代码片段是一个GPIO（通用输入/输出）驱动程序的C实现。代码定义了两个数据结构，<code>hal_gpio_pin_t</code>和<code>hal_gpio_state_t</code>，它们分别<strong>包含有关引脚配置和状态的信息</strong>。代码还定义了几个函数<strong>来处理中断和添加/删除GPIO状态节点的链接列表</strong>。</p>
<ul>
<li><p><code>HAL_GpioInterruptHandle</code>函数：==通过迭代GPIO状态节点的链表并检查指定port上的任何pin是否触发了中断来处理GPIO中断。如果引脚发生中断，则该函数执行与该引脚相关联的回调函数==。</p>
</li>
<li><p><code>HAL_GpioConflictSearch</code>函数：搜索GPIO状态节点的链表，**<u>以检查引脚是否与已注册的引脚冲突</u>**。仅当定义了<code>HAL_GPIO_CONFLICT_CHECK_ENABLE</code>宏并将其设置为大于零的值时，才使用此函数。</p>
</li>
<li><p><code>HAL_GpioAddItem</code>函数：将新的GPIO状态节点添加到链接列表中。该函数首先检查新节点是否与已注册的引脚发生冲突，然后再将其添加到列表中。</p>
</li>
<li><p><code>HAL_GpioRemoveItem</code>函数：从链接列表中删除GPIO状态节点。该函数通过遍历列表以查找指定的节点并将其删除。</p>
</li>
</ul>
<p>总的来说，这段代码片段提供了GPIO驱动程序的基本实现，可用于配置和控制微控制器上的GPIO引脚。</p>
<p>这是<code>HAL_GpioInterruptHandle</code>函数的函数实现，该函数==负责处理GPIO中断==。</p>
<ol>
<li><p>该函数接受一个参数<code>port</code>，该参数是发生中断的端口号。该函数首先遍历GPIO引脚状态结构的链表，以找到与端口号相对应的结构。如果找不到一个合适的结构，则函数将简单地返回。</p>
</li>
<li><p>接下来，该函数使用<code>GPIO_GpioGetInterruptFlags</code>或<code>GPIO_PortGetInterruptFlags</code>函数**<u>检索在指定端口上发生的引脚中断的集合</u><strong>，具体取决于芯片是否具有每个引脚的个别GPIO中断标志。然后，</strong>该函数清除引发中断的引脚的中断标志**。</p>
</li>
<li><p>然后，该函数再次遍历GPIO引脚状态结构的链表，这次检查每个结构以查看它是否对应于触发中断的引脚之一。如果找到匹配项，则函数调用与引脚关联的回调函数来处理中断。</p>
</li>
<li><p>最后，该函数通过清除刚刚处理的引脚的中断标志来更新触发中断的引脚中断集。如果没有更多的中断需要处理，该函数将返回。</p>
</li>
</ol>
<h3 id="1-4-函数-static-hal-gpio-status-t-HAL-GpioConflictSearch-hal-gpio-state-t-head-uint8-t-port-uint8-t-pin"><a href="#1-4-函数-static-hal-gpio-status-t-HAL-GpioConflictSearch-hal-gpio-state-t-head-uint8-t-port-uint8-t-pin" class="headerlink" title="1.4 函数 static hal_gpio_status_t HAL_GpioConflictSearch(hal_gpio_state_t *head, uint8_t port, uint8_t pin)"></a>1.4 函数 static hal_gpio_status_t HAL_GpioConflictSearch(hal_gpio_state_t *head, uint8_t port, uint8_t pin)</h3><p>这段代码定义了一个函数<code>HAL_GpioConflictSearch</code>，它通过遍历<code>hal_gpio_state_t</code>结构体的链表来**<u>查找指定的端口和引脚与链表中现有的端口和引脚是否有冲突</u>**。</p>
<ol>
<li><p>该函数需要链表的头部（head）、端口号（port）和引脚号（pin）作为输入。</p>
</li>
<li><p>然后，它使用while循环遍历链表，检查是否有<code>hal_gpio_state_t</code>结构体的端口和引脚与输入的相同。</p>
</li>
<li><p>如果找到匹配的<code>hal_gpio_state_t</code>结构体，则该函数返回<code>kStatus_HAL_GpioPinConflict</code>，表示存在冲突。如果没有找到匹配的结构体，则函数返回<code>kStatus_HAL_GpioSuccess</code>，表示不存在冲突。</p>
</li>
</ol>
<p>当预处理宏<code>HAL_GPIO_CONFLICT_CHECK_ENABLE</code>被定义且其值大于零时，才会编译此函数。</p>
<p>预处理指令，用于检查宏<code>HAL_GPIO_CONFLICT_CHECK_ENABLE</code>是否被定义，并且其值大于0。</p>
<p>如果该宏被定义并且其值大于0，那么<code>#if</code>和<code>#endif</code>语句中的代码将会被编译，否则将被跳过。</p>
<h3 id="1-5-函数-static-hal-gpio-status-t-HAL-GpioAddItem-hal-gpio-state-t-head-hal-gpio-state-t-node"><a href="#1-5-函数-static-hal-gpio-status-t-HAL-GpioAddItem-hal-gpio-state-t-head-hal-gpio-state-t-node" class="headerlink" title="1.5 函数 static hal_gpio_status_t HAL_GpioAddItem(hal_gpio_state_t **head, hal_gpio_state_t *node)"></a>1.5 函数 static hal_gpio_status_t HAL_GpioAddItem(hal_gpio_state_t **head, hal_gpio_state_t *node)</h3><p>这个函数**<u>将一个新的 GPIO 引脚添加到 GPIO 引脚的链表中</u>**。它把链表头的指针和要添加的新 GPIO 引脚的指针作为输入参数。</p>
<p>该函数<strong>首先禁用全局中断</strong>，然后<strong>检查链表是否为空</strong>。</p>
<ol>
<li>如果它是空的，新的 GPIO 引脚将添加为链表的第一个元素。</li>
<li>否则，函数通过搜索链表来检查新的 GPIO 引脚是否与任何现有 GPIO 引脚冲突。</li>
<li>如果找到冲突，函数会重新启用全局中断并返回指示 GPIO 引脚冲突的错误状态。</li>
<li>如果没有发现冲突，则在链接列表的末尾添加新的 GPIO 引脚，并返回成功状态。</li>
<li>最后，在返回之前，该函数启用全局中断。</li>
</ol>
<h3 id="1-6-函数-static-hal-gpio-status-t-HAL-GpioRemoveItem-hal-gpio-state-t-head-hal-gpio-state-t-node"><a href="#1-6-函数-static-hal-gpio-status-t-HAL-GpioRemoveItem-hal-gpio-state-t-head-hal-gpio-state-t-node" class="headerlink" title="1.6 函数 static hal_gpio_status_t HAL_GpioRemoveItem(hal_gpio_state_t **head, hal_gpio_state_t *node)"></a>1.6 函数 static hal_gpio_status_t HAL_GpioRemoveItem(hal_gpio_state_t **head, hal_gpio_state_t *node)</h3><p>此函数从 GPIO 引脚的链表中移除一个节点。它以列表的头<code>**head</code>和要移除的节点 <code>*node</code>作为输入，二者都是指向 <code>hal_gpio_state_t</code> 结构的指针。</p>
<p>该函数通过使用 <code>DisableGlobalIRQ() </code>函数<strong>禁用中断</strong>并将 <code>PRIMASK</code> 寄存器的值存储在 <code>regPrimask</code> 中来启动。然后它使用 while 循环<strong>遍历列表，查找要删除的节点</strong>。一旦找到，它会更新指针以从列表中删除节点。如果要移除的节点是列表的头，则会更新 *head。</p>
<p>最后，该函数使用 <code>EnableGlobalIRQ(regPrimask)</code> <strong>启用中断，并返回</strong> <code>kStatus_HAL_GpioSuccess</code>。</p>
<h3 id="1-7-GPIOX-INT1-IRQHandler-和-GPIOX-INT0-IRQHandler"><a href="#1-7-GPIOX-INT1-IRQHandler-和-GPIOX-INT0-IRQHandler" class="headerlink" title="1.7 GPIOX_INT1_IRQHandler() 和 GPIOX_INT0_IRQHandler()"></a>1.7 GPIOX_INT1_IRQHandler() 和 GPIOX_INT0_IRQHandler()</h3><p>这些是设备上每个GPIO端口的中断处理程序函数。</p>
<p>它们是为了没有专门为每个GPIO端口提供中断处理程序的平台而实现的，这由 <code>FSL_FEATURE_PORT_HAS_NO_INTERRUPT</code> 宏指示。</p>
<p>对于每个GPIO端口，定义了两个中断处理程序，<code>GPIOX_INT0_IRQHandler()</code>和<code>GPIOX_INT1_IRQHandler()</code>。</p>
<ul>
<li><code>GPIOX_INT0_IRQHandler()</code>函数是端口的<strong>实际中断处理程序</strong>，并调用<code>HAL_GpioInterruptHandle()</code>函数来处理中断。</li>
<li><code>GPIOX_INT1_IRQHandler()</code>函数是<strong>中断优先级配置的占位符</strong>，它只调用<code>GPIOX_INT0_IRQHandler()</code>函数。</li>
</ul>
<p><code>SDK_ISR_EXIT_BARRIER</code>宏用于<strong>在退出中断处理程序之前添加障碍，以确保在从中断返回之前完成所有存储器访问</strong>。</p>
<h3 id="1-8-PORTX-IRQHandler"><a href="#1-8-PORTX-IRQHandler" class="headerlink" title="1.8 PORTX_IRQHandler()"></a>1.8 PORTX_IRQHandler()</h3><p>这是一系列针对 GPIO 端口的中断处理函数。</p>
<p>根据所使用的特定微控制器，这些功能将以前缀 GPIO 或 PORT 命名。 如果微控制器具有 GPIO 的“无中断”<code>FSL_FEATURE_PORT_HAS_NO_INTERRUPT</code>功能，则中断处理程序将使用 GPIO 前缀并具有类似 <code>GPIOA_INT0_IRQHandler()</code> 的名称。否则，中断处理程序将使用 PORT 前缀并具有类似于 <code>PORTA_IRQHandler() </code>的名称。 </p>
<p>每个中断处理函数负责处理特定 GPIO 端口的中断。例如，<code>GPIOA_INT0_IRQHandler() </code>处理端口 A、引脚 0 的中断。 在每个中断处理函数中，<code>HAL_GpioInterruptHandle() </code><strong>以端口号作为参数被调用</strong>。此函数负责查找触发中断的引脚并调用任何已注册的回调。 **<u>==<code>SDK_ISR_EXIT_BARRIER</code> 宏用于标记中断处理函数的结束。这是一种防止编译器在从中断返回后生成代码的方法，这可能会导致系统堆栈或中断处理出现问题==</u>**。</p>
<h3 id="1-9-函数-void-HAL-GpioPreInit-void"><a href="#1-9-函数-void-HAL-GpioPreInit-void" class="headerlink" title="1.9 函数 void HAL_GpioPreInit(void)"></a>1.9 函数 void HAL_GpioPreInit(void)</h3><p>函数 <code>HAL_GpioPreInit()</code> 将全局指针 <code>s_GpioHead</code> 初始化为 <code>NULL</code>，用作包含每个已配置 GPIO 引脚的 GPIO 状态信息的链表的头部。</p>
<p>此函数通常在 GPIO 驱动程序初始化期间调用，**<u>在添加或配置任何 GPIO 引脚之前</u>**。</p>
<h3 id="1-10-函数-hal-gpio-status-t-HAL-GpioInit-hal-gpio-handle-t-gpioHandle-hal-gpio-pin-config-t-pinConfig"><a href="#1-10-函数-hal-gpio-status-t-HAL-GpioInit-hal-gpio-handle-t-gpioHandle-hal-gpio-pin-config-t-pinConfig" class="headerlink" title="1.10 函数 hal_gpio_status_t HAL_GpioInit(hal_gpio_handle_t gpioHandle, hal_gpio_pin_config_t *pinConfig)"></a>1.10 函数 hal_gpio_status_t HAL_GpioInit(hal_gpio_handle_t gpioHandle, hal_gpio_pin_config_t *pinConfig)</h3><p>**<u>这是用提供的配置，初始化GPIO引脚的功能实现</u>**。</p>
<p><em><u><strong>该函数使用<code>gpioHandle</code>参数表示GPIO引脚的句柄和使用<code>pinConfig</code>参数表示引脚的配置的指针。</strong></u></em></p>
<p>该函数首先断言<code>gpioHandle</code>和<code>pinConfig</code>参数不为null，并且<code>gpioHandle</code>参数的大小至少与<code>hal_gpio_state_t</code>结构的大小一样。然后将<code>gpioHandle</code>参数转换为指向<code>hal_gpio_state_t</code>结构的指针<code>gpioState</code>，该结构包含有关GPIO引脚状态的信息。</p>
<ol>
<li><p>如果启用冲突检查<code>HAL_GPIO_CONFLICT_CHECK_ENABLE</code>，则该函数搜索GPIO引脚的链表，以确保指定端口和引脚没有冲突。如果发现冲突，则该函数返回<code>kStatus_HAL_GpioPinConflict</code>。</p>
</li>
<li><p>然后，该函数使用<code>HAL_GpioAddItem</code>函数将GPIO引脚添加到GPIO引脚的链表中，<u><strong>并使用<code>GPIO_PinInit</code>函数设置GPIO方向和其他配置选项</strong></u>。</p>
</li>
<li><p>最后，如果初始化成功，该函数返回<code>kStatus_HAL_GpioSuccess</code>。</p>
</li>
</ol>
<h3 id="1-11-函数-hal-gpio-status-t-HAL-GpioDeinit-hal-gpio-handle-t-gpioHandle"><a href="#1-11-函数-hal-gpio-status-t-HAL-GpioDeinit-hal-gpio-handle-t-gpioHandle" class="headerlink" title="1.11 函数 hal_gpio_status_t HAL_GpioDeinit(hal_gpio_handle_t gpioHandle)"></a>1.11 函数 hal_gpio_status_t HAL_GpioDeinit(hal_gpio_handle_t gpioHandle)</h3><p>此函数负责**==取消初始化 GPIO 引脚==**。</p>
<p>它接收 GPIO 引脚的句柄，该句柄是在使用 <code>HAL_GpioInit</code> 函数初始化引脚时获得的。 </p>
<ol>
<li>首先，该函数使用断言检查输入 <code>gpioHandle</code> 是否不为 <code>NULL</code>。 </li>
<li>接下来，它使用 <code>gpioHandle</code> 获取指向 <code>GPIO</code> 状态结构的指针。</li>
<li>然后，如果 GPIO 引脚配置为输入引脚，则该函数通过使用 <code>kHAL_GpioInterruptDisable</code> 参数调用 <code>HAL_GpioSetTriggerMode</code> 来**<u>==禁用其中断触发模式==</u>**。 </li>
<li>最后，函数使用<code>HAL_GpioRemoveItem</code>函数从链表<code>s_GpioHead</code>中移除<code>GPIO管脚状态</code>，返回<code>kStatus_HAL_GpioSuccess</code>表示操作成功。</li>
</ol>
<h3 id="1-12-函数-hal-gpio-status-t-HAL-GpioGetInput-hal-gpio-handle-t-gpioHandle-uint8-t-pinState"><a href="#1-12-函数-hal-gpio-status-t-HAL-GpioGetInput-hal-gpio-handle-t-gpioHandle-uint8-t-pinState" class="headerlink" title="1.12 函数 hal_gpio_status_t HAL_GpioGetInput(hal_gpio_handle_t gpioHandle, uint8_t *pinState)"></a>1.12 函数 hal_gpio_status_t HAL_GpioGetInput(hal_gpio_handle_t gpioHandle, uint8_t *pinState)</h3><p>**<u>==此函数获取配置为输入的 GPIO 引脚的当前状态==</u>**。</p>
<p>它需要一个 GPIO 引脚的句柄（表示为 <code>hal_gpio_handle_t</code> 类型）和一个指向变量的指针来<strong>存储引脚状态</strong>。 </p>
<p>在函数内部，它首先断言 gpioHandle 和 pinState 参数不为 NULL。**<u>==然后它将 gpioHandle 转换为 hal_gpio_state_t 类型并使用 <code>GPIO_PinRead</code> 函数读取引脚状态。 GPIO_PinRead函数返回一个uint32_t类型，转换为uint8_t类型存储在<code>pinState</code>变量中。==</u>**最后函数返回kStatus_HAL_GpioSuccess表示操作成功。</p>
<h3 id="1-13-函数-hal-gpio-status-t-HAL-GpioSetOutput-hal-gpio-handle-t-gpioHandle-uint8-t-pinState"><a href="#1-13-函数-hal-gpio-status-t-HAL-GpioSetOutput-hal-gpio-handle-t-gpioHandle-uint8-t-pinState" class="headerlink" title="1.13 函数 hal_gpio_status_t HAL_GpioSetOutput(hal_gpio_handle_t gpioHandle, uint8_t pinState)"></a>1.13 函数 hal_gpio_status_t HAL_GpioSetOutput(hal_gpio_handle_t gpioHandle, uint8_t pinState)</h3><p>**<u>此函数设置 GPIO 引脚的输出状态</u>**。</p>
<p>它将要配置的 GPIO 引脚的句柄和<strong>指定要设置的输出状态（高电平或低电平）的值作为输入</strong>。 </p>
<p>该函数首先检查 GPIO 句柄是否为 NULL。然后它将句柄转换为 hal_gpio_state_t 指针并使用它来获取 GPIO 端口和引脚号。</p>
<p>最后，它使用 <code>GPIO_PinWrite</code> 函数设置 GPIO 引脚的输出状态，**<u>该函数将 GPIO 端口、引脚号和输出值作为输入</u>**。 该函数返回一个状态代码以指示操作是否成功。</p>
<h3 id="1-14-函数-hal-gpio-status-t-HAL-GpioInstallCallback-hal-gpio-handle-t-gpioHandle，-hal-gpio-callback-t-callback-void-callbackParam"><a href="#1-14-函数-hal-gpio-status-t-HAL-GpioInstallCallback-hal-gpio-handle-t-gpioHandle，-hal-gpio-callback-t-callback-void-callbackParam" class="headerlink" title="1.14 函数 hal_gpio_status_t HAL_GpioInstallCallback(hal_gpio_handle_t gpioHandle， hal_gpio_callback_t callback, void *callbackParam)"></a>1.14 函数 hal_gpio_status_t HAL_GpioInstallCallback(hal_gpio_handle_t gpioHandle， hal_gpio_callback_t callback, void *callbackParam)</h3><p>**<u>==此函数将回调函数及其关联参数安装到给定句柄指定的 GPIO 引脚==</u>**。 </p>
<p>该函数接受三个参数： </p>
<ul>
<li><code>gpioHandle</code>：<u>将要安装其回调函数的 GPIO 引脚</u>的句柄。 </li>
<li><code>callback</code>：指向将要安装的回调函数的<u>函数指针</u>。 </li>
<li><code>callbackParam</code>：指向<u>将要传递给回调函数的参数</u>的空指针。</li>
</ul>
<p>该函数首先断言 gpioHandle 不为 NULL。然后它将句柄转换为 <code>hal_gpio_state_t</code> 指针，**<u>并将 hal_gpio_state_t 结构的 <code>callbackParam</code> 和 <code>callback</code> 字段分别设置为 callbackParam 和 callback 的值。</u>**</p>
<p>最后，该函数返回 kStatus_HAL_GpioSuccess。 </p>
<p>安装回调函数后，<u><em>当在 GPIO 引脚上触发中断时，GPIO 驱动程序可以调用它</em></u>。 </p>
<p>GPIO 驱动在回调函数被调用时会将 <code>callbackParam</code> 参数传给回调函数。</p>
<p><strong>应用程序可以使用此参数将上下文信息传递给回调函数</strong>。</p>
<h3 id="1-15-函数-hal-gpio-status-t-HAL-GpioGetTriggerMode-hal-gpio-handle-t-gpioHandle-hal-gpio-interrupt-trigger-t-gpioTrigger"><a href="#1-15-函数-hal-gpio-status-t-HAL-GpioGetTriggerMode-hal-gpio-handle-t-gpioHandle-hal-gpio-interrupt-trigger-t-gpioTrigger" class="headerlink" title="1.15 函数 hal_gpio_status_t HAL_GpioGetTriggerMode(hal_gpio_handle_t gpioHandle, hal_gpio_interrupt_trigger_t *gpioTrigger)"></a>1.15 函数 hal_gpio_status_t HAL_GpioGetTriggerMode(hal_gpio_handle_t gpioHandle, hal_gpio_interrupt_trigger_t *gpioTrigger)</h3><p>**<u>==该函数用于获取某个GPIO引脚的中断触发方式==</u>**。</p>
<p>该函数有两个参数：gpioHandle 和 gpioTrigger。 </p>
<ul>
<li>gpioHandle是GPIO引脚的句柄，用于标识GPIO引脚。</li>
<li>gpioTrigger 是一个<strong>指向 <code>hal_gpio_interrupt_trigger_t</code> 类型变量的指针，将用于返回 GPIO 引脚的中断触发模式</strong>。</li>
</ul>
<p>该函数首先检查 gpioHandle 参数是否有效。然后它将 gpioHandle 参数转换为指向 hal_gpio_state_t 结构的指针，该结构是 GPIO 驱动程序的内部状态结构。</p>
<p>**<u>==然后该函数检查 GPIO 引脚是否配置为输入引脚，如果不是，则返回错误==</u>**。 </p>
<p>最后，**<u>==该函数从 <code>hal_gpio_state_t</code> 结构中获取 GPIO 引脚的中断触发模式，并将其存储在 gpioTrigger 参数中==</u>**。</p>
<p>如果函数成功完成，它会返回 kStatus_HAL_GpioSuccess。</p>
<h3 id="1-16-函数-hal-gpio-status-t-HAL-GpioSetTriggerMode-hal-gpio-handle-t-gpioHandle-hal-gpio-interrupt-trigger-t-gpioTrigger"><a href="#1-16-函数-hal-gpio-status-t-HAL-GpioSetTriggerMode-hal-gpio-handle-t-gpioHandle-hal-gpio-interrupt-trigger-t-gpioTrigger" class="headerlink" title="1.16 函数 hal_gpio_status_t HAL_GpioSetTriggerMode(hal_gpio_handle_t gpioHandle, hal_gpio_interrupt_trigger_t gpioTrigger)"></a>1.16 函数 hal_gpio_status_t HAL_GpioSetTriggerMode(hal_gpio_handle_t gpioHandle, hal_gpio_interrupt_trigger_t gpioTrigger)</h3><p>此函数设置 GPIO 引脚的中断触发模式。</p>
<p>它接受 GPIO 引脚的句柄，以及所需的中断触发模式。</p>
<ol>
<li>该函数首先检查引脚的方向是否未设置为输出，**<u><em>因为中断触发只能用于输入引脚</em></u>**。</li>
<li>然后它将给定的触发模式映射到硬件平台的相应中断配置值。**<u>它设置 GPIO 引脚的触发模式，并在 NVIC（嵌套向量中断控制器）中启用相应的中断</u>**，优先级为 <code>HAL_GPIO_ISR_PRIORITY</code>（可能在代码库的其他地方定义）。</li>
<li>最后，它返回一个状态代码，指示操作是成功还是遇到错误。</li>
</ol>
<h3 id="1-17-函数-hal-gpio-status-t-HAL-GpioWakeUpSetting-hal-gpio-handle-t-gpioHandle-uint8-t-enable"><a href="#1-17-函数-hal-gpio-status-t-HAL-GpioWakeUpSetting-hal-gpio-handle-t-gpioHandle-uint8-t-enable" class="headerlink" title="1.17 函数 hal_gpio_status_t HAL_GpioWakeUpSetting(hal_gpio_handle_t gpioHandle, uint8_t enable)"></a>1.17 函数 hal_gpio_status_t HAL_GpioWakeUpSetting(hal_gpio_handle_t gpioHandle, uint8_t enable)</h3><p><strong><u>==该函数是 GPIO 驱动程序的一部分，用于启用/禁用 GPIO 引脚的唤醒功能。==</u></strong></p>
<p>当设备处于低功耗模式时，如果特定 GPIO 引脚上的唤醒功能已启用，则它可以被该引脚上的信号唤醒。 </p>
<p>该函数有两个参数，一个 GPIO 句柄和一个启用标志。 </p>
<blockquote>
<p>GPIO 句柄用于标识要配置的特定 GPIO 引脚，而启用标志用于指定是启用还是禁用唤醒功能。 </p>
</blockquote>
<ol>
<li>该函数首先断言 GPIO 句柄不为 NULL。</li>
<li>**<u>然后检查GPIO引脚方向是否输出。如果输出方向，则返回错误</u>**。</li>
<li>然后它检查启用标志是否为 0，这意味着禁用唤醒功能。如果启用标志为 0，则返回错误。否则，它返回成功。</li>
</ol>
<p>总的来说，该函数用于配置GPIO引脚的唤醒功能，确保输入参数有效。</p>
<h3 id="1-18-函数-hal-gpio-status-t-HAL-GpioEnterLowpower-hal-gpio-handle-t-gpioHandle"><a href="#1-18-函数-hal-gpio-status-t-HAL-GpioEnterLowpower-hal-gpio-handle-t-gpioHandle" class="headerlink" title="1.18 函数 hal_gpio_status_t HAL_GpioEnterLowpower(hal_gpio_handle_t gpioHandle)"></a>1.18 函数 hal_gpio_status_t HAL_GpioEnterLowpower(hal_gpio_handle_t gpioHandle)</h3><p><code>HAL_GpioEnterLowpower</code> 的实现似乎是一个placeholder占位符函数，它返回<code>kStatus_HAL_GpioSuccess</code>而不执行任何实际操作。</p>
<p><strong><u>==此函数很可能旨在由 HAL 库的用户实现，以提供特定于其应用程序的低功耗功能。==</u></strong></p>
<h3 id="1-19-函数-hal-gpio-status-t-HAL-GpioExitLowpower-hal-gpio-handle-t-gpioHandle"><a href="#1-19-函数-hal-gpio-status-t-HAL-GpioExitLowpower-hal-gpio-handle-t-gpioHandle" class="headerlink" title="1.19 函数 hal_gpio_status_t HAL_GpioExitLowpower(hal_gpio_handle_t gpioHandle)"></a>1.19 函数 hal_gpio_status_t HAL_GpioExitLowpower(hal_gpio_handle_t gpioHandle)</h3><p>**<u>==此函数负责在退出低功耗模式后将 GPIO 引脚恢复为之前的配置==</u>**。</p>
<p>它以一个 GPIO 句柄作为输入并返回一个状态代码，指示操作是否成功。 </p>
<ul>
<li>该函数首先断言 GPIO 句柄有效。</li>
<li>然后它从句柄中检索 GPIO 状态，并使用引脚方向（输入或输出）和默认值 0 初始化一个新的 GPIO 引脚配置对象。 <ul>
<li>如果之前将引脚配置为输出，则新配置对象中的引脚方向将设置为输出。</li>
</ul>
</li>
<li>然后，该函数使用 <code>GPIO_PinInit</code> 函数使用新配置初始化 GPIO 引脚。 <ul>
<li>如果该引脚之前被配置为输入，则该函数调用 <code>HAL_GpioSetTriggerMode</code> 函数来**<u>恢复进入低功耗模式之前设置的中断触发模式</u>**。</li>
</ul>
</li>
<li>最后，函数返回一个状态码，表示操作成功。</li>
</ul>
<h2 id="2-fsl-adapter-gpio-h"><a href="#2-fsl-adapter-gpio-h" class="headerlink" title="2.  fsl_adapter_gpio.h"></a>2.  fsl_adapter_gpio.h</h2><h3 id="2-1-引言"><a href="#2-1-引言" class="headerlink" title="2.1. 引言"></a>2.1. 引言</h3><p>这是用于 GPIO（通用输入/输出）接口的 HAL（硬件抽象层）头文件的开头。它从许可证和标题保护开始。 </p>
<ul>
<li>header包括 <code>fsl_common.h</code>，它是在不同 SDK（软件开发工具包）组件之间共享的通用实用函数、结构和宏的集合。</li>
<li>此外，如果定义了 <code>SDK_OS_FREE_RTOS</code>，它会包含 <code>FreeRTOS.h</code>，这是 FreeRTOS 操作系统的头文件。 </li>
<li>header guard 定义为 <code>HAL_GPIO_H</code> 以防止多次包含同一头文件。</li>
</ul>
<p>头文件为 GPIO 适配器提供定义和结构，它是位于供应商 (NXP) 提供的低级 GPIO 驱动程序之上的抽象层。 该文件提供了以下定义： </p>
<ul>
<li>GPIO适配器版本 </li>
<li>GPIO 冲突检查使能 </li>
<li>GPIO适配器句柄大小 </li>
<li>GPIO句柄定义宏 </li>
<li>GPIO 适配器 ISR 优先级 </li>
<li>GPIO 句柄类型 (hal_gpio_handle_t) </li>
<li>GPIO回调函数类型(hal_gpio_callback_t) </li>
<li>GPIO 中断触发类型 (hal_gpio_interrupt_trigger_t) </li>
<li>GPIO 状态代码 (hal_gpio_status_t) </li>
<li>GPIO 方向类型 (hal_gpio_direction_t) </li>
<li>GPIO 引脚配置结构 (hal_gpio_pin_config_t)</li>
</ul>
<p>这个头文件定义了 GPIO 适配器，它是一个抽象 GPIO 接口的硬件特定细节的驱动程序。驱动程序提供 API 来配置和控制设备的 GPIO 引脚，例如**<u>设置引脚的方向、读取或写入其值以及在引脚上启用中断</u>**。 该文件以一些标准 C 语言定义开头，包括 GPIO 适配器句柄、回调函数、中断触发器、状态和方向的类型定义。这些类型在整个 GPIO 适配器驱动程序 API 中使用，以提供清晰一致的接口。 </p>
<p>该文件还定义了一些宏，包括 GPIO 适配器驱动程序的版本号、GPIO 适配器句柄的大小以及启用或禁用 GPIO 冲突检查的标志。 最后，该文件包括 <code>fsl_common.h</code> 头文件，它提供了在 Freescale/NXP SDK 软件中使用的通用宏和定义，以及 <code>FreeRTOS.h</code> 头文件，它为正在使用的 FreeRTOS 操作系统提供 API。</p>
<p>这是 GPIO（通用输入/输出）适配器的头文件，用于配置和控制MCU上的 GPIO 引脚。 该文件定义了几种类型，包括 <code>hal_gpio_handle_t</code>、<code>hal_gpio_callback_t</code>、<code>hal_gpio_interrupt_trigger_t</code>、<code>hal_gpio_status_t</code>、<code>hal_gpio_direction_t </code>和 <code>hal_gpio_pin_config_t</code>。 </p>
<ul>
<li><code>hal_gpio_handle_t</code>是指向GPIO适配器句柄的指针，</li>
<li><code>hal_gpio_callback_t</code>是用于回调的函数指针，</li>
<li><code>hal_gpio_interrupt_trigger_t</code>定义了中断触发器，</li>
<li><code>hal_gpio_status_t</code>定义了GPIO适配器的状态，</li>
<li><code>hal_gpio_direction_t</code>定义了GPIO引脚的方向，</li>
<li><code>hal_gpio_pin_config_t</code>是一个保存配置的结构GPIO 引脚的设置。</li>
</ul>
<p>头文件还包含宏，例如 </p>
<ul>
<li><code>FSL_GPIO_ADAPTER_VERSION</code> 指示驱动程序的版本，<code>HAL_GPIO_CONFLICT_CHECK_ENABLE</code> 启用/禁用 GPIO 冲突检查，以及</li>
<li><code>HAL_GPIO_HANDLE_SIZE </code>定义 GPIO 适配器句柄的大小。 </li>
<li>此外，头文件定义了一个宏 <code>GPIO_HANDLE_DEFINE</code> 来定义一个 4 字节对齐的 GPIO 句柄</li>
<li>和一个宏 <code>HAL_GPIO_ISR_PRIORITY</code> 来定义 GPIO ISR（中断服务程序）的优先级。</li>
</ul>
<h3 id="2-2-预先初始化引脚-void-HAL-GpioPreInit-void"><a href="#2-2-预先初始化引脚-void-HAL-GpioPreInit-void" class="headerlink" title="2.2 预先初始化引脚 void HAL_GpioPreInit(void)"></a>2.2 预先初始化引脚 void HAL_GpioPreInit(void)</h3><p>此函数初始化位于内存的 <code>.bss</code> 部分中的静态变量。这通常由 IDE 自动完成，但如果在自动清理 <code>.bss</code> 部分之前使用 GPIO 适配器，则可以使用此功能。 用户通常不需要调用此 API。代码注释中提供了一个示例来演示如何使用它。</p>
<ul>
<li>首先，调用 HAL_GpioPreInit() 函数，</li>
<li>然后使用 GPIO_HANDLE_DEFINE 宏定义 GPIO 句柄。</li>
<li>然后，使用所需的 GPIO 引脚配置定义并初始化 hal_gpio_pin_config_t 结构。</li>
<li>最后，调用 HAL_GpioInit() 函数以使用先前定义的 GPIO 句柄以指定配置初始化 GPIO 引脚。</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HAL_GpioPreInit();</span><br><span class="line">GPIO_HANDLE_DEFINE(g_GpioHandle);</span><br><span class="line"><span class="type">hal_gpio_pin_config_t</span> config;</span><br><span class="line">    config.direction = kHAL_GpioDirectionOut;</span><br><span class="line">    config.port = <span class="number">0</span>;</span><br><span class="line">    config.pin = <span class="number">0</span>;</span><br><span class="line">    config.level = <span class="number">0</span>;</span><br><span class="line">HAL_GpioInit((<span class="type">hal_gpio_handle_t</span>)g_GpioHandle, &amp;config);</span><br></pre></td></tr></tbody></table></figure>



<h3 id="2-3-初始化-hal-gpio-status-t-HAL-GpioInit-hal-gpio-handle-t-gpioHandle-hal-gpio-pin-config-t-pinConfig"><a href="#2-3-初始化-hal-gpio-status-t-HAL-GpioInit-hal-gpio-handle-t-gpioHandle-hal-gpio-pin-config-t-pinConfig" class="headerlink" title="2.3 初始化 hal_gpio_status_t HAL_GpioInit(hal_gpio_handle_t gpioHandle, hal_gpio_pin_config_t *pinConfig);"></a>2.3 初始化 hal_gpio_status_t HAL_GpioInit(hal_gpio_handle_t gpioHandle, hal_gpio_pin_config_t *pinConfig);</h3><p>这是 GPIO（通用输入/输出）模块中的一个函数，它使用**<u>==用户定义的设置初始化 GPIO 实例==</u>**。该函数有两个参数： </p>
<ul>
<li>gpioHandle：指向调用者分配的大小为<code>HAL_GPIO_HANDLE_SIZE</code>的内存空间的指针。句柄应该是 4 字节对齐的。用户可以通过两种方式定义句柄：<ul>
<li>使用 <code>GPIO_HANDLE_DEFINE(gpioHandle) </code></li>
<li>或 <code>uint32_t gpioHandle[((HAL_GPIO_HANDLE_SIZE + sizeof(uint32_t) - 1U) / sizeof(uint32_t))]</code></li>
</ul>
</li>
<li><code>pinConfig</code>：指向 <code>hal_gpio_pin_config_t</code> 类型的用户定义配置结构的指针，**<u>该结构保存 GPIO 的配置。该结构有四个字段</u>**： <ul>
<li>direction：GPIO的方向，输出可以设置为<code>kHAL_GpioDirectionOut</code>，输入可以设置为<code>kHAL_GpioDirectionIn</code>。 </li>
<li>port：GPIO 端口号。 </li>
<li>pin：GPIO 引脚号。 </li>
<li>level：**<u>GPIO的初始值，可设置为0或1</u>**。</li>
</ul>
</li>
<li>该函数返回以下状态代码之一： <ul>
<li>kStatus_HAL_GpioError：初始化 GPIO 时发生错误。 </li>
<li>kStatus_HAL_GpioPinConflict：pinConfig 传递的pin 和port 对已经初始化，所以conflict。</li>
<li>kStatus_HAL_GpioSuccess：GPIO 初始化成功。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GPIO_HANDLE_DEFINE(g_GpioHandle);</span><br><span class="line"><span class="type">hal_gpio_pin_config_t</span> config;</span><br><span class="line">config.direction = kHAL_GpioDirectionOut;</span><br><span class="line">config.port = <span class="number">0</span>;</span><br><span class="line">config.pin = <span class="number">0</span>;</span><br><span class="line">config.level = <span class="number">0</span>;</span><br><span class="line">HAL_GpioInit((<span class="type">hal_gpio_handle_t</span>)g_GpioHandle, &amp;config);</span><br></pre></td></tr></tbody></table></figure>



<h3 id="2-4-取消初始化-HAL-GpioDeinit-hal-gpio-handle-t-gpioHandle"><a href="#2-4-取消初始化-HAL-GpioDeinit-hal-gpio-handle-t-gpioHandle" class="headerlink" title="2.4 取消初始化 HAL_GpioDeinit(hal_gpio_handle_t gpioHandle)"></a>2.4 取消初始化 HAL_GpioDeinit(hal_gpio_handle_t gpioHandle)</h3><p><code>HAL_GpioDeinit</code> 函数用于取消初始化 GPIO 实例。**<u>==它禁用触发模式==</u>**。 </p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">hal_gpio_status_t</span> <span class="title function_">HAL_GpioDeinit</span><span class="params">(<span class="type">hal_gpio_handle_t</span> gpioHandle)</span>;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>gpioHandle：GPIO句柄指针。句柄应该是 4 字节对齐的，因为某些设备不支持未对齐的访问。</li>
</ul>
<p>如果 GPIO 去初始化成功，该函数返回 kStatus_HAL_GpioSuccess。</p>
<h3 id="2-5-获取输入引脚状态-HAL-GpioGetInput"><a href="#2-5-获取输入引脚状态-HAL-GpioGetInput" class="headerlink" title="2.5 获取输入引脚状态 HAL_GpioGetInput()"></a>2.5 获取输入引脚状态 HAL_GpioGetInput()</h3><p>此函数用于获取输入 GPIO 引脚的当前状态。通过 pinState 指针参数读取并返回引脚状态。 这是一个示例用法：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GPIO_HANDLE_DEFINE(g_GpioHandle);</span><br><span class="line"><span class="type">uint8_t</span> pinState;</span><br><span class="line">HAL_GpioInit((<span class="type">hal_gpio_handle_t</span>)g_GpioHandle, &amp;config);</span><br><span class="line">HAL_GpioGetInput((<span class="type">hal_gpio_handle_t</span>)g_GpioHandle, &amp;pinState);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>==<u>在此示例中，已使用 <code>HAL_GpioInit() </code>初始化 GPIO 引脚，然后使用 <code>HAL_GpioGetInput() </code>读取引脚的当前状态。引脚的当前状态通过 <code>pinState</code> 指针参数返回。</u>==</strong></p>
<h3 id="2-6-设置输出电平HAL-GpioSetOutput"><a href="#2-6-设置输出电平HAL-GpioSetOutput" class="headerlink" title="2.6 设置输出电平HAL_GpioSetOutput"></a>2.6 设置输出电平HAL_GpioSetOutput</h3><p>这是 <code>HAL_GpioSetOutput</code> 函数的函数定义。此函数**<u>==将 GPIO 引脚的电压电平设置为指定值==</u>**。下面简单解释一下参数和返回值： </p>
<ul>
<li>gpioHandle：这是一个指向GPIO句柄对象的指针，表示设备上的一个特定的GPIO引脚。句柄应该是 4 字节对齐的，以确保正确的内存访问。 </li>
<li>pinState：这是一个 8 位无符号整数，表示 GPIO 引脚的所需电压电平。值为 0 表示低电压电平，而值为 1 表示高电压电平。 </li>
<li>返回值：该函数返回一个hal_gpio_status_t类型的值，代表操作成功或失败。如果操作成功，函数返回 kStatus_HAL_GpioSuccess。</li>
</ul>
<h3 id="2-7-获取Pin中断触发模式-HAL-GpioGetTriggerMode"><a href="#2-7-获取Pin中断触发模式-HAL-GpioGetTriggerMode" class="headerlink" title="2.7 获取Pin中断触发模式 HAL_GpioGetTriggerMode"></a>2.7 获取Pin中断触发模式 HAL_GpioGetTriggerMode</h3><p>函数 <code>HAL_GpioGetTriggerMode</code> **<u>==获取引脚中断触发模式==</u>**。</p>
<p>触发模式由枚举类型<code>hal_gpio_interrupt_trigger_t</code>表示，可以是以下值之一: </p>
<ul>
<li>kHAL_GpioInterruptTriggerLowLevel：低电平触发中断 </li>
<li>kHAL_GpioInterruptTriggerHighLevel：高电平触发中断 </li>
<li>kHAL_GpioInterruptTriggerRisingEdge：上升沿触发中断 </li>
<li>kHAL_GpioInterruptTriggerFallingEdge：下降沿触发中断 </li>
<li>kHAL_GpioInterruptTriggerEitherEdge：在任一边沿触发中断</li>
</ul>
<p>**<u>==如果引脚配置为输出，函数返回 kStatus_HAL_GpioError==</u>**。 </p>
<p>该函数有两个参数： </p>
<ul>
<li>gpioHandle：GPIO句柄指针。 </li>
<li>gpioTrigger：保存管脚触发模式值的指针。</li>
</ul>
<p>该函数返回以下状态代码之一： </p>
<ul>
<li>kStatus_HAL_GpioSuccess：引脚触发模式已成功检索。 </li>
<li>kStatus_HAL_GpioError：引脚配置为输出。</li>
</ul>
<h3 id="2-8-设置触发模式-HAL-GpioSetTriggerMode"><a href="#2-8-设置触发模式-HAL-GpioSetTriggerMode" class="headerlink" title="2.8 设置触发模式 HAL_GpioSetTriggerMode"></a>2.8 设置触发模式 HAL_GpioSetTriggerMode</h3><p>HAL_Gpio* 函数是硬件抽象层 (HAL) 库的一部分，用于与微控制器上的 GPIO（通用输入/输出）引脚进行交互。 GPIO 引脚可用于多种用途，例如控制 LED 或读取按钮按下情况。 </p>
<ul>
<li>HAL_GpioPreInit() 函数用于初始化位于 .bss 部分的静态变量。该变量将用于存储 GPIO 引脚的配置信息。通常不需要此功能，仅在某些情况下使用，例如在 .bss 部分被 IDE 自动清理之前使用 GPIO 适配器时。 </li>
<li>HAL_GpioInit() 函数使用 GPIO 句柄和用户配置结构初始化 GPIO 实例。用户可以配置配置结构来设置引脚方向（输入或输出）、端口号、引脚号和初始引脚电平。 gpioHandle参数是一个指向调用者分配的内存空间的指针，用于存储GPIO实例的信息。 </li>
<li>HAL_GpioDeinit() 函数通过禁用触发模式来取消初始化 GPIO 实例。当不再需要 GPIO 引脚时，应调用此函数。 </li>
<li>HAL_GpioGetInput() 函数获取输入 GPIO 引脚的电压电平。电压电平在 pinState 参数中返回。 </li>
<li>HAL_GpioSetOutput() 函数设置输出 GPIO 引脚的电压电平。所需的电压电平在 pinState 参数中传递。 </li>
<li>HAL_GpioGetTriggerMode() 函数获取 GPIO 引脚的中断触发模式。触发模式决定了是什么导致在引脚上产生中断，例如上升沿或下降沿。触发模式在 gpioTrigger 参数中返回。 </li>
<li>HAL_GpioSetTriggerMode() 函数设置 GPIO 引脚的中断触发模式。所需的触发模式在 gpioTrigger 参数中传递。</li>
</ul>
<h3 id="2-9-HAL-GpioInstallCallback"><a href="#2-9-HAL-GpioInstallCallback" class="headerlink" title="2.9 HAL_GpioInstallCallback()"></a>2.9 HAL_GpioInstallCallback()</h3><p>该函数用于**<u>为GPIO模块安装一个回调函数及其对应的参数</u>**。</p>
<p>当引脚状态中断发生时，驱动会通过调用已安装的回调函数通知上层。 GPIO管脚状态可以通过回调函数内部调用函数<code>HAL_GpioGetInput()</code>获取。 该函数采用三个参数： </p>
<ul>
<li>gpioHandle：GPIO句柄指针。 </li>
<li>callback：要安装的回调函数。 </li>
<li>callbackParam：回调函数的参数。</li>
</ul>
<p>该函数返回一个状态代码，指示回调是否已成功安装。如果成功，返回值为 kStatus_HAL_GpioSuccess。</p>
<h3 id="2-10-HAL-GpioWakeUpSetting"><a href="#2-10-HAL-GpioWakeUpSetting" class="headerlink" title="2.10 HAL_GpioWakeUpSetting()"></a>2.10 HAL_GpioWakeUpSetting()</h3><p><code>HAL_GpioWakeUpSetting</code> 函数**<u>==启用或禁用 GPIO 唤醒功能==</u>**。</p>
<p>此功能允许系统**<u>通过 GPIO 引脚状态的变化从低功耗模式唤醒</u>**。 </p>
<p>该函数采用 gpioHandle 参数，该参数是指向 GPIO 句柄的指针。句柄应该是 4 字节对齐的，因为某些设备不支持未对齐的访问。 </p>
<p>enable 参数是一个布尔值，指示是启用还是禁用唤醒功能。值 1 启用该功能，而值 0 禁用它。 </p>
<p>该函数返回一个 hal_gpio_status_t 状态码，其中 kStatus_HAL_GpioSuccess 表示成功，kStatus_HAL_GpioError 表示发生错误。</p>
<h3 id="2-11-HAL-GpioEnterLowpower"><a href="#2-11-HAL-GpioEnterLowpower" class="headerlink" title="2.11 HAL_GpioEnterLowpower()"></a>2.11 HAL_GpioEnterLowpower()</h3><p>根据提供的函数定义，函数 HAL_GpioEnterLowpower() 用于准备进入低功耗。但是，函数定义中并未指定为低功耗准备所采取的确切步骤。该**<u>==函数很可能会执行必要的步骤将 GPIO 模块置于低功耗状态==</u>**，例如禁用未使用的引脚或将时钟频率设置为较低的值。</p>
<p>在定义此函数的 HAL 库的文档或源代码中可能会提供更多信息。</p>
<h3 id="2-12-HAL-GpioExitLowpower"><a href="#2-12-HAL-GpioExitLowpower" class="headerlink" title="2.12 HAL_GpioExitLowpower()"></a>2.12 HAL_GpioExitLowpower()</h3><p>这两个函数 HAL_GpioEnterLowpower 和 HAL_GpioExitLowpower 似乎是用于管理低功耗的更大系统的一部分。 GPIO 模块用于控制系统的唤醒行为，这些函数可能分别用于准备 GPIO 模块进入低功耗模式和从低功耗模式恢复。 </p>
<p>HAL_GpioEnterLowpower 可以执行诸如禁用 GPIO 中断、将 GPIO 引脚设置为低功耗状态或降低 GPIO 模块的时钟频率以节省电量等操作。 </p>
<p>HAL_GpioExitLowpower 可能会执行 HAL_GpioEnterLowpower 的反向操作，例如恢复 GPIO 中断，将 GPIO 引脚恢复到之前的状态，或者提高 GPIO 模块的时钟频率以恢复正常操作。 </p>
<p>总体而言，这些功能似乎是用于管理功耗和唤醒行为的更大系统的一部分，而不是独立的 GPIO 功能。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-09-01T09:27:18.000Z" title="9/1/2022, 9:27:18 AM">2022-09-01</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a></span><span class="level-item">几秒读完 (大约82个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F2-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BB%8B%E7%BB%8D/">嵌入式系统2--开发板介绍</a></p><div class="content"><h1 id="嵌入式系统2–开发板介绍"><a href="#嵌入式系统2–开发板介绍" class="headerlink" title="嵌入式系统2–开发板介绍"></a>嵌入式系统2–开发板介绍</h1><h2 id="T-PAD开发板简介"><a href="#T-PAD开发板简介" class="headerlink" title="T-PAD开发板简介"></a>T-PAD开发板简介</h2><p>核心板+底板：</p>
<p><img src="/./%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F2/TPAD.PNG" alt="TPAD"></p>
<p>核心板：</p>
<p><img src="/./%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F2/%E6%A0%B8%E5%BF%83%E6%9D%BF.PNG" alt="核心板"></p>
<ul>
<li>DDRAM: 1G</li>
<li>EMMC: 掉电不丢失，相当于硬盘，8G</li>
</ul>
<p>接线方式：</p>
<p><img src="/./%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F2/%E6%8E%A5%E7%BA%BF%E6%96%B9%E5%BC%8F.PNG" alt="接线方式"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-09-01T08:50:08.000Z" title="9/1/2022, 8:50:08 AM">2022-09-01</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a></span><span class="level-item">2 分钟读完 (大约328个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F1-%E7%AE%80%E4%BB%8B/">嵌入式系统1--简介</a></p><div class="content"><h1 id="嵌入式系统1–简介"><a href="#嵌入式系统1–简介" class="headerlink" title="嵌入式系统1–简介"></a>嵌入式系统1–简介</h1><h2 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h2><p>是不是RTOS，由<strong>任务调度策略</strong>决定：</p>
<ul>
<li>Windows等OS不是实时操作系统，因为，CPU为任务分配时间片，到了时间不管有没有执行完都换下一个任务，所有任务都有机会运行到，是<strong>时间线轮转策略</strong>；</li>
<li>RTOS有uCosⅡ、VxWorks等，CPU对多个任务分配优先级，执行完一个才执行下一个，是<strong>基于优先级的调度策略</strong>；</li>
</ul>
<h2 id="硬件最小系统"><a href="#硬件最小系统" class="headerlink" title="硬件最小系统"></a>硬件最小系统</h2><ul>
<li>处理器<ul>
<li>51</li>
<li>arm</li>
<li>powerpc</li>
<li>MIPS</li>
</ul>
</li>
<li>电源电路</li>
<li>复位电路</li>
<li>时钟电路</li>
<li>存储电路<ul>
<li>RAM：掉电丢失<ul>
<li>SRAM</li>
<li>DRAM：需要周期性刷新，不然不断电也丢数据</li>
</ul>
</li>
<li>ROM：只读，不能写，掉电不丢失<ul>
<li>PROM：只能写一次</li>
<li>EPROM：可擦除，所以可写入多次，写入前必须擦除，擦除需要紫外线；</li>
<li>EEPROM：先擦后写，电可擦除，容量小，2k左右</li>
</ul>
</li>
<li>FLASH:多次写入，先擦后写<ul>
<li>NORFlash</li>
<li>NANDFlash</li>
<li>EMMC</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="嵌入式软件开发模式"><a href="#嵌入式软件开发模式" class="headerlink" title="嵌入式软件开发模式"></a>嵌入式软件开发模式</h2><ul>
<li>开发主机（Host） — 也叫<strong>上位机</strong><ul>
<li>代码编写、编译</li>
</ul>
</li>
<li>目标板（Target） — 也叫<strong>下位机</strong><ul>
<li>代码运行</li>
</ul>
</li>
<li>连接介质</li>
</ul>
<p><img src="/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F1/1.PNG"></p>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.png" alt="Gavin"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Gavin</p><p class="is-size-6 is-block">Embedded &amp; IC Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shanghai, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">122</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">35</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">58</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/DustOfStars/" target="_blank" rel="me noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/DustOfStars/"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Configuration/"><span class="level-start"><span class="level-item">Configuration</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/IC%E9%AA%8C%E8%AF%81/"><span class="level-start"><span class="level-item">IC验证</span></span><span class="level-end"><span class="level-item tag">15</span></span></a><ul><li><a class="level is-mobile" href="/categories/IC%E9%AA%8C%E8%AF%81/%E8%B7%AF%E7%A7%91V0/"><span class="level-start"><span class="level-item">路科V0</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Leetcode/"><span class="level-start"><span class="level-item">Leetcode</span></span><span class="level-end"><span class="level-item tag">8</span></span></a><ul><li><a class="level is-mobile" href="/categories/Leetcode/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="level-start"><span class="level-item">数据结构</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/NLP/"><span class="level-start"><span class="level-item">NLP</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/NLP/EDA/"><span class="level-start"><span class="level-item">EDA</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/NLP/Numpy/"><span class="level-start"><span class="level-item">Numpy</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/NLP/Torch/"><span class="level-start"><span class="level-item">Torch</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/NLP/Torch/Model/"><span class="level-start"><span class="level-item">Model</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/NLP%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/"><span class="level-start"><span class="level-item">NLP代码详解</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/NXP/"><span class="level-start"><span class="level-item">NXP</span></span><span class="level-end"><span class="level-item tag">16</span></span></a><ul><li><a class="level is-mobile" href="/categories/NXP/KW38/"><span class="level-start"><span class="level-item">KW38</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/NXP/RT1050/"><span class="level-start"><span class="level-item">RT1050</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/NXP/RT1052/"><span class="level-start"><span class="level-item">RT1052</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/NXP/RT1052/%E9%87%8E%E7%81%AB/"><span class="level-start"><span class="level-item">野火</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/Plugins/"><span class="level-start"><span class="level-item">Plugins</span></span><span class="level-end"><span class="level-item tag">12</span></span></a><ul><li><a class="level is-mobile" href="/categories/Plugins/Analytics/"><span class="level-start"><span class="level-item">Analytics</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Plugins/Comment/"><span class="level-start"><span class="level-item">Comment</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Plugins/Donation/"><span class="level-start"><span class="level-item">Donation</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Plugins/Other/"><span class="level-start"><span class="level-item">Other</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Plugins/Search/"><span class="level-start"><span class="level-item">Search</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Plugins/Share/"><span class="level-start"><span class="level-item">Share</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ReferenceManual/"><span class="level-start"><span class="level-item">ReferenceManual</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/STL/"><span class="level-start"><span class="level-item">STL</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/STL/forward-list/"><span class="level-start"><span class="level-item">forward_list</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/STL/vector/"><span class="level-start"><span class="level-item">vector</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Widgets/"><span class="level-start"><span class="level-item">Widgets</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"><span class="level-start"><span class="level-item">嵌入式</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"><span class="level-start"><span class="level-item">代码解读</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/%E4%B8%AD%E6%96%AD/"><span class="level-start"><span class="level-item">中断</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">工具</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7/vim/"><span class="level-start"><span class="level-item">vim</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E5%AD%97IC/"><span class="level-start"><span class="level-item">数字IC</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%8B%B1%E8%AF%AD/"><span class="level-start"><span class="level-item">英语</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-11T06:11:12.000Z">2023-12-11</time></p><p class="title"><a href="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/">RT1050开发--第7节 RT1050 硬件启动模式</a></p><p class="categories"><a href="/categories/NXP/">NXP</a> / <a href="/categories/NXP/RT1050/">RT1050</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-11T05:37:29.000Z">2023-12-11</time></p><p class="title"><a href="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC6%E8%8A%82-rt1050-memory-mapping/">RT1050开发--第6节 RT1050 Memory Mapping</a></p><p class="categories"><a href="/categories/NXP/">NXP</a> / <a href="/categories/NXP/RT1050/">RT1050</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-05T14:28:25.000Z">2023-12-05</time></p><p class="title"><a href="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC5%E8%8A%82-rt1050-hello-world-%EF%BC%88keil-v5%EF%BC%89/">RT1050开发--第5节 RT1050 Hello World （Keil V5）</a></p><p class="categories"><a href="/categories/NXP/">NXP</a> / <a href="/categories/NXP/RT1050/">RT1050</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-04T14:33:36.000Z">2023-12-04</time></p><p class="title"><a href="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC4%E8%8A%82-rt1050%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">RT1050开发--第4节 RT1050开发环境搭建</a></p><p class="categories"><a href="/categories/NXP/">NXP</a> / <a href="/categories/NXP/RT1050/">RT1050</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-04T14:31:32.000Z">2023-12-04</time></p><p class="title"><a href="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC3%E8%8A%82-rt1050%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/">RT1050开发--第3节 RT1050硬件平台</a></p><p class="categories"><a href="/categories/NXP/">NXP</a> / <a href="/categories/NXP/RT1050/">RT1050</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/12/"><span class="level-start"><span class="level-item">十二月 2023</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/11/"><span class="level-start"><span class="level-item">十一月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/03/"><span class="level-start"><span class="level-item">三月 2023</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">十月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/09/"><span class="level-start"><span class="level-item">九月 2022</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/08/"><span class="level-start"><span class="level-item">八月 2022</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/07/"><span class="level-start"><span class="level-item">七月 2022</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">五月 2022</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">四月 2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">三月 2022</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/02/"><span class="level-start"><span class="level-item">二月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/01/"><span class="level-start"><span class="level-item">一月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/01/"><span class="level-start"><span class="level-item">一月 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/01/"><span class="level-start"><span class="level-item">一月 2017</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/01/"><span class="level-start"><span class="level-item">一月 2016</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/01/"><span class="level-start"><span class="level-item">一月 2015</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2014/01/"><span class="level-start"><span class="level-item">一月 2014</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2013/01/"><span class="level-start"><span class="level-item">一月 2013</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/ARM/"><span class="tag">ARM</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BLE/"><span class="tag">BLE</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BOARD/"><span class="tag">BOARD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Demo/"><span class="tag">Demo</span><span class="tag">19</span></a></div><div class="control"><a class="tags has-addons" href="/tags/FLASH/"><span class="tag">FLASH</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GPIO/"><span class="tag">GPIO</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GPIO%E4%B8%AD%E6%96%AD/"><span class="tag">GPIO中断</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Getting-Started/"><span class="tag">Getting Started</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/IC%E9%AA%8C%E8%AF%81/"><span class="tag">IC验证</span><span class="tag">15</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Icarus-User-Guide/"><span class="tag">Icarus User Guide</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/"><span class="tag">Icarus用户指南</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LED/"><span class="tag">LED</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Leetcode/"><span class="tag">Leetcode</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Model/"><span class="tag">Model</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NLP/"><span class="tag">NLP</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NXP/"><span class="tag">NXP</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Numpy/"><span class="tag">Numpy</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PDF/"><span class="tag">PDF</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RAM/"><span class="tag">RAM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ROM/"><span class="tag">ROM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RT1050/"><span class="tag">RT1050</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RT1052/"><span class="tag">RT1052</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ReferenceManual/"><span class="tag">ReferenceManual</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/STL/"><span class="tag">STL</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/System-Verilog/"><span class="tag">System Verilog</span><span class="tag">15</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Thread/"><span class="tag">Thread</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Torch/"><span class="tag">Torch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/UART/"><span class="tag">UART</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/UVM/"><span class="tag">UVM</span><span class="tag">15</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ZigBee/"><span class="tag">ZigBee</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pyTorch/"><span class="tag">pyTorch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vector/"><span class="tag">vector</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vim/"><span class="tag">vim</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"><span class="tag">二分查找</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"><span class="tag">代码解读</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"><span class="tag">代码随想录</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BD%8E%E5%8A%9F%E8%80%97%E8%AE%A1%E6%97%B6%E5%99%A8LPTMR/"><span class="tag">低功耗计时器LPTMR</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"><span class="tag">双指针</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%91%A8%E6%9C%9F%E4%B8%AD%E6%96%AD%E8%AE%A1%E6%97%B6%E5%99%A8PIT/"><span class="tag">周期中断计时器PIT</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9F%BA%E7%A1%80/"><span class="tag">基础</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AE%9E%E6%97%B6%E6%97%B6%E9%92%9FRTC/"><span class="tag">实时时钟RTC</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"><span class="tag">嵌入式</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B7%A5%E5%85%B7/"><span class="tag">工具</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%80%BB%E7%BB%93/"><span class="tag">总结</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E6%8E%A2%E7%B4%A2/"><span class="tag">数据探索</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E7%BB%84/"><span class="tag">数组</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/"><span class="tag">有序数组的平方</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"><span class="tag">滑动窗口</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"><span class="tag">移除元素</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD100%E5%8F%A5/"><span class="tag">考研英语100句</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%8B%B1%E8%AF%AD/"><span class="tag">英语</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%E2%85%A1/"><span class="tag">螺旋矩阵Ⅱ</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E6%97%B6%E5%99%A8PWM%E6%A8%A1%E5%9D%97TPM/"><span class="tag">计时器PWM模块TPM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B/"><span class="tag">设计流程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%93%BE%E8%A1%A8/"><span class="tag">链表</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"><span class="tag">长度最小的子数组</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="DustOfStars" height="28"></a><p class="is-size-7"><span>&copy; 2024 Gavin</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Discuss on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus/discussions"><i class="fas fa-comments"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>