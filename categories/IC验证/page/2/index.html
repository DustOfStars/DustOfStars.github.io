<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><title>分类: IC验证 - DustOfStars</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#f7f7f7"><meta name="application-name" content="DustOfStars"><meta name="msapplication-TileImage" content="/img/favicon.png"><meta name="msapplication-TileColor" content="#f7f7f7"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="DustOfStars"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Go ahead, and believe in yourself."><meta property="og:type" content="blog"><meta property="og:title" content="DustOfStars"><meta property="og:url" content="https://dustofstars.github.io/"><meta property="og:site_name" content="DustOfStars"><meta property="og:description" content="Go ahead, and believe in yourself."><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://dustofstars.github.io/img/og_image.png"><meta property="article:author" content="Gavin"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://dustofstars.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://dustofstars.github.io"},"headline":"DustOfStars","image":["https://dustofstars.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Gavin"},"publisher":{"@type":"Organization","name":"DustOfStars","logo":{"@type":"ImageObject","url":"https://dustofstars.github.io/img/logo.png"}},"description":"Go ahead, and believe in yourself."}</script><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-72437521-5" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-72437521-5');</script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0">
<style>.not-gallery-item { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .not-gallery-item > span { position: relative; z-index: 10; }  .not-gallery-item img, .not-gallery-item .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .not-gallery-item img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .not-gallery-item-fallback { color: inherit; } .not-gallery-item-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="DustOfStars" type="application/atom+xml">
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="DustOfStars" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Discuss on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus/discussions"><i class="fas fa-comments"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">IC验证</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-05-08T06:11:19.000Z" title="5/8/2022, 6:11:19 AM">2022-05-08</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/IC%E9%AA%8C%E8%AF%81/">IC验证</a></span><span class="level-item">1 小时读完 (大约7333个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%974%E9%AA%8C%E8%AF%81%E7%9A%84%E8%AE%A1%E5%88%92/">芯片验证漫游指南4验证的计划</a></p><div class="content"><h1 id="1-计划概述"><a href="#1-计划概述" class="headerlink" title="1 计划概述"></a>1 计划概述</h1><p>在选择验证方法和构建验证环境之前，需要搞清楚验证计划是什么。在展开设计之前，设计人员和验证人员会阅读功能描述文档，以理解设计的各项功能为前提，考虑如何实现或验证各项功能。如果功能描述本身不清晰，则需要与系统人员沟通来修改功能描述文档；如果设计和验证双方人员对某一项功能理解有分歧，也需要与系统人员的解释保持统一。完成验证计划后，还需要对其进行修改吗？答案是肯定的。</p>
<p>因为在实际项目执行过程中功能描述文档和设计不断更新，直到流片前都有可能在进行更新，验证人员需要做好相应的验证计划更新。所以，验证计划的生命在设计被构建之前就诞生了，伴随着设计的周期，直到流片。验证计划从创建到执行分为以下几个阶段：</p>
<ol>
<li>创建验证计划；</li>
<li>选择验证方法；</li>
<li>人力资源调配；</li>
<li>构建验证平台和环境组件；</li>
<li>开发测试用例。</li>
</ol>
<p>创建一份验证计划是首要的任务，通过收集下列材料可以更好地组织出有价值的计划：</p>
<ul>
<li>结构功能描述；</li>
<li>设计的各种操作使用模式；</li>
<li>在正常输入和错误输入情形下设计的行为；</li>
<li>设计的接口；</li>
<li>在一些边界情况下设计的行为；</li>
<li>设计在实际使用中的场景描述。</li>
</ul>
<p>这些资料通常可以从硬件功能描述和系统文档中找到。同时，也可以从硅后测试、固件开发人员那里得到设计的实际使用配置情况。合理的验证计划可以为芯片开发带来很多好处：</p>
<ul>
<li>使得设计和验证人员对功能描述文档的理解和翻译保持一致。</li>
<li>将自然语言描述的功能通过可测试的语言来描述。</li>
<li>可以更合理地评估出工作量、人力安排和进度节点。</li>
<li>为验证人员提供清晰的验证目标、任务和进度安排。</li>
<li>为功能文档提供反馈，修改文档中不明确、有歧义的描述。</li>
</ul>
<p>从更宽泛的意义上来看，一份验证计划几乎囊括所有与验证相关的东西，其中不只包括要验证的设计功能，还包括验证方法、人力安排、进度评估，等等。验证计划的生命期很长，在实际环境中，很多因素会不断影响计划的更新，这些可能的因素包括：</p>
<ul>
<li>会有不同人员更新验证计划。一份充分的验证计划，需要系统、设计、验证、软件人员给出意见，共同参与制定。</li>
<li>需要更新上百上千的测试用例，并与计划中的待测功能映射。</li>
<li>考虑选择不同的验证方法。针对不同的设计，<strong>需要考虑选择动态仿真、形式验证或者硬件加速方法</strong>。如果采用两种以上的方法，还需要<strong>考虑如何实现技术平台上的兼容和跨越式复用</strong>。</li>
<li>如果有新的设计要求，需要更新计划，同时设法把对人力和进度的影响降低到最小。设计人员在设计的过程中仍然可能收到新的功能需求，一旦确定要添加新的功能，就需要考虑额外的人力和进度受到的影响。</li>
<li>如果有多个组参与验证，则需要考虑如何协调。对于大型的SoC 项目，一般会有多个功能组参与，甚至他们可能工作在不同的城市，这时，协调组与组之间的工作并综合出整体进度结果就很重要了。</li>
</ul>
<p>在早期制定一份验证计划，随着设计更新和验证进度跟踪，提高验证的质量，降低项目的风险。同时，验证计划对人力和时间进度的合理估计，也使得验证的流程和进度更加透明。</p>
<h1 id="2-计划的内容"><a href="#2-计划的内容" class="headerlink" title="2 计划的内容"></a>2 计划的内容</h1><p>在制定验证计划的具体过程中，我们将技术部分和项目部分都考虑进来。从技术角度而言，需要<strong>考虑的有验证的功能点、验证的层次、测试用例、验证方法和覆盖率要求</strong>。从项目管理角度，也需要考虑使用的工具、人力安排、进度安排和风险评估。</p>
<h2 id="2-1-技术的视角"><a href="#2-1-技术的视角" class="headerlink" title="2.1 技术的视角"></a>2.1 技术的视角</h2><h3 id="验证的功能"><a href="#验证的功能" class="headerlink" title="验证的功能"></a>验证的功能</h3><p>需要验证的功能点来自于功能描述文档，设计和验证人员在阅读文档的过程中，会将设计的功能、参数、性能从自然语言拆分转化为一个个可以单独验证的功能点，并用定性定量的语言描述这些功能。</p>
<p>我们将功能点按照优先级分为：</p>
<ul>
<li>基本功能：通常包括时钟、电源、复位、寄存器访问和基本特性，这些可以在模块级完成验证。</li>
<li>互动功能：一些需要同其他模块互动的特性，需要在更高层次的子系统级或芯片级完成验证。</li>
<li>次要功能：通常这些功能在项目后期完成验证，如性能验证、效能验证。即使它们没有通过验证要求，也不会对芯片造成致命影响。</li>
</ul>
<h3 id="验证的层次"><a href="#验证的层次" class="headerlink" title="验证的层次"></a>验证的层次</h3><p>结合验证的功能点，需要清楚该功能点是否可以在较低的层次完成验证。从验证效率和激励自由度来看，我们应该<strong>尽量在较低的层次验证更多的功能点。在较高的层次，如芯片级，应该侧重于系统集成测试</strong>。</p>
<h3 id="验证方法"><a href="#验证方法" class="headerlink" title="验证方法"></a>验证方法</h3><p>需要考虑采取<strong>何种验证方法，动态仿真、形式验证还是硬件加速？采取什么样的透明度，黑盒、白盒还是灰盒？采用定向测试还是随机约束激励</strong>？在第3章，我们对比了不同方法适用的场景。</p>
<h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><p>有了验证的目标，选择合适的层次和方法，在完成了验证平台搭建以后，我们就需要考虑如何利用验证平台给出适当的激励，检查测试结果。</p>
<h3 id="覆盖率要求"><a href="#覆盖率要求" class="headerlink" title="覆盖率要求"></a>覆盖率要求</h3><p>覆盖率是<strong>衡量激励生成种类和功能点验证的量化指标</strong>。无论通过何种验证方法，都需要采用覆盖率来确保给出了足够多的激励类型，并且设计的边界和内部穷历了可能的状态。除了给出合法的激励之外，<strong>也需要考虑给出一些错误的激励，测试设计的稳定性和纠错能力</strong>。</p>
<h2 id="2-2-项目的视角"><a href="#2-2-项目的视角" class="headerlink" title="2.2 项目的视角"></a>2.2 项目的视角</h2><h3 id="工具选择"><a href="#工具选择" class="headerlink" title="工具选择"></a>工具选择</h3><p>对项目而言，需要通过验证计划中选择的方法考虑选择相应的工具，包括：</p>
<ul>
<li>仿真工具；</li>
<li>形式验证工具；</li>
<li>验证IP；</li>
<li>断言IP；</li>
<li>调试器；</li>
<li>硬件加速器；</li>
<li>高层次验证语言（HVL,High-level Verification Language）。</li>
</ul>
<p>选定验证方法和工具后，接下来需要考虑安排具备合适技能的验证人员完成工作。</p>
<h3 id="人力安排"><a href="#人力安排" class="headerlink" title="人力安排"></a>人力安排</h3><h3 id="进度安排"><a href="#进度安排" class="headerlink" title="进度安排"></a>进度安排</h3><h3 id="风险评估"><a href="#风险评估" class="headerlink" title="风险评估"></a>风险评估</h3><p>在项目执行中，无论是设计人员、验证人员还是项目经理，都面临诸多不确定的因素：</p>
<ul>
<li>芯片结构不稳定因素。在项目执行后期，如果突然面临结构的变化，肯定给相关设计带来很大影响，而验证任务量和时间也需要改变。</li>
<li>工具的不稳定因素。在新的项目中，我们倾向于使用新的工具版本，因为它们会带来新的性能提升和特性；而新版本工具的使用需要适应期，并非一帆风顺。替换工具时面临的工具替换成本、环境流程更新、技术培训都要更大一些。</li>
<li>人力的不稳定因素。我们希望在项目中人员结构可以稳定，这样就不会出现模块的验证人员被临时替换、加大验证风险的问题。同时，如果一个人投入到两个以上的项目，那么他在不同项目中的精力分配也需要考虑进来。</li>
<li>模块交付时间的不稳定因素。验证的展开与设计的交付时间密不可分，HDL 设计的交付时间对验证进度的影响非常大。所以，在计划初期，验证经理应从设计团队那里获取清晰的交付时间，在此基础上做进度和人力安排。</li>
</ul>
<p>在清楚了一份验证计划中需要包含的各项因素之后，接下来就要考虑如何在项目初期准备这样一份关键计划，以及在项目执行过程中怎样针对不确定因素相应地更新计划，确保项目的进度受到的影响最小。</p>
<h1 id="3-计划的实现"><a href="#3-计划的实现" class="headerlink" title="3 计划的实现"></a>3 计划的实现</h1><p>一份细致的验证计划包括项目动向、更新内容和工程进度，面对人力资源总是紧张的窘境，只有清晰的计划才能够合理运用人力资源，保证时间和人力的平衡。在4.2节，我们列举了项目中诸多不稳定因素，它们使得验证计划需要时常保持更新，给出合理的安排，这样的过程就蕴含着从计划到实践再到反馈，最后到修改计划的周期。计划变更的周期在不断地发生，如图4.1所示。</p>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%974%E9%AA%8C%E8%AF%81%E7%9A%84%E8%AE%A1%E5%88%92/%E9%AA%8C%E8%AF%81%E8%AE%A1%E5%88%92%E7%9A%84%E5%91%A8%E6%9C%9F.png" class="" title="验证计划的周期">

<p>在对设计进行验证以后，我们需要<strong>衡量验证的完备性</strong>，这时需要对<strong>覆盖率进行分析</strong>。当发现覆盖率无法满足要求时，要针对覆盖率漏洞更改验证计划并添加新的测试用例。通过这样的反馈环路，循序渐进地逼近功能验证的收敛目标。那么如何制定验证计划呢？通常按照如下步骤：</p>
<ol>
<li>邀请相关人员参加会议；</li>
<li>开会讨论；</li>
<li>确定测试场景；</li>
<li>创建验证环境。</li>
</ol>
<h2 id="3-1-邀请相关人员"><a href="#3-1-邀请相关人员" class="headerlink" title="3.1 邀请相关人员"></a>3.1 邀请相关人员</h2><p>邀请与系统设计和功能模块相关的人员参加会议，共同讨论。参加会议的人员一般包括：</p>
<ul>
<li>设计人员；</li>
<li>验证人员；</li>
<li>硅后测试人员；</li>
<li>软件开发人员；</li>
<li>系统人员；</li>
<li>验证经理（或项目经理）。</li>
</ul>
<p>这些人员在看待如何验证一个模块的问题上各有不同的角度。例如，系统人员关注功能描述是否被实现，测试场景是否可以覆盖到这些功能点；设计人员考虑具体的设计细节是否会被测试到；软件开发人员关心如何配置寄存器来使用某一项功能。我们将这些利益相关者看待验证模块的不同角度总结在表4.1。</p>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%974%E9%AA%8C%E8%AF%81%E7%9A%84%E8%AE%A1%E5%88%92/%E9%AA%8C%E8%AF%81%E8%AE%A1%E5%88%92%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BA%BA%E5%91%98.png" class="" title="验证计划的相关人员">

<p>在实际工作中，我们不一定可以面面俱到地同时邀请到这么多的项目角色，而且，这么多不同的角色一起开会，沟通起来难免存在一些障碍和分歧。所以，实际的建议可以变成分阶段进行：</p>
<ol>
<li>验证经理、设计人员和验证人员一起开会，确定大致需要验证的功能点、进度和人力安排。</li>
<li>系统人员、设计人员和验证人员一起沟通对功能描述文档存在的分歧，确保理解一致。</li>
<li>设计人员、验证人员、硅后测试人员和软件人员一起为模块应用的实际场景添加测试用例。</li>
</ol>
<h2 id="3-2-开会讨论"><a href="#3-2-开会讨论" class="headerlink" title="3.2 开会讨论"></a>3.2 开会讨论</h2><p>在开会讨论前，作为会议的组织者，需要搞清楚开会的目的和议题分别是什么。</p>
<ul>
<li>验证计划的内容组成；</li>
<li>需要确定的验证功能点。</li>
</ul>
<p>同时，需要一份合适的验证计划模板指导会议讨论的内容。验证计划的模板（或组织结构）应包括下面的内容：</p>
<ul>
<li>设计功能简要描述；</li>
<li>硬件实现框图；</li>
<li>待验证的功能点；</li>
<li>验证环境搭建；</li>
<li>测试用例构成；</li>
<li>编译脚本和回归测试；</li>
<li>覆盖率分析。</li>
</ul>
<p>在计划模板中，会议前需要了解的是功能描述和硬件实现方案；开会中只需要讨论和确定哪些功能点是要验证的、哪些是不需要验证的。至于验证环境搭建和测试用例构成，则是验证工作展开以后更新到计划中。面对不同背景的项目人员，我们在会议中需要注意几个方面，以使会议最终可以取得预期的结果。这些值得注意的方面包括：</p>
<ul>
<li>由于与会人员具有不同的背景，在讨论中遇到分歧时，应换位思考，从对方的角度看待这个问题，给予理解。</li>
<li>需要覆盖设计在实际过程中软件的使用情况和在系统中的角色扮演，探明真实运用场景。</li>
<li>弄明白哪些功能是核心功能、哪些功能是次要功能。</li>
<li>确定所有需要验证的功能点，以及声明哪些功能点不需要验证、哪些场景是伪场景（不实际的运用）。</li>
</ul>
<p>只有不同系统层面的人相互沟通，充分交流不同视角和观点，我们对验证功能点及其在系统运用中的认识才会更加清晰。</p>
<h2 id="3-3-确定测试场景"><a href="#3-3-确定测试场景" class="headerlink" title="3.3 确定测试场景"></a>3.3 确定测试场景</h2><p>经过细致的讨论，可以确定哪些功能点需要测试，继而模拟实际场景给出激励。在考虑如何生成测试场景时，我们需要思考下面几个地方：</p>
<ul>
<li>针对某些功能点，我们如何给出特定的测试场景。这些场景是否同实际情况一致或者类似，比如我们给出的时钟信号频率是否同设计要求的频率一致，不同时钟之间的同步异步关系是否参照系统要求。</li>
<li>需要测试的场景，需要待验设计的哪些功能模块参与。这种情况一般在模块级测试中，往往需要较多的子模块参与进来，而随着测试的层次升高，我们需要唤醒使能的模块数量就逐渐减少了。我们在构建测试用例前，心中已经模拟出测试序列，明确了参与进来的模块，以及如何配置寄存器、等待某些状态信号完成下一步功能设置，直到最后完成整个功能测试。</li>
<li>如果一些场景涉及电源开关，要考虑是否在PA（Power Aware）场景中完成测试。</li>
<li>如果一些场景与性能有关，要考虑如何发送大规模的数据量实现压力数据传输场景。</li>
<li>针对不同的功能点，要考虑选择合适的验证层次，以及对应的验证方法。</li>
</ul>
<h2 id="3-4-创建验证环境"><a href="#3-4-创建验证环境" class="headerlink" title="3.4 创建验证环境"></a>3.4 创建验证环境</h2><p>确定测试场景和验证方法后，要<strong>构建验证环境产生激励来实现场景</strong>。构建环境时，<strong>针对设计模块的接口信号需要实现对应的激励发生组件，通过控制协调不同的激励组件来构建场景</strong>。在实现激励发生组件中，需要考虑接口信号是标准总线还是系统控制信号。如果有可以复用的验证资源，那么会节省构建平台的时间。有些时候，如果接口是标准总线，且没有可复用的验证资源，就需要自己实现总线激励模型。从成本的角度来看，只需要实现设计中所纳入的总线特性即可。例如，如果设计实现的是 AHB 总线协议，但是只支持单次的读写访问，那么我们在实现AHB激励组件时，不必要实现AHB协议的全部，而只需要实现单次读写协议，满足设计接口的协议要求即可。</p>
<p><strong>同时要考虑收集数据和对比结果，这就需要监视信号组件和检查组件的实现。监视信号组件的主要任务是监视设计的接口信号以及内部信号。如果是总线接口，那么需要在解析总线的情况下将观察到的数据打包整理；如果是控制信号或者其他信号，要按照信号的定义，在特定事件下捕捉有效信号。监视信号组件最终将分析整理好的数据发送给检查组件，由检查组件进行数据比较，给出比较信息和报告，最终判定测试是否成功</strong>。</p>
<h1 id="4-计划的进程评估"><a href="#4-计划的进程评估" class="headerlink" title="4 计划的进程评估"></a>4 计划的进程评估</h1><p>在验证过程中需要不断地更新验证进度，从各项参数综合评估验证的完备性。通过收集以下信息来评估验证计划的实施进程：</p>
<ul>
<li>回归测试通过率（regression pass rate）；</li>
<li>代码覆盖率（code coverage）；</li>
<li>断言覆盖率（assertion coverage）；</li>
<li>功能覆盖率（function coverage）；</li>
<li>缺陷曲线（bug curve）。</li>
</ul>
<p>接下来分别介绍这些信息的收集和分析过程。</p>
<h2 id="4-1-回归测试通过率"><a href="#4-1-回归测试通过率" class="headerlink" title="4.1 回归测试通过率"></a>4.1 回归测试通过率</h2><p>回归测试表是<strong>将测试设计所有功能点的用例合并</strong>为一个测试集。回归测试表的<strong>主要功能是在设计经过缺陷修复或性能提高后测试原有的所有功能点，确保设计正常工作</strong>。这种往复的测试方式不仅在于确保新的设计变化不影响之前的功能，也可以用来避免修改后的设计对别的模块造成的功能失效。所以，设计的维护不仅按照设计需求提供新的功能，也要保证新功能不影响原有的功能。不同的公司和团队之间，往往有着不同的回归测试工具和方法。这里需要注意的是工具和脚本的版本可能会对回归测试造成影响。例如，如果切换了仿真器的版本，那么可能出现新的问题需要调试，所以在项目后期阶段设计趋于稳定时，不建议切换工具或脚本的版本。另外一个重要的地方是，<strong>回归测试表中的测试用例需确保是可以重现激励场景</strong>的。这一点对于定向测试方法（例如C/C++）是容易实现的，而<strong>对随机约束测试而言，要在测试中显示出每次测试使用的随机种子（random seed），只有通过这个特定的种子，才可以重新产生之前的激励，跟踪调试失败的用例</strong>。</p>
<p>我们将回归测试的流程归纳为图4.2。值得注意的是，<strong>在某一个层次的回归测试通过，接下来可以向上迁移到新的验证层次，展开新的回归测试流程；或者在设计需求发生变化时，重新从模块级开始递交测试表</strong>。</p>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%974%E9%AA%8C%E8%AF%81%E7%9A%84%E8%AE%A1%E5%88%92/%E5%9B%9E%E5%BD%92%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B.png" class="" title="回归测试流程">

<p>不同层次的回归测试表，每个测试用例的仿真时间消耗也不一样。一般而言，模块级是最快的，到了芯片级，一个回归测试表如果包含数千规模的测试用例，往往需要若干天时间才能最终运行完毕得出结果。所以，不同层次、不同设计规模、不同测试场景复杂度，都会影响测试用例的仿真时间。递交测试表的重要因素就是仿真速度，由于考虑到递交测试表主要依靠计算资源和验证结构的性能表现，我们对验证平台的优化和运算资源都会在此时提出更高的要求。因为只有更快速地往复递交和得出结果，才能更快得知新的设计变动是否可靠。</p>
<h2 id="4-2-代码覆盖率"><a href="#4-2-代码覆盖率" class="headerlink" title="4.2 代码覆盖率"></a>4.2 代码覆盖率</h2><p>代码覆盖率是用来衡量RTL代码是否被充分运行的指标，目前的仿真器也都提供方法来收集代码覆盖率，并且进行合并和分析。通过回归测试表，我们可以产生基于测试用例的代码覆盖数据，并且在回归测试完成后，通过合并数据，生成总的数据来分析各个模块的覆盖率情况。常见的代码覆盖率包括：</p>
<ul>
<li>语句覆盖率（statement coverage）：指的是程序的每一行代码是否被执行过。</li>
<li>条件覆盖率（condition coverage）：指的是每个条件中的逻辑操作数被覆盖的情况。</li>
<li>决策覆盖率（branch coverage）：指的是在if,case,while,repeat,forever,for和loop语句中各个分支执行的情况。</li>
<li>事件覆盖率（event coverage）：用来记录某一个事件被触发的次数。</li>
<li>跳转覆盖率（toggle coverage）：用来记录某个设计边界信号数据位的0/1跳转情况，如从0到1，或从1到0的跳转。</li>
<li>状态机覆盖率（finite stage machine coverage）：仿真器的覆盖率功能可以识别出设计中的状态机部分，记录各种状态被进入的次数，以及状态之间的跳转情况。</li>
</ul>
<p>值得注意的一点是，仿真器在收集覆盖率数据的时候会牺牲一些运行效率，这是因为它需要对代码保持“更多的关注”，所以资源消耗要更多一些。我们建议<strong>只在需要收集覆盖率时传入一些仿真命令触发覆盖率收集，而更多情况下不需要传入这些命令，也不需要编译带有支持覆盖率收集的仿真目标</strong>。在项目执行中，<strong>一般在模块级验证节点结束后开始收集模块级的代码覆盖率，在芯片级验证节点结束后收集芯片级的代码覆盖率。在两部分的数据收集都完成后，进行这两个级别的覆盖率数据融合，生成总的数据库</strong>。一般项目中有专人来负责收集和分析覆盖率，各个模块的覆盖率数据分发给相应的验证人员，等待他们分析、过滤或添加新的测试用例，再次递交测试收集新的数据；以此循环往复，提高总体的覆盖率。</p>
<p>通常，我们比较<strong>关注语句覆盖率、决策覆盖率和跳转覆盖率</strong>，各个模块在这三项覆盖率上有相应的指标。只有至少达到了90%以上的覆盖率，才有足够的信心来分析下面的两类覆盖率。</p>
<h2 id="4-3-断言覆盖率"><a href="#4-3-断言覆盖率" class="headerlink" title="4.3 断言覆盖率"></a>4.3 断言覆盖率</h2><p>断言描述本身支持覆盖率收集，一般通过仿真或者硬件加速的方式收集，也可以通过形式验证的工具收集。在常见的仿真中，仿真器记录断言的先决条件是否被触发，以及判断语句成功还是失败。根据选择的验证方法，我们可以将断言覆盖率分为：</p>
<ul>
<li><strong>基于动态仿真或者硬件加速的断言覆盖率</strong>；</li>
<li><strong>基于形式验证的静态断言覆盖率</strong>。</li>
</ul>
<h2 id="4-4-功能覆盖率"><a href="#4-4-功能覆盖率" class="headerlink" title="4.4 功能覆盖率"></a>4.4 功能覆盖率</h2><p>功能覆盖率衡量是否实现设计的各项功能，且是否按预想的行为执行。功能覆盖率关注设计的输入、输出和内部状态，通常以如下方式描述信号采样要求：</p>
<ul>
<li>对于输入，它检测数据端的输入和命令组合类型，以及控制信号与数据传输的组合情况。</li>
<li>对于输出，它检测是否有完整的数据传输类别，以及各种情况的反馈时序。</li>
<li>对于设计内部，需要检查的信号与验证计划中需要覆盖的功能点相对应。通过对信号的单一覆盖、交叉覆盖或时序覆盖来检查功能是否被触发，以及执行是否正确。</li>
</ul>
<h2 id="4-5-缺陷曲线"><a href="#4-5-缺陷曲线" class="headerlink" title="4.5 缺陷曲线"></a>4.5 缺陷曲线</h2><p>验证过程中会不断发现新的设计缺陷，使用缺陷记录表或已有的商业工具将这些缺陷记录下来，提交给设计人员。设计人员在分析缺陷、修复缺陷后，也会修改缺陷记录，并通知验证人员。验证人员递交原有的回归测试，必要时添加新的测试用例，直到所有的测试通过，才能宣布新修复的缺陷是成功的。在缺陷被记录的过程中，我们通过时间坐标和特定时段的缺陷数量绘制出缺陷率曲线。在1.4节中，我们指出了缺陷曲线对验证计划的影响。从图1.8我们看到，<strong>尽早地将缺陷曲线收敛，意味着后期发现缺陷的数量和可能性越小</strong>。有时要当心的是，如果到了验证后期发现了一个基本功能存在重大缺陷，那就是一个危险信号：意味着很可能在之前验证过程中遗漏了一些重要的测试场景。实际项目的经验重复告诉我们，一份详尽准确、不断更新维护的验证计划是迈向成功验证的基石。</p>
<h1 id="5-作者结束语"><a href="#5-作者结束语" class="headerlink" title="5 作者结束语"></a>5 作者结束语</h1><blockquote>
<p>验证计划的制定不只是需要验证师，还需要其他相关领域的同事共同参与。验证师与验证经理对同一份验证计划的关注角度也不相同。在验证前期，整理好的<strong>验证功能测试点会便于验证的回顾</strong>；在验证中期，<strong>验证环境的结构框图让代码变得更加清晰易懂</strong>；在验证尾期，验证师需要<strong>收集回归测试通过率、代码覆盖率、断言覆盖率、功能覆盖率和缺陷曲线</strong>。这些内容将综合构成验证的量化指标，也让验证经理更容易<strong>评估验证的完备性</strong>。</p>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-05-06T14:31:29.000Z" title="5/6/2022, 2:31:29 PM">2022-05-06</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/IC%E9%AA%8C%E8%AF%81/">IC验证</a></span><span class="level-item">2 小时读完 (大约18963个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%973%E9%AA%8C%E8%AF%81%E7%9A%84%E6%96%B9%E6%B3%95/">芯片验证漫游指南3验证的方法</a></p><div class="content"><p>到了目前的阶段，已经无法依赖单一的工具、语言或方法来达到验证的完备性。在实际的验证工作中，需要综合使用多种语言、方法、工具实现此目的。不同的语言、方法、脚本和工具之间没有绝对的优劣之分。比如，<strong>仿真验证协同形式验证一起完善功能覆盖率，也可以通过语言和脚本之间的整合完成一项验证流程</strong>。总而言之，作为一名有经验的工程师，需要掌握现有的各种方法和工具，通过合理的选择，“保质、高效、低耗”地完成验证任务。所以，我们在这里将验证方法分为若干类，梳理目前主流的验证方法和工具。</p>
<p>主要的验证方法包括：</p>
<ul>
<li>动态仿真（dynamic simulation）；</li>
<li>静态检查（formal check）；</li>
<li>虚拟模型（virtual prototype）；</li>
<li>硬件加速（hardware acceleration）；</li>
<li>电源功耗（power consumption）；</li>
<li>性能评估（performance evaluation）。</li>
</ul>
<p>基于此，我们引入一节“开发环境”，介绍日常的编码环境。所谓“工欲善其事，必先利其器”，一个应手的开发环境，是迈向高效的一步。</p>
<h1 id="1-动态仿真"><a href="#1-动态仿真" class="headerlink" title="1 动态仿真"></a>1 动态仿真</h1><p>动态仿真（dynamic
simulation）: 最常见的验证方式——，是<strong>通过测试序列和激励生成器给入待验设计适当的激励，随着仿真进程的推进，判断输出是否符合预期</strong>。简而言之，我们需要<strong>仿真器</strong>来配合这一项工作，验证人员也需要查看<strong>比较结果和仿真波形</strong>，最终判定测试用例是否通过。按激励生成方式和检查方式，可以将动态仿真进一步划分为：</p>
<ul>
<li>定向测试（directed test）；</li>
<li>随机测试（random test）；</li>
<li>参考模型检查（reference model check）；</li>
<li>断言检查（assertion check）。</li>
</ul>
<p>参考模型一般伴随着定向测试或随机测试，所以我们接下来着重了解定向测试、随机测试和断言检查。</p>
<h1 id="1-1-定向测试"><a href="#1-1-定向测试" class="headerlink" title="1.1 定向测试"></a>1.1 定向测试</h1><p>定向测试 ： 指的是<strong>激励内容在仿真之前已经决定下来，测试用例给出的激励序列不会在下一次提交任务时改变</strong>。</p>
<p>我们日常通过C/C++代码来实现子系统级或芯片系统级的测试，这是因为待验设计往往包含处理器，而且从硅后测试复用的角度来看，我们也倾向于运用C代码来编写高层次的测试用例。从图3.2可以看出，测试用例经过编译，转换为硬件存储器可以读入的文件（一般为二进制格式，主要包含地址和数据两部分）。待验设计经过上电复位（power up and reset），从存储器中读取二进制文件，处理器将二进制数据译码（decoding）为指令和数据，进行运算或存储访问。定向测试最终的数据比较分为两种情况：</p>
<ul>
<li><strong>通过内置的C代码进行数据正确性检查</strong>；</li>
<li><strong>通过外置的参考模型或者其他检查器来进行信号一致性检查</strong>。</li>
</ul>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%973%E9%AA%8C%E8%AF%81%E7%9A%84%E6%96%B9%E6%B3%95/%E5%AE%9A%E5%90%91%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B.png" class="" title="定向测试流程">

<p>有时我们考虑直接将第三方提供的可执行文件或二进制文件作为激励源交给存储器，这就省略了C代码编译的步骤，但这需要相应的运行环境兼容。</p>
<p>将上述定向测试流程与实际项目进行对比，如图3.3所示，<strong>测试用例可以通过C代码交给处理器进行硬件行为的仿真检查。如果模块验证环境中缺少处理器，如何在这一级实现C代码的垂直复用（从模块级到芯片系统级）呢</strong>？</p>
<p>可以考虑下面的步骤：</p>
<ul>
<li>将C代码交给转换器将其转换为文本命令格式；</li>
<li>文本命令格式可以被总线翻译器识别进而转换为总线上的读写操作。</li>
</ul>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%973%E9%AA%8C%E8%AF%81%E7%9A%84%E6%96%B9%E6%B3%95/C%E4%BB%A3%E7%A0%81%E7%9A%84%E5%9E%82%E7%9B%B4%E5%A4%8D%E7%94%A8%E6%96%B9%E6%A1%88.png" class="" title="C代码的垂直复用方案">

<p>上面的步骤中需要引入转换器实现复用，也可以考虑将转换器和总线翻译器通过标准的SystermVerilog C-DPI接口，从而实现良好的复用性。关于如何应用C-DPI接口，读者可以在17.1节获取更多的进行
转换细节。</p>
<p>定向测试一般应用在模块测试的早期或者在系统级芯片测试场景中，它适合于测试设计的基本功能，能直接翻译出验证人员想要的场景。它的<strong>缺陷也很明显，就是每一个定向测试用例在通过之后的重复仿真是冗余的，因为这样无法产生新的测试序列，也不会带来更多的覆盖率</strong>。不过，正因为它的激励序列确定性（determinacy），<strong>定向测试可以用来构成基本测试表，在验证前期完成设计的基本功能检查</strong>。</p>
<h1 id="1-2-随机测试"><a href="#1-2-随机测试" class="headerlink" title="1.2 随机测试"></a>1.2 随机测试</h1><p>与定向测试序列相对的是<strong>随机序列（random sequence）。随机序列通过预先定义的约束，每次随机产生合理的数值，通过激励产生器给出测试序列。图3.4可以说明，与定向测试相比，随机测试可以直接
通过激励生成器发送测试序列</strong>。</p>
<p>产生随机数的方法有很多种，并且有很多语言可以实现。但考虑到灵活地给随机绑定一些约束时，我们就需要特定的语言提供这样的属性，目前常用的语言有SystemVerilog和e语言。从图3.5来自Wilson2014年的调查数据来看，SystemVerilog的使用率大致已经上升到了75%左右。</p>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%973%E9%AA%8C%E8%AF%81%E7%9A%84%E6%96%B9%E6%B3%95/%E9%9A%8F%E6%9C%BA%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B.png" class="" title="随机测试流程">

<p><strong>约束实际上是决定随机激励能否符合接口协议的关键，也是朝向验证合理状态空间的关键。随机约束生成器一般通过静态约束或动态反馈约束给出每一轮的激励</strong>。从图3.6可以看出，在实际的验证环境中，往往有很多对随机约束起控制和反馈作用的因素，它们分别是：</p>
<ul>
<li><strong>静态随机约束</strong>。即默认的约束，一般与激励一起定义，不随测试而变化。</li>
<li>反馈的动态随机约束。在测试过程中通过上一轮的结果来对下一轮随机序列给予反馈，通过额外的偏置约束（biasing constraint）给出更小的随机域（random region）。</li>
<li><strong>待验设计的功能验证开关</strong>。待验设计的功能点有时可以通过测试序列来关联，进而从该序列是否要验证某一项功能来决定某一组随机约束是否生效。</li>
<li><strong>激励的结构成员</strong>。随机激励的成员一般分为接口成员（与设计进行交互）和成员间的逻辑变量（决定成员之间数值关系的变量）。</li>
<li>验证环境的配置参数。如果验证环境是可配置的，那么这些配置参数也可能会影响序列的产生。</li>
<li><strong>验证环境中不同激励组件之间的同步通信</strong>。如果验证环境中包含多个激励组件，那么要实现这些随机组件之间的协同，就需要考虑通过同步通信（synchronization communication）来实现。</li>
</ul>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%973%E9%AA%8C%E8%AF%81%E7%9A%84%E6%96%B9%E6%B3%95/%E9%9A%8F%E6%9C%BA%E7%BA%A6%E6%9D%9F%E7%9A%84%E6%8E%A7%E5%88%B6%E5%92%8C%E5%8F%8D%E9%A6%88%E5%9B%A0%E7%B4%A0.png" class="" title="随机约束的控制和反馈因素">


<h2 id="1-3-基于覆盖率驱动的随机验证"><a href="#1-3-基于覆盖率驱动的随机验证" class="headerlink" title="1.3 基于覆盖率驱动的随机验证"></a>1.3 基于覆盖率驱动的随机验证</h2><p>目前常用的一种随机验证方式是基于覆盖率驱动的，这种方式与3.1.2节提到的影响随机生成的因素<strong>“反馈的动态随机约束”一样，有着类似的反馈控制原理</strong>。从图3.7可以看出，<strong>与常用随机约束验证方式不同的一点是，覆盖率收集器在每次测试中都通过监视器来收集覆盖率（主要指功能覆盖率），将其与已有的覆盖率数据库进行合并，同时根据现有的覆盖率数据库为下一次随机约束给出反馈。这些反馈被用来进一步缩窄随机约束域，使其偏置产生一些序列，覆盖那些未知的功能测试点</strong>。</p>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%973%E9%AA%8C%E8%AF%81%E7%9A%84%E6%96%B9%E6%B3%95/%E5%9F%BA%E4%BA%8E%E8%A6%86%E7%9B%96%E7%8E%87%E9%A9%B1%E5%8A%A8%E7%9A%84%E9%9A%8F%E6%9C%BA%E9%AA%8C%E8%AF%81%E6%B5%81%E7%A8%8B.png" class="" title="基于覆盖率驱动的随机验证流程">



<h2 id="1-4-基于TLM的随机验证"><a href="#1-4-基于TLM的随机验证" class="headerlink" title="1.4 基于TLM的随机验证"></a>1.4 基于TLM的随机验证</h2><p>测试用例可以指定每一次激励的数据内容，也可以在较高层次上指定每一次激励数据包（data packet）的内容。我们在2.1节中介绍了通过TLM在产品定义早期对设计建立模型。<strong>在抽象层次上，TLM比硬件时序行为更高一级，被用来描述设计或验证环境。基于TLM的随机验证方式，指的是在随机环境中使用的最小颗粒是 TLM 级别的数据包。该激励数据包不止包含一个时钟周期给出的激励，而是在更长的时间范围内（一般为一次完整的数据操作，例如完整的数据读写或数据包传输）定义更多且有内在联系的数据</strong>。</p>
<p>TLM验证带来的<strong>好处是，验证人员可以更便捷地描述一些测试场景，更贴近真实的用例</strong>。比如硅后系统测试和固件开发，是基于系统级别的，它们专注的并非单一模块的某一项功能，而是子系统或整个系统的复杂工作模式。从图3.8可以看到，TLM测试抽象级较高，需要由TLM2RTL激励生成器做进一步的转换。将TLM激励生成器进一步放大，可以看到它内部的一些转换模块，包括读写操作、复位操作、中断操作和其他操作。<strong>这些方法一般是根据TLM操作命令经过转换去调用的，我们将这样的激励生成器称为总线功能模型</strong>（BFM,Bus Functional Model）。</p>
<p><strong>BFM的作用是将高抽象级的TLM命令转换为低抽象级的硬件端口时序</strong>。进一步看，在高抽象级到低抽象级的转换中，除了数据抽象度在降低外，激励所用的时间也在转换中被施加到待测接口上。因此，要完成一项 TLM 命令的转换，经常需要数十个甚至数百个时钟周期。</p>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%973%E9%AA%8C%E8%AF%81%E7%9A%84%E6%96%B9%E6%B3%95/%E5%9F%BA%E4%BA%8ETLM%E7%9A%84%E9%9A%8F%E6%9C%BA%E9%AA%8C%E8%AF%81%E6%B5%81%E7%A8%8B.png" class="" title="基于TLM的随机验证流程">

<h2 id="1-5-断言检查"><a href="#1-5-断言检查" class="headerlink" title="1.5 断言检查"></a>1.5 断言检查</h2><p>影响验证产出的一个重要因素是<strong>如何准确地描述功能</strong>。如图3.9所示，清晰的描述可以帮助设计人员更方便地实现设计功能，验证人员也需要检查各种可能的行为是否符合预期。</p>
<p>断言（assertion）提供了这样的特性，它善于针对某一特定的逻辑或时序进行预设，一旦设计的实际行为不符合断言的描述，则给出检查报告。</p>


<p>断言本身不限定于某一种语言或者工具，它的特性可以准确地描述出设计的预期行为。所以有多种实现断言的方法和工具，在过去的20年间，这些被业界支持的基于断言的验证方法和工具如图3.10所示。</p>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%973%E9%AA%8C%E8%AF%81%E7%9A%84%E6%96%B9%E6%B3%95/%E6%94%AF%E6%8C%81%E6%96%AD%E8%A8%80%E7%9A%84%E8%AF%AD%E8%A8%80%E5%92%8C%E5%B7%A5%E5%85%B7%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B.png" class="" title="支持断言的语言和工具的发展历程">

<p>在这里，我们按照断言方法不同的运用将它们分为如下几类：</p>
<ul>
<li>商业开发的断言IP，可用来插入到HDL中做检查，例如CheckWare（0-In/Mentor）。</li>
<li>专门开发的断言语言，例如PSL（Property Specification Language）。</li>
<li>广义的验证模块，不依赖于特定的语言或工具，例如OVL（Open Verification Language/Accellera），这些验证库中含有多个常用的验证模块，可用来在设计中例化。</li>
<li>根据广义的验证语言描述而使用其他语言实现的验证库，例如按照OVL实现的QVL（Questa Verification Library/Mentor）和 OVA（OpenVera Assertion checker library/Synopsys）。</li>
<li>扩展某一种语言的特性，延伸出断言的功能，例如SVA（SystemVerilog Assertion）。</li>
</ul>
<p>可以在验证平台中使用断言，也可以插入到设计中使用断言。<strong>断言可以同时为验证人员和设计人员所用</strong>。使用断言的优势在于以下几个方面：</p>
<ul>
<li>由于断言的位置更贴近于不同功能点的源码位置，这使得相应检查的功能点发生错误时能更快、更清晰地定位出错误源。</li>
<li>断言自身可以表达更长的时序，<strong>覆盖任意长度的功能时序</strong>，这使得它可以在更高的抽象级别描述设计行为。</li>
<li><strong>断言也有覆盖率的功能</strong>，通过断言覆盖率可以建立量化数据来衡量验证进度。</li>
<li>断言可以被直接置入到设计中（无论是设计人员置入还是验证人员置入），这使得断言可以在不同的层次上得到复用，使得它有更久的生命周期和验证延展。</li>
</ul>
<p>这里谈到了断言的复用性，实际上断言的应用场景非常多，且它便捷的即插即用特性使得有多种商业断言 IP 可供植入到验证环境中。下面通过图3.11说明断言应用的场景及其垂直复用的特性。从应用场景来看，典型的断言场景包括：</p>
<ul>
<li>集成连接。例如，片上网络多个发起端和目标端之间的访问路径检查，或者系统集成中各个模块之间的连接关系。</li>
<li>总线协议。针对工业标准总线，有商业验证 IP 可以协助验证设计是否按照总线协议实施。</li>
<li>仲裁机制。仲裁机制中的各种模式通过检查来保证仲裁执行的合理。</li>
<li>数据一致性。对于存储单元，数据的一致性检查可以通过检查端口读写来预期数据的一致性。</li>
<li>数据进出。对于队列设计，也可以建立模型来检查断言。</li>
<li>状态机。检查状态机的跳转是否正常。</li>
<li>输入限定。基于假设的输入限定可以通过断言来判断输入是否符合预期，这对错误源排查也有帮助。</li>
<li>自定义断言。用来检查各个设计的细节，通常这些细节属于设计人员和验证人员关注的功能焦点。</li>
</ul>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%973%E9%AA%8C%E8%AF%81%E7%9A%84%E6%96%B9%E6%B3%95/%E6%96%AD%E8%A8%80%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.png" class="" title="断言的应用场景">

<p>从复用性来看，<strong>断言可以实现从模块级到子系统级再到芯片系统级的垂直复用</strong>。从图3.11可以看出，从单元1在模块级验证时插入的断言“数据进出”和“状态机”，在子系统级和芯片系统级两个环境都可以保持监测检查状态。这一点要<strong>归功于断言可以作为非综合模块被植入到设计中，或者通过绑定的形式嵌入到设计中（不影响设计结构）。在子系统中，新的断言部分“子系统集成”又可以用来检查从单元1与从单元2之间的集成关系，该检查在芯片系统中也可以保留下来</strong>。</p>
<h1 id="2-静态检查"><a href="#2-静态检查" class="headerlink" title="2 静态检查"></a>2 静态检查</h1><p>与动态仿真相对应的是静态检查，它<strong>本身不需要仿真、波形激励，验证人员通过工具的辅助即可以发现设计中存在的问题</strong>。静态检查可细分出更多种类，它们关注的领域各不相同，我们将这些方法概括为：</p>
<ul>
<li>语法检查（syntax check）；</li>
<li>语义检查（linting check）；</li>
<li>跨时钟域检查（CDC,Cross-clock Domain Check）；</li>
<li>形式验证（formal verification）。</li>
</ul>
<h2 id="2-1-语法检查"><a href="#2-1-语法检查" class="headerlink" title="2.1 语法检查"></a>2.1 语法检查</h2><p>如大多数编译器（compiler）自带的功能一样，验证工具<strong>一旦需要建立模型（无论是针对动态仿真还是静态检查的模型），都需要编译器对目标语言提供语法检查</strong>。仿真编译器会帮助检查语法错误，例如<strong>拼写、声明、引用、例化、连接、定义等常见的语法错误</strong>。不同仿真工具对语言标准的解释也可能存在偏差，所以使用不同厂商工具提供的编译器时需注意以下几点：</p>
<ul>
<li>某些不常见的语法使用，在编译器A中可以通过，却不见得在编译器B中也可以通过，这种差别通常跟仿真器的特性和支持有关。如果在设计验证中使用了不同的工具，那么我们要做的应该是让代码（无论是设计代码还是验证代码）满足所有工具的要求，确保它们跟工具
之间保持良好的语法兼容。</li>
<li>语言本身有不同年份的标准，所以需在编译过程中注意加注不同的选项。假如编译器默认按照VHDL93标准来编译VHDL文件，那么当显式声明文件为VHDL87格式时，需要额外加注编译选项。</li>
<li>除了语法检查，编译器也提供其他选项来检查设计代码风格是否符合可综合规范。建议在编译时添加这些选项，以帮助检查设计中较明显的漏洞。</li>
<li>值得注意的是，目前 SystemVerilog2012中的标准并没有全部被编译器支持，而且不同工具的支持程度不尽相同。如果准备使用一个较“偏门”的语言特性，在实现它之前可以查看工具支持文档，或者查看编译结果来获知该特性是否被支持。</li>
</ul>
<p>对初步认识仿真工具的人而言，不同编译器对同一项语法错误给出的错误提示可能也不相同。这里我们给出的建议是：</p>
<ul>
<li>认真阅读错误信息。没错，请你认真阅读错误信息。</li>
<li>在认真阅读无果的情况下，可以根据错误信息的代码，通过工具命令结合错误代码来查看错误信息的具体解释。</li>
<li>如果经过前两个步骤仍然无法解决，请找一位有经验的工程师帮你一起检查错误，并且给你一些如何理解错误、查找语法错误点的方法。</li>
</ul>
<h2 id="2-2-语义检查"><a href="#2-2-语义检查" class="headerlink" title="2.2 语义检查"></a>2.2 语义检查</h2><p>和语法检查相比，语义检查是在<strong>设计可行性</strong>上做深入检查的（当然前提也是首先通过了语法检查）。语义检查是通过专用的工具来协助完成的，如0-In（Mentor）和Spyglass。</p>
<p>语义检查的范围包括：</p>
<ul>
<li>常见的设计错误；</li>
<li>影响<strong>覆盖率收敛</strong>的问题；</li>
<li>可能会产生X值以及受其影响的设计部分。</li>
</ul>
<p>进一步细化这些检查项，它们会具体检查以下设计方面：</p>
<ul>
<li>验证收敛性检查<ul>
<li>无法达到的逻辑部分</li>
<li>无法跳转到的状态机状态</li>
<li>无法完成的状态机跳转逻辑</li>
</ul>
</li>
<li>硅效用检查<ul>
<li>寄存器被固定赋值</li>
<li>寄存器未初始化</li>
<li><strong>X值的传播</strong></li>
</ul>
</li>
<li>功能问题检查<ul>
<li>状态机检查</li>
<li>总线检查</li>
<li>case语句检查</li>
<li>数学逻辑检查</li>
</ul>
</li>
</ul>
<p><strong>这些静态检查最大的便捷性在于，可以在早期发现一些功能实现以外的设计问题，而且也有助于完善设计代码，提高有效覆盖率以及RTL与网表的逻辑一致性</strong>（例如寄存器未初始化或者固定赋值）。语义检查最显著的两个优势在于：</p>
<ul>
<li>不需要验证环境。设计人员可以在发布设计版本前用语义工具检查修改设计中的问题，这对在仿真之前扫清基本障碍、保证设计质量很有帮助。</li>
<li>不需要写断言。这与接下来介绍的形式验证有关；<strong>语义检查无关乎设计从功能描述到实现的翻译准确度，所以不需要断言参与进来</strong>。</li>
</ul>
<h2 id="2-3-跨时钟域检查"><a href="#2-3-跨时钟域检查" class="headerlink" title="2.3 跨时钟域检查"></a>2.3 跨时钟域检查</h2><p>大多数复杂的设计都拥有不止一个时钟，<strong>多个时钟之间也常表现为异步的关系</strong>。<strong>设计中的不同功能模块如果被不同的时钟驱动，就会形成不同的时钟域（clock domain）</strong>。单一时钟域模块的设计方式和验证环境较为简单，而拥有多时钟域的硬件，其跨时钟域的逻辑通信就需要<strong>考虑同步问题</strong>。在这里，用来验证这些设计要求的过程称为跨时钟域检查。</p>
<p>需要同步是因为考虑到不同时钟域的信号采样问题，当时钟域A的信号进入时钟域B被采样时，<strong>每个周期都有相对时钟B不同的延迟，这种随机性可能导致建立时间或保持时间无法满足，进而导致不可预期的功能失败</strong>。</p>
<p>这种跨时钟域问题无法通过常规的验证方法来分析，例如动态仿真，也不能被静态时序分析（static timing analysis）判断出来。而这里通过静态的跨时钟域检查就可以分析这一问题。如图3.12所示，通过该方法，可以在早期的 RTL 阶段识别出跨时钟域的通信电路上是否有合适的同步处理，所以，跨时钟域检查（CDC）是为了保证所有信号都能得到正确的同步。目前支持CDC检查的商业工具有Spyglass和0-In（Mentor）等。</p>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%973%E9%AA%8C%E8%AF%81%E7%9A%84%E6%96%B9%E6%B3%95/%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E6%A3%80%E6%9F%A5.png" class="" title="跨时钟域检查">

<h2 id="2-4-形式验证"><a href="#2-4-形式验证" class="headerlink" title="2.4 形式验证"></a>2.4 形式验证</h2><p>形式验证分为两种方式：</p>
<ul>
<li><strong>等价检查</strong>（EC,Equivalence Check）。用来保证两个电路的行为是等价的，可用来检查不同抽象级的电路是否一致，例如RTL级和网表。</li>
<li><strong>属性检查</strong>（PC,Property Check），又称为模型检查（MC,Model Check）。电路的行为通过验证语言来描述其属性（property），<strong>随后通过静态方式证明在所有状态空间下都满足该条件，否则举出反例</strong>（counter example）证明设计行为不符合属性描述（property description）。</li>
</ul>
<p>我们这里介绍属性检查，即通过验证语言（PSL、SVA）来描述设计行为，用断言（assertion）结合静态工具进行空间穷举，证明设计行为同属性描述保持一致。属性检查的流程通常如图3.13所示。</p>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%973%E9%AA%8C%E8%AF%81%E7%9A%84%E6%96%B9%E6%B3%95/%E5%B1%9E%E6%80%A7%E6%A3%80%E6%9F%A5%E6%B5%81%E7%A8%8B.png" class="" title="属性检查流程">

<p>在动态仿真验证中，我们是通过生成各种测试序列来访问设计中的状态（state）的，<strong>在理论上，所有可以跳转的设计状态总和被称为可及状态空间</strong>（reachable state space）。遍历可及状态空间的所有状态对动态仿真而言是非常大的挑战，这种通过访问状态、检查结果的方式，<strong>需要覆盖率反馈来衡量可及状态空间还有多少状态没有被访问</strong>。</p>
<p><strong>动态仿真验证的方式实际上很难穷举所有可能的序列去完全覆盖可及状态空间，而形式验证可以通过数学方式来穷举出所有的状态空间，彻底验证设计</strong>。从图3.14可以看到，在仿真过程中，通过随机和覆盖率反馈的形式，可以产生不同的测试序列来访问状态空间，直到发现新的缺陷。这是一种实用的测试办法，但另一方面，动态仿真验证无法确定设计中不存在缺陷，因为图中其他隐藏缺陷依然存在尚未被探索到的状态空间内。</p>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%973%E9%AA%8C%E8%AF%81%E7%9A%84%E6%96%B9%E6%B3%95/%E5%8F%AF%E5%8F%8A%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4.png" class="" title="可及状态空间">

<p>形式验证可以通过数学的方法遍历状态空间，进而证明设计行为符合属性描述。<strong>在遍历过程中，一旦遇到反例，形式验证工具便会停下来，报出反例情景，让用户核对错误是否属实，再考虑修改设计或者进一步约束属性使其更精确地描述设计行为</strong>。从图3.15中可以看到，在大量的状态空间中，形式验证工具只需要针对某一项属性描述举出反例，即可报告给验证人员，而并不需要穷举所有的反例。待设计缺陷被确认、修正之后，验证人员可以继续通过工具来对设计属性进行检查。</p>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%973%E9%AA%8C%E8%AF%81%E7%9A%84%E6%96%B9%E6%B3%95/%E5%BD%A2%E5%BC%8F%E9%AA%8C%E8%AF%81%E5%9C%A8%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E4%B8%AD%E5%AF%BB%E6%89%BE%E5%8F%8D%E4%BE%8B.png" class="" title="形式验证在状态空间中寻找反例">

<p>像上面所讲的将属性描述（由断言构成）与设计结合进行一致性检查的方法，自提出到现在已超过20年了，期间有不同的商业工具提供支持，如OneSpin、0-In和Jasper等。图3.16概括了这些工具的发展历程。</p>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%973%E9%AA%8C%E8%AF%81%E7%9A%84%E6%96%B9%E6%B3%95/%E5%BD%A2%E5%BC%8F%E9%AA%8C%E8%AF%81%E7%9A%84%E5%B7%A5%E5%85%B7%E5%92%8C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B.png" class="" title="形式验证的工具和语言的发展历程">


<h1 id="3-开发环境"><a href="#3-开发环境" class="headerlink" title="3 开发环境"></a>3 开发环境</h1><p>介绍一下验证人员日常编码SV的开发环境。</p>
<h2 id="3-1-Vim开发环境"><a href="#3-1-Vim开发环境" class="headerlink" title="3.1 Vim开发环境"></a>3.1 Vim开发环境</h2><h2 id="3-2-商业SV开发环境——DVT"><a href="#3-2-商业SV开发环境——DVT" class="headerlink" title="3.2 商业SV开发环境——DVT"></a>3.2 商业SV开发环境——DVT</h2><p>在语言编辑和调试的基础上，DVT的测试平台语义检查器（testbench linter）可以通过静态代码分析，发现不合适的语句、代码风格、无用语句、性能问题以及与OVM/UVM相悖的使用方式。它可以通过改进验证代码的可靠性和可维护性来协助验证人员更好地完成
验证任务。与之相比，普通的编译器往往只会检查代码是否符合语言规范，不会给出代码可靠性和可维护性的报告，也无法进一步给出建议以使代码与方法学保持一致。此外，DVT自带的文档生成器可以用来从代码中的注释自动生成HTML文档。这种方式使得设计验证人员花费更少的精力便可得到一份结构良好的设计和验证文档，文档的内容包含类和成员介绍、继承树、设计结构、UML类图和验证框架等。</p>
<h1 id="4-虚拟模型"><a href="#4-虚拟模型" class="headerlink" title="4 虚拟模型"></a>4 虚拟模型</h1><p>虚拟模型即<strong>高抽象级的硬件模型</strong>，软件模型可依赖虚拟模型在早期开发，并将反馈交给硬件设计。这种反馈在以往的瀑布模式开发周期中是无法实现的，因为软件的开发往往需要等到硬件设计制造完成之后才能展开。通过虚拟模型，硬件可以更早地获取软件反馈而对设计进行修改。这种硬件和软件更紧密的协作方式，可以体现更多的优势，比如利用虚拟模型获取的性能数据可以对硬件早期结构提供参考意见，或者判断硬件和软件的协同任务是否满足功耗目标。在目前多核的手机移动平台上，将不同的任务合理分配到多核上以取得更好性能的需求日益增长，这种软件层面的评估就可以在虚拟建模阶段完成。目前，我们<strong>通过多项虚拟建模的技术例如协同设计、协同仿真和验证，试图在早期发现设计缺陷，以便在相对容易实施的阶段完成这些缺陷的修改</strong>。如图3.17所示，通过这种将设计问题更早暴露出来的方式，可以达到芯片成功流片的目标，满足市场越来越紧迫的窗口需求。</p>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%973%E9%AA%8C%E8%AF%81%E7%9A%84%E6%96%B9%E6%B3%95/%E8%99%9A%E6%8B%9F%E5%BB%BA%E6%A8%A1%E7%9A%84%E8%A6%81%E7%B4%A0.png" class="" title="虚拟建模的要素">

<p>广义的虚拟建模包括一系列的验证技术，如仿真（simulation）、模拟（emulation）和FPGA，而目前的现状是，验证人员往往综合使用这些方法获得更好的效果。在这里，我们<strong>将虚拟模型限定于仿真（simulation），而将模拟和 FPGA 归类为硬件加速技术</strong>，我们将在3.5节详细介绍硬件加速技术。那么，虚拟建模的优点有哪些呢？</p>
<ul>
<li>在早期通过软件测试发现硬件和软件的问题。这种方式可以提前进行软件开发，更早暴露软件和硬件之间的协作问题或功能边界定义不清晰的问题，在模块 RTL 阶段就发现和修改缺陷。</li>
<li>软件反馈进入硅前开发周期。软件和硬件的紧密协作使得软件也参与到了硬件结构定义和实现的工作中。</li>
<li>减少硬件协同软件的验证工作。虚拟模型使得硬件设计有源可寻，同时软件的早期进入也可以帮助硬件完成一些难以通过仿真完成的系统测试。</li>
<li>为用户建立硅前平台模型。早期的系统模型一旦经过软件测试，就可以为用户提供上层开发的环境。</li>
<li>硅后平台的参照模型。硅前平台模型有更多可见的内部结构，这些细节在物理芯片上是观察不到的。</li>
</ul>
<p>虚拟建模是一项不断完善和发展的技术，正被广泛运用到芯片设计验证领域。那么，主要的虚拟建模平台有哪些呢？目前工业界一致推广利用TLM（Transaction Level Models）建立抽象模型，而TLM也已经发展到了TLM 2.0标准。主要的EDA建模仿真工具支持基于TLM 2.0的SystemC和UVM，我们将支持SystemC建模的仿真工具分为下面两种：</p>
<ul>
<li>仿真器（simulator）。它们支持SystemC的编译和仿真。由于SystemC可以纵深硬件抽象度，所以模型既可以拥有TLM端口，也可以拥有硬件信号端口。如果模型在边界上规定了信号时序，那么可以将端口信号添加到波形窗口中查看，也可以通过断点的方式来调试SystemC模型。</li>
<li>专用的虚拟建模平台（virtual prototyping platforms）。这些平台专门服务于虚拟建模和仿真。从抽象级来看，它们的视野显著高于 RTL 仿真；从开发链来看，它们从更早期的产品定义阶段开始。这些虚拟建模平台主要的特性包括结构设计和评测、软硬件之间的权衡分析、早期的性能和功耗评估、软件集成测试、为 RTL 验证提供参考模型。不同 EDA 厂商提供的平台有 First Encounter（Cadence）、Vista（Mentor）和Virtualizer（Synopsys）等。</li>
</ul>
<p>那么在这些平台上，虚拟模型建立的方式是什么呢？实际上，虚拟模型的建立与RTL建模类似，只是抽象层次变高了，或者代码量变少了（但不见得变简单了，这要看逻辑实现的细节程度）。芯片中各子模块对应不同的软件驱动库、应用库，要尽可能在系统建模中囊括各子模块 TLM 模型，这样才会给软件提供更贴近实际的环境（即可以将硅后开发的软件先在虚拟平台上测试）。在虚拟建模平台上，可以通过可视化界面和自动化方式集成已备好的模块。在集成过程中，我们将模型分为两个类别：</p>
<ul>
<li>自建虚拟模型（即对照自定义硬件建立的虚拟模型）；</li>
<li>商业第三方IP（这些虚拟模型IP对应硬件IP模块，完善的商业IP交付包囊括多个设计验证部分，包括RTL、SystemC和验证平台等）。</li>
</ul>
<p>此外，虚拟模型可以作为参考模型参与到RTL仿真中，这种SystemC同RTL的协同仿真模式包括：</p>
<ul>
<li>协同设计（co-design）。将SystemC模型集成到现有的设计当中，作为暂时替代设计的一部分。<strong>对此种设计的要求是，虚拟模型的边界接口应有合适的时序与相邻模块完成信号交互</strong>。</li>
<li>协同验证（co-verification）。将虚拟模型作为参考模型集成在验证环境中，该方法也减轻了验证人员的负担。</li>
</ul>
<p>越来越多的公司应用虚拟建模来尽可能地提前软件开发时间，同时此种方法对现有工作方式提出了挑战，比如团队学习，如何在硬件设计流程引入该方法，如何衡量虚拟建模的长远价值和人力额外投入，如何将虚拟模型团队同设计验证团队整合，等等。这需要团队整体看到它的优势并愿意为之改变，将它的优势更好地发挥出来。</p>
<h1 id="5-硬件加速"><a href="#5-硬件加速" class="headerlink" title="5 硬件加速"></a>5 硬件加速</h1><p>动态仿真和静态检查方法各自具有优势，然而它们都不具备的一个优势是<strong>速度</strong>。尤其是在SoC的设计体量越来越大时，仿真速度成为制约验证进度的重要障碍。由于仿真速度的限制，一些真实的用例无法在RTL级仿真很快地呈现结果，这种困难在硅后软件测试发现问题反馈给硬件团队时更加明显，因为通常这意味着硬件团队需要将耗时（仿真时间）很长的软件进行分析，找到可能的问题点，拆分软件场景，进而在硬件仿真上尝试重现问题。</p>
<p>仿真速度的限制使得无法通过仿真在早期测试软件，这一任务一般交给其他两种方法：</p>
<ul>
<li>虚拟模型平台（virtual prototype platform）；</li>
<li>硬件加速（hardware acceleration）。</li>
</ul>
<p>虚拟模型平台的一项优势是可以<strong>在硬件设计之前建立硬件模型，并通过集成来生成虚拟模型平台</strong>，当然，这也意味着新的工作量和技能学习。</p>
<p>那么，硬件加速的流程是什么呢？<strong>一般需要等到硬件设计初步稳定，进而将其映射到可配置的平台上。设计的数字电路部分可以通过更高的时钟频率（受限的，无法达到真实芯片频率）来仿真，这种方式比RTL仿真速度已有质的提升</strong>，稍后我们比较速度的提升优势。</p>
<p>目前，业界主要的硬件加速方式分为两种，<strong>即FPGA和专用的模拟器（emulator）</strong>。实际上，专用模拟器仍然是基于FPGA的定制产品，只不过比起商用的FGPA（Xilinx、Altera）在硬件加速方面还有其他显著的优点：</p>
<ul>
<li>内部可编程单元网络的连接方式不同于商用FPGA，这使得它在综合布线效率上面显著优于FPGA，而且对内部可编程单元的利用率也高于FPGA。</li>
<li>外部连接的方式不同于FPGA，这使得它可以通过多路复用技术实现片上存储共享，而不再像FPGA一样需要定制的存储器。同时，通过扩大I/O引脚数目扩展器件之间的通信带宽，确保模拟器之间的通信速度不成为瓶颈。</li>
<li>智能的数据采集和内置追踪存储器的特性，使被映射到模拟器平台的所有逻辑单元在理论上都是可见的。这种采集方式在一开始建立平台时就可以通过定义采集信号列表来修改内部走线，同时不降低模拟速度。</li>
</ul>
<p>模拟器的这些特点与FPGA可以显著地区分开，在实际工作中，F<strong>PGA和模拟器使用的场景也有所不同。FPGA原型验证主要是针对小型设计或单独的IP，而模拟器则用来面向更大、更复杂的SoC设计。</strong>FPGA主要为软件开发提供平台，而模拟器则是为了硬件和软件协同验证和整个系统的测试。最近10年，模拟平台技术日趋完，使用便利性越来越好，从而越来越多的公司开始考虑使用模拟器。这主要是基于以下因素：</p>
<ul>
<li>更快的平台建立时间；</li>
<li>更快的编译综合时间（从RTL到仿真运行）；</li>
<li>良好的调试条件，如信号可追踪、波形可保存、设置断点等；</li>
<li>模拟器的高存储量、资源可裁剪，同时支持多任务；</li>
<li>通过云端购买使用流量使用远程服务，而不再像FPGA需要一次性购买，降低了开发投入成本；</li>
<li>易于操作。</li>
</ul>
<p>FPGA与模拟器在各方面的对比展示于表3.1中。</p>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%973%E9%AA%8C%E8%AF%81%E7%9A%84%E6%96%B9%E6%B3%95/FPGA%E4%B8%8E%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%9A%84%E6%AF%94%E8%BE%83.png" class="" title="FPGA与模拟器的比较">

<p>目前业界的硬件加速标准并未达成一致，主流的三家公司实现硬件加速的具体技术也各有特点。我们在上面提到的模拟器（emulator），通过将设计逻辑映射到可编程单元的方式，主要有Veloce（Mentor）和 ZeBu（Synopsys）。Veloce 通过定制的可编程单元（非常类似于FPGA）、不同的内部连接网络结构以及透明的可调试电路实现其模拟器功能。平台上的每一块模拟器芯片都可用来模拟一部分的设计逻辑，而整个芯片的功能则通过集成各个模拟器芯片实现片间快速通信。ZeBu不一样的地方在于它直接采用FPGA，而且将透明的可调式电路技术和其他特性实现到FPGA中，多个FPGA进一步组成完整的模拟器功能。Cadence公司的仿真加速器（simulation accelerator）Palladium显得与众不同，作为独立的加速器平台，其内部包含数量巨大的简单处理器，每一块处理器又可以仿真一部分设计逻辑，将运算结果在它们之间传递。看起来，这些处理器的运算速度低于我们的桌面处理器，但由于成千上万个小的处理器并行工作，实际的仿真速率远超独立处理器的表现。同时，这些独立的小型处理器支持透明化的调试方式。</p>
<p>模拟器的高速性能使得其有望同真实世界中的电路交流，但需要注意速率差异的问题。假设我们要设计一个USB器件，可能会将物理层的USB与模拟器相连，进而与计算机或其他器件相连。这时候，我们将模拟器与真实世界的应用器件连接，随之而来的问题是，真实世界的频率高于模拟器的频率。<strong>我们需要为它们之间的频率差异搭建降速同步的桥接（speed bridge），通过主动降低快速端的速度并缓存快速端的数据，适配两端的数据交换</strong>。</p>
<p>如果要将RTL验证平台移植到模拟平台上，<strong>可以将硬件部分迁移到模拟平台，同时将验证环境继续运行在仿真平台一侧，这种方式称为联合仿真（co-simulation）</strong>。硬件的激励由仿真平台或真实世界的接口给入。<strong>硬件加速受到的限制是，它们没有办法像RTL仿真一样透明地观察硬件信号和内部逻辑，也无法随时设置断点调试硬件</strong>。在联合仿真平台中，加速因子最大的受限因素在于仿真平台的运行速度，以及它与模拟平台之间通信的频率。</p>
<p>因此，在构建一个联合加速平台时，需要考虑的是：</p>
<ul>
<li>尽可能地将验证平台实现为可综合的，这样有助于它们被移植到模拟平台上，从而减少模拟平台与仿真平台的通信需求。</li>
<li>如果仍然有一些验证组件无法被移植到模拟平台上，那么需要考虑如何使仿真平台与模拟平台之间的通信速度变得更快，或者使通信次数更少。通过TLM通信方式提高每次通信的信息量从而减少它们之间需要同步的次数，是值得采用的加速方法。</li>
</ul>
<h1 id="6-效能验证"><a href="#6-效能验证" class="headerlink" title="6 效能验证"></a>6 效能验证</h1><p>在 PC 时代，少有人将处理器功耗提上验证的日程，因为大家对处理器性能的关注多于对功耗的考虑。我们十多前年使用2G的功能手机，“超长待机”一词渐渐作为广告主打语进入用户的视线，这得益于硬件本身的低功耗（对性能本身的要求不太突出）和大容量的电池。到了智能手机时代，随着对桌面办公和娱乐的移动化的需求增加，手持设备（手机）需要提供桌面机的性能，这催生了智能手机市场过去几年的蓬勃发展。软件对硬件性能日趋增长的要求，以及移动网络数据传输性能的不断提高，都在促进着硬件性能的革新。在移动时代，硬件提升性能的方式主要表现为以下几种：</p>
<ul>
<li>提升原有处理器性能、存储器空间、数据总线带宽或者采取多核处理方式。</li>
<li>增加额外的协处理单元或新的功能模块（如Video/GPU单元）。</li>
<li>在后端允许的情况下提高工作时钟频率。</li>
<li>提升工艺制程。</li>
</ul>
<p>总体上看，随着性能的提升，能耗也会逐步提高，这在过去的PC时代不是一个显著问题，但移动时代越发要求硬件的性能提升，同时要求能耗也可以接受。</p>
<p>本节以移动芯片为例，讨论目前对性能（performance）和效能（power consumption）的权衡。在图3.18中，无线通信技术被标注上了1G、2G、3G和4G。香农定律预测，传输性能每8个月提升一倍；摩尔定律指出，晶体管的单位密度每18个月提升一倍，处理器的性能也因此大约提升一倍。预测指出，电池生产商每10年左右将能源密度提升一倍，而存储器的性能大约每12年提升一倍。那么，从不同器件的性能增长差异来看，这也揭示了移动硬件的技术缺口：</p>
<ul>
<li>处理器和存储器之间的带宽缺口。即处理器的性能同存储器的带宽缺口的差距逐步增大，进而存储性能无法满足运算性能。</li>
<li>效能缺口。传输和运算速率双双大幅提升，使得功耗迅速增长，但由于电池技术受限，使得功耗成为了瓶颈之一。</li>
<li>算法复杂度缺口。传输速率超过运算速率的涨幅，需要更多的处理器来并行完成越来越复杂的算法。</li>
</ul>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%973%E9%AA%8C%E8%AF%81%E7%9A%84%E6%96%B9%E6%B3%95/%E7%A7%BB%E5%8A%A8%E7%A1%AC%E4%BB%B6%E9%A2%86%E5%9F%9F%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BC%BA%E5%8F%A3.png" class="" title="移动硬件领域的技术缺口">

<p>上面讲述的技术缺口与目前硬件提升性能的方式大致保持吻合，接下来主要就如何解决效能缺口入手，讨论目前主流的效能验证方式。</p>
<h2 id="6-1-功率和能量"><a href="#6-1-功率和能量" class="headerlink" title="6.1 功率和能量"></a>6.1 功率和能量</h2><p>首先我们引入基本的概念，功率和能量在日常器件效能讨论中经常会提起，它们是两个关联的术语。</p>
<p>功率=能量/时间（单位：瓦）</p>
<p>能量=功率×时间（单位：焦）</p>
<p>有时候，我们设法降低功率，能耗随之降低，但这不是绝对的，有些任务在高速高功率情况下可以用更短时间完成，而且实际功耗要比在低速低功率情况下更少。例如，<strong>如果静态功耗可以忽略，一个任务需要固定的时钟周期数完成，那么无论时钟快慢，它消耗的能量是一样的；当静态功耗无法忽略时（例如目前最先进的工艺制程已大致在7nm），反倒是时钟更快、功率更高的情况下完成这项任务更高效</strong>。所以，效能的验证和评估实际上就是对能量利用效率的优化途径。</p>
<h2 id="6-2-静态功耗和动态功耗"><a href="#6-2-静态功耗和动态功耗" class="headerlink" title="6.2 静态功耗和动态功耗"></a>6.2 静态功耗和动态功耗</h2><p>从上面的例子我们知道，如果要考虑功耗，需要考虑两部分即<strong>静态功耗和动态功耗</strong>，总功耗如下：</p>
<p><em>总功耗=开关功耗+短路功耗+静态功耗</em></p>
<p>这里<strong>开关功耗和短路功耗构成了动态功耗的部分</strong>。</p>
<p><em>开关功耗=C·V·V·F</em></p>
<p>其中，C是负载电容，V是电压，F是频率。</p>
<p><em>短路功耗=V·I（短路）</em></p>
<p>I（短路）为在开关切换过程中<strong>N极和P极同时有效时发生的短路电流</strong>。</p>
<p><em>静态功耗=V·I（漏电）</em></p>
<p>静态功耗（或漏电功耗）则是晶体管在电路稳定时出现的漏电造成的功耗。</p>
<h2 id="6-3-节能技术"><a href="#6-3-节能技术" class="headerlink" title="6.3 节能技术"></a>6.3 节能技术</h2><p>移动芯片节能（省电）技术是全方位的改进流程，从工艺制程到电路、封装到模块设计、SoC 设计、系统和应用软件开发，等等，整个环节都需要有效利用能量。表3.2是从芯片硬件和软件方面所采用的节能技术（省去工艺制程）。</p>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%973%E9%AA%8C%E8%AF%81%E7%9A%84%E6%96%B9%E6%B3%95/%E7%A1%AC%E4%BB%B6%E5%92%8C%E8%BD%AF%E4%BB%B6%E9%87%87%E7%94%A8%E7%9A%84%E8%8A%82%E8%83%BD%E6%8A%80%E6%9C%AF.png" class="" title="硬件和软件采用的节能技术">

<p>与之前介绍过的硬件设计流程类似，节能的设计流程（见图3.19）也是从规划到实施最后到集成的。面对越来越复杂的系统，实用的方式还是从系统设计开始，逐步分解到电路设计，我们先从硬件层面考虑如何实现低功耗设计。</p>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%973%E9%AA%8C%E8%AF%81%E7%9A%84%E6%96%B9%E6%B3%95/%E8%8A%82%E8%83%BD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B.png" class="" title="节能的设计流程">

<h2 id="6-4-效能验证"><a href="#6-4-效能验证" class="headerlink" title="6.4 效能验证"></a>6.4 效能验证</h2><p>这里主要针对硅前设计阶段进行效能验证，涉及的流程分为两部分：</p>
<ul>
<li><strong>功能验证</strong>。主要采用PA（Power Aware）方式，包括UPF（Unified Power Format）和CPF（Comment Power Format）。通过与仿真器结合，模拟电源域的开关进行设计检查。</li>
<li><strong>功耗预测与优化</strong>。使用第三方功耗分析工具，结合仿真数据（FSDB/VCD/SAIF），进行功耗预测并给出分析结果。</li>
</ul>
<p>PA（Power Aware）效能设计流程</p>
<p>UPF/CPF这两种功耗格式较为类似，可以将它们的应用阶段分为4个部分：</p>
<ul>
<li>规定功耗格式文件，指定电源掉电、触发隔离和状态保持等行为，以及它们的控制信号。</li>
<li>RTL仿真（门级仿真也可以支持）除了要保证功能正确，还要进行低功耗逻辑和断电控制功能验证，检查状态丢失、分离和保持。</li>
<li>逻辑功能检查和等价性检查（带有UPF/CPF插入的单元）。</li>
<li>逻辑综合和DFT（带有UPF/CPF插入的单元）。</li>
</ul>
<p>对于硅前验证阶段，验证人员接触到的主要是RTL仿真。我们一般采取的策略是：</p>
<ul>
<li>进行非效能的RTL仿真（不带PA）。</li>
<li>在RTL功能仿真通过的情况下，进行PA仿真。</li>
<li>在门级仿真阶段，如果时间允许，可以在后期进行门级PA仿真。</li>
</ul>
<h2 id="6-5-功耗预测与优化"><a href="#6-5-功耗预测与优化" class="headerlink" title="6.5 功耗预测与优化"></a>6.5 功耗预测与优化</h2><p>一般我们期望尽早获取功耗的估测信息，而这一期望与芯片开发过程相悖，因为往往在流片以后的软件开发阶段测量出来的功耗是更准确的。但是，<strong>等到流片之后才去测量功耗，低功耗设计的成本就很大了</strong>，这是因为一方面这使我们试错的成本增加，另一方面产品效能优化迭代的周期也变长了。所以，我们希望在硅前设计阶段甚至规划阶段（TLM虚拟模型）估测出芯片功耗，分析出可以降低功耗的设计方法。这里，我们将目光落在RTL和门级阶段，通过现有的功耗设计平台，在早期进行功耗估算、低功耗设计、电源效率提升等事务。</p>
<p>简而言之，目前使用这些工具都是为了查看、估算、分析和降低功耗，通过在 RTL级和门级功耗数据指标和报告，为设计和验证人员提供计算和跟踪功耗的方法。现有的功耗预测分析工具包括PowerArtist（Ansys）、Spyglass Power（Synopsys）、PrimeTime PX（Synopsys）和Redhawk（Ansys）等。我们通过对实际项目中不同工具的比较，提供如表3.3所示的建议。</p>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%973%E9%AA%8C%E8%AF%81%E7%9A%84%E6%96%B9%E6%B3%95/%E4%B8%8D%E5%90%8C%E5%8A%9F%E8%80%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E6%AF%94%E8%BE%83.png" class="" title="不同功耗分析工具的比较">

<p>在硅前验证阶段，目前相对容易做到的是<strong>运用PA设计流程进行相应的RTL仿真和后端流程</strong>。通过仿真器进行 PA 仿真，在保证原有功能实现的情况下，进一步检查低功耗逻辑和断电控制功能。对于功耗预测与优化，有几点因素值得考虑：</p>
<ul>
<li>工具的评估和选择：不同的工具有不同的适应场景和性能。</li>
<li>如何将功耗分析与优化纳入项目流程：对于低功耗芯片设计，功耗分析的方向值得提上项目日程。</li>
<li>如何量化功耗优化成果：一方面需要考虑如何选取合适的测试场景来模拟芯片的实际应用，另一方面也需要<strong>选择合适的仿真时间窗口作为分析的数据来源</strong>。</li>
<li>对比分析不同代芯片的功耗，并给出节省功耗的建议：基于前几代芯片的实际功耗数据，利用功耗估测协助低功耗设计，再通过实际芯片的数据给出反馈，进一步修正估测数据。这种收敛方式有助于更准确的功耗预测。</li>
</ul>
<h1 id="7-性能验证"><a href="#7-性能验证" class="headerlink" title="7 性能验证"></a>7 性能验证</h1><p>在了解效能验证之后，我们来了解性能（performance）验证。性能验证中离不开大量的运算和数据传输。之前提到，<strong>硅前RTL验证的瓶颈之一在于仿真速度，且这一因素到了芯片级仿真阶段被进一步放大</strong>。在产品定义过程中，对系统的运算和数据传输都有要求，在产品实现阶段尽早地得出一些性能有关数据，不但可以帮助提前验证硬件性能是否满足要求，还可以在进度允许的情况下修改硬件设计完善其性能。这种<strong>将性能测试提前的方式也使硅前验证与硅后测试采用一致的测试用例，从而得出可比对的性能数据</strong>。</p>
<p>性能验证用来衡量一个系统在特定工作负载下的响应能力和稳定性，同时性能报告也可以用来分析和优化系统的质量标准，例如可靠性和资源使用能力。性能验证是实用的计算机科学工程方法，在软件工程测试中分类较多，如负载测试（load testing）、压力测试（stress testing）、浸泡测试（soak testing）、尖峰冲击测试（spike testing）、配置测试（configuration testing）和隔断测试（isolation testing）等。</p>
<p>在硅前验证阶段，目前性能验证还是一个新颖的概念，一方面是因为业界对这一测试还没有形成统一标准，另一方面是因为性能验证更多地是在衡量指标，与验证（判断设计是否与功能描述一致）本身的聚焦不太重合。但对一些性能要求严格的硬件设计，我们确实希望在更早期就得出一些数据，最好能够赶上给设计做出反馈并加以完善，以此降低开发成本。所以，这要求我们能够自己先定义出硅前性能验证的目标、环境和方法。</p>
<h2 id="7-1-设定目标"><a href="#7-1-设定目标" class="headerlink" title="7.1 设定目标"></a>7.1 设定目标</h2><p>目前我们对性能验证的考虑主要侧重在<strong>负载测试和压力测试方面</strong>，完成下面的目标：</p>
<ul>
<li>证明系统（或者子系统）的性能是否符合产品要求。</li>
<li>衡量哪一部分的子系统会成为整个系统或者某些特性要求的瓶颈。</li>
</ul>
<p>开始性能测试之前，首先问一问自己“为什么要进行性能验证”，因为只有朝着明确的性能目标前进，才能得出下面的关键测试数据：</p>
<ul>
<li>数据并发量（concurrency）/吞吐量（throughput）。测试数据并发量是系统整体性能的考量，因为在某一个时间段，多个子系统会并行工作，共享一些网络和内存资源；测试吞吐量是围绕一条完整的数据通路测算出它的最大吞吐量或传输速率，例如测试USB的传输速率。</li>
<li><strong>响应时间</strong>。这集中体现在处理器访问寄存器和存储器的读写回路延迟，也适用于其他协处理器或者DMA（Direct Memory Access）。</li>
</ul>
<p>在性能验证计划中描述测试方式和场景是一个难点，性能指标应出现在功能描述文档中。在实际项目中，虽然我们不能很好地知道软件使用硬件的场景以及软件如何调度各个硬件模块，但可以先着眼于单个子系统的性能测试，或者通过测试单一的数据链路找到最薄弱的节点，这种方式可以将问题的复杂性降低到可理解并且可描述测试场景的难度。</p>
<h2 id="7-2-测试环境"><a href="#7-2-测试环境" class="headerlink" title="7.2 测试环境"></a>7.2 测试环境</h2><p>如果测试环境贴近用户实际使用的情况，我们得出的数据会更加真实有意义。然而在硅前硬件实现阶段，我们与用户之间存在不小的距离。退而求其次，我们希望<strong>和固件开发团队合作，找到一些典型的子系统应用场景，通过仿真来观察子系统的性能</strong>。为了将测试的成本降低，尽可能选择原有的验证环境，<strong>以动态的环境配置嵌入监视系统性能的组件</strong>。这些组件根据其特征分为：</p>
<ul>
<li><strong>在线监视</strong>（online monitoring）。一般将监视器（monitor）绑定到目标模块或总线上，动态监测目标的运算处理量或数据传输速度。</li>
<li><strong>线下分析</strong>（offline analysis）。将监视到的数据记录下来，通过线下的脚本分析，绘制出性能的波动曲线。</li>
</ul>
<h2 id="7-3-验证方法"><a href="#7-3-验证方法" class="headerlink" title="7.3 验证方法"></a>7.3 验证方法</h2><p>从性能验证流程来看，我们可以考虑参照微软的性能测试方法学流程（见图3.20），它包括以下步骤：</p>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%973%E9%AA%8C%E8%AF%81%E7%9A%84%E6%96%B9%E6%B3%95/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E5%AD%A6%E6%B5%81%E7%A8%8B.png" class="" title="性能测试方法学流程">

<ol>
<li>构建验证环境：一般利用现有的功能验证环境，通过更新使其能够完成性能检测和分析的任务。</li>
<li>决定性能验收标准：在测试前限定反馈时间、吞吐量、资源利用率等验收标准。一般而言，对于硅前测试，我们可以测出反馈时间和吞吐量，而资源利用率是一个系统概念，较难测试。</li>
<li>制定计划和测试用例：需要与系统人员、固件人员一起列出重要的测试场景，同时建立可以衡量性能的标准。</li>
<li>配置测试环境：如果环境足够灵活，可以在回归测试（regression test）中打开或关闭性能检测功能，以此平衡性能测试可能带来的仿真效率降低。</li>
<li>开发用例和测试：开发测试用例，检测带验模块，收集性能检测数据。</li>
<li>分析结果、报告和再测试：分析测试数据，提交性能报告，如果硬件性能与计划的性能之间有缺口，做出硬件修改。再次测试，直到硬件性能符合预期、满足验收标准。</li>
</ol>
<p>如前面提到的，实际项目中的性能测试除了不规范和较难实现以外，还缺少明确的验收标准。这使得不同验证人员编写的测试用例与实际应用各有不同，检查性能的标准也不同。目前，我们通过下面一些形式实现性能验证：</p>
<ul>
<li>在芯片网络结构的端点处（network terminal）绑定总线协议的监测器，以此在网络核心处检测芯片整体的通信情况，计算网络的实时吞吐量，以及单个挂接的子系统的数据传输速率。</li>
<li>将一些 RTL 仿真较为耗时的测试用例迁移到硬件加速平台，利用模拟器来完成性能测试。</li>
<li>为测试用例提供一些宏定义，实现高密度数据传输，以此保证有足够的数据吞吐，来测试数据传输的峰值。</li>
</ul>
<h1 id="8-趋势展望"><a href="#8-趋势展望" class="headerlink" title="8 趋势展望"></a>8 趋势展望</h1><p>目前主要的验证方法包括<strong>动态仿真、形式验证和硬件加速</strong>。如何选择验证方法，是否可以构建一个可复用的验证平台实现不同验证方法的跨越，是接下来我们关心的问题。设计的尺寸和复杂度的不断增长，即使可以利用IP缩短设计时间，但是更多模块之间的互动场景也要求<strong>更充分地验证这些状态空间</strong>。目前仿真技术的瓶颈在于速度，总结这几年项目的切身感受，笔者认为在仿真中，除了需要 EDA 厂商提供加速方式以外，也需要项目自身结合实际情况使仿真实现轻量化，
以进一步为仿真提速。</p>
<p><strong>形式验证可以穷尽检验一些设计属性</strong>。对于合适尺寸的IP，只需要一些时间和运算资源，就可以穷尽检验出设计属性是否满足。例如一个32位的乘法器，动态验证可能需要几年的时间穷举出所有可能的情况，形式验证往往几分钟到数小时的时间就可以了。<strong>形式验证随着系统的复杂度提高、状态空间的急剧增长，运行速度也在不断下降</strong>。相比较而言，IP是适合形式验证的设计尺寸。</p>
<p>学术和工业领域对形式验证的算法研究非常活跃，但还需解决的问题是，使用者<strong>对形式验证语言依旧不精通</strong>。<strong>使用者需要保证属性描述精确地反映了设计的功能，同时属性描述的总和能够对应一个设计的所有功能，只有满足了这两点，才有足够信心确信形式验证的完备性</strong>。目前，我们可以通过 EDA 厂商提供的可复用的断言库来实现高层次的属性描述，弥补我们对断言描述本身的知识缺乏。此外，形式验证让我们“不那么放心”的一点是，<strong>它无法像仿真一样为我们提供一个动态的行为</strong>，而验证人员又需要“眼见为实”来亲自判断设计的实际行为是否正确。所以，如果采取形式验证，那么建议的一种方式是<strong>以动态仿真作为辅助手段完成基本的功能检查</strong>。</p>
<p>硬件加速的历史更悠久，可以回溯到20世纪80年代中期到90年代中后期。在RTL仿真还未被推出和广泛使用之前，占据验证市场的还是门级硬件模拟技术。随着 Verilog 和VHDL语言的推出及自动逻辑综合技术的应用，RTL仿真就逐渐取代了硬件加速技术。这一技术更迭的背后，关键因素还是速度，因为那一时期的设计还不足以复杂到仿真器性能无法满足的情况。而在20年后的今天，硬件加速技术显然又有着收复失地的趋势，三大主流工具商都提供各自的硬件加速解决方案。硬件加速的速度优势还是相当明显的。动态仿真的性能平均保持在1kHz，硬件模拟技术大致在1MHz，而FPGA在10MHz左右。无论硬件模拟还是 FPGA，都比动态仿真的速度提高不少。通过更快速的验证技术，我们才有可能抵消设计的复杂度增长和测试代码不断增大的体量。那么，硬件加速技术是不是未来的主流呢？仍然不是绝对的。目前硬件加速技术也有自己的不足，比如：</p>
<ul>
<li><strong>编译时间较长</strong>。硬件加速需要额外的逻辑综合和硬件映射的时间，然而综合、布局、布线和映射在动态仿真中是不必要的环节。</li>
<li><strong>调试手段少且慢</strong>。最新的硬件加速技术可实现记录、修改或等待信号等常用的调试手段，然而由于技术限制，添加或修改新的信号仍然需要再次编译，消耗大量时间。此外，受限于可用的存储量，我们<strong>无法记录所有层次的信号，只能选择性地记录某些信号在某一段时间内的行为</strong>。从调试流程上来看，硬件加速技术仍然无法达到动态仿真的易调试程度。这么看来，尽管在速度上硬件加速有显著的优势，但<strong>动态仿真和形式验证在调试层也有其优点</strong>。</li>
</ul>
<p>那么，实际工作中我们如何选择这些技术呢？一般地，我们倾向于以下方式：</p>
<ul>
<li><strong>在模块级或 IP 级验证中，更多使用动态仿真和形式验证</strong>，尽量将缺陷率曲线更快、更多地收敛在这一层次。</li>
<li>在芯片系统级验证过程中，使用动态仿真测试模块之间的集成关系。</li>
<li>对于耗时长的测试用例，如固件启动测试、性能测试、大规模数据存储测试等，在系统测试阶段使用硬件加速以更快地得到结果。</li>
</ul>
<p>从验证平台搭建和复用的角度出发，需要考虑如何实现一个可以横跨这三种技术的可复用平台。通过一个统一平台，自如地在这三种技术之间实现横向跨越，完成从模块级到子系统级再到芯片级验证的纵向复用，将是接下来实现技术融合和验证复用的方向。</p>
<p>为探讨这一方向，我们就下面两个问题展开论述：</p>
<ul>
<li>不同技术之间的验证平台横向跨越；</li>
<li>不同层次之间的验证平台纵向复用。</li>
</ul>
<h2 id="8-1-技术之间的横向跨越"><a href="#8-1-技术之间的横向跨越" class="headerlink" title="8.1 技术之间的横向跨越"></a>8.1 技术之间的横向跨越</h2><p>在解决横向跨越问题之前，需要理解为什么有这样的需求。从图3.21可以看到，这三种技术之间有着共通的技术桥接、共同的一些核心基础技术：</p>
<ul>
<li>我们的核心基础技术有验证 IP、覆盖率、调试和软件驱动测试。三种验证方法构建于这些基础上，如它们都需要提供调试接口，也需要提供各自的覆盖率来完成验证。</li>
<li><strong>形式验证和动态仿真之间，可以通过断言和 X-prop 技术来桥接，这两种验证方法都可以利用这些技术实施验证</strong>。</li>
<li>在动态仿真和硬件加速之间，可以通过软硬件协同验证的方式实现这两种技术的桥接。</li>
<li>对于断言VIP，可以利用它完成形式验证，或者植入到动态仿真环境中。一些可以综合的断言VIP，也可以移植到硬件加速平台中继续完成验证任务。</li>
</ul>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%973%E9%AA%8C%E8%AF%81%E7%9A%84%E6%96%B9%E6%B3%95/%E4%B8%8D%E5%90%8C%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB.png" class="" title="不同验证方法之间的联系">

<p>那么，如何基于这些项目实际中的桥接设计出可以合并的数据库和通用的验证平台就成为了关键。但对于这两点，目前三大工具厂商还缺乏一种完整的解决方案。例如，验证的覆盖率数据库如何在三种技术中实现互通和合并？如何定义出合理的结构完成形式验证平台到动态仿真平台的复用？什么样的动态仿真平台才可以顺利移植到硬件加速平台上？这些都还是有待解决的问题。</p>
<h2 id="8-2-层次之间的纵向复用"><a href="#8-2-层次之间的纵向复用" class="headerlink" title="8.2 层次之间的纵向复用"></a>8.2 层次之间的纵向复用</h2><p>在不同验证层次之间进行复用，我们也会遇到实际的痛点。例如，随机约束的仿真方法（SystemVerilog,UVM/OVM或Specman/e）适合于模块级和子系统级验证，而定向测试方法（C/C++）则适用于子系统级和芯片系统级的验证过程。在这里，我们看到子系统级验证有两种可能的验证方法，我们需要考虑是选择其中一种还是两者兼具？如何实现模块级随机测试到子系统级随机测试的复用？如何实现子系统级定向测试到芯片系统级的定向测试复用？又比如，通过何种方式实现从随机约束测试到定向测试的复用？只有完成层次之间的垂直复用，验证的时间成本和人力成本才会降低，验证效率才会进一步提高。</p>
<p>面对目前这三种主流验证技术，我们需要从验证效率出发，合理选择使用这些技术，实现技术之间的横向跨越和层次之间的垂直复用，在不断提速的SoC集成设计过程中保持加速，与设计实现共同飞跃。</p>
<h1 id="9-作者结束语"><a href="#9-作者结束语" class="headerlink" title="9 作者结束语"></a>9 作者结束语</h1><blockquote>
<p>关于验证方法，其实在笔者多年的技术世界观中，曾一度认为只有随机测试和形式验证才能拯救设计漏洞。但后来发现，每一种验证方法都有其在各自领域、特定验证场景中的优势。尤其是，SoC在最近几年已经完美地翻越了10亿门的篱笆，让传统的仿真在这样大的庞然大物面前如临大敌。如何解决验证的完备性与速度之间的冲突，已经成为选择验证方法的重要考量标准。项目进度的不断压缩，对硬件和软件联合仿真提出更严格的要求，也为虚拟模型和硬件加速等新兴技术开拓了市场。</p>
<p>本书的主要内容着眼于动态仿真技术。这项技术在过去的20年一直是验证领域的主流，也是读者在验证领域亲密接触的对象。在本书出版的同时，硬件加速技术正以更快的步伐走入验证世界，读者需要对这些验证方法做好准备。</p>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-05-06T11:36:06.000Z" title="5/6/2022, 11:36:06 AM">2022-05-06</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/IC%E9%AA%8C%E8%AF%81/">IC验证</a></span><span class="level-item">2 小时读完 (大约13878个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%972%E9%AA%8C%E8%AF%81%E7%9A%84%E7%AD%96%E7%95%A5/">芯片验证漫游指南2验证的策略</a></p><div class="content"><h1 id="1-设计的流程"><a href="#1-设计的流程" class="headerlink" title="1. 设计的流程"></a>1. 设计的流程</h1><p>我们在第1章给出了芯片产品开发的流程图，在描述中我们将开发流程分为两条主线：</p>
<ul>
<li>芯片功能的细分；</li>
<li>不同人员的任务分配。</li>
</ul>
<p>也就是说，不同人员需要在硅前不同阶段实现和测试芯片的模块功能。如果我们从另外一个角度看，芯片的开发即是将抽象级别逐次降低的过程，从一开始的抽象自然语言描述到硬件HDL语言描述再到最后的门级网表。在我们介绍过RTL设计和门级网表后，这里需要引入一个<strong>更高抽象级的描述方式TLM（事务级模型，Transaction Level Model）。TLM一般在早期用于模拟硬件的行为，侧重于它的功能描述，而不在于严格的时序</strong>。同时各个 TLM 模型也会被集成为一个系统，用来评估系统的整体性能和模块之间的交互。</p>
<p>TLM模型在早期的设计和验证中，如果足够准确的话，可以替代验证人员的参考模型，一方面为硬件设计提供了可以参考的设计（来源于系统描述），一方面也加速了验证（无须再构建参考模型，而且TLM模型足够准确反映硬件描述）。</p>
<h2 id="1-1-TLM模型的需求和ESL开发"><a href="#1-1-TLM模型的需求和ESL开发" class="headerlink" title="1.1 TLM模型的需求和ESL开发"></a>1.1 TLM模型的需求和ESL开发</h2><p>早期的芯片开发模式是遵循<strong>从系统结构设计到芯片设计制造，再到上层软件开发</strong>的。随着产品开发的进展，需要让系统人员、硬件人员和软件人员保持充沛的工作量，同时对于一个芯片项目而言，我们也希望硬件人员和软件人员可以尽可能地同时进行开发。这听起来怎么可能？毕竟芯片还没有制造出来，没有开发板怎么去构建软件呢？</p>
<p>在这里，系统结构人员会在早期构建一个高抽象级的系统，该系统具备相应的基本功能，且各模块的接口保持数据交互。通过将功能描述变成可运行的系统，让硬件人员和软件人员在早期利用该系统进行硬件参照和软件开发。这种可以为复杂系统建立模型、让多个流程分支可以并行开发的方式称为ESL（电子系统级，electronic systemlevel）开发。</p>
<h2 id="1-2-传统的系统设计流程"><a href="#1-2-传统的系统设计流程" class="headerlink" title="1.2 传统的系统设计流程"></a>1.2 传统的系统设计流程</h2><p>传统的系统设计流程如图2.1所示，是瀑布形式（waterfall）开发的，这种顺序开发的方式存在明显的边界：</p>
<ul>
<li>时间边界：不同的开发子过程之间顺序执行，几乎没有交叠的空间来缩短整体的项目交付时间。</li>
<li>组织边界：开发小组之间的交流发生在上一个过程结束、下一个过程开始时，这引入了额外的沟通成本;</li>
</ul>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%972%E9%AA%8C%E8%AF%81%E7%9A%84%E7%AD%96%E7%95%A5/%E4%BC%A0%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B.png" class="" title="传统的设计流程">

<h2 id="1-3-ESL系统设计流程"><a href="#1-3-ESL系统设计流程" class="headerlink" title="1.3 ESL系统设计流程"></a>1.3 ESL系统设计流程</h2><p>图2.2为ESL系统设计流程。为了模糊或者融合这种边界，ESL开发流程通过建立虚拟原型（virtual prototype），又称TLM模型，使参与到系统开发的各小组做<strong>并行开发</strong>。之所以有这种魔力，是因为 TLM 模型不再是一种无法被硬件开发和软件开发利用的抽象描述，而是一种更早期开发的软件模型。在ESL开发的协助下，其余的开发流程可以更早地与系统设计一块进行开发，从整体上看，这种方式有助于缩短芯片开发的时间。除此之外，ESL在前期产品定义的阶段有相对可量化的模型，有助于早期评估产品的功能、性能是否满足客户要求，也能减轻一些低配置性能的风险以及降低过多设计的成本。</p>
<p>这是为什么呢？原因有以下几点：</p>
<ul>
<li>在早期定义产品时，市场部门将产品功能和性能要求从客户那里收集回来，交由系统结构人员来定义芯片结构。这中间存在一些问题，例如，系统结构人员无法深入到局部功能，更无从列举出所有的用例来判断功能是否满足需求，而在性能测试方面也只能通过一些表
格化数据做出静态估算。这时，TLM 模型可以帮助在系统级别完成模型搭建和系统集成，甚至测算系统的性能。这样，系统结构人员有更多的信心给出合理的结构配置。</li>
<li>正由于可以在芯片结构的定义阶段快速做出性能评估，系统结构人员才可以及时地做出资源调整来满足用户的需求。否则，尽管芯片可能是低缺陷率的，但如果它的执行速度不够快、功耗过高，那么仍然无法满足客户的要求。</li>
<li>过度设计的结构就像给一只袜子缀上水钻一样没有必要。客户给的报价摆在那里，你的设计过度，不但意味着成本的增长，也意味着更高的复杂度和风险。</li>
</ul>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%972%E9%AA%8C%E8%AF%81%E7%9A%84%E7%AD%96%E7%95%A5/ESL%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E6%96%B9%E5%BC%8F.png" class="" title="ESL系统设计流程">

<p>ESL和TLM对系统模型的要求使得需要有一门语言具备这些特性：</p>
<ul>
<li>纵深多个抽象级别来进行模型描述；</li>
<li>标准开放；</li>
<li>高效的仿真性能和调试接口；</li>
<li>被主流仿真工具支持；</li>
<li>本身包含TLM事务级传输的接口。</li>
</ul>
<p>这样的语言就是接下来要介绍的SystemC。SystemC是可以满足TLM模型开发的一种语言。严格来讲，它本身不是一种语言，而是建立在C++之上的一种类库（class library）。SystemC语言可以用来描述系统级别的硬件行为，而这一点恰是其他语言无法满足的。2006年，SystemC被IEEE收入IEEE 1666标准，它本身也易于学习，具有C++/Java基础和硬件设计概念的人使用起来都不需要太多的学习成本。</p>
<h2 id="1-4-语言的抽象级比较"><a href="#1-4-语言的抽象级比较" class="headerlink" title="1.4 语言的抽象级比较"></a>1.4 语言的抽象级比较</h2><p>不同的硬件领域使用到的建模语言都有它们各自适合的抽象级，图2.3指出了各个语言擅长的抽象级领域。从左至右，<strong>VHDL和Verilog主要用做RTL仿真和数字电路的综合</strong>，也用来在早期搭建一些验证平台。SystemVerilog/Vera/e是用来做功能验证语言的，其中包括了它们的随机约束重要特性，同时可以发现，SystemVerilog 本身可以用来描述硬件做 RTL仿真和门级综合。在此之上，<strong>SystemC 更偏向于系统层，它在结构层面上可以做更高抽象级的描述，虽然本身无法描述电路的综合网表，但它能够作为虚拟平台为上层软件开发做准备</strong>。MATLAB在信号处理上面被用来作为描述和算法验证。</p>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%972%E9%AA%8C%E8%AF%81%E7%9A%84%E7%AD%96%E7%95%A5/%E4%B8%8D%E5%90%8C%E7%A1%AC%E4%BB%B6%E7%9B%B8%E5%85%B3%E8%AF%AD%E8%A8%80%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%BA%A7%E6%AF%94%E8%BE%83.png" class="" title="不同硬件相关语言的抽象级比较">

<h2 id="1-5-传统的系统集成视角"><a href="#1-5-传统的系统集成视角" class="headerlink" title="1.5 传统的系统集成视角"></a>1.5 传统的系统集成视角</h2><p>前面已经提到，传统的瀑布开发模型（见图2.4）无法让硬件人员和软件人员在系统结构定义早期参与其中。硬件的设计和验证人员需等待系统定义完成之后，才能将功能描述文档分别翻译出来，建立可综合模型和参考模型。软件人员只有在硬件流片以后才真正开始进行软件开发，尽管目前的FPGA有着比硬件更快的仿真优势，但无论从时间还是从速度来看，它仍然不是理想的软件开发平台。虽然FPGA等硬件加速工具对硅后系统测试有积极意义，但因介入较晚，加上基于速度层面的考量，其对软件系统层开发的贡献依然存在局限性。</p>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%972%E9%AA%8C%E8%AF%81%E7%9A%84%E7%AD%96%E7%95%A5/%E7%80%91%E5%B8%83%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B.png" class="" title="瀑布开发模型">

<h2 id="1-6-ESL系统集成视角"><a href="#1-6-ESL系统集成视角" class="headerlink" title="1.6 ESL系统集成视角"></a>1.6 ESL系统集成视角</h2><p>新型的ESL系统开发方式（见图2.5）在系统定义阶段建立TLM模型。这一模型的建立对系统人员、硬件设计人员、验证人员和软件开发人员有显著帮助：</p>
<ul>
<li>系统人员在TLM模型集成系统上更易评估系统性能。</li>
<li>硬件设计人员同时利用功能描述文档和TLM模型，更准确地翻译为可综合的RTL设计。</li>
<li>验证人员可以直接将TLM模型作为参考模型集成到验证环境中，省去额外开发参考模型的时间。</li>
<li>软件开发人员可以在TLM集成后的虚拟系统上进行软件开发，在芯片真正出片后，则只需做一些基于实际硬件的软件移植；这可以把软件开发的起点大大提前。</li>
</ul>
<p>TLM 建模有很多优点。然而，在真正考虑施行 ESL 系统集成流程时，需要考虑一些实际的问题：</p>
<ul>
<li>TLM建模对系统人员有更高的技能要求。不但要求他们掌握SystemC开发，同时要求有硬件描述的基础。他们的工作量同时包括功能描述文档和 TLM 模型，且TLM需要准确翻译功能描述文档，确保一致性。从传统流程迈向 ESL 流程，可能需要做一些妥协，<strong>引入专门的虚拟建模（virtual prototyping）团队协助系统人员翻译功能描述文档。他们的共同产出最终作为一致的参考标准</strong>。</li>
<li>尽管已经有了可以被综合的 SystemC 的子集和代码规范，但这种方式目前仍未得到业界的广泛应用。在某个硬件模块没有就位或者需要加快仿真速度时，可以临时用TLM模型替换原先的硬件设计。<strong>前提是，系统的仿真行为保持不变，且TLM模型接口上的时序满足HDL仿真的要求</strong>。</li>
<li>当 TLM 模型被验证环境复用时，要求 TLM 与验证环境之间保持标准接口（TLM interface），以便于TLM模型的插拔。</li>
<li>软件开发需在完整的系统层面进行，因此当TLM协助软件开发时，TLM子模块要被尽早地集成到一起，作为整体系统为软件开发所用。TLM 模型需要具备标准接口，以便更快地实现系统集成。</li>
</ul>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%972%E9%AA%8C%E8%AF%81%E7%9A%84%E7%AD%96%E7%95%A5/ESL%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E6%96%B9%E5%BC%8F.png" class="" title="ESL系统开发方式">


<p>目前常见的设计流程仍然是瀑布开发方式或类 ESL 开发方式。类 ESL 开发指的是开发流程并没有完全遵循上述流程，而是在一些地方引入TLM建模。在图2.6中，由于系统人员的技能限制，项目开发需要额外引入虚拟建模团队。虚拟建模团队服务的主要对象是软件开发一方，他们与硬件设计、验证团队的沟通会较少。这种类ESL的开发可能有多种组合，但需要警惕的是，在方便软件开发早期进入项目时，TLM模型应该与系统定义保持绝对的一致性，从而为硬件和软件方提供模型和代码参考。</p>
<p>从图2.6来看，这种类ESL的方式是存在风险的，因为虚拟建模团队从系统定义到TLM模型的过程存在二次翻译。如果翻译不准确、存在疏漏，可以想象，基于 TLM 模型的软件开发不会那么容易被移植到真正的硬件系统上，因为硬件本身也是二次翻译的。所以，理想的合作边界应该如图2.7所示，虚拟建模首先和系统定义保持原义的一致性，硬件和软件则可以将TLM模型视为功能描述的一致性翻译，然后各自在TLM模型上进行开发。</p>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%972%E9%AA%8C%E8%AF%81%E7%9A%84%E7%AD%96%E7%95%A5/ESL%E5%BC%80%E5%8F%91%E6%B2%9F%E9%80%9A%E5%85%85%E5%88%86.png" class="" title="ESL开发沟通充分">

<h1 id="2-验证的层次"><a href="#2-验证的层次" class="headerlink" title="2. 验证的层次"></a>2. 验证的层次</h1><p>从系统定义阶段开始，我们将芯片系统划分为子系统，进而将每个子系统划分为不同的功能模块，直到划分为复杂度合适的模块。到设计阶段，按照自底向上的方式开始做硬件设计和集成。从定义阶段到设计阶段，再到后端部分，整个硅前的流程都是将芯片按照层次划分的，<strong>一般称为芯片系统级（chip level /system level）、子系统级（sub-system level）和模块级（module level /unit level）</strong>。</p>
<p>这种层次划分的方式对于芯片开发有哪些好处呢？</p>
<ul>
<li>便于拆解功能模块，实现人员的并行工作协同。这一点是从项目执行效率出发的。</li>
<li>对于系统定义而言，这是从主要的功能、性能要求量化为系统不同模块定义的方法。</li>
<li>从设计和验证角度出发，合适的复杂度模块有助于估计工作量和人员分配。设计最终是通过模块化来集成的，而验证环境在模块化后可方便地在更高层的环境中复用。</li>
<li>对于后端，在进行了合理的区域划分后，模块和芯片系统可以并行进行后续的物理设计流程。设计模块在每个阶段进行相关的设计检查，集成后的芯片系统最终进行设计检查并通过流片要求。</li>
</ul>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%972%E9%AA%8C%E8%AF%81%E7%9A%84%E7%AD%96%E7%95%A5/%E6%89%8B%E6%9C%BA%E9%80%9A%E4%BF%A1%E8%8A%AF%E7%89%87%E7%BB%93%E6%9E%84%E7%A4%BA%E4%BE%8B.png" class="">

<p>如果我们是在为一款手机设计通信芯片，如图2.8显示，一开始的系统定义阶段可能要规划出这么多的功能模块，还需考虑模块的性能因素。每一款芯片都包括多个子系统，每个子系统包含多个功能模块。从图1.3中的这款手机通信芯片结构来看，它包括的子系统有：</p>
<ul>
<li>处理器子系统；</li>
<li>协处理器子系统；</li>
<li>本地存储子系统；</li>
<li>外部存储控制器系统；</li>
<li>数据接口系统；</li>
<li>系统模块外设；</li>
<li>多媒体子系统；</li>
<li>调制解调子系统。</li>
</ul>
<p>核心模块调制解调子系统中的2G/3G/4G 由于自身的复杂性提高，可以进一步作为独立的系统来对待，进而细分下去。至于如何划分层次，我们一般从如下几个角度考虑：</p>
<ul>
<li>系统的复杂性：如果系统相对独立，自身就有作为子系统的条件；如果本身仍过于复杂，则可以进一步细分。</li>
<li>芯片集成的便利性：对于顶层芯片集成而言，一个合适的子系统应与外界有清晰的功能边界，如系统信号边界、标准总线边界、与其他子系统交互的边界，同时这些信号边界也尽可能保持稳定和精简。这是从顶层集成的工作量和后端布局布线的角度出发的。</li>
<li>验证的阶段：验证人员需要清楚，哪些功能点在模块级验证、哪些在子系统级验证和芯片系统级验证、是否有必要在不同级别重复验证、各个层次是否会保证验证完备性。</li>
<li>后端的流程：如果一个子系统占芯片整体面积的10%以上，那么后端就有理由考虑将其单独综合，因为合理的划分子系统且并行综合有助于后期整个芯片综合的收敛。</li>
</ul>
<p>接下来主要从验证的角度来考虑，如何选择合适的验证层次和对应的验证环境：</p>
<ul>
<li>模块级（block level /unit level）；</li>
<li>子系统级（sub-system level）；</li>
<li>芯片系统级（chip level）；</li>
<li>硅后系统级（post-silicon system level）</li>
</ul>
<h2 id="2-1-模块级"><a href="#2-1-模块级" class="headerlink" title="2.1 模块级"></a>2.1 模块级</h2><p>如果是图2.8中的处理器子系统，考虑先将DMA（Direct Memory Access）、Cache缓存和 Core0/Core1分别展开模块验证。每个模块验证首先要考虑的是，哪些功能点可以在模块一级完全验证。</p>
<p>决策基于如下因素：</p>
<ul>
<li>内部功能如状态机验证；</li>
<li>内部数据存储验证；</li>
<li>数据打包功能、编解码功能；</li>
<li>指令执行；</li>
<li>寄存器配置。</li>
</ul>
<p>同时需要考虑哪些功能无法在模块一级被验证到：</p>
<ul>
<li>与其他相邻模块的互动信号；</li>
<li>与其他子系统的互动信号；</li>
<li>与芯片外部的互动信号；</li>
<li>与电源开关的验证。</li>
</ul>
<p>我们需要考虑在更高的层次来验证这些部分。</p>
<h2 id="2-2-子系统级"><a href="#2-2-子系统级" class="headerlink" title="2.2 子系统级"></a>2.2 子系统级</h2><p>一个成熟的<strong>子系统，既拥有完备的功能可以执行专门的任务，也有足够稳定的接口用来在更高层做集成。与模块相比，子系统更稳定也更封闭</strong>，这对顶层集成是有好处的。也正是这种便于集成和相对封闭的特征，使得我们可以从公司外部或内部得到不同的子系统。</p>
<p>合格交付的子系统应该包含：</p>
<ul>
<li>设计包；</li>
<li>验证包；</li>
<li>回归测试表；</li>
<li>覆盖率收集脚本和数据；</li>
<li>完整的文档（设计、验证、集成、后端）。</li>
</ul>
<p>完备的交付可以增强顶层集成的信心，同时减少在集成过程中发生的一些接口理解分歧和参数化配置问题。单就验证而言，除了充分验证内部功能，如果对子系统的外部接口需要进行参数或编译预处理（compiler directive），验证人员则需要就这些参数和不同的编译选项（可能因此产生不同的硬件结构功能）给出完备验证。从子系统的封闭性和复用性来看，它们会在多个芯片项目中被使用，这对设计复用来讲是一件好事，而验证也需要将验证环境参数化以适应硬件的参数化配置。只有充分验证了参数化的子系统，才可能让它在不同的芯片项目中实现预期的功能。对验证管理而言，子系统验证是一个理想的可以切分的单元。这一层下面的模块之间互动很多，而这一层本身趋于封闭，与外围的接口有限，所以便于在子系统层设置独立的验证小组——“包产到组”。</p>
<h2 id="2-3-芯片系统级"><a href="#2-3-芯片系统级" class="headerlink" title="2.3 芯片系统级"></a>2.3 芯片系统级</h2><p>在芯片系统级，我们的验证平台的复用性较高，这主要是因为：</p>
<ul>
<li>外围的验证组件不需要像模块级、子系统级的组件那样，数量多且需经常更新。它们主要侧重于验证芯片的输入输出。</li>
<li>芯片内部的子系统之间的交互、协作检查主要交给处理器和子系统，从寄存器检查和数据检查入手，实现定向测试（directed test）用例。</li>
</ul>
<p>芯片系统级的验证侧重于不同子系统之间的信号交互以及实现更贴近实际场景的用例。这里的实际用例并非在系统软件层面，而是将系统软件层面的场景进一步拆分为多个模块互动情景后，再分开测试。</p>
<h2 id="2-4-硅后系统级"><a href="#2-4-硅后系统级" class="headerlink" title="2.4 硅后系统级"></a>2.4 硅后系统级</h2><p>尽管硅前验证部分与硅后系统软件开发联系较少，但尽早将硅后软件开发的实际用例用在硅前测试，能够发现一些实际使用中的问题。实际上，系统软件用例和硅前的随机测试具有互补的特性，功能验证中的缺陷如果没有在硅后测试、软件开发、用户使用中发现，那么隐藏的缺陷会静静地躺在那里，也许永远不会被发现（没有零缺陷的芯片，却有用户未发现缺陷的芯片）。所以，将硅后的驱动、固件和系统软件尽早在硅前引入验证过程，则可以与硅前的验证方法形成互补，使验证更加完善。</p>
<p>前面介绍了验证的4个阶段，给出了它们各自使用的测试场景。这里再给出可以遵循的几点原则，帮助大家在验证时选择适合的级别：</p>
<ul>
<li>能够在更低的级别完成某一项功能验证，就不要在更高层次上去验证。小的验证环境更有利于控制激励场景的产生，能更加全面地覆盖功能点。</li>
<li>低层次已经充分验证过某一项功能，高层次就不要重复验证。低层次无法完全覆盖功能点验证时，应在高层次完全覆盖。</li>
<li>在低层次的验证阶段应适当考虑高层次的测试用例，并在低层次创造一些条件模拟发生的条件和场景。</li>
<li>在高层次的验证阶段，验证环境中的参考模型、数据比对、监视器等模块应首先考虑从低层次环境复用，无法满足时再考虑重新构建。</li>
<li>对于新的模块或者新的功能，应投入更多精力、给于更高优先级，在不同层次充分验证。</li>
</ul>
<p>通过表2.1来更好地理解不同验证层次的侧重、性能和
使用方法。选择一个合适的验证层次，通过在不同层次分配不同的功能验证点，是最终迈向验证完备性的一项必备技能。</p>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%972%E9%AA%8C%E8%AF%81%E7%9A%84%E7%AD%96%E7%95%A5/%E4%B8%8D%E5%90%8C%E9%AA%8C%E8%AF%81%E5%B1%82%E6%AC%A1%E7%9A%84%E4%BE%A7%E9%87%8D%E3%80%81%E6%80%A7%E8%83%BD%E5%92%8C%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.png" class="">

<h1 id="3-验证的透明度"><a href="#3-验证的透明度" class="headerlink" title="3. 验证的透明度"></a>3. 验证的透明度</h1><p>可以按照激励的生成方式和检查的功能点分布将验证划分为三种基本方式：</p>
<ul>
<li>黑盒验证；</li>
<li>白盒验证；</li>
<li>灰盒验证。</li>
</ul>
<p>接下来，我们逐一解释这三种不同透明度的验证特征。</p>
<h2 id="3-1-黑盒验证"><a href="#3-1-黑盒验证" class="headerlink" title="3.1 黑盒验证"></a>3.1 黑盒验证</h2><p>如果验证人员对设计的细节缺乏认识，那么黑盒验证是一种合适的方式。因为验证环境只需要将激励给入设计的外部接口，检查设计的另一侧输出就足够了。测试成功与否只是根据一个输入是否得到一个正确的输出去判断，验证环境本身不会关注设计的内部。</p>
<p>图2.9是黑盒验证的结构。</p>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%972%E9%AA%8C%E8%AF%81%E7%9A%84%E7%AD%96%E7%95%A5/%E9%BB%91%E7%9B%92%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%84.png" class="" title="黑盒验证结构">

<p>从图2.9可以看到，激励生成器（stimulator）只负责给设计灌入激励，监视器（monitor）和检查器（checker）只查看和比较输出信号。<strong>黑盒验证的一个缺点是缺少设计的透明度和激励的可控性</strong>，由此带来的问题包括：</p>
<ul>
<li>测试失败时无法更深层次地定位问题。验证人员只能判断测试是否成功，无法进一步定位到缺陷所在的位置进而与设计人员完成深度协作。</li>
<li>难以发现一些较深的缺陷。因为验证人员无法根据设计本身给出<strong>更窄的随机约束定向地生成一些激励</strong>，同时，这对设计内部功能点的功能覆盖率收敛没有太多的帮助。</li>
</ul>
<p>设计的接口采用标准接口时，图2.9中的激励生成器或总线功能模型可以使用成熟度高的验证IP。这些验证IP一般由第三方公司提供，有时公司内部也有这样的IP，它们的特点是像标准接口一样易于在验证环境中插拔和控制，且接口时序严格按照总线文档定义。监测器也来自于验证IP，这减少了验证人员底层开发的工作量。所以，当模块的接口是标准接口时，验证环境可以复用一些验证IP。</p>
<p>由于黑盒验证本身不包含设计的内部逻辑信息，所以当设计因缺陷而更新或添加新的特性时，原有的测试列表仍然较稳定，验证人员只需要对新添加的特性考虑新的测试场景。<strong>黑盒验证有利于保持测试环境的稳定，当后续项目中更新了设计时，新的验证人员也只需要很少的力气来维护继承的验证环境</strong>。</p>
<h2 id="3-2-白盒验证"><a href="#3-2-白盒验证" class="headerlink" title="3.2 白盒验证"></a>3.2 白盒验证</h2><p>白盒验证可以弥补黑盒验证的一些不足。验证人员了解设计的内部工作逻辑、层次、信号等，他们因而可以对更底层的设计细节进行测试。<strong>这种验证方式检查设计是否严格遵循功能描述文档，测试发生失败时可以更快速地定位到缺陷</strong>。对于白盒验证的环境，我们的参考模型逻辑非常简略，甚至不需要参考模型，<strong>只需要植入监视器和断言来检查各个内部逻辑。这种环境配置背后的原则是，充分检查各个逻辑驱动和结构以后，就不需要测试它的整体功能了。不过</strong>，使用白盒验证也面临一些方法学上的缺陷：</p>
<ul>
<li>由于本身专注于设计内部逻辑检查而忽略整体功能的测试，<strong>设计本身违反规范时，白盒验证难以发现缺陷</strong>。</li>
<li>在数据一致性检查方面，白盒验证难以从整体入手给出实际测试用例。</li>
<li>白盒验证的测试用例很多是从设计细节入手的，所以，设计发生更新时，验证环境的维护成本偏高。这一点在项目间复用方面带来的影响更多，新接手验证环境的人要付出很大的成本去理解设计细节和验证环境的细节；这时候白盒验证环境的低复用性缺点就暴露出来
了。</li>
</ul>
<h2 id="3-3-灰盒验证"><a href="#3-3-灰盒验证" class="headerlink" title="3.3 灰盒验证"></a>3.3 灰盒验证</h2><p>黑盒验证和白盒验证各有优势和劣势。在实际验证中，我们倾向于将黑盒和白盒两种方法结合起来，以一种称为灰盒验证的方式（其结构见图2.10），<strong>将监视器、断言、参考模型一同用来完善验证</strong>。这种糅合方式带来的好处包括：</p>
<ul>
<li>监视器和断言可以有更好的透明度来着重检查设计的一些重要内部逻辑。</li>
<li>参考模型已经有了断言检查局部逻辑的帮助，所以可以降低一部分精确度，而主要专注在输入和输出数据的比较上。</li>
</ul>
<p>从复用性角度考虑，灰盒验证也有灵活的变动方式：</p>
<ul>
<li>对于新的设计，我们的验证人员需要更深入地理解设计本身。采用灰盒验证一开始通过监视器和断言来进行局部验证，待设计初步完善和趋于稳定时，验证人员就有了对设计更全局性的理解来构建参考模型。又因为前期监视器和断言保证局部逻辑的正确，参考模型的
构建不需要完全精确，只需要较少的精力来实现。</li>
<li>该设计移植到别的项目时，设计难免需要进行局部修改，这时，灰盒验证的复用性优势相对于验证环境就体现出来了。哪怕是新的验证人员接手这个验证环境，好的灰盒环境也可以清晰地将黑盒和白盒的部分划分开。在设计复用的项目中，建议首先打开黑盒开关，
这对新的验证人员来讲测试成本较低，也不需要对设计和验证环境了解太多。同时，这么做也可以第一时间保证原有功能的稳定性，并反馈给设计人员新的改动造成的影响。紧接着，验证人员可以针对新的特性创建特定的黑盒测试序列，新的黑盒测试序列因设计本身的稳定
而不需要关注设计内部的太多细节。</li>
<li>完成黑盒验证环节后，可以在时间允许的情况下有序引入白盒的开关。首先应考虑创建新的白盒断言点或功能检查点，关注新的功能部分；其次，完成新的功能点白盒覆盖后，考虑逐个打开原有的白盒功能检查开关。打开白盒检查开关时，我们也遵循着每次添加较少
的开关来跑回归测试的策略，便于发现问题后快速定位到新打开的开关一侧；另外，白盒检查点的开关有优先级，如果验证人员足够专业，在他的代码或者文档中会对这些白盒开关给出说明和重要性排列。文档说明有助于新的验证人员按照优先级的高低来打开不同的开关。</li>
</ul>
<p>所以，灰盒验证不但可以继承黑盒验证和白盒验证的优势，而且对验证环境在新项目中的复用有明显优势。</p>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%972%E9%AA%8C%E8%AF%81%E7%9A%84%E7%AD%96%E7%95%A5/%E9%BB%91%E7%9B%92%E3%80%81%E7%99%BD%E7%9B%92%E5%92%8C%E7%81%B0%E7%9B%92%E7%9A%84%E9%AA%8C%E8%AF%81%E7%89%B9%E7%82%B9.png" class="">

<p>最后，我们通过表2.2来总结黑盒验证、白盒验证和灰盒验证的特点。可以看出，灰盒验证可以<strong>最好地平衡设计增量和验证复用</strong>。在设计阶段，如果验证人员有充分的经验来实现灰盒验证环境，清晰划分黑盒部分和白盒部分，那么在后续的项目中，灰盒验证的良好复用性和灵活性会给模块的集成带来便利。在高度集成化的今天，我们对设计复用性的考量，是从整个设计交付包（design delivery package）出发的，包括之前提到的设计包、验证包、文档包、回归测试包和覆盖率包等。</p>
<p>无论设计人员还是验证人员，都需要从各自的角度考虑复用性，全盘考虑设计的整个流程。设计交付只有能带来更好的“用户体验”，缩短集成时间（设计和验证），这才是好的设计和验证方式。</p>
<h1 id="4-激励的原则"><a href="#4-激励的原则" class="headerlink" title="4. 激励的原则"></a>4. 激励的原则</h1><p>激励的原则实际上就是为了解决一个问题，<strong>即如何保证激励源最大的自由度。只有从环境结构上保证了激励源最大的自由度，才能在输入一侧提供更丰富的组合，有条件地穷历一些测试序列</strong>。</p>
<p>按照这个核心原则，我们可以按下面这些因素评估激励的自由度：</p>
<ul>
<li>接口类型；</li>
<li>序列颗粒度；</li>
<li>可控性；</li>
<li>组件独立性；</li>
<li>组合自由度。</li>
</ul>
<p>下面我们具体了解激励在这些方面的表现和评估方法。</p>
<h2 id="4-1-接口类型"><a href="#4-1-接口类型" class="headerlink" title="4.1 接口类型"></a>4.1 接口类型</h2><p>面对一个设计的输入接口，我们可以先判断接口的类型
（interface type）。如果设计的接口类型复杂多样，可以通过接口类型的划分，化繁为简地找到从哪里下手给出激励。常见的接口类型可以分为：</p>
<ul>
<li>系统控制接口（system control interface）。例如，时钟、复位、安全、电源开关等，以及这些系统控制信号旁生出的控制信号，如时钟门控信号（clock gating signal）。</li>
<li>标准总线接口（standard bus interface）。公开的行业标准总线协议，例如常见的AMBA系列协议、OCP、MIPI系列协议等，其文档详细，同时有丰富的验证IP提供服务。</li>
<li>非标准总线接口（non-standard bus interface）。公司内部定义的接口，或者根据模块功能需求定义的接口。<strong>接口时序相对简单，文档也较粗略</strong>。公司内部即使有可复用的验证IP，验证IP本身也可能未经过充分测试，而且在非标准协议定制的背景下，验证IP的复用性较低。</li>
<li>测试接口（test interface）。该测试接口主要留给可测性（DFT,Design For Test）功能使用，在功能验证中禁用即可。</li>
<li>其他控制接口（miscellaneous control interface）。如果被测设计是处于子系统中的功能模块且与相邻多个模块交互，那么该控制接口的信号数量较多、功能较分散；如果该设计是子系统，则该类型的控制接口数量较少且功能较集中。</li>
</ul>
<p>有了清晰的分类，验证人员就可根据不同的接口类型选择验证IP，或者自己着手搭建激励组件（verification component）了。</p>
<h2 id="4-2-序列颗粒度"><a href="#4-2-序列颗粒度" class="headerlink" title="4.2 序列颗粒度"></a>4.2 序列颗粒度</h2><p>对不同的接口我们会引入不同的验证组件。激励生成器（stimulus generator/driver）是接口验证组件的重要部分，它提供一些基本的功能方法用来生成小颗粒度的激励（sequence granularity）。用户也可以进一步做上层封装，从更高抽象级的角度生成大颗粒度或宏颗粒度的激励序列。我们按照软件层概念将激励序列颗粒度划分为下面的层级：</p>
<ul>
<li>基本颗粒层；</li>
<li>高级颗粒层；</li>
<li>宏颗粒层；</li>
<li>用户自定义颗粒层。</li>
</ul>
<p>从激励生成器提供的方法继承和封装入手，可以将这些颗粒层的关系表现为，<strong>基本颗粒层提供基本颗粒生成方法，而在其上，高级颗粒层和宏颗粒层做了深入的封装，帮助建立数据包（packet）和帧（frame）的概念。用户也可以依赖基本颗粒层，根据实际场景的需要实现自定义颗粒层，以方便特定场景的激励控制。序列的颗粒层次如图2.11所示</strong>。</p>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%972%E9%AA%8C%E8%AF%81%E7%9A%84%E7%AD%96%E7%95%A5/%E5%BA%8F%E5%88%97%E7%9A%84%E9%A2%97%E7%B2%92%E5%B1%82%E6%AC%A1.png" class="" title="序列的颗粒层次">

<p>我们以一个商业总线验证IP为例。该验证IP包具有基本颗粒层和高级颗粒层来生成不同级别的测试序列，在一些情况下，验证IP也提供宏颗粒层的定义来满足更高规模的数据传输。这里的抽象级<strong>指的是从时序和数据量传输的角度出发，越高的抽象级越不关注底层的时序而更重视数据的传输量，也是 TLM（Transaction Level Model）含义的延伸。当验证人员不能从已有的各种颗粒层中生成自己期望的测试序列时，便可以利用已有的基本颗粒层和高级颗粒层来构建自己的颗粒层</strong>。</p>
<h2 id="4-3-可控性"><a href="#4-3-可控性" class="headerlink" title="4.3 可控性"></a>4.3 可控性</h2><p>可控性（controllability）是从对不同颗粒层的控制角度出发的。按照序列颗粒度的划分，对应的可控性评估如表2.3所示。</p>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%972%E9%AA%8C%E8%AF%81%E7%9A%84%E7%AD%96%E7%95%A5/%E5%BA%8F%E5%88%97%E7%9A%84%E9%A2%97%E7%B2%92%E5%B1%82%E6%AC%A1.png" class="">

<p>在<strong>功能验证周期的初期阶段，应从基本颗粒层中选择激励方法，这有利于我们在接口的基本功能中调节测试不同的总线传输情况</strong>，这里的验证点<strong>侧重于协议功能和时序检查</strong>。随着设计趋于稳定，我们逐渐选择高级颗粒层和宏颗粒层，将验证精力<strong>转移到数据量的一致性传输和性能评估</strong>上，而这两层的颗粒控制性没有像基本颗粒层那样细致到可以调节每一个参数变量，它们会同验证重点保持一致，主要提供跟数据量有关的可约束参数。</p>
<h2 id="4-4-组件独立性"><a href="#4-4-组件独立性" class="headerlink" title="4.4 组件独立性"></a>4.4 组件独立性</h2><p>将一个设计的边界信号划分为不同的接口类型，并创建出对应的接口验证组件之后，我们就应该考虑各个组件之间的独立性了。<strong>组件的独立性（component independency）实际上也是协调性的基本保障，因为有了独立性，各个组件之间才会最大程度地不受其他组件的制约，同时又可以通过有效的通信机制实现组件之间的同步协调</strong>。我们接下来看看实现组件独立性需要考虑的因素：</p>
<ul>
<li>必须按照接口类型来划分组件。</li>
<li>对于系统控制信号组件，尽可能将信号的关系按照实际集成关系做控制，例如，多个时钟是不是同步关系，多个复位信号是否可以单独控制等。</li>
<li>对于总线接口（标准或者非标准），实现一对一的控制关系。例如，若有两组相同的总线，则应引入两个总线组件分别控制，而非建立一个总线组件却拥有两套总线接口；后者有悖于可控性和复用性的要求。</li>
<li>对于其他控制接口，应从实际相邻设计那里准确了解各信号的使能极性、脉冲有效还是电平有效、是否存在握手关系、时序等真实的设计信息，来模拟高层集成环境中的控制场景。同时由于这部分信号偏于杂乱，在尽可能梳理信号的不同来源和功能后，需要在接口组
件中通过封装好的方法来实现灵活驱动。</li>
<li>验证环境中的系统控制信号组件会与其他接口组件发生连接，例如提供必要的时钟和复位信息，那么这些连接也应遵循实际集成的情况，确保组件驱动端的时钟输入与设计的时钟输入端同步。</li>
</ul>
<h2 id="4-5-组合自由度"><a href="#4-5-组合自由度" class="headerlink" title="4.5 组合自由度"></a>4.5 组合自由度</h2><p>最后一个衡量因素——组合自由度（combination space）是对上述因素的整体评估。<strong>只有通过底层的精细划分，建立抽象级更高的颗粒度，通过独立组件之间的协调来给出激励，才能提供较高的组合自由度。在这里，除了组件的独立性外，需要考虑组件之间的协调方式。</strong></p>
<p>一般将协调方式分为两种：</p>
<ul>
<li><strong>中心统筹式</strong>（centrally organized）。通过中心化的调遣，将不同的任务统一分派给各个接口组件，产生不同的激励组合场景。</li>
<li><strong>分布事件驱动式</strong>（distributed event driven）。将激励控制权交给各个接口组件，通过接口组件之间的通信来实现分布式的事件驱动模式，即组件之间的通信通过事件（event）、信箱（mailbox）、接口信号（interface signal）等方式实现同步通信。</li>
</ul>
<p>通过上述因素，我们可以评定出一个验证环境中各个接口组件之间的组合，是否可以提供足够的自由度，最终有可能穷历出预定的激励序列。</p>
<h1 id="5-检查的方法"><a href="#5-检查的方法" class="headerlink" title="5. 检查的方法"></a>5. 检查的方法</h1><p>懂得了如何实现和评估激励自由度的方法后，需要考虑在各种可能的激励组合下如何选择适当的检查，以完成验证环境的另外一项核心要素——检查。检查就是查看设计是否按照功能描述做出期望的行为，识别所有错误的输出，发现设计缺陷。我们是按照接口类型来划分激励的；</p>
<p>对于检查，类型的划分方式则基于被检查逻辑的层次，这些层次包括：</p>
<ul>
<li>模块的内部设计细节；</li>
<li>模块的输入输出；</li>
<li>模块与相邻模块的互动信号；</li>
<li>模块在芯片系统级的应用角色。</li>
</ul>
<p>不同的检查层次，可以考虑采用不同的检查方法，如表2.4所示。</p>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%972%E9%AA%8C%E8%AF%81%E7%9A%84%E7%AD%96%E7%95%A5/%E4%B8%8D%E5%90%8C%E5%B1%82%E6%AC%A1%E7%9A%84%E6%A3%80%E6%9F%A5%E6%96%B9%E6%B3%95.png" class="">

<p>从表2.4可以看出，<strong>经常使用的方法有监测器（monitor）、断言（assertion）、参考模型（reference model）、比较器（comparator/scoreboard）、定向测试和形式验证等</strong>。接下来，我们简要分析不同检查方法的要点，关于这些方法的更多介绍，读者可以在8.6节详细了解。</p>
<p>一般而言，<strong>监测器（monitor）是必备的组件，它便于我们观察硬件信号。所以，在各个层次都可以找到监测器的身影</strong>。查看设计内部信号另外一个可行办法是使用 SystemVerilog绑定（bind）的特性。由于监测器可能被置入到各种方法中，我们需要从复用的角度，在构建监测器的时候考虑如下因素：</p>
<ul>
<li>监测器一般跟激励发生器的作用域一致。这指的是，如果该激励发生器对应一组总线，那么应该有一个对应的监视器负责监视总线的传输。</li>
<li>监测器应根据检查的层次将信号监测分为模块内部和模块边界。</li>
</ul>
<p><strong>对于断言（assertion），我们主要依靠它检查模块的内部逻辑细节和时序信息。利用断言，我们可以通过仿真或形式验证来完成测试</strong>。是否选用仿真或形式验证的方式，这里给的建议是：</p>
<ul>
<li>如果是模块级别，断言通过形式验证完全覆盖设计的多数功能点从效率和完备性来看是可靠的。同时建议在子系统或芯片一级创建基本的测试用例进行仿真，以作为形式验证的补充。</li>
<li>如果断言验证的功能点较分散或主要关切于模块的核心逻辑、时序，则倾向于使用仿真验证，采取灰盒模式，而用断言来验证重要设计细节。</li>
<li>如果断言总体可以覆盖模块的所有设计功能部分，采取形式验证或者白盒仿真验证两种方法都是可取的。</li>
</ul>
<p><strong>除了待测设计本身的尺寸、复杂度以外，参考模型（reference model）的构建也与验证方法有关。从2.3节来看，白盒验证对参考模型的要求最低，而黑盒验证却将最大的压力交给如何实现准确的参考模型。</strong></p>
<p>比较器（comparator）的结构相对简单，一般依靠足够稳定的监测器和准确的参考模型，<strong>比较器只需要将监测的硬件输出和参考模型的输出做比较，给出充分的比较信息。测试用例结束时，给出自定义的测试报告即可</strong>。</p>
<p>当模块完成了模块测试、子系统测试，迁入到芯片系统级测试后，我们在系统一级复用监测器和断言。这些从低层次复用来的监测器和断言，在高层测试中主要用于覆盖目标模块与其他模块互动的功能点。在系统测试中，从实际应用场景出发，我们一般采用定向测试即C/C++代码，编译后由系统中的处理器来执行。<strong>定向测试的一个好处是为硅后测试提供可复用的测试代码</strong>。</p>
<h1 id="6-集成的环境"><a href="#6-集成的环境" class="headerlink" title="6. 集成的环境"></a>6. 集成的环境</h1><p>分析完激励的原则和检查的方法后，验证平台（testbench）的核心要素就大致齐备了。接下来将进一步分析验证环境的集成需要考虑的因素，并梳理各部分之间的关系。从图2.12可以看出，验证集成环境分为：</p>
<ul>
<li>验证平台（verification platform）；</li>
<li>待验设计（design under verification）；</li>
<li>运行环境（runtime environment）；</li>
<li>验证管理（verification management）。</li>
</ul>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%972%E9%AA%8C%E8%AF%81%E7%9A%84%E7%AD%96%E7%95%A5/%E9%AA%8C%E8%AF%81%E7%8E%AF%E5%A2%83%E7%9A%84%E8%A6%81%E7%B4%A0.png" class="" title="验证环境的要素">


<h2 id="6-1-验证平台"><a href="#6-1-验证平台" class="headerlink" title="6.1 验证平台"></a>6.1 验证平台</h2><p>验证平台是验证人员日常工作的对象。在建立或复用验证框架时，主要考虑激励分类和检查方法两部分，这两部分直接影响验证平台的框架。</p>
<p>激励分为如下两类：</p>
<ul>
<li>定向激励。一般通过文本激励、C代码激励、预先生成激励码等形式给入。</li>
<li>随机激励。通过随机约束给入激励，这里的随机方式不局限于SV，也包括其他随机验证语言，或者利用脚本语言来产生随机激励。</li>
</ul>
<p>检查一般分为如下三类：</p>
<ul>
<li>线上检查（online check）。在仿真的过程中动态比对数据，并给出比较结果。</li>
<li>线下检查（offline check）。在仿真结束后比对仿真中收集的数据，给出比较结果。</li>
<li>断言检查（assertion check）。通过仿真或形式验证的方式利用断言检查设计的功能点。</li>
</ul>
<h2 id="6-2-待验设计"><a href="#6-2-待验设计" class="headerlink" title="6.2 待验设计"></a>6.2 待验设计</h2><p>根据功能描述的建模方式，硬件设计可以分为两类：</p>
<ul>
<li>HDL 硬件模型。即，使用 HDL 语言描述的硬件模型，按照硬件层次可以分为RTL和网表。该模型的特点是与硬件设计师距离最近，也是最贴合硬件逻辑行为的模型。</li>
<li>虚拟原型（virtual prototype）。在硬件定义的早期阶段，引入虚拟原型对硬件的框架和性能进行评估。在数字信号处理模块中需要复杂的算法参与，所以在硬件实现之前，可以采用软件算法模型来代替硬件的功能（不考虑时序替代）。常用的虚拟原型语言包括
SystemC、C/C++、MATLAB等。</li>
</ul>
<p>仿真过程中可以将 HDL 硬件模型与虚拟原型混合，进行联合仿真。这时，需要考虑虚拟原型的接口是否可以在硬件仿真环境中较为方便地集成，以及是否有对虚拟原型的接口时序的要求。</p>
<h2 id="6-3-运行环境"><a href="#6-3-运行环境" class="headerlink" title="6.3 运行环境"></a>6.3 运行环境</h2><p>运行环境的主要职责是将验证平台和待验设计进行融合（软件激励端和硬件模型端的互动）。</p>
<p>根据前面对验证平台和待验设计的分类，运行环境需要考虑的因素有：</p>
<ul>
<li>验证平台。运行环境需要传入参数，根据测试场景选择测试序列、随机种子数值、参数化的环境结构和实例化验证平台。</li>
<li>待验模型。除了考虑如何实现HDL硬件模型与虚拟原型在仿真器中<strong>协同仿真</strong>之外，还需要实现验证平台和待验设计的接口对接，包括硬件信号接口连接和内部信号的接口监测。</li>
<li>仿真全流程建立。包括验证和设计的文件提取
（extraction）、文件依赖度分析（dependency analysis）、编译（compilation and elaboration）、仿真（simulation）、结果分析（result analysis）和回归测试（regression test）等。全流程的建立一般是由环境建设者（environment builder）通过脚本（script）语言来做管理的，用于仿真流程建立的常见脚本语言包括Shell、Makefile、Perl、Tcl、Python等。</li>
</ul>
<h2 id="6-4-验证管理"><a href="#6-4-验证管理" class="headerlink" title="6.4 验证管理"></a>6.4 验证管理</h2><p>无论芯片的尺寸有多大，验证人员和验证经理都需要对自己负责的模块或芯片做量化的验证管理。除常见的 Excel 表格管理外，也可使用其他验证管理工具进行管理。这些验证管理工具需要考虑的因素有：</p>
<ul>
<li>验证计划和进度管理（verification plan and progress management）。验证计划需要将抽象内容与量化后的测试用例、功能覆盖率相对应，进而给出可视化的验证进度。</li>
<li>文件版本控制管理（file version control management）。文件版本控制在团队协作中几乎是必需品，常见的工具有SVN、Git、Clearcase等。</li>
<li>项目环境配置管理（project environment configuration management）。项目环境的配置文件不但包括项目中使用的各种工具的版本、单元库的版本、验证IP的版本，也包括验证环境的顶层配置。通过这些环境配置管理，每一个参与项目的人都可以很快地实现环境配置，省去同步验证环境的工作。</li>
<li>缺陷率跟踪管理（defect tracking management）。之前提到的缺陷率曲线，需要验证人员和验证经理保持记录的习惯，除了通过缺陷率曲线衡量验证的进度，还需要通过记录跟踪缺陷的修复、后续验证的工作。</li>
</ul>
<p>足够稳定的验证平台，能够在更早期利用不同抽象级别的待验模型展开验证环境的搭建和验证工作。通过模块化和自动化的运行方式，实现环境的从建立到检查，一个完善的验证环境能够给验证人员助力不少。从项目管理的角度，也需要一个完善的工具（可能是几个工具共同协助）帮助我们完成验证管理，最终达到验证目标。</p>
<h1 id="7-作者结束语"><a href="#7-作者结束语" class="headerlink" title="7. 作者结束语"></a>7. 作者结束语</h1><blockquote>
<p>笔者还记得接手的第一个验证环境是Specman eRM结构，当时苦于缺少合适的文档，很多代码和工具的使用让我吃了不少的苦头。经历了OVM的验证阶段后，再回头思考eRM，发现验证的思想有很多是可以借鉴和优化的。就是说，尽管我们验证者（Verifier）需要用更多的时间去适应变化更快的验证技术和工具，但在这背后都是逐步继承的关系。你学习到的知识，多年以后有一部分将被替代，而核心的部分还将被保留下来。本章关于验证策略的通识，就是属于那些不会被替代的部分。你会在任何一种验证语言或者验证方法学中捕捉到与验证策略有关的信息，因为它是验证作为一种综合技术能力的基础。</p>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-05-06T09:49:31.000Z" title="5/6/2022, 9:49:31 AM">2022-05-06</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/IC%E9%AA%8C%E8%AF%81/">IC验证</a></span><span class="level-item">2 小时读完 (大约14615个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%971%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E5%85%A8%E8%A7%86/">芯片验证漫游指南1芯片验证全视</a></p><div class="content"><h1 id="1-功能验证简介"><a href="#1-功能验证简介" class="headerlink" title="1 功能验证简介"></a>1 功能验证简介</h1><p>如果你在设计一款处理器，你需要考虑将其拆分成为运算器（算术逻辑运算单元，ALU,Arithmetic Logic Unit）、高速缓冲存储器（Cache）和连接它们的总线（Bus）；如果你在设计一款系统集成芯片（SoC、System-on-Chip），那么它可能包括的子系统包括处理器、片上网络（NoC,Network-on-Chip）、存储器、I/O 控制器（例如 USB,PCIe）等。你会发现，随着系统集成度的提高，系统自身的复杂性增加，而且结合实际工程项目来看，系统复杂度的提高对于功能验证的要求是首当其冲的。由于功能验证在芯片全流程中占据关键位置，验证工程师需要充分理解系统验证的全过程，这个过程就是功能验证的生命周期。功能验证在项目的延续中（目前芯片迭代周期越来越短的一个重要原因，就是依靠剪裁以前项目来做快速的芯片设计）得到不断的提升，而这要求验证工程师考虑如何完善验证流程和环境。在本书一开始，路桑将带领读者从芯片开发流程进入，检视芯片验证在整个项目中的作用（见图1.1）。</p>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%971%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E5%85%A8%E8%A7%86/%E8%8A%AF%E7%89%87%E7%A1%85%E5%89%8D%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B.png" class="" title="芯片硅前开发流程">

<p>一般而言，新的芯片项目首先从市场人员与客户沟通开始。市场人员收集客户对芯片的要求（主要包括功能、尺寸、功耗、性能），这些指标被记录在设计结构和产品文档中。随后，客户关心的系统层面功能被系统设计人员按照功能进一步划分为各个独立的子系统。这些子系统如果本身过于庞大，则被划分为<strong>功能模块</strong>，直到被划分出来的尺寸可以被小的设计团队进行硬件实现。硬件设计人员按照芯片的功能模块划分成不同的小组，同时系统设计人员的数目随系统复杂度的升高而增加。在硬件设计过程中，硬件设计工程师将具体的功能描述文本通过逻辑翻译成为硬件描述语言（HDL,Hardware DescriptionLanguage模型），目前广泛使用的HDL语言VHDL和Verilog均被各大EDA（Electronic Design Automation）公司的软件支持。由于SystemVerilog囊括了Verilog语法和更多高级设计属性，其也被用做一种设计语言。</p>
<p>当细分的模块初步完成RTL级（寄存器级别，Register Transistor Level）的设计之后，验证人员要做几项工作来检查设计：</p>
<ul>
<li>设计文件是否正确地按照功能描述文档实施了？</li>
<li>硬件设计人员是否有遗漏掉的边界情况（corner case）？</li>
<li>硬件设计是否足够稳定以处理一些错误情况（error response）？</li>
</ul>
<p>在实际项目中，硬件设计人员和功能验证人员的合作是紧密的，具体表现在：</p>
<ul>
<li>系统设计团队将功能需求（抽象指标）翻译为功能描述（自然语言）之后，硬件设计团队和功能验证团队要围绕功能描述文档分别展开各自的工作。</li>
<li>在设计团队初步实现设计以后，验证团队要搭建验证环境展开各功能点的验证。</li>
<li>当验证环境测试出的结果与预期不符合时，需根据情况区别对待。如果设计与功能描述存在明显不符，验证人员应报告出设计缺陷，同时设计人员应修复设计，这样从验证到设计再转回到验证即完成一个缺陷检测和修正周期；当结果和预期有模糊边界时（例如时序
问题、状态机跳转问题），验证人员和设计人员对功能描述的理解可能存在分歧，此时他们应做初步讨论，确定哪一方的理解有偏差。当讨论未决时，双方应找系统设计人员进行“裁决”，以明确设计思想，统一对功能的理解。</li>
</ul>
<p>因此，硬件设计的完成度和缺陷率在设计人员和验证人员的迭代周期中不断得到完善，最终可以达到目标。关于功能验证目标的定义，我们会在1.4节详细讲述。芯片硬件和软件的开发集成过程在图1.2中给出。</p>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%971%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E5%85%A8%E8%A7%86/%E8%8A%AF%E7%89%87%E7%A1%AC%E4%BB%B6%E5%92%8C%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91%E9%9B%86%E6%88%90%E8%BF%87%E7%A8%8B.png" class="" title="芯片硬件和软件的开发集成过程">

<p>功能验证完成后，后端人员（backend）将 RTL 文件综合生成门级网表（gate netlist），同时进行布局布线，最终使物理电路可以在设定的时钟频率上工作。在后端的各种流程中，与验证人员联系紧密的当属<strong>标准延时格式</strong>（SDF,Standard Delay Format）文件，该文件包含门级网表中各个门单元之间的延时信息，它们被用来准确描述物理电路的时序和检查要求。对于功能验证流程，我们所说的仿真可以
根据项目的实施流程将其划分为<strong>前端仿真和后端仿真</strong>：</p>
<ul>
<li>前端仿真指的是进行 RTL 仿真，在这种仿真中是<strong>没有真实延时情况</strong>的。对于一个寄存器（register），它的输出端（Q port）相对时钟输入端（Clk port）的延时为零延时（delta delay）。</li>
<li>后端仿真指的是进行<strong>门级（gate level）仿真</strong>。在实际项目中，由于后端SDF文件本身需要不断迭代（直至满足时钟频率要求），我们进一步将门级仿真划分为<strong>零延时（zero delay）仿真、单位延时（unit delay）仿真和SDF仿真</strong>。<ul>
<li>零延时仿真<strong>只有门级网表参与仿真</strong>，没有SDF文件来具体反向标注（back annotation）门级延时情况，所以门之间的延时仍然为零延时。这时门级零延时仿真与 RTL 仿真的区别仅在于前者是后者的逻辑映射，从寄存器级别到门级的逻辑转译，这一步是由后端的综合工具（synthesis tooling）完成的。</li>
<li>单位延时仿真类似于零延时仿真，也没有 SDF 输入，而是将各个单元门之间的路径延时和门内的延时都以单位延时计算，以此<strong>模拟时序的叠加</strong>，但并不准确，依然无法反映实际物理时序。此仿真同零延时仿真一样，<strong>只可用作逻辑实现检查，无法检查物理时序</strong>。</li>
<li>后端产生出SDF文件时，我们将门级网表反向标注上SDF文件中包含的时序信息，最终进行真实延时电路的仿真。</li>
</ul>
</li>
</ul>
<p>从验证完整性而言，前端仿真和后端仿真均需要在项目中实施，但它们侧重的目标有所不同。<strong>前端仿真是为了检测出功能逻辑的缺陷，而后端仿真是为了检测出门级电路由延迟导致采样失败所产生的功能缺陷</strong>。</p>
<p>因此，验证人员不能将前端仿真的功能缺陷检测任务下移到后端仿真阶段。就效率而言，前端仿真要显著高于后端仿真。同时，后端仿真之所以不能忽略，是因为它可以协助后端人员测试出实际生成电路中是否存在时序不满足的问题。</p>
<p>完成后端仿真以后，我们将后端生成的标准格式文件最终交付给芯片生产商进行流片（tape out）。从上面的描述来看，这是一颗完整的芯片从<strong>定义、分块、设计、验证和后端的硅前（pre-silicon）流程</strong>。</p>
<p>同时，芯片在流片以后所面临的硅后流程（post-silicon）也是一个完整的周期，包括组件测试、驱动、系统固件和应用软件编写，等等。由于功能验证处在硅前流程中，我们在这里主要阐述该流程，
同时将一些相对独立的部分略去（这并不代表它们不重要），例如，可测试性设计（DFT,Design For Test）。设计和验证团队协同工作示意于图1.3中。</p>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%971%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E5%85%A8%E8%A7%86/%E8%AE%BE%E8%AE%A1%E5%92%8C%E9%AA%8C%E8%AF%81%E5%9B%A2%E9%98%9F%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" class="" title="设计和验证团队协同工作流程">

<h1 id="2-验证的处境"><a href="#2-验证的处境" class="headerlink" title="2 验证的处境"></a>2 验证的处境</h1><h2 id="2-1-验证语言的发展"><a href="#2-1-验证语言的发展" class="headerlink" title="2.1 验证语言的发展"></a>2.1 验证语言的发展</h2><p>简单而言，验证的目标就是<strong>在一定的时间内尽可能多地测试硬件设计</strong>，发现设计缺陷并报告出来。同时，验证本身也是一项棘手的挑战，这一点可以从语言发展和各种快速发展的EDA工具上得到佐证。</p>
<p>我们从VHDL的语言发展线路来看，它的标准IEEE Std 1076-1987逐步经历了1076-1993,1076-2002再到1076-2008，这中间的年份从1987年逐步发展到2008年，可是我们真正在使用的设计标准是哪一部分呢？可能超过90%以上的设计都基于1076-1987和1076-1993，这是将近20年之前的标准，可是设计人员用它来描述电路已经足够了。因为设计面临的问题不是语言自身的局限，更多的是设计人员的经验和思想。</p>
<p>同样，我们看看Verilog语言的发展从IEEE Std 1364-1995到1364-2001再到1364-2005。目前我们所使用的Verilog代码也基本是在遵循1364-2001的标准，EDA工具商也主要在支持这一年份标准。</p>
<p>再来看看目前的主流验证语言SystemVerilog的发展情况，如果不考虑它之前在Accellera坐板凳的日子，它正式被认定位IEEE Std 1800-2005是从2005年才开始的！可我们看看它在这10年中便经历了1800-2009和1800-2012，更重要的是，<strong>它的每一次更新都得到了工具商的及时支持</strong>。为什么呢？因为实际验证的需要，绝对需要。</p>
<h2 id="2-2-验证面临的挑战"><a href="#2-2-验证面临的挑战" class="headerlink" title="2.2 验证面临的挑战"></a>2.2 验证面临的挑战</h2><p>随着芯片自身复杂度的日渐提高，以及一直存在的项目进度压力，如何实现验证的完整性和高效性成一个大家都关注的话题。概括来讲，验证目前面临的两大挑战是：</p>
<ul>
<li>如何穷尽所有可能的情况给设计产生激励。</li>
<li>如何在各种可能的激励情况下判断出不符合硬件描述的行为并报告出来。</li>
</ul>
<p>我们先看看第一个挑战——如何穷尽所有可能的情况。在这里以手机屏幕显示为例，假设手机屏幕分辨率是1920×1080，像素点的色彩值是232，同时，每个像素点之间的状态是独立的，那么屏幕可能分布的状态应该是：232×（1920×1080）=8 906 044 184 985 600</p>
<p>如果再考虑到像素点色彩值的变化，那么在连续两个时钟下，像素点可能发生的状态跳转空间是：232×（1920×1080）×232×（1920×1080）=7.9×1031
这仅仅是屏幕色彩的一个基本功能，而可以预见到的状态空间数目足以让人抓狂。所以，面对这样的挑战，我们需要<strong>作出一些平衡，这种平衡来自于状态空间本身的庞大和项目实施中的进度压力</strong>。如何<strong>划分出有效的测试空间、如何给出随机约束激励</strong>是验证人员需要具备的职业素质。</p>
<p>接下来我们看看第二个挑战，如何在各种可能的激励下判断出硬件设计的缺陷。首先把常见的硬件设计划分为如表1.1所示的几类，同时再看看针对不同设计的激励输入类型和结果判断的方法。</p>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%971%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E5%85%A8%E8%A7%86/%E4%B8%8D%E5%90%8C%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%BF%80%E5%8A%B1%E8%BE%93%E5%85%A5%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%BB%93%E6%9E%9C%E6%AF%94%E5%AF%B9%E6%96%B9%E6%B3%95.png" class="" title="不同设计的激励输入类型和结果比对方法">

<p>从表1.1可以发现，不同类型的设计需要产生的激励类型和结果比对方法是不一样的。针对不同类型、不同复杂度、不同集成度的设计，应采用不同的验证方法。从验证工具的分类看，可以将其<strong>分为仿真验证和形式验证</strong>；从复杂度出发，可以划分为<strong>黑盒验证、白盒验证以及灰盒验证</strong>。关于验证的方式以及合适的运用场景，我们也会在第2章里面展开详细讨论。</p>
<h1 id="3-验证能力的5个维度"><a href="#3-验证能力的5个维度" class="headerlink" title="3 验证能力的5个维度"></a>3 验证能力的5个维度</h1><p>列出验证人员需要具备的5个能力维度：</p>
<ol>
<li>完备性</li>
<li>复用性</li>
<li>高效性</li>
<li>高产出</li>
<li>代码性能</li>
</ol>
<h2 id="3-1-完备性"><a href="#3-1-完备性" class="headerlink" title="3.1 完备性"></a>3.1 完备性</h2><p>完备性要求<strong>验证的充分</strong>。然而，充分一词对于验证而言边界是模糊的，很难量化到什么时候才可以达到完成验证的标准。所以，作为一名验证经理，需要引入各种数据来综合量化出验证的进度，其中<strong>包括验证功能点的覆盖率、代码覆盖率、是否经过效能验证流程（power aware verification）、是否经过跨时钟域（clock domain crossing）检查</strong>等。</p>
<p>通过数据量化，验证人员和验证经理更有信心来宣布在某一个项目节点中，设计已经得到“充分”的验证。当然，对于功能覆盖率部分，如何将功能描述文档充分理解，进而列出要测试的功能点并尽可能地细分出来，这需要系统人员、设计人员和验证人员的共同努力。同时，将抽象的验证计划转换到功能覆盖率要求验证人员具备这样的能力。</p>
<h2 id="3-2-复用性"><a href="#3-2-复用性" class="headerlink" title="3.2 复用性"></a>3.2 复用性</h2><p>从项目的实际运用角度看，复用性和完备性是同等重要的。没有人愿意在下一个项目中将以前的验证环境做较大的更新，因为这意味着额外的资源消耗，包括时间、人力和项目进度的考虑。</p>
<p>在硬件设计角度而言，通过<strong>标准总线协议</strong>，可以最大限度地在模块之间实现相对独立和快速集成。对于目前项目周期不断缩短的现状来看，一方面是市场的瞬息万变导致的，一方面也是由于SoC自身趋向于软件的周期迭代方式而形成的。对于一个系列芯片而言，后续芯片的<strong>性能提高、功耗优化</strong>都是建立在前一代的基础上的。而这些不断的提高和优化具体到每一个硬件子系统而言，可能就是它们的存储大小、时钟快慢、动态电源开关、总线宽度、缓存深度来综合决定的，并且下一代硬件设计自身一般不会有第一代芯片的艰难历程（否则也就称不上是系列芯片了）。</p>
<p>那么从硬件设计的角度看，这些更新如果不在逻辑上面有大的变动，那么带来的工作量是可以估计的。而从验证角度看，我们很自然地希望验证的工作量不要太大——可事实并不一定是这样的。首先从芯片项目的人员安排看，验证人员相比于设计人员流动性更高。那么当一个验证人员在尝试维护和修改上一个项目的验证代码时，就要看他的“运气”，而他的运气与上一个验证人员的代码风格有直接关系。因此，如何标准化验证环境和测试规范，成为验证复用性的一个重要考量。同时，验证人员在处理一些总线协议时要有意识引入参数来为日后的复用做好准备。不断融合的验证方法学走到今天，UVM（Universal Verification Methodology）之所以划分出不同的功能组件，实现小的颗粒度，提供快速插拔式的环境集成能力，也是从复用性考虑的。</p>
<h2 id="3-3-高效性"><a href="#3-3-高效性" class="headerlink" title="3.3 高效性"></a>3.3 高效性</h2><p>高效性指的是用尽可能少的工作量完成验证工作。在保证验证完备性的考虑下，实际上<strong>复用性和高效性会有存在冲突的可能</strong>。例如，验证人员会考虑如何“短平快”地在一个紧张周期内完成验证工作，但他可能不会采用UVM等方法学框架，也有可能不会考虑将参数引入到验证环境中。因为这些“额外”的因素虽然对复用性有帮助，但与高效性冲突（费时）。所以，验证人员需要针对不同的情况在维度之间做好平衡，至少需要保持一种意识，那就是工程学的执行阶段本身就是一种平衡。对于验证人员来讲，他需要做出的判断就是在每一个项目的验证任务中做好取舍，给出合适的验证考量综合维度。对于同一项验证任务而言，采取不同的验证策略有不同的验证效果。例如，一开始考虑采用随机约束的验证方法，那么单单就约束而言，它的约束一开始是比较窄合适，还是一开始比较宽合适？</p>
<p>这里我们给出图1.5来说明高效性在一项验证任务的不同周期需要有相应的变化。在开始阶段，考虑到设计不够完备且尚未经历过验证，我们将其称为<strong>基本功能验证阶段</strong>。这个阶段，我们将随机约束域降低到基本范围，尽可能少地触碰到边界情况，把重点放到如何先将各项基本功能都验证到。第二个阶段是在已经完成基本功能验证以后开始的<strong>完备功能验证阶段</strong>，这时可以逐渐放开随机约束域，而开放的域范围需要验证人员考虑到各种合理的情形再做限定。到了功能覆盖率一般上升到80%附近时，就处于<strong>最后的爬坡阶段</strong>。这时，再沿用之前广泛的约束域就会产生很多无效的随机种子，这些“无效”的随机种子对于剩下的验证覆盖率几乎没有什么帮助。这时，验证人员需要通过理解设计本身和随机约束两方面来考虑具体贡献覆盖率的测试序列，再进一步缩窄随机约束域，偏置（biasing）产生一些激励。对于最后这一阶段，一种极端的情况就是将随机约束域缩到尽可能地窄，甚至和<strong>定向测试</strong>（directed test）没有什么区别。</p>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%971%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E5%85%A8%E8%A7%86/%E9%9A%8F%E6%9C%BA%E7%BA%A6%E6%9D%9F%E5%9F%9F%E4%B8%8E%E5%8A%9F%E8%83%BD%E8%A6%86%E7%9B%96%E7%8E%87%E7%9A%84%E5%85%B3%E7%B3%BB.png" class="" title="随机约束域与功能覆盖率的关系">

<h2 id="3-4-高产出"><a href="#3-4-高产出" class="headerlink" title="3.4 高产出"></a>3.4 高产出</h2><p>高产出指的是在一定的时间，能够调试、报告、帮助修正出多少设计缺陷，以及如何建立完整的验证环境。多年来，数字设计（RTL级别）的基础并没有发生太多变化，同时EDA厂商提供的自动化工具又进一步提高了设计的可靠性。但这一情况却并不适用于数字验证，因为EDA工具目前仍然只能作为辅助手段（例如提供更多的调试功能和接口），却不能帮助自动化建立复杂的验证环境。这也就不难解释2017年IC行业功能验证领域的调查数据显示，当前在设计和验证领域面临着最大的挑战之一就是为快速的芯片产品迭代和员工数量增长之间找到一个平衡点，实现单位产出的提高。</p>
<h2 id="3-5-代码性能"><a href="#3-5-代码性能" class="headerlink" title="3.5 代码性能"></a>3.5 代码性能</h2><p>代码性能似乎也跟高效性、高产出有冲突的地方。因为验证代码的整洁性、复用性甚至一点点的美感都与验证完备性没有直接联系。这也包括你的验证经理可能有好长时间都不会注意到你写的验证代码，除非有一天你验证的那个设计出了一个缺陷，而且是一个显而易见的缺陷却没有被发现，才会引起验证经理的注意并专门来回顾可能是一团糟的代码结构。每一位验证人员需要记住一句台词“出来混，迟早是要还的”。不管是别人的验证代码中存在着没有注释、没有缩进、超长函数等不良问题，还是你因为项目紧张，在快速搭建验证环境和编写测试用例时没有考虑到“后来阅读者”和“你后来阅读”而偷的各种懒。相信我，时间会让你为此买单的。所以，作为一名验证人员，请你在写每一行代码时把它当做你日后行业名声的荣誉墙。尽管你迫于项目的压力需要快速建立环境疲于完成验证计划，但等到你闲时会去改善那些代码吗？不要再相信这些鬼话了，现在就去做吧！</p>
<p>从上面的5个维度来看，做一名合格的验证人员实属不易，更不要说考虑到每一项验证任务量体裁衣制定出合适的5个维度指数。虽然项目执行没有尽善尽美，但针对验证人员自身，如果可以意识到这5个维度的存在，并且能够在实际工作中综合考量它们，那你就是有意识地在培养自己成为一名优秀的验证师了。</p>
<h1 id="4-验证的任务和目标"><a href="#4-验证的任务和目标" class="headerlink" title="4 验证的任务和目标"></a>4 验证的任务和目标</h1><p>验证师的工作就是完成分配给他的任务，这个任务可能是模块级（module level）、子系统级（subsystem level）或者系统级（chip level）的。准确来讲，验证的目标就是“按时保质低耗完成”目标硬件设计的验证工作，这句话实际也包含了要完成验证目标需要考虑到的三个方面。</p>
<ul>
<li>按时保质低耗<ul>
<li>按时<ul>
<li><blockquote>
<p>验证师需要按照项目预先的进度来考虑验证的节点（milestone），在项目开始时就将节点记挂在心上。之前提到的验证师的5个能力维度，在面对项目进度时，也需要考虑哪个维度为主、哪个维度为辅。例如，硬件设计的验证计划、验证环境的复杂度和复用性、大概需要用多少测试用例来尽快达到验证工作量的80%，这些都是要与项目进度一同考虑的。要知道“一个都不能少”在芯片流程中的重要性，没有一款芯片可以因为其中一个模块的验证延迟而有信心去流片。所以，整支验证队伍自上到下，覆盖到各个模块的验证师都应该有这种意识：即，无论何时，时间总是第一位的，时间就意味着客户的耐心和市场的窗口。</p>
</blockquote>
</li>
</ul>
</li>
<li>保质<ul>
<li><blockquote>
<p>保质指的是尽可能少地将缺陷暴露在流片以后，至少要尽可能少地暴露在客户和市场面前。因为从成本的角度看，缺陷暴露在不同的阶段造成的损失有指数级的差别。如果芯片交付给客户以后才被反馈出一些大的缺陷，那么芯片设计方就会背负很大的压力，除了要同客户一起进行高密度的对话、联调外，整个产品链都要为这个缺陷付出更大的人力、物力成本；如果芯片是在客户方通过测试却被市场发现自身性能不如预期的话，那么会对芯片设计公司和客户双方都造成消极的影响，无论是在市场反馈还是用户对品牌的认知度上，都是如此。</p>
</blockquote>
</li>
</ul>
</li>
<li>低耗<ul>
<li><blockquote>
<p>低消耗有两方面，用更短的时间、更少的人力来完成芯片设计任务，这是一笔前期看得见的可以预期控制的成本；同时，也有一些成本是突发的，其中一个就是缺陷的暴露问题。从图1.6可以看出，暴露在不同研发阶段的缺陷对芯片项目造成的额外成本是随着项目进程指数级递增。</p>
</blockquote>
</li>
<li><img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%971%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E5%85%A8%E8%A7%86/%E5%9C%A8%E4%B8%8D%E5%90%8C%E9%98%B6%E6%AE%B5%E5%8F%91%E7%8E%B0%E8%AE%BE%E8%AE%A1%E7%BC%BA%E9%99%B7%E6%89%80%E5%AF%BC%E8%87%B4%E7%9A%84%E9%A2%9D%E5%A4%96%E6%88%90%E6%9C%AC%E6%9B%B2%E7%BA%BF.png" class="" title="在不同阶段发现设计缺陷所导致的额外成本曲线"></li>
<li><blockquote>
<p>硅前验证中RTL验证发现的缺陷带来的影响要明显小于Gate验证中带来的影响。因为RTL阶段发现的缺陷，只需要修改RTL代码，而Gate验证发现的缺陷除了需要同时做RTL修改和网表修改，更是要后端一系列流程的反复。如果在硅后测试中发现了缺陷，就需要考虑这个缺陷是不是致命的。所谓致命的，就是它无法使用一些重要功能，甚至本身会导致一些重要功能的失效和错误行为，且没有办法通过软件层面来做修复。这样的致命性缺陷就意味着芯片要做第二次流片，要针对致命缺陷做出修复、功能验证、后端流程，这样的过程通常耗时三个月以上。如果一个致命缺陷等到被交付给客户以后才发现，那么造成的损失则是双方的。对于客户来讲，他们需要为这个致命缺陷吞下产品延迟上市的苦酒；而对于芯片公司来讲，恐怕这可能是双方最后一次合作了。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>芯片研发与客户反馈<ul>
<li><blockquote>
<p>进一步来看，如果我们将硅前流程、硅后流程同客户反馈联系在一起（见图1.7），就能对芯片流程有一个更清晰的认识。从图1.7可以发现，芯片在出片以后被检测出的严重缺陷会直接导致芯片的二次流片，这对成本控制而言是一种额外的损失，同时将时间和人力资源消耗在本可以避免的二次流片上。所以，功能验证是唯一可以用低成本在硅前流程将上述目标“按时、保质、低耗”达成的方法。也正因如此，对于功能验证而言，验证经理通过量化的方式来衡量验证产出的进度。用来衡量的两个标准，一个是时间，一个是发现的缺陷数量。</p>
</blockquote>
</li>
<li><img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%971%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E5%85%A8%E8%A7%86/%E8%8A%AF%E7%89%87%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%A2%E6%88%B7%E5%8F%8D%E9%A6%88%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" class=""></li>
</ul>
</li>
<li>缺陷增长曲线<ul>
<li><blockquote>
<p>通过缺陷数量在时间线上的记录，我们可以绘制出缺陷数量的增长曲线，如图1.8所示。</p>
</blockquote>
</li>
<li><img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%971%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E5%85%A8%E8%A7%86/%E7%BC%BA%E9%99%B7%E6%95%B0%E9%87%8F%E7%9A%84%E5%A2%9E%E9%95%BF%E6%9B%B2%E7%BA%BF.png" class=""></li>
<li><blockquote>
<p>一般来讲，缺陷数量的增长曲线是逐渐逼近趋于缓慢的。功能验证需要保证的是将缺陷数量的增值（至少是致命缺陷数量）保证在硅前阶段，不应该让其发生在硅后测试阶段。针对缺陷的类型，我们一般遵循先易后难的验证方法，这表现在两个方面：</p>
</blockquote>
<ul>
<li>我们给出的激励向量应该是先易后难，先从简单的激励向量测试设计的基本功能，这一点我们在1.3节提到随机约束域的宽窄设定和验证阶段之间的关系。当验证将基本功能测试完毕后，我们再朝着更复杂的情景着手去测试其他功能。</li>
<li>我们查找出的缺陷也应该是先基本后高级。这么做有两方面的好处，当开始的激励向量是基本形态的时，有助于设计本身在缺陷报告反馈中逐步稳定，同时留出一定的时间用来帮助设计师和验证师针对设计细节交换意见，在硬件描述上面统一理解。</li>
</ul>
</li>
<li>这种缓冲会使得在其后的复杂测试中，设计师和验证师双方就复杂情形中的硬件输出结果快速达成一致，因为之前已经就功能描述达成一致了。对于验证师而言，这么做也符合验证的曲线，也就是前期的缺陷曲线斜率较高，是因为设计本身容易被发现一些基本设计问题；随着验证周期的进展，缺陷曲线率慢慢减小，说明设计自身的稳定和功能完备情况趋于最终的设计目标。</li>
<li>对于验证经理，如果有追踪缺陷率曲线的习惯，那么一般建议检查两个地方：<ul>
<li>缺陷率曲线是否在收敛，或者斜率是否在变小，这一定程度上可以说明验证的状态是否在收敛和趋于完备。</li>
<li>需要注意验证过程中发现的缺陷种类，应从基本缺陷再到高级缺陷。假如到了后期，尽管缺陷率收敛，却发现了基本缺陷，这时应对整个验证质量打一个问号。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>有必要的话，同验证师一起回顾验证计划、验证环境和测试序列。因为越到后期越不应该发现基本类型的缺陷，否则验证经理无法对于整个验证任务的完成有足够的信心。</p>
<h1 id="5-验证的周期"><a href="#5-验证的周期" class="headerlink" title="5 验证的周期"></a>5 验证的周期</h1><h2 id="5-1-验证周期中的检查点"><a href="#5-1-验证周期中的检查点" class="headerlink" title="5.1 验证周期中的检查点"></a>5.1 验证周期中的检查点</h2><p>功能验证有着一整套完备的流程，从硬件系统定义贯穿到硅后测试部分。一般来讲，验证团队会基于时间差同时进行多个项目，多个项目之间自然也存在着借鉴、更新的关系，所以验证的环境和复用性也是在不断提高的。每一个项目在进行瀑布模式开发时，验证团队也
会在细分的流程中完成任务，同时在展开下一项任务之前进行一些重要检查点（checkpoint）的回顾工作。验证人员不断地在新项目中完善验证环境，验证的周期因而也是不断往复、螺旋上升的过程。</p>
<p>图1.9将功能验证的各个关键节点罗列并使之成为一个周期。<strong>验证周期的起始点从创建验证计划开始，验证计划需要参照系统工程师给出的功能详述文档。接着验证人员开发验证环境，在创建验证环境的过程中，验证人员一般会邀请设计人员和系统人员一同回顾验证计划，确保验证计划没有明显的遗漏，所以验证计划的回顾是第一个检查点</strong>。</p>
<img src="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%971%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E5%85%A8%E8%A7%86/%E5%8A%9F%E8%83%BD%E9%AA%8C%E8%AF%81%E7%9A%84%E5%AE%8C%E5%A4%87%E5%91%A8%E6%9C%9F.png" class="">

<p>验证环境准备完毕且有一些可供测试的激励时，验证人员会比对设计的输出结果。如果发现有比对错误，验证人员首先要自己去调试环境，定位到硬件HDL文件存在缺陷的大致位置。如果验证人员有充分的经验，他还可以进一步给设计人员修改代码的建议。硬件设计经过一定数量的激励测试，验证人员就可以准备回归（regression）测试了。<strong>回归测试就是将已有的所有测试序列都执行一次</strong>。一般来讲，<strong>随机序列的回归测试覆盖率贡献要大于直接序列的回归测试，不过这种优势会随着验证率曲线的增长而变得不那么明显，具体的原因就是随机激励无法给出定向激励来填补剩余的验证空间，而定向测试则可以被有经验的验证人员运用，用来验证边界情况</strong>。在完成回归测试之前，我们需要进行第二个检查点——<strong>验证代码检查</strong>，这一检查点的作用是通过回顾验证代码从而发现可能遗漏的测试激励、不恰当的随机约束、代码结构的缺陷等。</p>
<p>完成回归测试后进行第三个重要的检查点——<strong>流片前验证完备性检查</strong>。一般这项检查是验证经理最后签字的。验证经理根据一份检查清单来将验证进度做量化的综合评定，最后判读是否完成验证的任务。当然，这一过程并非只有在流片前才会评估，而是发生在这一期间内若干阶段，包括<strong>模块验证阶段、子系统验证阶段、芯片系统验证阶段和最后的网表验证阶段</strong>。每一个阶段验证经理都有相应的通过标准和检查清单，判定模块、子系统和最终的芯片系统是否达到验证的目标。</p>
<p>即使在最终流片以后，验证团队也需要和硅后系统测试团队完成对接。这是由于，硅后系统测试阶段才是真正能够判定小到每一个功能模块大到整个芯片系统的各项功能能否正常工作的标准。通常，系统测试团队参考功能验证团队的验证计划，<strong>从底部测试每个模块的功能，逐步向上层走，最终测试整个芯片的联合功能</strong>。在系统测试环节中，如果发生了功能测试失败，系统测试人员与验证人员协作，最终定位到是硬件自身缺陷还是测试中的环境配置，或者是寄存器设置问题。如果最终测试发现了硬件缺陷，那么硬件团队和软件团队也会一起评估该缺陷是否是不可修复的。<strong>针对硅后测试发现缺陷的情况，一般首先考虑是否有软件修复的可能，接下来才考虑硬件上有无变通的办法。</strong>当两方面都无法解决时，我们只能宣告，一个无法硅后修复的缺陷在测试阶段发现了。当然，更糟糕的情况是，这个缺陷竟然是一个致命缺陷。</p>
<p>经过系统测试后，验证团队最终被硅后测试发现的缺陷<strong>展开逃逸分析</strong>，来检讨为什么漏洞会在硅后测试环节中被发现（而不是在硅前验证环节）。</p>
<p>可能引起漏洞在硅前验证阶段逃逸的情况包括：</p>
<ul>
<li>验证计划制定不充分，没有完全覆盖功能验证点。</li>
<li>激励序列生成不完全，没有覆盖全部的有效激励场景。</li>
<li>验证环境不完备，例如比较器（checker/scoreboard）没有足够完善去比对输出结果。</li>
</ul>
<p>展开逃逸分析之后，要进行验证周期的最后一项检查——<strong>吸取教训</strong>。吸取教训是一种被动的方式，我们在完成的项目中犯了一些错误，如果不想被同一块石头绊倒两次（没有人会愿意吧），就需要吸取教训。这种被动的方式和主动提高验证效率没有冲突，恰恰是在我们没有考虑到的地方吸取教训，在我们考虑到的地方主动完善，使之成为一种内外结合提高验证质量的方式。</p>
<p>关于吸取教训，在这里我们给出一些建议：</p>
<ul>
<li><strong>请在整个验证周期内保持收集与验证完善相关信息，比如，突发状况以及如何克服，陷阱从哪里来，有哪些遗憾</strong>，等等。之所以这么做，是因为我们通常在项目结束以后会懈怠下来，我们的记忆无法保存事发当时的一些细节，也容易忘掉当时一些心理上的痛苦。所以
就像做一份验证记录一样，保持着这样一份完整记录，将来我们可以从中很快地回溯起来我们一路是如何走过的。</li>
<li>除了一些个别情况，验证缺陷的暴露与整个模块验证团队都有关系。因为可能我们一起制定的验证计划不够充分，一起回顾测试序列的时候也不够仔细……要思考团队整体的疏忽在什么地方。每个人都需要考虑到自己在验证周期的不同阶段应该充分履行的责任是什
么。</li>
<li>尽量从一些教训中量化今后可以加强的地方。比如，如果功能覆盖率和代码覆盖率的指标是硬性的，那么验证人员就不应该妥协，应想办法达到这个标准；又比如，一些跨时钟域的问题没有被发现或者在网表仿真时才被发现，以后就应该将跨时钟域检查、同步单元检
查作为标准在验证过程中执行下去。</li>
</ul>
<h2 id="5-2-功能详述"><a href="#5-2-功能详述" class="headerlink" title="5.2 功能详述"></a>5.2 功能详述</h2><p>对于一个芯片，大到芯片自身，小到可以细分的模块，都需要系统工程师给出功能详述文档。这里以较小颗粒度的模块功能文档为例，看看一个基本大小的模块如何依靠功能文档来实现硬件设计和功能验证。</p>
<p>一份功能文档，通常包含如下几方面的信息：</p>
<ul>
<li>接口信息。是不是标准接口、是标准接口的哪一个版本。如果接口是标准接口，那么功能详述中不需要详尽列出接口的时序信息、命令、数据传输等，而只需给出基本的时钟、复位、接口信号名。对于标准接口，设计人员和验证人员可以下载标准接口文档来更详尽地了解接口信息。如果接口是公司内部定义的接口，则需要参照内部定义的接口文档；如果是自定义接口，由于这种接口没有被规范化，功能文档中应尽可能周全地描述需要给出的信息，以方便日后设计人员和验证人员双方参考。</li>
<li>结构信息。结构信息将模块进一步细分为各个功能组件，以及包含组件之间的逻辑关系。各功能组件对设计人员而言可以匹配出对应的 RTL 文件，其后可以自底向上进行集成；对于验证人员而言，为了尽可能与设计保持同步，验证环境的开发可以同设计组件同步展
开。从设计组件A和验证环境VA，再到组件B和验证环境VB，再到组件C和验证环境VC，最后集成出模块M（A+B+C）和验证环境V（VA+VB+VC），就可以完成模块M的集成验证了。</li>
<li>交互信息。由于模块稍后会被集成到更高一级的子系统当中，所以功能详述文档中包含模块 M 同外界模块交互的示意图。必要时，这些交互信号之间也会给出准确的时序信息，确保集成后两个模块之间的交互按照预期定义的时序发生。比如一对握手（handshake）信号，需要指明输入信号的频率、是否需要考虑同步、是电平信号还是脉冲信号、大致维持几个时钟周期，相应的输出信号也要有类似的考量，以满足输出信号接收方的要求。</li>
</ul>
<p>功能详述文档是硬件设计和功能验证的基础部分，也是共同参考依照的标准。设计人员通过自己的理解将其实现成 RTL 文件，而验证人员也按照自己的理解为设计构建出验证环境。尽管看起来验证人员重复了一次功能上的理解，但正也是因为这样，确保了功能描述文件
可以被设计和验证双方理解一致。验证人员自己设计的参考模型（reference model）才也会按照功能详述文档做出正确的行为和数据输出。参考模型对应硬件设计，通过结果比对检查是否有不符合预期结果的情况。这种方式可以让功能文档变得易读清晰，降低设计人员误解功能描述和实现错误硬件的可能性。</p>
<h2 id="5-3-制定验证计划"><a href="#5-3-制定验证计划" class="headerlink" title="5.3 制定验证计划"></a>5.3 制定验证计划</h2><p>验证计划是为了完成验证目标的，因此它本身要回答两个问题——<strong>验证对象是谁、如何验证</strong>。制定验证计划的主体在不同公司可能不同，例如，公司A是由系统人员制定验证计划的，而公司B是由验证人员制定验证计划的。不过可以肯定的一点是，最后回顾验证计划
时，会将系统人员、设计人员和验证人员组织到一起来回顾，检查可能存在的验证漏洞。验证计划也存在颗粒度，与模块大小、处在系统的层次相关。</p>
<p>这里我们仍然以模块M为例，考虑验证计划中的检查事项：</p>
<ul>
<li><strong>验证方法：是采用直接验证、随机约束验证、形式验证还是其他的方式。</strong></li>
<li>验证工具：选择需要的验证工具来支持验证方法。</li>
<li>验证完备标准：量化出一些参数以衡量验证任务是否完成。</li>
<li>验证资源：包括人力、时间、硬件、软件等所有与项目预算有关的内容。</li>
<li>验证的功能点：需要给出验证的功能点以及在什么层次去验证它，更具体的包括生成何种激励、检查设计的何种状态和数据输出。</li>
</ul>
<h2 id="5-4-开发验证环境"><a href="#5-4-开发验证环境" class="headerlink" title="5.4 开发验证环境"></a>5.4 开发验证环境</h2><p>验证环境的开发是验证人员花费时间较多的部分。<strong>验证人员从搭建环境开始，实现激励产生器（stimulus generator）、参考模型（reference model）和数据比较器（data comparator）</strong>。</p>
<p>验证环境的运行需要软件工具的支持，目前的主流仿真工具均可以对仿真验证提供广泛支持。当然，制定验证计划时需要考虑采取何种验证方法，之后才开发验证环境。不同的验证方法决定不同验证环境的结构和所用的软件。<strong>伴随着设计缺陷的发现和修正，验证环境也需要保持更新，最终同硬件设计一样趋于稳定，进入验证的下一个阶段</strong>。</p>
<h2 id="5-5-调试环境和HDL文件"><a href="#5-5-调试环境和HDL文件" class="headerlink" title="5.5 调试环境和HDL文件"></a>5.5 调试环境和HDL文件</h2><p>验证人员在调试方面的时间投入最多。环境的建立在验证早期投入较多，设计的功能调试却是一步步向前推进的。验证刚开始时，验证人员调试的对象主要集中在环境的协调整合上；环境稳定后，验证人员递交测试，进行仿真验证。针对每一个功能点的验证均需要给出一个或者多个激励向量，在激励给入后，将参考模型和实际输出进行比较，发现比较错误时需要进一步定位问题的源头：</p>
<ul>
<li>环境是否有瑕疵；</li>
<li>测试序列是否合理；</li>
<li>参考模型是否遵循功能详述文档；</li>
<li>硬件设计本身是否存在功能缺陷。</li>
</ul>
<p>定位问题时，一般建议验证人员：</p>
<ol>
<li>先从环境着手，试图去稳定环境部分，因为这一部分是我们可以控制的。</li>
<li>让环境趋于稳定后，我们再去定位问题是否来源于硬件设计。判定设计存在缺陷时，验证人员需要了解设计、定位到缺陷的位置，提交给设计人员并得到反馈。</li>
<li>设计缺陷被修复后，应重复递交同一个测试用例，用例中产生的测试向量也不应该改变。如果使用的是随机约束方式，应记住上一次仿真出错的时间位置和随机种子（random seed），在后面重新递交时采用同一个随机种子以产生同样的测试向量，确保外部激励的场景是一致的。这种方式背后的逻辑是，在调试过程中应尽量减少变量的数量，理想情况下只有一个变量。对于上面的场景，这个变量就是设计缺陷在修复前和修复后的功能表现。</li>
<li>至于如何设定随机种子，在仿真器的用户使用文档中可以找到相应的使用方法和仿真选项。</li>
</ol>
<h2 id="5-6-回归测试"><a href="#5-6-回归测试" class="headerlink" title="5.6 回归测试"></a>5.6 回归测试</h2><p>回归测试指的是验证硬件在某个缺陷修复或添加了某项新功能后，仍然可以通过以前的所有测试用例（test case）和可能添加的新的测试用例。可能存在的环境变化包括硬件设计自身的改进、缺陷修复、功能添加和验证环境的更新。在每次的回归测试中都可能发现新的缺陷、添加新的测试用例或者更新验证环境。</p>
<p>每次回归测试都会帮助完成两个目标：</p>
<ul>
<li>确保这次改动没有引入新的缺陷，并修复了之前的漏洞，或者按照预定目标实现了新的功能。</li>
<li><strong>随机验证在每次递交时默认的随机种子不同，这对重复递交一套回归测试表也是有意义的。</strong>伴随着功能覆盖率，可以通过往复的回归测试和补充的定向测试来将逐步提高验证完备性。</li>
</ul>
<p>当代的回归测试逐步趋向自动化，需要一种合适的回归测试工具协助完成回归测试表的提交、分配到不同的服务器上面以计算量来换取时间的缩短、自动识别仿真的结果、到最后给出验证报告。</p>
<p>这种回归测试工具，可以从 EDA 公司的工具表中找到商业化的产品，同时大中型公司也有适合自己团队工作流程和需求的定制工具。回归测试是实现验证完备性的一项重要手段，因为只有通过将大量测试用例并行提交到服务器群，才可能完成覆盖率的快速上升，满足项目进度的要求。</p>
<h2 id="5-7-芯片生产"><a href="#5-7-芯片生产" class="headerlink" title="5.7 芯片生产"></a>5.7 芯片生产</h2><p>经历过回归测试阶段（RTL 回归和门级网表回归），意味着芯片的逻辑和物理数据都经过各项检查了。在将芯片最后送交给半导体生产商（fabrication facility）之前，项目经理与设计经理、验证经理、后端经理一起回顾整个检查表（checklist），确保所有的标准都已经通过。芯片的数据提交给生产商后，最终制造出来，我们称之为流片（tape-out）。</p>
<p><strong>值得注意的是，此时功能验证的流程并没有全部走完，仍然需要提交回归测试，通过保持不停的随机测试，在新的状态空间上测试，可能发现新的问题</strong>。如果在递交给厂商生产以后发现新的缺陷，要像硅后测试发现的缺陷一样对待。通过分析这些缺陷，考虑是否有软件补救办法，或者提交设计修改意见，在下一次流片前准备好设计方案和验证方案，将其计划到下一次验证周期内。</p>
<h2 id="5-8-硅后系统测试"><a href="#5-8-硅后系统测试" class="headerlink" title="5.8 硅后系统测试"></a>5.8 硅后系统测试</h2><p>芯片返回后，系统测试人员依照系统集成的顺序从底层模块开始测试。测试前，需将芯片同测试开发板结合起来，或将芯片植入到待开发的系统上。随后硅前人员（设计人员、验证人员、系统人员）和硅后人员（测试人员）保持频繁的沟通，一旦测试出了问题，第一时间判断是测试的方法不恰当还是硬件自身的问题。之所以要求硅前人员参与，是因为我们不期望硅后测试出现太多的问题，尤其是致命的缺陷。当一个硬件缺陷被发现之后，硅前人员需要讨论这个缺陷的严重性，从软件层面上讨论可行的补救办法，再从硬件层面看是否有其他办法使能这项功能，或者不使这项缺陷扩大影响面导致重要功能失败。如果最终无法避免这个缺陷，且该缺陷严重影响系统功能，就需要在下个芯片设计周期内去修改和验证这项功能。</p>
<h2 id="5-9-逃逸分析"><a href="#5-9-逃逸分析" class="headerlink" title="5.9 逃逸分析"></a>5.9 逃逸分析</h2><p>有时，我们难以避免个别的验证漏洞一直被忽视，导致它们可以从硅前验证阶段“逃走”，到硅后测试才被发现。遇到这样的情况，硬件设计人员和验证人员都要与测试人员沟通，尝试在硅前的仿真环境中重现遇到的测试失败场景。如果可以复现，设计人员和验证人员要再次思考这个漏洞逃脱的原因；<strong>如果无法复现，则仍旧无法保证硬件做出的更改可以在下次流片后修复这次测试的问题</strong>。这种硅后测试失败要求硅前验证重现的难度，相较于在交给客户之后遇到的应用失败场景还是容易很多的。因为一旦从硬件级别向上堆叠经过驱动层、固件层再到客户的应用层，更加难以在硅前验证环境中重现客户应用失败的场景。作为验证人员，如果你有幸遇到过这样的场景重现和失效点定位的问题，那么想必你会深深记住它的。当逃逸分析完成以后，这一过程会对下一个芯片周期中，设计人员如何规避设计陷阱、验证人员如何完善验证方案、产生尽可能多的有效测试序列都是很有意义的。在整个芯片过程中都贯穿着“吸取教训”四个字，<strong>因为要完成芯片从硅前到硅后的过程本身就很漫长（相比软件的迭代开发而言）。要积累尽可能多的经验，芯片工程师应该在每一个关键节点养成总结的习惯，并在下一个阶段有意识地去完善，保持一种不断成长的态度</strong>。</p>
<h1 id="6-作者结束语"><a href="#6-作者结束语" class="headerlink" title="6 作者结束语"></a>6 作者结束语</h1><blockquote>
<p>在刚进入职场时，我每天都在公司工作到很晚，倒不是工作太多、效率不高导致的，而是给自己设定了目标，需要在更短的时间熟悉公司的流程。我翻阅了公司内部和外部的很多文档，一天从早到晚除了睡觉以外，手边都放着各种文档。如果将这些文档分类，那么一部分是技术文档，我大致用了三年的时间掌握了主流验证技术；而另外一部分是验证流程的相关文档，这部分文档是常读常新的，我总可以在不懂时翻阅文档，或者请教更有经验的同事。有句话说，“自己知道得越多，知道自己不知道的也就越多”。在IC验证这条道路上我们面对的不仅仅是更新很快的验证知识，也包括一些“常识”。所谓常识，就同前辈教的道理一样，往往在遇到挫折时才想得起来，对此我也深有体会。之所以将这一章作为本书的开头，就是为了让读者能够清楚：在通往专业化的验证道路上，需要经历不少的磨炼。接下来，我们将从验证通识的各个方面分别展开论述。当然，你也可以跳过验证通识的内容部分，转而阅读SystemVerilog和UVM的知识。但请不要忘记一点，验证通识对于你提升自己的专业化素质会有很大的帮助。</p>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-05-06T09:40:21.000Z" title="5/6/2022, 9:40:21 AM">2022-05-06</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/IC%E9%AA%8C%E8%AF%81/">IC验证</a></span><span class="level-item">8 分钟读完 (大约1194个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/IC%E9%AA%8C%E8%AF%81/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%970/">芯片验证漫游指南0</a></p><div class="content"><p>本书从结构上分为四个部分，分别是：</p>
<ul>
<li>验证的通识部分（第1章至第6章）： 具备不同经验的读者都可以从中获取验证世界的全貌。<ul>
<li>第1章是对芯片验证的总览；</li>
<li>第2章从各个维度来介绍验证的策略；</li>
<li>第3章描述目前所有的验证方法；</li>
<li>第4章则从验证计划入手介绍如何量化验证；</li>
<li>第5章从验证管理的角度来论述其各个要素；</li>
<li>而第6章则作为进入下一部分（SystemVerilog语言）的准备来介绍验证环境的结构和组件。</li>
</ul>
</li>
<li>SystemVerilog语言部分（第7章至第9章）： 该部分不同于以往的语言类学习书籍，它的重点不在于提供完整的语法要点，而是结合贯穿于本书的设计MCDF来展开实践，带领读者思考如何利用SV的主要特性去构建一个完整的验证环境。因此，该部分是从<ul>
<li>验证环境基础要素学习（第7章）到</li>
<li>基本组件的实现（第8章），再到最后的</li>
<li>环境集成（第9章）。</li>
<li>这一部分对于缺少SV语言基础的读者会有帮助，同时建议参考对照SV语言的标准手册一同学习。对于具备SV经验的读者，阅读这一部分也会帮助其梳理以往容易出错的知识点。</li>
</ul>
</li>
<li>UVM验证方法学部分（第10章至第14章）：通过SV语言部分的学习，读者可以利用MCDF的 SV 轻量级环境来理解验证环境的共性，包括环境的组织、构建、通信和运行。当进入到UVM部分时，建议读者逐章阅读，以此达到循序渐进的效果。  <ul>
<li>第10章带领读者游览UVM世界，了解其重要的各个特性；</li>
<li>第11章则仿照SV的学习步骤，给读者介绍UVM的各个组件和环境构成；</li>
<li>第12章是UVM的TLM通信部分；</li>
<li>第13章是UVM的运行部分，即介绍序列的各种用法；</li>
<li>第14章是平行于UVM结构的部分但又不可或缺，即寄存器模型部分。</li>
<li>从SV部分过渡到UVM部分的读者会在这部分的各章节中有似曾相似识的感觉，因为UVM的主要特性和结构已经在SV部分中有类似的实现，这种连续性有助于将SV与UVM进行特性对比和学习。</li>
</ul>
</li>
<li>高级应用部分（第15章至第18章）： 该部分结合了实际项目和验证潮流，对中高级验证工程师有启示作用。我也希望读者可以从这些部分了解到，语言和方法学是验证的技能基础，但要解决项目的实际需求、提高整体的验证效率和一致性、实现跨平台、跨研发部分的验证平台，还需要做出更多的定制化解决方案。而对于目前还没有令人满意的解决方案的验证难题，我们还需要时间去构想推动新的验证方法和工具。<ul>
<li>第15章给出了如何实现验证平台自动化和测试标准化的方案，适用于大中型公司的验证效率提升；</li>
<li>第16章着眼于目前在标准制定过程中的便携激励标准，介绍了已有的便携激励工具和跨平台的验证结构；</li>
<li>第17章针对SV与UVM同其他语言的接口给予实践指导；</li>
<li>第18章则将一些分散的高级话题给出行业的解决方案。读者可以将这一部分作为工作的指导手册，在将来遇到相关问题时参考。</li>
</ul>
</li>
<li>尽管试图给出动态验证的全貌，但我也不得不遗憾地指出，几个重要内容暂未在本书首版中囊括，包括：从验证计划到功能覆盖率的量化手段和标准，功能覆盖率驱动的智能化收敛验证，断言的应用场景和复用实践，验证IP的开发模式和推广等，未尽的地方只能寄希望于在下一版中补缺，而在那时，验证世界风起云涌，又将出现什么新的技术还未尽可知，且让我们拭目以待吧。</li>
</ul>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/categories/IC%E9%AA%8C%E8%AF%81/">上一页</a></div><div class="pagination-next is-invisible is-hidden-mobile"><a href="/categories/IC%E9%AA%8C%E8%AF%81/page/3/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/categories/IC%E9%AA%8C%E8%AF%81/">1</a></li><li><a class="pagination-link is-current" href="/categories/IC%E9%AA%8C%E8%AF%81/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.png" alt="Gavin"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Gavin</p><p class="is-size-6 is-block">Embedded &amp; IC Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shanghai, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">122</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">35</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">58</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/DustOfStars/" target="_blank" rel="me noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/DustOfStars/"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Configuration/"><span class="level-start"><span class="level-item">Configuration</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/IC%E9%AA%8C%E8%AF%81/"><span class="level-start"><span class="level-item">IC验证</span></span><span class="level-end"><span class="level-item tag">15</span></span></a><ul><li><a class="level is-mobile" href="/categories/IC%E9%AA%8C%E8%AF%81/%E8%B7%AF%E7%A7%91V0/"><span class="level-start"><span class="level-item">路科V0</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Leetcode/"><span class="level-start"><span class="level-item">Leetcode</span></span><span class="level-end"><span class="level-item tag">8</span></span></a><ul><li><a class="level is-mobile" href="/categories/Leetcode/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="level-start"><span class="level-item">数据结构</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/NLP/"><span class="level-start"><span class="level-item">NLP</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/NLP/EDA/"><span class="level-start"><span class="level-item">EDA</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/NLP/Numpy/"><span class="level-start"><span class="level-item">Numpy</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/NLP/Torch/"><span class="level-start"><span class="level-item">Torch</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/NLP/Torch/Model/"><span class="level-start"><span class="level-item">Model</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/NLP%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/"><span class="level-start"><span class="level-item">NLP代码详解</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/NXP/"><span class="level-start"><span class="level-item">NXP</span></span><span class="level-end"><span class="level-item tag">16</span></span></a><ul><li><a class="level is-mobile" href="/categories/NXP/KW38/"><span class="level-start"><span class="level-item">KW38</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/NXP/RT1050/"><span class="level-start"><span class="level-item">RT1050</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/NXP/RT1052/"><span class="level-start"><span class="level-item">RT1052</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/NXP/RT1052/%E9%87%8E%E7%81%AB/"><span class="level-start"><span class="level-item">野火</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/Plugins/"><span class="level-start"><span class="level-item">Plugins</span></span><span class="level-end"><span class="level-item tag">12</span></span></a><ul><li><a class="level is-mobile" href="/categories/Plugins/Analytics/"><span class="level-start"><span class="level-item">Analytics</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Plugins/Comment/"><span class="level-start"><span class="level-item">Comment</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Plugins/Donation/"><span class="level-start"><span class="level-item">Donation</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Plugins/Other/"><span class="level-start"><span class="level-item">Other</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Plugins/Search/"><span class="level-start"><span class="level-item">Search</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Plugins/Share/"><span class="level-start"><span class="level-item">Share</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ReferenceManual/"><span class="level-start"><span class="level-item">ReferenceManual</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/STL/"><span class="level-start"><span class="level-item">STL</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/STL/forward-list/"><span class="level-start"><span class="level-item">forward_list</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/STL/vector/"><span class="level-start"><span class="level-item">vector</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Widgets/"><span class="level-start"><span class="level-item">Widgets</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"><span class="level-start"><span class="level-item">嵌入式</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"><span class="level-start"><span class="level-item">代码解读</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/%E4%B8%AD%E6%96%AD/"><span class="level-start"><span class="level-item">中断</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">工具</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7/vim/"><span class="level-start"><span class="level-item">vim</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E5%AD%97IC/"><span class="level-start"><span class="level-item">数字IC</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%8B%B1%E8%AF%AD/"><span class="level-start"><span class="level-item">英语</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-11T06:11:12.000Z">2023-12-11</time></p><p class="title"><a href="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/">RT1050开发--第7节 RT1050 硬件启动模式</a></p><p class="categories"><a href="/categories/NXP/">NXP</a> / <a href="/categories/NXP/RT1050/">RT1050</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-11T05:37:29.000Z">2023-12-11</time></p><p class="title"><a href="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC6%E8%8A%82-rt1050-memory-mapping/">RT1050开发--第6节 RT1050 Memory Mapping</a></p><p class="categories"><a href="/categories/NXP/">NXP</a> / <a href="/categories/NXP/RT1050/">RT1050</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-05T14:28:25.000Z">2023-12-05</time></p><p class="title"><a href="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC5%E8%8A%82-rt1050-hello-world-%EF%BC%88keil-v5%EF%BC%89/">RT1050开发--第5节 RT1050 Hello World （Keil V5）</a></p><p class="categories"><a href="/categories/NXP/">NXP</a> / <a href="/categories/NXP/RT1050/">RT1050</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-04T14:33:36.000Z">2023-12-04</time></p><p class="title"><a href="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC4%E8%8A%82-rt1050%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">RT1050开发--第4节 RT1050开发环境搭建</a></p><p class="categories"><a href="/categories/NXP/">NXP</a> / <a href="/categories/NXP/RT1050/">RT1050</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-04T14:31:32.000Z">2023-12-04</time></p><p class="title"><a href="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC3%E8%8A%82-rt1050%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/">RT1050开发--第3节 RT1050硬件平台</a></p><p class="categories"><a href="/categories/NXP/">NXP</a> / <a href="/categories/NXP/RT1050/">RT1050</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/12/"><span class="level-start"><span class="level-item">十二月 2023</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/11/"><span class="level-start"><span class="level-item">十一月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/03/"><span class="level-start"><span class="level-item">三月 2023</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">十月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/09/"><span class="level-start"><span class="level-item">九月 2022</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/08/"><span class="level-start"><span class="level-item">八月 2022</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/07/"><span class="level-start"><span class="level-item">七月 2022</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">五月 2022</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">四月 2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">三月 2022</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/02/"><span class="level-start"><span class="level-item">二月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/01/"><span class="level-start"><span class="level-item">一月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/01/"><span class="level-start"><span class="level-item">一月 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/01/"><span class="level-start"><span class="level-item">一月 2017</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/01/"><span class="level-start"><span class="level-item">一月 2016</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/01/"><span class="level-start"><span class="level-item">一月 2015</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2014/01/"><span class="level-start"><span class="level-item">一月 2014</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2013/01/"><span class="level-start"><span class="level-item">一月 2013</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/ARM/"><span class="tag">ARM</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BLE/"><span class="tag">BLE</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BOARD/"><span class="tag">BOARD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Demo/"><span class="tag">Demo</span><span class="tag">19</span></a></div><div class="control"><a class="tags has-addons" href="/tags/FLASH/"><span class="tag">FLASH</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GPIO/"><span class="tag">GPIO</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GPIO%E4%B8%AD%E6%96%AD/"><span class="tag">GPIO中断</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Getting-Started/"><span class="tag">Getting Started</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/IC%E9%AA%8C%E8%AF%81/"><span class="tag">IC验证</span><span class="tag">15</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Icarus-User-Guide/"><span class="tag">Icarus User Guide</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/"><span class="tag">Icarus用户指南</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LED/"><span class="tag">LED</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Leetcode/"><span class="tag">Leetcode</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Model/"><span class="tag">Model</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NLP/"><span class="tag">NLP</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NXP/"><span class="tag">NXP</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Numpy/"><span class="tag">Numpy</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PDF/"><span class="tag">PDF</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RAM/"><span class="tag">RAM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ROM/"><span class="tag">ROM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RT1050/"><span class="tag">RT1050</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RT1052/"><span class="tag">RT1052</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ReferenceManual/"><span class="tag">ReferenceManual</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/STL/"><span class="tag">STL</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/System-Verilog/"><span class="tag">System Verilog</span><span class="tag">15</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Thread/"><span class="tag">Thread</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Torch/"><span class="tag">Torch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/UART/"><span class="tag">UART</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/UVM/"><span class="tag">UVM</span><span class="tag">15</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ZigBee/"><span class="tag">ZigBee</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pyTorch/"><span class="tag">pyTorch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vector/"><span class="tag">vector</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vim/"><span class="tag">vim</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"><span class="tag">二分查找</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"><span class="tag">代码解读</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"><span class="tag">代码随想录</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BD%8E%E5%8A%9F%E8%80%97%E8%AE%A1%E6%97%B6%E5%99%A8LPTMR/"><span class="tag">低功耗计时器LPTMR</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"><span class="tag">双指针</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%91%A8%E6%9C%9F%E4%B8%AD%E6%96%AD%E8%AE%A1%E6%97%B6%E5%99%A8PIT/"><span class="tag">周期中断计时器PIT</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9F%BA%E7%A1%80/"><span class="tag">基础</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AE%9E%E6%97%B6%E6%97%B6%E9%92%9FRTC/"><span class="tag">实时时钟RTC</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"><span class="tag">嵌入式</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B7%A5%E5%85%B7/"><span class="tag">工具</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%80%BB%E7%BB%93/"><span class="tag">总结</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E6%8E%A2%E7%B4%A2/"><span class="tag">数据探索</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E7%BB%84/"><span class="tag">数组</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/"><span class="tag">有序数组的平方</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"><span class="tag">滑动窗口</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"><span class="tag">移除元素</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD100%E5%8F%A5/"><span class="tag">考研英语100句</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%8B%B1%E8%AF%AD/"><span class="tag">英语</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%E2%85%A1/"><span class="tag">螺旋矩阵Ⅱ</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E6%97%B6%E5%99%A8PWM%E6%A8%A1%E5%9D%97TPM/"><span class="tag">计时器PWM模块TPM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B/"><span class="tag">设计流程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%93%BE%E8%A1%A8/"><span class="tag">链表</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"><span class="tag">长度最小的子数组</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="DustOfStars" height="28"></a><p class="is-size-7"><span>&copy; 2024 Gavin</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Discuss on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus/discussions"><i class="fas fa-comments"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>