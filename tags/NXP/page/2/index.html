<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><title>标签: NXP - DustOfStars</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#f7f7f7"><meta name="application-name" content="DustOfStars"><meta name="msapplication-TileImage" content="/img/favicon.png"><meta name="msapplication-TileColor" content="#f7f7f7"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="DustOfStars"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Go ahead, and believe in yourself."><meta property="og:type" content="blog"><meta property="og:title" content="DustOfStars"><meta property="og:url" content="https://dustofstars.github.io/"><meta property="og:site_name" content="DustOfStars"><meta property="og:description" content="Go ahead, and believe in yourself."><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://dustofstars.github.io/img/og_image.png"><meta property="article:author" content="Gavin"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://dustofstars.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://dustofstars.github.io"},"headline":"DustOfStars","image":["https://dustofstars.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Gavin"},"publisher":{"@type":"Organization","name":"DustOfStars","logo":{"@type":"ImageObject","url":"https://dustofstars.github.io/img/logo.png"}},"description":"Go ahead, and believe in yourself."}</script><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-72437521-5" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-72437521-5');</script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0">
<style>.not-gallery-item { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .not-gallery-item > span { position: relative; z-index: 10; }  .not-gallery-item img, .not-gallery-item .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .not-gallery-item img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .not-gallery-item-fallback { color: inherit; } .not-gallery-item-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="DustOfStars" type="application/atom+xml">
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="DustOfStars" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Discuss on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus/discussions"><i class="fas fa-comments"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">标签</a></li><li class="is-active"><a href="#" aria-current="page">NXP</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-03-24T04:01:45.000Z" title="3/24/2023, 4:01:45 AM">2023-03-24</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><span> / </span><a class="link-muted" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/">代码解读</a></span><span class="level-item">17 分钟读完 (大约2555个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/kw38-helloworld/">kw38_helloworld</a></p><div class="content"><h1 id="kw38-helloworld"><a href="#kw38-helloworld" class="headerlink" title="kw38_helloworld"></a>kw38_helloworld</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Init board hardware. */</span></span><br><span class="line">    BOARD_InitPins();</span><br><span class="line">    BOARD_BootClockRUN();</span><br><span class="line">    BOARD_InitDebugConsole();</span><br><span class="line"></span><br><span class="line">    PRINTF(<span class="string">"hello world.\r\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        ch = GETCHAR();</span><br><span class="line">        PUTCHAR(ch);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="main功能"><a href="#main功能" class="headerlink" title="main功能"></a>main功能</h2><p>这段代码是一个简单的hello world程序，它的作用是在终端输出”hello world.”，并且可以接收终端输入的字符并将其输出。</p>
<p>在main函数中，首先调用了BOARD_InitPins()函数来初始化板子的引脚，然后调用了BOARD_BootClockRUN()函数来初始化时钟，最后调用了BOARD_InitDebugConsole()函数来初始化调试控制台。</p>
<p>接下来，使用PRINTF函数在终端输出”hello world.”，然后进入一个死循环，不断地接收终端输入的字符并将其输出，直到程序结束。</p>
<p>其中，GETCHAR函数用于接收终端输入的字符，PUTCHAR函数用于将字符输出到终端。</p>
<h2 id="main的函数调用"><a href="#main的函数调用" class="headerlink" title="main的函数调用"></a>main的函数调用</h2><p>这段代码调用了三个函数，分别是BOARD_InitPins()、BOARD_BootClockRUN()和BOARD_InitDebugConsole()。</p>
<ul>
<li>BOARD_InitPins()函数用于初始化板子的引脚，</li>
<li>BOARD_BootClockRUN()函数用于初始化时钟，</li>
<li>BOARD_InitDebugConsole()函数用于初始化调试控制台。</li>
</ul>
<p>在这个程序中，这三个函数的作用是为了确保程序能够正常运行，因为程序需要使用板子的引脚、时钟和调试控制台。</p>
<h2 id="main的包含头文件"><a href="#main的包含头文件" class="headerlink" title="main的包含头文件"></a>main的包含头文件</h2><p>这段代码include了以下几个文件：</p>
<ul>
<li>fsl_device_registers.h：包含了芯片的寄存器定义，用于访问芯片的寄存器。</li>
<li>fsl_debug_console.h：包含了调试控制台的相关函数，用于在终端输出和输入字符。</li>
<li>board.h：包含了板子的相关函数和宏定义，用于初始化板子的引脚和时钟。</li>
<li>pin_mux.h：包含了引脚的配置信息，用于初始化板子的引脚。</li>
<li>stdbool.h：包含了bool类型的定义，用于定义布尔类型的变量。</li>
<li>clock_config.h：包含了时钟的配置信息，用于初始化时钟。</li>
</ul>
<p>其中，fsl_device_registers.h、fsl_debug_console.h、board.h和pin_mux.h是MCUXpresso SDK提供的库文件，而stdbool.h和clock_config.h是标准C库文件。这些文件的作用是为了确保程序能够正常运行，因为程序需要使用芯片的寄存器、调试控制台、板子的引脚和时钟。</p>
<h2 id="pin-mux-h"><a href="#pin-mux-h" class="headerlink" title="pin_mux.h"></a>pin_mux.h</h2><p>这是一个头文件，用于使用 MCUXpresso 配置工具为微控制器配置引脚复用和电气特性。</p>
<p>它提供了一个函数来初始化微控制器使用的引脚，可以在启动期间调用。 该文件定义了用于配置引脚电气特性的宏常量 <code>SOPT5_LPUART0ODE_0b0</code>、<code>SOPT5_LPUART0RXSRC_0b0</code> 和 <code>SOPT5_LPUART0TXSRC_0b00</code>。 </p>
<p>头文件由包含保护 (<code>#ifndef _PIN_MUX_H_</code>) 保护，确保它在编译单元中仅包含一次。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SOPT5_LPUART0ODE_0b0 0x00u    <span class="comment">/*LPUART0开漏禁用*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOPT5_LPUART0RXSRC_0b0 0x00u  <span class="comment">/*LPUART0接收数据源选择：LPUART_RX pin */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOPT5_LPUART0TXSRC_0b00 0x00u <span class="comment">/*LPUART0发送数据源选择：LPUART_TX pin */</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>声明了两个函数：</p>
<ul>
<li>void BOARD_InitPins(void);  配置引脚routing和可选引脚电气特性</li>
<li>void BOARD_InitBootPins(void);  初始化启动引脚；</li>
</ul>
<h2 id="pin-mux-c"><a href="#pin-mux-c" class="headerlink" title="pin_mux.c"></a>pin_mux.c</h2><h3 id="void-BOARD-IninPins-void"><a href="#void-BOARD-IninPins-void" class="headerlink" title="void BOARD_IninPins(void)"></a>void BOARD_IninPins(void)</h3><p>这段代码是来自项目中的“pin_mux.c”文件，该文件包含了MKW38A512微控制器的引脚配置函数。</p>
<p>所选代码块是函数“BOARD_InitPins()”，它配置了LPUART0外设的引脚路由和电气特性。</p>
<p>具体来说，它将</p>
<ol>
<li>使能PortC的时钟；</li>
<li>42号和43号引脚的引脚复用设置为LPUART0_RX和LPUART0_TX。</li>
<li>将LPUART0传输数据源设置为LPUART0_TX引脚，将LPUART0接收数据源设置为LPUART_RX引脚，并在LPUART0上禁用了开漏特性。</li>
</ol>
<p>该函数由“BOARD_InitBootPins()”调用，在引导过程中调用以初始化引脚。</p>
<h2 id="clock-config-c"><a href="#clock-config-c" class="headerlink" title="clock_config.c"></a>clock_config.c</h2><h3 id="void-BOARD-BootClockRUN-void"><a href="#void-BOARD-BootClockRUN-void" class="headerlink" title="void BOARD_BootClockRUN(void)"></a>void BOARD_BootClockRUN(void)</h3><p>这段代码是MKW38A512芯片的时钟配置代码，主要包括两个函数：BOARD_BootClockRUN和BOARD_BootClockVLPR。</p>
<p>这两个函数分别用于配置系统在RUN模式和VLPR模式下的时钟。在这两个函数中，主要使用了MCUXpresso Config Tools提供的时钟驱动函数来配置系统时钟。具体来说，这两个函数的主要步骤如下：</p>
<ol>
<li>BOARD_RfOscInit函数：<strong>初始化射频晶振，用于提供系统时钟的参考时钟</strong>。</li>
<li>CLOCK_SetSimSafeDivs函数：设置<strong>系统时钟分频器的初始值</strong>，以确保在时钟模式切换时，核心时钟、总线时钟、flexbus时钟和flash时钟都在允许的范围内。</li>
<li>BOARD_InitOsc0函数：初始化MCG OSC，用于提供系统时钟的参考时钟。</li>
<li>CLOCK_BootToFeeMode函数：<strong>将MCG模式设置为FEE模式</strong>，即FLL Engaged External模式，此时FLL时钟和外部参考时钟都被使能。</li>
<li>CLOCK_SetInternalRefClkConfig函数：配置<strong>内部参考时钟MCGIRCLK</strong>。</li>
<li>CLOCK_SetSimConfig函数：设置<strong>SIM模块的时钟配置</strong>。</li>
<li>SystemCoreClock变量：设置当前系统核心时钟的频率。</li>
</ol>
<p>其中，BOARD_BootClockRUN函数用于配置系统在RUN模式下的时钟，而BOARD_BootClockVLPR函数用于配置系统在VLPR模式下的时钟。</p>
<p>在这两个函数中，<strong>主要的区别在于MCG模式的设置不同，以及时钟分频器的设置不同</strong>。</p>
<ul>
<li>在RUN模式下，MCG模式被设置为<strong>FEE</strong>模式，时钟分频器的初始值为1，2，2，5，</li>
<li>而在VLPR模式下，MCG模式被设置为<strong>BLPI</strong>模式，时钟分频器的初始值为1，5，1，</li>
</ul>
<h2 id="board-c"><a href="#board-c" class="headerlink" title="board.c"></a>board.c</h2><h3 id="void-BOARD-InitDebugConsole-void"><a href="#void-BOARD-InitDebugConsole-void" class="headerlink" title="void BOARD_InitDebugConsole(void)"></a>void BOARD_InitDebugConsole(void)</h3><p>这段代码是初始化调试控制台的函数。在这个函数中，首先设置了<strong>LPUART0的时钟源为OSCERCLK</strong>，然后初始化了调试控制台。</p>
<p>调试控制台的初始化使用了MCUXpresso SDK提供的DbgConsole_Init函数，该函数需要传入调试控制台的实例、波特率、类型和时钟源频率等参数。在这个函数中，调试控制台的实例为BOARD_DEBUG_UART_INSTANCE，波特率为BOARD_DEBUG_UART_BAUDRATE，类型为BOARD_DEBUG_UART_TYPE，时钟源频率为uartClkSrcFreq。</p>
<h2 id="fsl-debug-console-c"><a href="#fsl-debug-console-c" class="headerlink" title="fsl_debug_console.c"></a>fsl_debug_console.c</h2><h3 id="int-DbgConsole-Printf-const-char-formatString-…"><a href="#int-DbgConsole-Printf-const-char-formatString-…" class="headerlink" title="int DbgConsole_Printf(const char *formatString, …)"></a>int DbgConsole_Printf(const char *formatString, …)</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* See fsl_debug_console.h for documentation of this function. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">DbgConsole_Printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *formatString, ...)</span></span><br><span class="line">{</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="type">int</span> logLength = <span class="number">0</span>, dbgResult = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> printBuf[DEBUG_CONSOLE_PRINTF_MAX_LOG_LEN] = {<span class="string">'\0'</span>};</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != g_serialHandle)</span><br><span class="line">    {</span><br><span class="line">        va_start(ap, formatString);</span><br><span class="line">        <span class="comment">/* format print log first */</span></span><br><span class="line">        logLength = StrFormatPrintf(formatString, ap, printBuf, DbgConsole_PrintCallback);</span><br><span class="line">        <span class="comment">/* print log */</span></span><br><span class="line">        dbgResult = DbgConsole_SendDataReliable((<span class="type">uint8_t</span> *)printBuf, (<span class="type">size_t</span>)logLength);</span><br><span class="line"></span><br><span class="line">        va_end(ap);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dbgResult;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这段代码是fsl_debug_console.c文件的一部分。该文件包含了调试控制台模块的实现。调试控制台模块提供了一组函数来初始化、去初始化、打印和从调试控制台读取数据。</p>
<p>所选代码是DbgConsole_Printf函数的实现。该函数用于将格式化数据打印到调试控制台。</p>
<blockquote>
<p>该函数接受<strong>一个格式字符串</strong>和<strong>一个可变数量的参数</strong>。格式字符串指定输出字符串的格式，参数是要格式化和打印的值。</p>
</blockquote>
<p>该函数首先使用StrFormatPrintf函数格式化输出字符串。该函数将格式字符串、可变参数和回调函数作为输入。<strong>回调函数用于输出格式化数据</strong>。在这种情况下，回调函数是DbgConsole_PrintCallback。</p>
<p>格式化输出字符串后，该函数使用DbgConsole_SendDataReliable函数将数据发送到调试控制台。该函数可靠地发送数据，这意味着它将重试发送数据，直到成功发送为止。</p>
<p>后缀代码包含了DbgConsole_Putchar和DbgConsole_Scanf函数的实现。DbgConsole_Putchar函数用于<strong>将单个字符打印到调试控制台</strong>。该函数只需调用DbgConsole_SendDataReliable函数并传递要打印的字符即可。</p>
<p>DbgConsole_Scanf函数用于从调试控制台读取格式化数据。该函数接受一个格式字符串和一个可变数量的参数。格式字符串指定输入数据的格式，参数是指向存储输入数据的变量的指针。</p>
<p>该函数首先使用DbgConsole_ReadLine<strong>函数读取一行输入</strong>。然后使用StrFormatScanf函数格式化输入数据，并将格式化数据存储在由参数指向的变量中。</p>
<p>总的来说，这些函数提供了一种方便的方式来与调试控制台交互，并打印和读取格式化数据。</p>
<h2 id="关于引脚的四种输出情况"><a href="#关于引脚的四种输出情况" class="headerlink" title="关于引脚的四种输出情况"></a>关于引脚的四种输出情况</h2><p>上拉 (Pull-up) 和下拉 (Pull-down) 是指在数字电路中使用电阻将输入或输出引脚连接到电源或地，以确保在没有输入信号的情况下，引脚保持在一个已知状态。具体来说，上拉是指将引脚连接到电源（通常是高电平），下拉是指将引脚连接到地（通常是低电平）。在某些情况下，还可以使用弱上拉或弱下拉，即使用较大阻值的电阻。</p>
<p>开漏 (Open-Drain) 和推挽 (Push-Pull) 是指输出引脚的驱动方式。<strong>开漏输出只能将引脚拉到低电平，而不能将其拉到高电平，而推挽输出可以将引脚驱动到高电平或低电平。</strong>在使用开漏输出时，还需要在输出引脚和电源之间连接一个上拉电阻，以确保输出引脚能够被拉到高电平。</p>
<p>开漏输出通常用于需要将多个设备连接到同一个总线上的情况，而推挽输出则更适用于需要直接驱动其他器件的情况。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-03-21T06:22:40.000Z" title="3/21/2023, 6:22:40 AM">2023-03-21</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><span> / </span><a class="link-muted" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/">代码解读</a></span><span class="level-item">23 分钟读完 (大约3511个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8Bfsl-gpio/">代码解读之fsl_gpio</a></p><div class="content"><h1 id="读fsl-gpio-c-和-fsl-gpio-h-代码"><a href="#读fsl-gpio-c-和-fsl-gpio-h-代码" class="headerlink" title="读fsl_gpio.c 和 fsl_gpio.h 代码"></a>读fsl_gpio.c 和 fsl_gpio.h 代码</h1><blockquote>
<p>使用kw38的win mcuxpresso版本 <code>SDK_2_6_615_FRDM-KW38_mcuxpresso_win</code></p>
</blockquote>
<h1 id="fsl-gpio-h"><a href="#fsl-gpio-h" class="headerlink" title="fsl_gpio.h"></a>fsl_gpio.h</h1><blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _FSL_GPIO_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _FSL_GPIO_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"fsl_common.h"</span></span></span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="Part1-gpio-pin-direction-t-和-gpio-checker-attribute-t"><a href="#Part1-gpio-pin-direction-t-和-gpio-checker-attribute-t" class="headerlink" title="Part1 gpio_pin_direction_t 和 gpio_checker_attribute_t"></a>Part1 gpio_pin_direction_t 和 gpio_checker_attribute_t</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">gpio_pin_direction</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    kGPIO_DigitalInput  = <span class="number">0U</span>, <span class="comment">/*!&lt; Set current pin as digital input*/</span></span><br><span class="line">    kGPIO_DigitalOutput = <span class="number">1U</span>, <span class="comment">/*!&lt; Set current pin as digital output*/</span></span><br><span class="line">} <span class="type">gpio_pin_direction_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">gpio_checker_attribute</span>{</span></span><br><span class="line">}<span class="type">gpio_checker_attribute_t</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><code>gpio_pin_direction_t</code> 确定Pin引脚方向，输入为0，输出为1。</p>
<p>GPIO 检查器属性用于某些具有 GPIO 属性检查器功能的 NXP 微控制器。此功能用于安全目的，<strong>根据访问属性检查是否允许访问 GPIO 引脚</strong>。</p>
<p><code>gpio_checker_attribute_t</code> 枚举定义了可以检查的可能属性。这些属性指定不同权限级别（用户非安全、用户安全和特权安全）的读取和写入权限。</p>
<p>另外还有一个属性值<code>kGPIO_IgnoreAttributeCheck</code>，表示忽略属性检查。</p>
<p>GPIO 检查器属性与 <code>GPIO_CheckAttribute()</code> 函数结合使用，<strong>以根据操作的属性检查是否允许 GPIO 引脚上的特定操作</strong>。</p>
<h3 id="Part2-gpio-pin-config-t-和-gpio-interrupt-config-t"><a href="#Part2-gpio-pin-config-t-和-gpio-interrupt-config-t" class="headerlink" title="Part2 gpio_pin_config_t 和 gpio_interrupt_config_t"></a>Part2 gpio_pin_config_t 和 gpio_interrupt_config_t</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">gpio_pin_config</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">gpio_pin_direction_t</span> pinDirection;</span><br><span class="line">    <span class="type">uint8_t</span> outputLogic; <span class="comment">/*!&lt; Set a default output logic, which has no use in input */</span></span><br><span class="line">} <span class="type">gpio_pin_config_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">gpio_interrupt_config</span>{</span></span><br><span class="line">} <span class="type">gpio_interrupt_config_t</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>这是一个 C 语言代码片段，它定义了两个数据结构和一个枚举类型，用于在微控制器上配置通用输入/输出 (GPIO) 引脚。</p>
<ol>
<li><code>gpio_pin_config_t</code> 定义了 GPIO 引脚的配置参数，包括它的方向（输入或输出）和<strong>它的默认输出逻辑（如果它是一个输出引脚）</strong>。</li>
<li>第二个数据结构 <code>gpio_interrupt_config_t</code> 是有条件地定义的，具体取决于微控制器是否支持其 GPIO 引脚上的中断。如果是，则此结构定义中断生成条件的配置参数。</li>
<li>枚举类型 <code>gpio_interrupt_config_t</code> 定义了中断生成条件的可能值，例如在上升沿、下降沿、任一边沿或逻辑电平为高或低时启用中断。</li>
</ol>
<h2 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h2><h3 id="GPIO配置"><a href="#GPIO配置" class="headerlink" title="GPIO配置"></a>GPIO配置</h3><h3 id="Part1-GPIO-PinInit"><a href="#Part1-GPIO-PinInit" class="headerlink" title="Part1 GPIO_PinInit()"></a>Part1 GPIO_PinInit()</h3><p>这是名为 <code>GPIO_PinInit()</code> 的函数的代码片段，它是用于处理微控制器上的通用输入/输出 (GPIO) 引脚的更大驱动程序的一部分。该驱动程序提供一组函数<strong>来配置、读取和写入 GPIO 引脚</strong>。</p>
<p>函数 <code>GPIO_PinInit()</code> <strong>初始化板使用的 GPIO 引脚</strong>。它采用三个参数：</p>
<ul>
<li>GPIO 外设的基地址 GPIO peripheral base pointer (GPIOA, GPIOB, GPIOC, and so on.)</li>
<li>GPIO 端口的引脚号 GPIO port pin number</li>
<li>以及指向定义 GPIO 引脚配置的 gpio_pin_config_t 结构的指针 GPIO pin configuration pointer</li>
</ul>
<p>gpio_pin_config_t 结构包含两个字段：</p>
<ul>
<li>pinDirection：GPIO引脚的方向，可以设置为kGPIO_DigitalInput或kGPIO_DigitalOutput。</li>
<li>outputLogic：GPIO引脚的输出逻辑电平，仅在引脚配置为数字输出时适用。它可以设置为 0 或 1。</li>
</ul>
<p>函数 <code>GPIO_PinInit()</code> 使用 <code>gpio_pin_config_t</code> 结构中定义的配置初始化 GPIO 引脚。</p>
<h3 id="GPIO输入操作"><a href="#GPIO输入操作" class="headerlink" title="GPIO输入操作"></a>GPIO输入操作</h3><h3 id="Part2-静态函数-GPIO-PinWrite"><a href="#Part2-静态函数-GPIO-PinWrite" class="headerlink" title="Part2 静态函数 GPIO_PinWrite()"></a>Part2 静态函数 GPIO_PinWrite()</h3><p>这是名为 <code>GPIO_PinWrite()</code> 的函数的代码片段。</p>
<p>函数<code>GPIO_PinWrite()</code>将一个GPIO引脚的输出电平设置为逻辑1或逻辑0。它需要三个参数：</p>
<ul>
<li>GPIO外设的基址、</li>
<li>GPIO端口的引脚号、</li>
<li>GPIO引脚的输出电平.</li>
</ul>
<p>输出参数可以设置为 0 或 1 以指定 GPIO 引脚的输出逻辑电平。<strong>如果输出为 0，则相应的引脚输出设置为逻辑低电平，否则，如果输出为 1，则相应的引脚输出设置为逻辑高电平</strong>。</p>
<p>函数 GPIO_PinWrite() 使用<strong>按位操作</strong>来设置 GPIO 引脚的输出电平。如果输出参数为0，则使用左移操作清除GPIO端口输出清除寄存器（<strong>GPIOx_PCOR</strong>）中的相应位。否则，如果输出参数为 1，则使用左移操作设置 GPIO 端口输出设置寄存器 (<strong>GPIOx_PSOR</strong>) 中的相应位。</p>
<p>此代码是用 C 编程语言编写的，并假定微控制器具有 GPIO 寄存器的特定实现，例如分别用于清除和设置 GPIO 输出引脚的 PCOR 和 PSOR 寄存器。</p>
<h3 id="Part3-静态函数-GPIO-PortSet"><a href="#Part3-静态函数-GPIO-PortSet" class="headerlink" title="Part3 静态函数 GPIO_PortSet()"></a>Part3 静态函数 GPIO_PortSet()</h3><p>这是名为 GPIO_PortSet() 的函数的代码片段.</p>
<p>函数 <code>GPIO_PortSet()</code> <strong>将多个 GPIO 引脚的输出电平设置为逻辑 1</strong>。它有两个参数：</p>
<ul>
<li>GPIO 外设的基址, base GPIO peripheral base pointer (GPIOA, GPIOB, GPIOC, and so on.)</li>
<li>指定要设置哪些 GPIO 引脚的掩码。GPIO pin number macro</li>
</ul>
<p><strong>掩码参数是一个位掩码，指示要设置的引脚。掩码参数的每一位对应一个特定的 GPIO 引脚。如果某位设置为 1，则相应的 GPIO 引脚输出设置为逻辑高电平</strong>。</p>
<p>函数 <code>GPIO_PortSet()</code> 通过使用<strong>按位或</strong>运算写入 GPIO 端口输出设置寄存器 (<strong>GPIOx_PSOR</strong>)，将指定 GPIO 引脚的输出电平设置为逻辑 1。在执行按位或操作之前，将掩码参数的值左移以与 GPIO 端口输出设置寄存器的位位置对齐。</p>
<p>此代码是用 C 编程语言编写的，并假定微控制器具有 GPIO 寄存器的特定实现，例如用于设置 GPIO 输出引脚的 PSOR 寄存器。</p>
<h3 id="Part4-静态函数-GPIO-PortClear"><a href="#Part4-静态函数-GPIO-PortClear" class="headerlink" title="Part4 静态函数 GPIO_PortClear()"></a>Part4 静态函数 GPIO_PortClear()</h3><p>这是名为 <code>GPIO_PortClear()</code> 的函数的代码片段.</p>
<p>函数 <code>GPIO_PortClear()</code> <strong>将多个 GPIO 引脚的输出电平设置为逻辑 0</strong>。它有两个参数：</p>
<ul>
<li>GPIO 外设的基址</li>
<li>和指定要清除哪些 GPIO 引脚的掩码。</li>
</ul>
<p>掩码参数是一个位掩码，指示要清除哪些引脚。掩码参数的每一位对应一个特定的 GPIO 引脚。如果某位设置为0，则相应的 GPIO 引脚输出设置为逻辑低电平。</p>
<p>函数 <code>GPIO_PortClear()</code> 通过使用按位或运算写入 GPIO 端口输出清除寄存器 (<strong>GPIOx_PCOR</strong>)，将指定 GPIO 引脚的输出电平设置为逻辑 0。在执行按位或操作之前，将掩码参数的值左移以与 GPIO 端口输出清除寄存器的位位置对齐。</p>
<p>此代码是用 C 编程语言编写的，并假定微控制器具有 GPIO 寄存器的特定实现，例如用于清除 GPIO 输出引脚的 PCOR 寄存器。</p>
<h3 id="Part5-静态函数-GPIO-PortToggle"><a href="#Part5-静态函数-GPIO-PortToggle" class="headerlink" title="Part5 静态函数 GPIO_PortToggle()"></a>Part5 静态函数 GPIO_PortToggle()</h3><p>这是名为 <code>GPIO_PortToggle()</code> 的函数的代码片段。</p>
<p>函数 <code>GPIO_PortToggle()</code> <strong>反转多个 GPIO 引脚的当前输出逻辑</strong>。它有两个参数：</p>
<ul>
<li>GPIO 外设的基地址</li>
<li>和一个掩码，它指定要切换的 GPIO 引脚。</li>
</ul>
<p>掩码参数是一个位掩码，指示要切换的引脚。掩码参数的每一位对应一个特定的 GPIO 引脚。如果某位设置为 1，则相应的 GPIO 引脚输出逻辑反转，即如果设置为逻辑 1，则变为逻辑 0，反之亦然。</p>
<p>函数 <code>GPIO_PortToggle()</code> 通过使用<strong>按位或</strong>运算写入 GPIO 端口<strong>输出切换寄存器 (GPIOx_PTOR)</strong> 来反转指定 GPIO 引脚的输出逻辑。在执行按位或操作之前，掩码参数的值左移以与 GPIO 端口输出切换寄存器的位位置对齐。</p>
<p>此代码是用 C 编程语言编写的，并假定微控制器具有 GPIO 寄存器的特定实现，例如用于切换 GPIO 输出引脚的 PTOR 寄存器。</p>
<h3 id="GPIO输入操作-1"><a href="#GPIO输入操作-1" class="headerlink" title="GPIO输入操作"></a>GPIO输入操作</h3><h3 id="Part6-静态函数-GPIO-PinRead"><a href="#Part6-静态函数-GPIO-PinRead" class="headerlink" title="Part6 静态函数 GPIO_PinRead()"></a>Part6 静态函数 GPIO_PinRead()</h3><p>这是一个名为 <code>GPIO_PinRead()</code> 的函数的代码片段。</p>
<p>函数 <code>GPIO_PinRead()</code> <strong>读取单个 GPIO 引脚的当前输入值</strong>。它需要两个参数：GPIO外设的基地址和要读取的GPIO引脚的引脚号。</p>
<p>函数 <code>GPIO_PinRead()</code> 通过使用<strong>移位和与操作</strong>从 GPIO 端口输入数据寄存器 (<strong>GPIOx_PDIR</strong>) 读取来读取指定 GPIO 引脚的输入值。按位移位操作将 GPIO 端口输入数据寄存器的值右对齐，以与指定 GPIO 引脚的位位置对齐。 <em><strong>AND 运算会屏蔽除对应于指定 GPIO 引脚的位之外的所有位</strong></em>。</p>
<p>该函数将指定 GPIO 引脚的输入值作为single-bit值（0 或 1）返回。</p>
<p>此代码是用 C 编程语言编写的，并假定微控制器具有 GPIO 寄存器的特定实现，例如用于读取 GPIO 输入引脚的 PDIR 寄存器。</p>
<h3 id="GPIO中断"><a href="#GPIO中断" class="headerlink" title="GPIO中断"></a>GPIO中断</h3><h3 id="GPIO-PortGetInterruptFlags-和-GPIO-PortClearInterruptFlags"><a href="#GPIO-PortGetInterruptFlags-和-GPIO-PortClearInterruptFlags" class="headerlink" title="GPIO_PortGetInterruptFlags() 和 GPIO_PortClearInterruptFlags()"></a>GPIO_PortGetInterruptFlags() 和 GPIO_PortClearInterruptFlags()</h3><p>此代码提供了一个 API，用于配置和处理 GPIO 引脚上的中断。</p>
<p>前两个函数 <code>GPIO_PortGetInterruptFlags()</code> 和 <code>GPIO_PortClearInterruptFlags()</code> <strong>分别用于读取和清除 GPIO 端口中多个引脚的中断状态标志</strong>。 </p>
<p>base参数是指GPIO peripheral的基地址，mask参数是用来指定要对哪个GPIO引脚进行读或清除操作。</p>
<p>此语句似乎描述了与数字系统中的 DMA 请求或电平敏感中断相关联的标志的行为。</p>
<p>如果某个引脚被配置为生成 DMA 请求，则当<strong>请求的 DMA 传输完成时，相应的标志将自动清除</strong>。这意味着该标志指示 DMA 传输的状态，并在传输完成时重置。</p>
<p>另一方面，如果引脚未配置为生成 DMA 请求，则相应的标志将保持设置状态，<strong>直到将逻辑 1 写入该标志</strong>。这意味着该标志可用于指示与 DMA 无关的事件的发生，例如中断或数据传输。</p>
<p>最后，如果引脚被配置为电平敏感中断并且中断信号保持有效，则标志立即再次设置。此行为允许系统响应连续信号，例如按钮按下或传感器读数，而不会错过任何事件。</p>
<h3 id="GPIO-SetPinInterruptConfig-和-GPIO-GetPinsDMARequestFlags-GPIO-SetMultipleInterruptPinsConfig"><a href="#GPIO-SetPinInterruptConfig-和-GPIO-GetPinsDMARequestFlags-GPIO-SetMultipleInterruptPinsConfig" class="headerlink" title="GPIO_SetPinInterruptConfig() 和 GPIO_GetPinsDMARequestFlags() GPIO_SetMultipleInterruptPinsConfig()"></a>GPIO_SetPinInterruptConfig() 和 GPIO_GetPinsDMARequestFlags() GPIO_SetMultipleInterruptPinsConfig()</h3><p>其余函数是有条件的，取决于 GPIO 端口是否支持中断。如果支持中断，则 <code>GPIO_SetPinInterruptConfig()</code> 函数用于设置单个引脚的中断配置。 pin 参数指定 GPIO 引脚号，而 config 参数用于指定中断配置。</p>
<p><code>GPIO_SetPinInterruptConfig()</code> 函数用于<strong>读取多个引脚的 DMA 请求标志</strong>。 <code>GPIO_SetMultipleInterruptPinsConfig()</code> 函数<strong>用于同时设置多个引脚的中断配置</strong>。 mask 参数用于指定要为其设置中断配置的 GPIO 引脚，而 config 参数指定中断配置。</p>
<p><em>中断配置选项包括设置中断/DMA 请求、触发中断/DMA 请求的边沿类型、触发中断的逻辑电平以及输出触发模式</em>。</p>
<h3 id="GPIO-CheckAttributeBytes"><a href="#GPIO-CheckAttributeBytes" class="headerlink" title="GPIO_CheckAttributeBytes()"></a>GPIO_CheckAttributeBytes()</h3><p>此代码片段定义了一个名为 <code>GPIO_CheckAttributeBytes()</code> 的函数。该函数有两个参数：一个指向 GPIO 外设（基）的指针和一个名为 attribute 的 gpio_checker_attribute_t 参数。</p>
<p>该函数检查 GPIO 模块是否具有设备特定数量的数据端口，以及它是否支持属性检查器。如果满足这些条件，该函数将继续检查成功访问指定 GPIO 引脚（掩码）的 GPIO 编程模型所需的字节级属性。</p>
<p>属性参数是一个枚举，表示 GACR 中 4 个数据字节的属性控制值。字节级属性是使用小端数据约定定义的。</p>
<h3 id="fgpio-driver-快速GPIO"><a href="#fgpio-driver-快速GPIO" class="headerlink" title="fgpio_driver  快速GPIO"></a>fgpio_driver  快速GPIO</h3><h3 id="FGPIO-PortInit"><a href="#FGPIO-PortInit" class="headerlink" title="FGPIO_PortInit()"></a>FGPIO_PortInit()</h3><blockquote>
<p>此代码片段介绍了 FGPIO 功能，该功能仅在某些 Kinetis MCU 上受支持。 FGPIO 寄存器是 <code>IOPORT</code> 接口的别名，通过 IOPORT 接口的访问与任何指令获取并行发生，并在一个周期内完成。此内存映射称为 <code>FGPIO</code>。</p>
</blockquote>
<p>然后代码定义了一个名为 <code>FGPIO_PortInit()</code> 的函数，该函数将指向 FGPIO 外设（基）的指针作为其参数。此函数<strong>通过关闭其时钟来初始化 FGPIO 外设</strong>。</p>
<p><code>FGPIO_Type</code> 可能是表示 FGPIO 外设的结构的类型定义。特定的 FGPIO 外设用后缀（FGPIOA、FGPIOB、FGPIOC 等）表示，并且可能具有不同的配置和引脚映射。</p>
<p>还有一个条件预处理器指令，用于检查 <code>FSL_FEATURE_SOC_FGPIO_COUNT</code> 功能是否已定义和支持。如果不支持，则不会编译指令中的代码。</p>
<p>同样，还有另一个条件预处理器指令检查 <code>FSL_FEATURE_PCC_HAS_FGPIO_CLOCK_GATE_CONTROL</code> 功能是否已定义和支持。如果不支持，则不会编译指令中的代码。</p>
<p>总的来说，这段代码设置了 FGPIO 功能并提供了一个函数来初始化 FGPIO 外设。但是，如果没有关于如何使用此代码以及 FGPIO_Type 结构是什么样子的更多上下文，则很难提供更详细的分析。</p>
<h1 id="fsl-gpio-c"><a href="#fsl-gpio-c" class="headerlink" title="fsl_gpio.c"></a>fsl_gpio.c</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PORT_Type *<span class="type">const</span> s_portBases[] = PORT_BASE_PTRS;</span><br><span class="line"><span class="type">static</span> GPIO_Type *<span class="type">const</span> s_gpioBases[] = GPIO_BASE_PTRS;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">GPIO_GetInstance</span><span class="params">(GPIO_Type *base)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint32_t</span> instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Find the instance index from base address mappings. */</span></span><br><span class="line">    <span class="keyword">for</span> (instance = <span class="number">0</span>; instance &lt; ARRAY_SIZE(s_gpioBases); instance++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (s_gpioBases[instance] == base)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    assert(instance &lt; ARRAY_SIZE(s_gpioBases));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_PinInit</span><span class="params">(GPIO_Type *base, <span class="type">uint32_t</span> pin, <span class="type">const</span> <span class="type">gpio_pin_config_t</span> *config)</span></span><br><span class="line">{</span><br><span class="line">    assert(<span class="literal">NULL</span> != config);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> u32flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (config-&gt;pinDirection == kGPIO_DigitalInput)</span><br><span class="line">    {</span><br><span class="line">        base-&gt;PDDR &amp;= ~(u32flag &lt;&lt; pin);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        GPIO_PinWrite(base, pin, config-&gt;outputLogic);</span><br><span class="line">        base-&gt;PDDR |= (u32flag &lt;&lt; pin);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">GPIO_PortGetInterruptFlags</span><span class="params">(GPIO_Type *base)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint8_t</span> instance;</span><br><span class="line">    PORT_Type *portBase;</span><br><span class="line">    instance = (<span class="type">uint8_t</span>)GPIO_GetInstance(base);</span><br><span class="line">    portBase = s_portBases[instance];</span><br><span class="line">    <span class="keyword">return</span> portBase-&gt;ISFR;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_PortClearInterruptFlags</span><span class="params">(GPIO_Type *base, <span class="type">uint32_t</span> mask)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint8_t</span> instance;</span><br><span class="line">    PORT_Type *portBase;</span><br><span class="line">    instance       = (<span class="type">uint8_t</span>)GPIO_GetInstance(base);</span><br><span class="line">    portBase       = s_portBases[instance];</span><br><span class="line">    portBase-&gt;ISFR = mask;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_CheckAttributeBytes</span><span class="params">(GPIO_Type *base, <span class="type">gpio_checker_attribute_t</span> attribute)</span></span><br><span class="line">{</span><br><span class="line">    base-&gt;GACR = ((<span class="type">uint32_t</span>)attribute &lt;&lt; GPIO_GACR_ACB0_SHIFT) | ((<span class="type">uint32_t</span>)attribute &lt;&lt; GPIO_GACR_ACB1_SHIFT) |</span><br><span class="line">                 ((<span class="type">uint32_t</span>)attribute &lt;&lt; GPIO_GACR_ACB2_SHIFT) | ((<span class="type">uint32_t</span>)attribute &lt;&lt; GPIO_GACR_ACB3_SHIFT);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-03-20T07:58:38.000Z" title="3/20/2023, 7:58:38 AM">2023-03-20</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><span> / </span><a class="link-muted" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/">代码解读</a></span><span class="level-item">1 小时读完 (大约8100个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8Bgpio-adapter/">代码解读之GPIO_Adapter</a></p><div class="content"><h1 id="读fsl-adapter-gpio-c-和-h-代码"><a href="#读fsl-adapter-gpio-c-和-h-代码" class="headerlink" title="读fsl_adapter_gpio.c 和 .h 代码"></a>读fsl_adapter_gpio.c 和 .h 代码</h1><h2 id="1-fsl-adapter-gpio-c"><a href="#1-fsl-adapter-gpio-c" class="headerlink" title="1. fsl_adapter_gpio.c"></a>1. fsl_adapter_gpio.c</h2><p>这个代码是一个包含头文件并定义与MCU中的GPIO（通用输入/输出）功能相关的一些宏的 C 源文件。它是为 NXP 公司制造的特定MCU编写的。</p>
<p>该文件包含以下头文件：</p>
<ul>
<li>fsl_device_registers.h：包含设备特定的寄存器定义。</li>
<li>fsl_gpio.h：提供用于GPIO操作的API函数。</li>
<li>fsl_port.h：提供用于PORT（端口控制和中断）操作的API函数。</li>
<li>fsl_adapter_gpio.h：提供用于GPIO操作的适配器功能。
该文件还定义了一个组件ID，<code>tools</code>使用它。</li>
</ul>
<p>该代码定义了两个宏：</p>
<ul>
<li>HAL_GPIO_CLZ(x)：计算32位数字x中前导零的数量，该数量用于确定GPIO引脚的bit位置。此宏的实现取决于用于编译代码的工具链。</li>
<li>HAL_GPIO_BSR(x)：根据GPIO引脚掩码的值计算GPIO引脚的bit位置。此宏使用 HAL_GPIO_CLZ(x) 宏计算掩码中前导零的数量，然后从31中减去结果（因为GPIO引脚编号是从LSB到MSB进行计数）。</li>
</ul>
<h3 id="1-1-结构体hal-gpio-pin-t-和-hal-gpio-state-t"><a href="#1-1-结构体hal-gpio-pin-t-和-hal-gpio-state-t" class="headerlink" title="1.1 结构体hal_gpio_pin_t 和 hal_gpio_state_t"></a>1.1 结构体<code>hal_gpio_pin_t</code> 和 <code>hal_gpio_state_t</code></h3><p>这些结构体定义了单片机中GPIO引脚的引脚配置和状态。</p>
<p><code>hal_gpio_pin_t</code>结构体用于配置GPIO引脚的属性，具有以下字段：</p>
<ul>
<li>port：一个整数值（0-7），指定引脚的PORT编号。</li>
<li>reserved：值为0的位域，用于填充。</li>
<li>pin：一个整数值（0-31），指定指定PORT内的引脚编号。</li>
<li>direction：一个整数值（0或1），<strong>指定引脚的方向（输入或输出）</strong>。</li>
<li>trigger：一个整数值（0-7），<strong>指定在引脚上启用中断时的触发条件</strong>。</li>
<li>reserved2：值为0的位域，用于填充。</li>
</ul>
<p><code>hal_gpio_state_t</code>结构体用于存储GPIO引脚的状态，具有以下字段：</p>
<ul>
<li>next：指向链表中下一个元素的指针。</li>
<li>callback：<strong>指向回调函数的函数指针，当引脚上的中断被触发时将执行该函数</strong>。</li>
<li>callbackParam：指向<strong>将传递给回调函数的数据的指针</strong>。</li>
<li>direction：一个整数值（0或1），指定引脚的方向（输入或输出）。</li>
<li>level：一个整数值（0或1），指定引脚的当前逻辑电平。</li>
<li>port：一个整数值（0-7），指定引脚的PORT编号。</li>
<li>pin：一个整数值（0-31），指定指定PORT内的引脚编号。</li>
<li>trigger：一个整数值（0-7），指定在引脚上启用中断时的触发条件。</li>
</ul>
<h3 id="1-2-静态变量-static-GPIO-Type-const-s-GpioPort-和-static-hal-gpio-state-t-s-GpioHead"><a href="#1-2-静态变量-static-GPIO-Type-const-s-GpioPort-和-static-hal-gpio-state-t-s-GpioHead" class="headerlink" title="1.2 静态变量 static GPIO_Type *const s_GpioPort[] 和 static hal_gpio_state_t *s_GpioHead;"></a>1.2 静态变量 static GPIO_Type <code>*const s_GpioPort[]</code> 和 static hal_gpio_state_t <code>*s_GpioHead</code>;</h3><p>这个部分定义了函数的原型，这些函数将在源文件中使用，但在这种情况下没有原型。</p>
<p>该部分还定义了一些静态变量：</p>
<ul>
<li><p>s_GpioPort：<u>指向GPIO_Type结构体指针的数组。每个指针对应微控制器中的一个GPIO端口</u>。</p>
</li>
<li><p>s_GpioHead：指向<code>hal_gpio_state_t</code>结构体链表的头部的指针。<strong>此链表用于跟踪MCU中所有GPIO引脚的状态</strong>。</p>
</li>
</ul>
<h3 id="1-3-函数-static-void-HAL-GpioInterruptHandle-uint8-t-port"><a href="#1-3-函数-static-void-HAL-GpioInterruptHandle-uint8-t-port" class="headerlink" title="1.3 函数 static void HAL_GpioInterruptHandle(uint8_t port)"></a>1.3 函数 static void HAL_GpioInterruptHandle(uint8_t port)</h3><p>这段代码片段是一个GPIO（通用输入/输出）驱动程序的C实现。代码定义了两个数据结构，<code>hal_gpio_pin_t</code>和<code>hal_gpio_state_t</code>，它们分别<strong>包含有关引脚配置和状态的信息</strong>。代码还定义了几个函数<strong>来处理中断和添加/删除GPIO状态节点的链接列表</strong>。</p>
<ul>
<li><p><code>HAL_GpioInterruptHandle</code>函数：==通过迭代GPIO状态节点的链表并检查指定port上的任何pin是否触发了中断来处理GPIO中断。如果引脚发生中断，则该函数执行与该引脚相关联的回调函数==。</p>
</li>
<li><p><code>HAL_GpioConflictSearch</code>函数：搜索GPIO状态节点的链表，**<u>以检查引脚是否与已注册的引脚冲突</u>**。仅当定义了<code>HAL_GPIO_CONFLICT_CHECK_ENABLE</code>宏并将其设置为大于零的值时，才使用此函数。</p>
</li>
<li><p><code>HAL_GpioAddItem</code>函数：将新的GPIO状态节点添加到链接列表中。该函数首先检查新节点是否与已注册的引脚发生冲突，然后再将其添加到列表中。</p>
</li>
<li><p><code>HAL_GpioRemoveItem</code>函数：从链接列表中删除GPIO状态节点。该函数通过遍历列表以查找指定的节点并将其删除。</p>
</li>
</ul>
<p>总的来说，这段代码片段提供了GPIO驱动程序的基本实现，可用于配置和控制微控制器上的GPIO引脚。</p>
<p>这是<code>HAL_GpioInterruptHandle</code>函数的函数实现，该函数==负责处理GPIO中断==。</p>
<ol>
<li><p>该函数接受一个参数<code>port</code>，该参数是发生中断的端口号。该函数首先遍历GPIO引脚状态结构的链表，以找到与端口号相对应的结构。如果找不到一个合适的结构，则函数将简单地返回。</p>
</li>
<li><p>接下来，该函数使用<code>GPIO_GpioGetInterruptFlags</code>或<code>GPIO_PortGetInterruptFlags</code>函数**<u>检索在指定端口上发生的引脚中断的集合</u><strong>，具体取决于芯片是否具有每个引脚的个别GPIO中断标志。然后，</strong>该函数清除引发中断的引脚的中断标志**。</p>
</li>
<li><p>然后，该函数再次遍历GPIO引脚状态结构的链表，这次检查每个结构以查看它是否对应于触发中断的引脚之一。如果找到匹配项，则函数调用与引脚关联的回调函数来处理中断。</p>
</li>
<li><p>最后，该函数通过清除刚刚处理的引脚的中断标志来更新触发中断的引脚中断集。如果没有更多的中断需要处理，该函数将返回。</p>
</li>
</ol>
<h3 id="1-4-函数-static-hal-gpio-status-t-HAL-GpioConflictSearch-hal-gpio-state-t-head-uint8-t-port-uint8-t-pin"><a href="#1-4-函数-static-hal-gpio-status-t-HAL-GpioConflictSearch-hal-gpio-state-t-head-uint8-t-port-uint8-t-pin" class="headerlink" title="1.4 函数 static hal_gpio_status_t HAL_GpioConflictSearch(hal_gpio_state_t *head, uint8_t port, uint8_t pin)"></a>1.4 函数 static hal_gpio_status_t HAL_GpioConflictSearch(hal_gpio_state_t *head, uint8_t port, uint8_t pin)</h3><p>这段代码定义了一个函数<code>HAL_GpioConflictSearch</code>，它通过遍历<code>hal_gpio_state_t</code>结构体的链表来**<u>查找指定的端口和引脚与链表中现有的端口和引脚是否有冲突</u>**。</p>
<ol>
<li><p>该函数需要链表的头部（head）、端口号（port）和引脚号（pin）作为输入。</p>
</li>
<li><p>然后，它使用while循环遍历链表，检查是否有<code>hal_gpio_state_t</code>结构体的端口和引脚与输入的相同。</p>
</li>
<li><p>如果找到匹配的<code>hal_gpio_state_t</code>结构体，则该函数返回<code>kStatus_HAL_GpioPinConflict</code>，表示存在冲突。如果没有找到匹配的结构体，则函数返回<code>kStatus_HAL_GpioSuccess</code>，表示不存在冲突。</p>
</li>
</ol>
<p>当预处理宏<code>HAL_GPIO_CONFLICT_CHECK_ENABLE</code>被定义且其值大于零时，才会编译此函数。</p>
<p>预处理指令，用于检查宏<code>HAL_GPIO_CONFLICT_CHECK_ENABLE</code>是否被定义，并且其值大于0。</p>
<p>如果该宏被定义并且其值大于0，那么<code>#if</code>和<code>#endif</code>语句中的代码将会被编译，否则将被跳过。</p>
<h3 id="1-5-函数-static-hal-gpio-status-t-HAL-GpioAddItem-hal-gpio-state-t-head-hal-gpio-state-t-node"><a href="#1-5-函数-static-hal-gpio-status-t-HAL-GpioAddItem-hal-gpio-state-t-head-hal-gpio-state-t-node" class="headerlink" title="1.5 函数 static hal_gpio_status_t HAL_GpioAddItem(hal_gpio_state_t **head, hal_gpio_state_t *node)"></a>1.5 函数 static hal_gpio_status_t HAL_GpioAddItem(hal_gpio_state_t **head, hal_gpio_state_t *node)</h3><p>这个函数**<u>将一个新的 GPIO 引脚添加到 GPIO 引脚的链表中</u>**。它把链表头的指针和要添加的新 GPIO 引脚的指针作为输入参数。</p>
<p>该函数<strong>首先禁用全局中断</strong>，然后<strong>检查链表是否为空</strong>。</p>
<ol>
<li>如果它是空的，新的 GPIO 引脚将添加为链表的第一个元素。</li>
<li>否则，函数通过搜索链表来检查新的 GPIO 引脚是否与任何现有 GPIO 引脚冲突。</li>
<li>如果找到冲突，函数会重新启用全局中断并返回指示 GPIO 引脚冲突的错误状态。</li>
<li>如果没有发现冲突，则在链接列表的末尾添加新的 GPIO 引脚，并返回成功状态。</li>
<li>最后，在返回之前，该函数启用全局中断。</li>
</ol>
<h3 id="1-6-函数-static-hal-gpio-status-t-HAL-GpioRemoveItem-hal-gpio-state-t-head-hal-gpio-state-t-node"><a href="#1-6-函数-static-hal-gpio-status-t-HAL-GpioRemoveItem-hal-gpio-state-t-head-hal-gpio-state-t-node" class="headerlink" title="1.6 函数 static hal_gpio_status_t HAL_GpioRemoveItem(hal_gpio_state_t **head, hal_gpio_state_t *node)"></a>1.6 函数 static hal_gpio_status_t HAL_GpioRemoveItem(hal_gpio_state_t **head, hal_gpio_state_t *node)</h3><p>此函数从 GPIO 引脚的链表中移除一个节点。它以列表的头<code>**head</code>和要移除的节点 <code>*node</code>作为输入，二者都是指向 <code>hal_gpio_state_t</code> 结构的指针。</p>
<p>该函数通过使用 <code>DisableGlobalIRQ() </code>函数<strong>禁用中断</strong>并将 <code>PRIMASK</code> 寄存器的值存储在 <code>regPrimask</code> 中来启动。然后它使用 while 循环<strong>遍历列表，查找要删除的节点</strong>。一旦找到，它会更新指针以从列表中删除节点。如果要移除的节点是列表的头，则会更新 *head。</p>
<p>最后，该函数使用 <code>EnableGlobalIRQ(regPrimask)</code> <strong>启用中断，并返回</strong> <code>kStatus_HAL_GpioSuccess</code>。</p>
<h3 id="1-7-GPIOX-INT1-IRQHandler-和-GPIOX-INT0-IRQHandler"><a href="#1-7-GPIOX-INT1-IRQHandler-和-GPIOX-INT0-IRQHandler" class="headerlink" title="1.7 GPIOX_INT1_IRQHandler() 和 GPIOX_INT0_IRQHandler()"></a>1.7 GPIOX_INT1_IRQHandler() 和 GPIOX_INT0_IRQHandler()</h3><p>这些是设备上每个GPIO端口的中断处理程序函数。</p>
<p>它们是为了没有专门为每个GPIO端口提供中断处理程序的平台而实现的，这由 <code>FSL_FEATURE_PORT_HAS_NO_INTERRUPT</code> 宏指示。</p>
<p>对于每个GPIO端口，定义了两个中断处理程序，<code>GPIOX_INT0_IRQHandler()</code>和<code>GPIOX_INT1_IRQHandler()</code>。</p>
<ul>
<li><code>GPIOX_INT0_IRQHandler()</code>函数是端口的<strong>实际中断处理程序</strong>，并调用<code>HAL_GpioInterruptHandle()</code>函数来处理中断。</li>
<li><code>GPIOX_INT1_IRQHandler()</code>函数是<strong>中断优先级配置的占位符</strong>，它只调用<code>GPIOX_INT0_IRQHandler()</code>函数。</li>
</ul>
<p><code>SDK_ISR_EXIT_BARRIER</code>宏用于<strong>在退出中断处理程序之前添加障碍，以确保在从中断返回之前完成所有存储器访问</strong>。</p>
<h3 id="1-8-PORTX-IRQHandler"><a href="#1-8-PORTX-IRQHandler" class="headerlink" title="1.8 PORTX_IRQHandler()"></a>1.8 PORTX_IRQHandler()</h3><p>这是一系列针对 GPIO 端口的中断处理函数。</p>
<p>根据所使用的特定微控制器，这些功能将以前缀 GPIO 或 PORT 命名。 如果微控制器具有 GPIO 的“无中断”<code>FSL_FEATURE_PORT_HAS_NO_INTERRUPT</code>功能，则中断处理程序将使用 GPIO 前缀并具有类似 <code>GPIOA_INT0_IRQHandler()</code> 的名称。否则，中断处理程序将使用 PORT 前缀并具有类似于 <code>PORTA_IRQHandler() </code>的名称。 </p>
<p>每个中断处理函数负责处理特定 GPIO 端口的中断。例如，<code>GPIOA_INT0_IRQHandler() </code>处理端口 A、引脚 0 的中断。 在每个中断处理函数中，<code>HAL_GpioInterruptHandle() </code><strong>以端口号作为参数被调用</strong>。此函数负责查找触发中断的引脚并调用任何已注册的回调。 **<u>==<code>SDK_ISR_EXIT_BARRIER</code> 宏用于标记中断处理函数的结束。这是一种防止编译器在从中断返回后生成代码的方法，这可能会导致系统堆栈或中断处理出现问题==</u>**。</p>
<h3 id="1-9-函数-void-HAL-GpioPreInit-void"><a href="#1-9-函数-void-HAL-GpioPreInit-void" class="headerlink" title="1.9 函数 void HAL_GpioPreInit(void)"></a>1.9 函数 void HAL_GpioPreInit(void)</h3><p>函数 <code>HAL_GpioPreInit()</code> 将全局指针 <code>s_GpioHead</code> 初始化为 <code>NULL</code>，用作包含每个已配置 GPIO 引脚的 GPIO 状态信息的链表的头部。</p>
<p>此函数通常在 GPIO 驱动程序初始化期间调用，**<u>在添加或配置任何 GPIO 引脚之前</u>**。</p>
<h3 id="1-10-函数-hal-gpio-status-t-HAL-GpioInit-hal-gpio-handle-t-gpioHandle-hal-gpio-pin-config-t-pinConfig"><a href="#1-10-函数-hal-gpio-status-t-HAL-GpioInit-hal-gpio-handle-t-gpioHandle-hal-gpio-pin-config-t-pinConfig" class="headerlink" title="1.10 函数 hal_gpio_status_t HAL_GpioInit(hal_gpio_handle_t gpioHandle, hal_gpio_pin_config_t *pinConfig)"></a>1.10 函数 hal_gpio_status_t HAL_GpioInit(hal_gpio_handle_t gpioHandle, hal_gpio_pin_config_t *pinConfig)</h3><p>**<u>这是用提供的配置，初始化GPIO引脚的功能实现</u>**。</p>
<p><em><u><strong>该函数使用<code>gpioHandle</code>参数表示GPIO引脚的句柄和使用<code>pinConfig</code>参数表示引脚的配置的指针。</strong></u></em></p>
<p>该函数首先断言<code>gpioHandle</code>和<code>pinConfig</code>参数不为null，并且<code>gpioHandle</code>参数的大小至少与<code>hal_gpio_state_t</code>结构的大小一样。然后将<code>gpioHandle</code>参数转换为指向<code>hal_gpio_state_t</code>结构的指针<code>gpioState</code>，该结构包含有关GPIO引脚状态的信息。</p>
<ol>
<li><p>如果启用冲突检查<code>HAL_GPIO_CONFLICT_CHECK_ENABLE</code>，则该函数搜索GPIO引脚的链表，以确保指定端口和引脚没有冲突。如果发现冲突，则该函数返回<code>kStatus_HAL_GpioPinConflict</code>。</p>
</li>
<li><p>然后，该函数使用<code>HAL_GpioAddItem</code>函数将GPIO引脚添加到GPIO引脚的链表中，<u><strong>并使用<code>GPIO_PinInit</code>函数设置GPIO方向和其他配置选项</strong></u>。</p>
</li>
<li><p>最后，如果初始化成功，该函数返回<code>kStatus_HAL_GpioSuccess</code>。</p>
</li>
</ol>
<h3 id="1-11-函数-hal-gpio-status-t-HAL-GpioDeinit-hal-gpio-handle-t-gpioHandle"><a href="#1-11-函数-hal-gpio-status-t-HAL-GpioDeinit-hal-gpio-handle-t-gpioHandle" class="headerlink" title="1.11 函数 hal_gpio_status_t HAL_GpioDeinit(hal_gpio_handle_t gpioHandle)"></a>1.11 函数 hal_gpio_status_t HAL_GpioDeinit(hal_gpio_handle_t gpioHandle)</h3><p>此函数负责**==取消初始化 GPIO 引脚==**。</p>
<p>它接收 GPIO 引脚的句柄，该句柄是在使用 <code>HAL_GpioInit</code> 函数初始化引脚时获得的。 </p>
<ol>
<li>首先，该函数使用断言检查输入 <code>gpioHandle</code> 是否不为 <code>NULL</code>。 </li>
<li>接下来，它使用 <code>gpioHandle</code> 获取指向 <code>GPIO</code> 状态结构的指针。</li>
<li>然后，如果 GPIO 引脚配置为输入引脚，则该函数通过使用 <code>kHAL_GpioInterruptDisable</code> 参数调用 <code>HAL_GpioSetTriggerMode</code> 来**<u>==禁用其中断触发模式==</u>**。 </li>
<li>最后，函数使用<code>HAL_GpioRemoveItem</code>函数从链表<code>s_GpioHead</code>中移除<code>GPIO管脚状态</code>，返回<code>kStatus_HAL_GpioSuccess</code>表示操作成功。</li>
</ol>
<h3 id="1-12-函数-hal-gpio-status-t-HAL-GpioGetInput-hal-gpio-handle-t-gpioHandle-uint8-t-pinState"><a href="#1-12-函数-hal-gpio-status-t-HAL-GpioGetInput-hal-gpio-handle-t-gpioHandle-uint8-t-pinState" class="headerlink" title="1.12 函数 hal_gpio_status_t HAL_GpioGetInput(hal_gpio_handle_t gpioHandle, uint8_t *pinState)"></a>1.12 函数 hal_gpio_status_t HAL_GpioGetInput(hal_gpio_handle_t gpioHandle, uint8_t *pinState)</h3><p>**<u>==此函数获取配置为输入的 GPIO 引脚的当前状态==</u>**。</p>
<p>它需要一个 GPIO 引脚的句柄（表示为 <code>hal_gpio_handle_t</code> 类型）和一个指向变量的指针来<strong>存储引脚状态</strong>。 </p>
<p>在函数内部，它首先断言 gpioHandle 和 pinState 参数不为 NULL。**<u>==然后它将 gpioHandle 转换为 hal_gpio_state_t 类型并使用 <code>GPIO_PinRead</code> 函数读取引脚状态。 GPIO_PinRead函数返回一个uint32_t类型，转换为uint8_t类型存储在<code>pinState</code>变量中。==</u>**最后函数返回kStatus_HAL_GpioSuccess表示操作成功。</p>
<h3 id="1-13-函数-hal-gpio-status-t-HAL-GpioSetOutput-hal-gpio-handle-t-gpioHandle-uint8-t-pinState"><a href="#1-13-函数-hal-gpio-status-t-HAL-GpioSetOutput-hal-gpio-handle-t-gpioHandle-uint8-t-pinState" class="headerlink" title="1.13 函数 hal_gpio_status_t HAL_GpioSetOutput(hal_gpio_handle_t gpioHandle, uint8_t pinState)"></a>1.13 函数 hal_gpio_status_t HAL_GpioSetOutput(hal_gpio_handle_t gpioHandle, uint8_t pinState)</h3><p>**<u>此函数设置 GPIO 引脚的输出状态</u>**。</p>
<p>它将要配置的 GPIO 引脚的句柄和<strong>指定要设置的输出状态（高电平或低电平）的值作为输入</strong>。 </p>
<p>该函数首先检查 GPIO 句柄是否为 NULL。然后它将句柄转换为 hal_gpio_state_t 指针并使用它来获取 GPIO 端口和引脚号。</p>
<p>最后，它使用 <code>GPIO_PinWrite</code> 函数设置 GPIO 引脚的输出状态，**<u>该函数将 GPIO 端口、引脚号和输出值作为输入</u>**。 该函数返回一个状态代码以指示操作是否成功。</p>
<h3 id="1-14-函数-hal-gpio-status-t-HAL-GpioInstallCallback-hal-gpio-handle-t-gpioHandle，-hal-gpio-callback-t-callback-void-callbackParam"><a href="#1-14-函数-hal-gpio-status-t-HAL-GpioInstallCallback-hal-gpio-handle-t-gpioHandle，-hal-gpio-callback-t-callback-void-callbackParam" class="headerlink" title="1.14 函数 hal_gpio_status_t HAL_GpioInstallCallback(hal_gpio_handle_t gpioHandle， hal_gpio_callback_t callback, void *callbackParam)"></a>1.14 函数 hal_gpio_status_t HAL_GpioInstallCallback(hal_gpio_handle_t gpioHandle， hal_gpio_callback_t callback, void *callbackParam)</h3><p>**<u>==此函数将回调函数及其关联参数安装到给定句柄指定的 GPIO 引脚==</u>**。 </p>
<p>该函数接受三个参数： </p>
<ul>
<li><code>gpioHandle</code>：<u>将要安装其回调函数的 GPIO 引脚</u>的句柄。 </li>
<li><code>callback</code>：指向将要安装的回调函数的<u>函数指针</u>。 </li>
<li><code>callbackParam</code>：指向<u>将要传递给回调函数的参数</u>的空指针。</li>
</ul>
<p>该函数首先断言 gpioHandle 不为 NULL。然后它将句柄转换为 <code>hal_gpio_state_t</code> 指针，**<u>并将 hal_gpio_state_t 结构的 <code>callbackParam</code> 和 <code>callback</code> 字段分别设置为 callbackParam 和 callback 的值。</u>**</p>
<p>最后，该函数返回 kStatus_HAL_GpioSuccess。 </p>
<p>安装回调函数后，<u><em>当在 GPIO 引脚上触发中断时，GPIO 驱动程序可以调用它</em></u>。 </p>
<p>GPIO 驱动在回调函数被调用时会将 <code>callbackParam</code> 参数传给回调函数。</p>
<p><strong>应用程序可以使用此参数将上下文信息传递给回调函数</strong>。</p>
<h3 id="1-15-函数-hal-gpio-status-t-HAL-GpioGetTriggerMode-hal-gpio-handle-t-gpioHandle-hal-gpio-interrupt-trigger-t-gpioTrigger"><a href="#1-15-函数-hal-gpio-status-t-HAL-GpioGetTriggerMode-hal-gpio-handle-t-gpioHandle-hal-gpio-interrupt-trigger-t-gpioTrigger" class="headerlink" title="1.15 函数 hal_gpio_status_t HAL_GpioGetTriggerMode(hal_gpio_handle_t gpioHandle, hal_gpio_interrupt_trigger_t *gpioTrigger)"></a>1.15 函数 hal_gpio_status_t HAL_GpioGetTriggerMode(hal_gpio_handle_t gpioHandle, hal_gpio_interrupt_trigger_t *gpioTrigger)</h3><p>**<u>==该函数用于获取某个GPIO引脚的中断触发方式==</u>**。</p>
<p>该函数有两个参数：gpioHandle 和 gpioTrigger。 </p>
<ul>
<li>gpioHandle是GPIO引脚的句柄，用于标识GPIO引脚。</li>
<li>gpioTrigger 是一个<strong>指向 <code>hal_gpio_interrupt_trigger_t</code> 类型变量的指针，将用于返回 GPIO 引脚的中断触发模式</strong>。</li>
</ul>
<p>该函数首先检查 gpioHandle 参数是否有效。然后它将 gpioHandle 参数转换为指向 hal_gpio_state_t 结构的指针，该结构是 GPIO 驱动程序的内部状态结构。</p>
<p>**<u>==然后该函数检查 GPIO 引脚是否配置为输入引脚，如果不是，则返回错误==</u>**。 </p>
<p>最后，**<u>==该函数从 <code>hal_gpio_state_t</code> 结构中获取 GPIO 引脚的中断触发模式，并将其存储在 gpioTrigger 参数中==</u>**。</p>
<p>如果函数成功完成，它会返回 kStatus_HAL_GpioSuccess。</p>
<h3 id="1-16-函数-hal-gpio-status-t-HAL-GpioSetTriggerMode-hal-gpio-handle-t-gpioHandle-hal-gpio-interrupt-trigger-t-gpioTrigger"><a href="#1-16-函数-hal-gpio-status-t-HAL-GpioSetTriggerMode-hal-gpio-handle-t-gpioHandle-hal-gpio-interrupt-trigger-t-gpioTrigger" class="headerlink" title="1.16 函数 hal_gpio_status_t HAL_GpioSetTriggerMode(hal_gpio_handle_t gpioHandle, hal_gpio_interrupt_trigger_t gpioTrigger)"></a>1.16 函数 hal_gpio_status_t HAL_GpioSetTriggerMode(hal_gpio_handle_t gpioHandle, hal_gpio_interrupt_trigger_t gpioTrigger)</h3><p>此函数设置 GPIO 引脚的中断触发模式。</p>
<p>它接受 GPIO 引脚的句柄，以及所需的中断触发模式。</p>
<ol>
<li>该函数首先检查引脚的方向是否未设置为输出，**<u><em>因为中断触发只能用于输入引脚</em></u>**。</li>
<li>然后它将给定的触发模式映射到硬件平台的相应中断配置值。**<u>它设置 GPIO 引脚的触发模式，并在 NVIC（嵌套向量中断控制器）中启用相应的中断</u>**，优先级为 <code>HAL_GPIO_ISR_PRIORITY</code>（可能在代码库的其他地方定义）。</li>
<li>最后，它返回一个状态代码，指示操作是成功还是遇到错误。</li>
</ol>
<h3 id="1-17-函数-hal-gpio-status-t-HAL-GpioWakeUpSetting-hal-gpio-handle-t-gpioHandle-uint8-t-enable"><a href="#1-17-函数-hal-gpio-status-t-HAL-GpioWakeUpSetting-hal-gpio-handle-t-gpioHandle-uint8-t-enable" class="headerlink" title="1.17 函数 hal_gpio_status_t HAL_GpioWakeUpSetting(hal_gpio_handle_t gpioHandle, uint8_t enable)"></a>1.17 函数 hal_gpio_status_t HAL_GpioWakeUpSetting(hal_gpio_handle_t gpioHandle, uint8_t enable)</h3><p><strong><u>==该函数是 GPIO 驱动程序的一部分，用于启用/禁用 GPIO 引脚的唤醒功能。==</u></strong></p>
<p>当设备处于低功耗模式时，如果特定 GPIO 引脚上的唤醒功能已启用，则它可以被该引脚上的信号唤醒。 </p>
<p>该函数有两个参数，一个 GPIO 句柄和一个启用标志。 </p>
<blockquote>
<p>GPIO 句柄用于标识要配置的特定 GPIO 引脚，而启用标志用于指定是启用还是禁用唤醒功能。 </p>
</blockquote>
<ol>
<li>该函数首先断言 GPIO 句柄不为 NULL。</li>
<li>**<u>然后检查GPIO引脚方向是否输出。如果输出方向，则返回错误</u>**。</li>
<li>然后它检查启用标志是否为 0，这意味着禁用唤醒功能。如果启用标志为 0，则返回错误。否则，它返回成功。</li>
</ol>
<p>总的来说，该函数用于配置GPIO引脚的唤醒功能，确保输入参数有效。</p>
<h3 id="1-18-函数-hal-gpio-status-t-HAL-GpioEnterLowpower-hal-gpio-handle-t-gpioHandle"><a href="#1-18-函数-hal-gpio-status-t-HAL-GpioEnterLowpower-hal-gpio-handle-t-gpioHandle" class="headerlink" title="1.18 函数 hal_gpio_status_t HAL_GpioEnterLowpower(hal_gpio_handle_t gpioHandle)"></a>1.18 函数 hal_gpio_status_t HAL_GpioEnterLowpower(hal_gpio_handle_t gpioHandle)</h3><p><code>HAL_GpioEnterLowpower</code> 的实现似乎是一个placeholder占位符函数，它返回<code>kStatus_HAL_GpioSuccess</code>而不执行任何实际操作。</p>
<p><strong><u>==此函数很可能旨在由 HAL 库的用户实现，以提供特定于其应用程序的低功耗功能。==</u></strong></p>
<h3 id="1-19-函数-hal-gpio-status-t-HAL-GpioExitLowpower-hal-gpio-handle-t-gpioHandle"><a href="#1-19-函数-hal-gpio-status-t-HAL-GpioExitLowpower-hal-gpio-handle-t-gpioHandle" class="headerlink" title="1.19 函数 hal_gpio_status_t HAL_GpioExitLowpower(hal_gpio_handle_t gpioHandle)"></a>1.19 函数 hal_gpio_status_t HAL_GpioExitLowpower(hal_gpio_handle_t gpioHandle)</h3><p>**<u>==此函数负责在退出低功耗模式后将 GPIO 引脚恢复为之前的配置==</u>**。</p>
<p>它以一个 GPIO 句柄作为输入并返回一个状态代码，指示操作是否成功。 </p>
<ul>
<li>该函数首先断言 GPIO 句柄有效。</li>
<li>然后它从句柄中检索 GPIO 状态，并使用引脚方向（输入或输出）和默认值 0 初始化一个新的 GPIO 引脚配置对象。 <ul>
<li>如果之前将引脚配置为输出，则新配置对象中的引脚方向将设置为输出。</li>
</ul>
</li>
<li>然后，该函数使用 <code>GPIO_PinInit</code> 函数使用新配置初始化 GPIO 引脚。 <ul>
<li>如果该引脚之前被配置为输入，则该函数调用 <code>HAL_GpioSetTriggerMode</code> 函数来**<u>恢复进入低功耗模式之前设置的中断触发模式</u>**。</li>
</ul>
</li>
<li>最后，函数返回一个状态码，表示操作成功。</li>
</ul>
<h2 id="2-fsl-adapter-gpio-h"><a href="#2-fsl-adapter-gpio-h" class="headerlink" title="2.  fsl_adapter_gpio.h"></a>2.  fsl_adapter_gpio.h</h2><h3 id="2-1-引言"><a href="#2-1-引言" class="headerlink" title="2.1. 引言"></a>2.1. 引言</h3><p>这是用于 GPIO（通用输入/输出）接口的 HAL（硬件抽象层）头文件的开头。它从许可证和标题保护开始。 </p>
<ul>
<li>header包括 <code>fsl_common.h</code>，它是在不同 SDK（软件开发工具包）组件之间共享的通用实用函数、结构和宏的集合。</li>
<li>此外，如果定义了 <code>SDK_OS_FREE_RTOS</code>，它会包含 <code>FreeRTOS.h</code>，这是 FreeRTOS 操作系统的头文件。 </li>
<li>header guard 定义为 <code>HAL_GPIO_H</code> 以防止多次包含同一头文件。</li>
</ul>
<p>头文件为 GPIO 适配器提供定义和结构，它是位于供应商 (NXP) 提供的低级 GPIO 驱动程序之上的抽象层。 该文件提供了以下定义： </p>
<ul>
<li>GPIO适配器版本 </li>
<li>GPIO 冲突检查使能 </li>
<li>GPIO适配器句柄大小 </li>
<li>GPIO句柄定义宏 </li>
<li>GPIO 适配器 ISR 优先级 </li>
<li>GPIO 句柄类型 (hal_gpio_handle_t) </li>
<li>GPIO回调函数类型(hal_gpio_callback_t) </li>
<li>GPIO 中断触发类型 (hal_gpio_interrupt_trigger_t) </li>
<li>GPIO 状态代码 (hal_gpio_status_t) </li>
<li>GPIO 方向类型 (hal_gpio_direction_t) </li>
<li>GPIO 引脚配置结构 (hal_gpio_pin_config_t)</li>
</ul>
<p>这个头文件定义了 GPIO 适配器，它是一个抽象 GPIO 接口的硬件特定细节的驱动程序。驱动程序提供 API 来配置和控制设备的 GPIO 引脚，例如**<u>设置引脚的方向、读取或写入其值以及在引脚上启用中断</u>**。 该文件以一些标准 C 语言定义开头，包括 GPIO 适配器句柄、回调函数、中断触发器、状态和方向的类型定义。这些类型在整个 GPIO 适配器驱动程序 API 中使用，以提供清晰一致的接口。 </p>
<p>该文件还定义了一些宏，包括 GPIO 适配器驱动程序的版本号、GPIO 适配器句柄的大小以及启用或禁用 GPIO 冲突检查的标志。 最后，该文件包括 <code>fsl_common.h</code> 头文件，它提供了在 Freescale/NXP SDK 软件中使用的通用宏和定义，以及 <code>FreeRTOS.h</code> 头文件，它为正在使用的 FreeRTOS 操作系统提供 API。</p>
<p>这是 GPIO（通用输入/输出）适配器的头文件，用于配置和控制MCU上的 GPIO 引脚。 该文件定义了几种类型，包括 <code>hal_gpio_handle_t</code>、<code>hal_gpio_callback_t</code>、<code>hal_gpio_interrupt_trigger_t</code>、<code>hal_gpio_status_t</code>、<code>hal_gpio_direction_t </code>和 <code>hal_gpio_pin_config_t</code>。 </p>
<ul>
<li><code>hal_gpio_handle_t</code>是指向GPIO适配器句柄的指针，</li>
<li><code>hal_gpio_callback_t</code>是用于回调的函数指针，</li>
<li><code>hal_gpio_interrupt_trigger_t</code>定义了中断触发器，</li>
<li><code>hal_gpio_status_t</code>定义了GPIO适配器的状态，</li>
<li><code>hal_gpio_direction_t</code>定义了GPIO引脚的方向，</li>
<li><code>hal_gpio_pin_config_t</code>是一个保存配置的结构GPIO 引脚的设置。</li>
</ul>
<p>头文件还包含宏，例如 </p>
<ul>
<li><code>FSL_GPIO_ADAPTER_VERSION</code> 指示驱动程序的版本，<code>HAL_GPIO_CONFLICT_CHECK_ENABLE</code> 启用/禁用 GPIO 冲突检查，以及</li>
<li><code>HAL_GPIO_HANDLE_SIZE </code>定义 GPIO 适配器句柄的大小。 </li>
<li>此外，头文件定义了一个宏 <code>GPIO_HANDLE_DEFINE</code> 来定义一个 4 字节对齐的 GPIO 句柄</li>
<li>和一个宏 <code>HAL_GPIO_ISR_PRIORITY</code> 来定义 GPIO ISR（中断服务程序）的优先级。</li>
</ul>
<h3 id="2-2-预先初始化引脚-void-HAL-GpioPreInit-void"><a href="#2-2-预先初始化引脚-void-HAL-GpioPreInit-void" class="headerlink" title="2.2 预先初始化引脚 void HAL_GpioPreInit(void)"></a>2.2 预先初始化引脚 void HAL_GpioPreInit(void)</h3><p>此函数初始化位于内存的 <code>.bss</code> 部分中的静态变量。这通常由 IDE 自动完成，但如果在自动清理 <code>.bss</code> 部分之前使用 GPIO 适配器，则可以使用此功能。 用户通常不需要调用此 API。代码注释中提供了一个示例来演示如何使用它。</p>
<ul>
<li>首先，调用 HAL_GpioPreInit() 函数，</li>
<li>然后使用 GPIO_HANDLE_DEFINE 宏定义 GPIO 句柄。</li>
<li>然后，使用所需的 GPIO 引脚配置定义并初始化 hal_gpio_pin_config_t 结构。</li>
<li>最后，调用 HAL_GpioInit() 函数以使用先前定义的 GPIO 句柄以指定配置初始化 GPIO 引脚。</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HAL_GpioPreInit();</span><br><span class="line">GPIO_HANDLE_DEFINE(g_GpioHandle);</span><br><span class="line"><span class="type">hal_gpio_pin_config_t</span> config;</span><br><span class="line">    config.direction = kHAL_GpioDirectionOut;</span><br><span class="line">    config.port = <span class="number">0</span>;</span><br><span class="line">    config.pin = <span class="number">0</span>;</span><br><span class="line">    config.level = <span class="number">0</span>;</span><br><span class="line">HAL_GpioInit((<span class="type">hal_gpio_handle_t</span>)g_GpioHandle, &amp;config);</span><br></pre></td></tr></tbody></table></figure>



<h3 id="2-3-初始化-hal-gpio-status-t-HAL-GpioInit-hal-gpio-handle-t-gpioHandle-hal-gpio-pin-config-t-pinConfig"><a href="#2-3-初始化-hal-gpio-status-t-HAL-GpioInit-hal-gpio-handle-t-gpioHandle-hal-gpio-pin-config-t-pinConfig" class="headerlink" title="2.3 初始化 hal_gpio_status_t HAL_GpioInit(hal_gpio_handle_t gpioHandle, hal_gpio_pin_config_t *pinConfig);"></a>2.3 初始化 hal_gpio_status_t HAL_GpioInit(hal_gpio_handle_t gpioHandle, hal_gpio_pin_config_t *pinConfig);</h3><p>这是 GPIO（通用输入/输出）模块中的一个函数，它使用**<u>==用户定义的设置初始化 GPIO 实例==</u>**。该函数有两个参数： </p>
<ul>
<li>gpioHandle：指向调用者分配的大小为<code>HAL_GPIO_HANDLE_SIZE</code>的内存空间的指针。句柄应该是 4 字节对齐的。用户可以通过两种方式定义句柄：<ul>
<li>使用 <code>GPIO_HANDLE_DEFINE(gpioHandle) </code></li>
<li>或 <code>uint32_t gpioHandle[((HAL_GPIO_HANDLE_SIZE + sizeof(uint32_t) - 1U) / sizeof(uint32_t))]</code></li>
</ul>
</li>
<li><code>pinConfig</code>：指向 <code>hal_gpio_pin_config_t</code> 类型的用户定义配置结构的指针，**<u>该结构保存 GPIO 的配置。该结构有四个字段</u>**： <ul>
<li>direction：GPIO的方向，输出可以设置为<code>kHAL_GpioDirectionOut</code>，输入可以设置为<code>kHAL_GpioDirectionIn</code>。 </li>
<li>port：GPIO 端口号。 </li>
<li>pin：GPIO 引脚号。 </li>
<li>level：**<u>GPIO的初始值，可设置为0或1</u>**。</li>
</ul>
</li>
<li>该函数返回以下状态代码之一： <ul>
<li>kStatus_HAL_GpioError：初始化 GPIO 时发生错误。 </li>
<li>kStatus_HAL_GpioPinConflict：pinConfig 传递的pin 和port 对已经初始化，所以conflict。</li>
<li>kStatus_HAL_GpioSuccess：GPIO 初始化成功。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GPIO_HANDLE_DEFINE(g_GpioHandle);</span><br><span class="line"><span class="type">hal_gpio_pin_config_t</span> config;</span><br><span class="line">config.direction = kHAL_GpioDirectionOut;</span><br><span class="line">config.port = <span class="number">0</span>;</span><br><span class="line">config.pin = <span class="number">0</span>;</span><br><span class="line">config.level = <span class="number">0</span>;</span><br><span class="line">HAL_GpioInit((<span class="type">hal_gpio_handle_t</span>)g_GpioHandle, &amp;config);</span><br></pre></td></tr></tbody></table></figure>



<h3 id="2-4-取消初始化-HAL-GpioDeinit-hal-gpio-handle-t-gpioHandle"><a href="#2-4-取消初始化-HAL-GpioDeinit-hal-gpio-handle-t-gpioHandle" class="headerlink" title="2.4 取消初始化 HAL_GpioDeinit(hal_gpio_handle_t gpioHandle)"></a>2.4 取消初始化 HAL_GpioDeinit(hal_gpio_handle_t gpioHandle)</h3><p><code>HAL_GpioDeinit</code> 函数用于取消初始化 GPIO 实例。**<u>==它禁用触发模式==</u>**。 </p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">hal_gpio_status_t</span> <span class="title function_">HAL_GpioDeinit</span><span class="params">(<span class="type">hal_gpio_handle_t</span> gpioHandle)</span>;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>gpioHandle：GPIO句柄指针。句柄应该是 4 字节对齐的，因为某些设备不支持未对齐的访问。</li>
</ul>
<p>如果 GPIO 去初始化成功，该函数返回 kStatus_HAL_GpioSuccess。</p>
<h3 id="2-5-获取输入引脚状态-HAL-GpioGetInput"><a href="#2-5-获取输入引脚状态-HAL-GpioGetInput" class="headerlink" title="2.5 获取输入引脚状态 HAL_GpioGetInput()"></a>2.5 获取输入引脚状态 HAL_GpioGetInput()</h3><p>此函数用于获取输入 GPIO 引脚的当前状态。通过 pinState 指针参数读取并返回引脚状态。 这是一个示例用法：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GPIO_HANDLE_DEFINE(g_GpioHandle);</span><br><span class="line"><span class="type">uint8_t</span> pinState;</span><br><span class="line">HAL_GpioInit((<span class="type">hal_gpio_handle_t</span>)g_GpioHandle, &amp;config);</span><br><span class="line">HAL_GpioGetInput((<span class="type">hal_gpio_handle_t</span>)g_GpioHandle, &amp;pinState);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>==<u>在此示例中，已使用 <code>HAL_GpioInit() </code>初始化 GPIO 引脚，然后使用 <code>HAL_GpioGetInput() </code>读取引脚的当前状态。引脚的当前状态通过 <code>pinState</code> 指针参数返回。</u>==</strong></p>
<h3 id="2-6-设置输出电平HAL-GpioSetOutput"><a href="#2-6-设置输出电平HAL-GpioSetOutput" class="headerlink" title="2.6 设置输出电平HAL_GpioSetOutput"></a>2.6 设置输出电平HAL_GpioSetOutput</h3><p>这是 <code>HAL_GpioSetOutput</code> 函数的函数定义。此函数**<u>==将 GPIO 引脚的电压电平设置为指定值==</u>**。下面简单解释一下参数和返回值： </p>
<ul>
<li>gpioHandle：这是一个指向GPIO句柄对象的指针，表示设备上的一个特定的GPIO引脚。句柄应该是 4 字节对齐的，以确保正确的内存访问。 </li>
<li>pinState：这是一个 8 位无符号整数，表示 GPIO 引脚的所需电压电平。值为 0 表示低电压电平，而值为 1 表示高电压电平。 </li>
<li>返回值：该函数返回一个hal_gpio_status_t类型的值，代表操作成功或失败。如果操作成功，函数返回 kStatus_HAL_GpioSuccess。</li>
</ul>
<h3 id="2-7-获取Pin中断触发模式-HAL-GpioGetTriggerMode"><a href="#2-7-获取Pin中断触发模式-HAL-GpioGetTriggerMode" class="headerlink" title="2.7 获取Pin中断触发模式 HAL_GpioGetTriggerMode"></a>2.7 获取Pin中断触发模式 HAL_GpioGetTriggerMode</h3><p>函数 <code>HAL_GpioGetTriggerMode</code> **<u>==获取引脚中断触发模式==</u>**。</p>
<p>触发模式由枚举类型<code>hal_gpio_interrupt_trigger_t</code>表示，可以是以下值之一: </p>
<ul>
<li>kHAL_GpioInterruptTriggerLowLevel：低电平触发中断 </li>
<li>kHAL_GpioInterruptTriggerHighLevel：高电平触发中断 </li>
<li>kHAL_GpioInterruptTriggerRisingEdge：上升沿触发中断 </li>
<li>kHAL_GpioInterruptTriggerFallingEdge：下降沿触发中断 </li>
<li>kHAL_GpioInterruptTriggerEitherEdge：在任一边沿触发中断</li>
</ul>
<p>**<u>==如果引脚配置为输出，函数返回 kStatus_HAL_GpioError==</u>**。 </p>
<p>该函数有两个参数： </p>
<ul>
<li>gpioHandle：GPIO句柄指针。 </li>
<li>gpioTrigger：保存管脚触发模式值的指针。</li>
</ul>
<p>该函数返回以下状态代码之一： </p>
<ul>
<li>kStatus_HAL_GpioSuccess：引脚触发模式已成功检索。 </li>
<li>kStatus_HAL_GpioError：引脚配置为输出。</li>
</ul>
<h3 id="2-8-设置触发模式-HAL-GpioSetTriggerMode"><a href="#2-8-设置触发模式-HAL-GpioSetTriggerMode" class="headerlink" title="2.8 设置触发模式 HAL_GpioSetTriggerMode"></a>2.8 设置触发模式 HAL_GpioSetTriggerMode</h3><p>HAL_Gpio* 函数是硬件抽象层 (HAL) 库的一部分，用于与微控制器上的 GPIO（通用输入/输出）引脚进行交互。 GPIO 引脚可用于多种用途，例如控制 LED 或读取按钮按下情况。 </p>
<ul>
<li>HAL_GpioPreInit() 函数用于初始化位于 .bss 部分的静态变量。该变量将用于存储 GPIO 引脚的配置信息。通常不需要此功能，仅在某些情况下使用，例如在 .bss 部分被 IDE 自动清理之前使用 GPIO 适配器时。 </li>
<li>HAL_GpioInit() 函数使用 GPIO 句柄和用户配置结构初始化 GPIO 实例。用户可以配置配置结构来设置引脚方向（输入或输出）、端口号、引脚号和初始引脚电平。 gpioHandle参数是一个指向调用者分配的内存空间的指针，用于存储GPIO实例的信息。 </li>
<li>HAL_GpioDeinit() 函数通过禁用触发模式来取消初始化 GPIO 实例。当不再需要 GPIO 引脚时，应调用此函数。 </li>
<li>HAL_GpioGetInput() 函数获取输入 GPIO 引脚的电压电平。电压电平在 pinState 参数中返回。 </li>
<li>HAL_GpioSetOutput() 函数设置输出 GPIO 引脚的电压电平。所需的电压电平在 pinState 参数中传递。 </li>
<li>HAL_GpioGetTriggerMode() 函数获取 GPIO 引脚的中断触发模式。触发模式决定了是什么导致在引脚上产生中断，例如上升沿或下降沿。触发模式在 gpioTrigger 参数中返回。 </li>
<li>HAL_GpioSetTriggerMode() 函数设置 GPIO 引脚的中断触发模式。所需的触发模式在 gpioTrigger 参数中传递。</li>
</ul>
<h3 id="2-9-HAL-GpioInstallCallback"><a href="#2-9-HAL-GpioInstallCallback" class="headerlink" title="2.9 HAL_GpioInstallCallback()"></a>2.9 HAL_GpioInstallCallback()</h3><p>该函数用于**<u>为GPIO模块安装一个回调函数及其对应的参数</u>**。</p>
<p>当引脚状态中断发生时，驱动会通过调用已安装的回调函数通知上层。 GPIO管脚状态可以通过回调函数内部调用函数<code>HAL_GpioGetInput()</code>获取。 该函数采用三个参数： </p>
<ul>
<li>gpioHandle：GPIO句柄指针。 </li>
<li>callback：要安装的回调函数。 </li>
<li>callbackParam：回调函数的参数。</li>
</ul>
<p>该函数返回一个状态代码，指示回调是否已成功安装。如果成功，返回值为 kStatus_HAL_GpioSuccess。</p>
<h3 id="2-10-HAL-GpioWakeUpSetting"><a href="#2-10-HAL-GpioWakeUpSetting" class="headerlink" title="2.10 HAL_GpioWakeUpSetting()"></a>2.10 HAL_GpioWakeUpSetting()</h3><p><code>HAL_GpioWakeUpSetting</code> 函数**<u>==启用或禁用 GPIO 唤醒功能==</u>**。</p>
<p>此功能允许系统**<u>通过 GPIO 引脚状态的变化从低功耗模式唤醒</u>**。 </p>
<p>该函数采用 gpioHandle 参数，该参数是指向 GPIO 句柄的指针。句柄应该是 4 字节对齐的，因为某些设备不支持未对齐的访问。 </p>
<p>enable 参数是一个布尔值，指示是启用还是禁用唤醒功能。值 1 启用该功能，而值 0 禁用它。 </p>
<p>该函数返回一个 hal_gpio_status_t 状态码，其中 kStatus_HAL_GpioSuccess 表示成功，kStatus_HAL_GpioError 表示发生错误。</p>
<h3 id="2-11-HAL-GpioEnterLowpower"><a href="#2-11-HAL-GpioEnterLowpower" class="headerlink" title="2.11 HAL_GpioEnterLowpower()"></a>2.11 HAL_GpioEnterLowpower()</h3><p>根据提供的函数定义，函数 HAL_GpioEnterLowpower() 用于准备进入低功耗。但是，函数定义中并未指定为低功耗准备所采取的确切步骤。该**<u>==函数很可能会执行必要的步骤将 GPIO 模块置于低功耗状态==</u>**，例如禁用未使用的引脚或将时钟频率设置为较低的值。</p>
<p>在定义此函数的 HAL 库的文档或源代码中可能会提供更多信息。</p>
<h3 id="2-12-HAL-GpioExitLowpower"><a href="#2-12-HAL-GpioExitLowpower" class="headerlink" title="2.12 HAL_GpioExitLowpower()"></a>2.12 HAL_GpioExitLowpower()</h3><p>这两个函数 HAL_GpioEnterLowpower 和 HAL_GpioExitLowpower 似乎是用于管理低功耗的更大系统的一部分。 GPIO 模块用于控制系统的唤醒行为，这些函数可能分别用于准备 GPIO 模块进入低功耗模式和从低功耗模式恢复。 </p>
<p>HAL_GpioEnterLowpower 可以执行诸如禁用 GPIO 中断、将 GPIO 引脚设置为低功耗状态或降低 GPIO 模块的时钟频率以节省电量等操作。 </p>
<p>HAL_GpioExitLowpower 可能会执行 HAL_GpioEnterLowpower 的反向操作，例如恢复 GPIO 中断，将 GPIO 引脚恢复到之前的状态，或者提高 GPIO 模块的时钟频率以恢复正常操作。 </p>
<p>总体而言，这些功能似乎是用于管理功耗和唤醒行为的更大系统的一部分，而不是独立的 GPIO 功能。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-10-17T07:40:02.000Z" title="10/17/2022, 7:40:02 AM">2022-10-17</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/NXP/">NXP</a></span><span class="level-item">13 分钟读完 (大约1900个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/NXP/uart%E6%80%BB%E7%BB%93/">UART总结</a></p><div class="content"><h1 id="总线协议-–-UART"><a href="#总线协议-–-UART" class="headerlink" title="总线协议 – UART"></a>总线协议 – UART</h1><h2 id="一、-UART简介"><a href="#一、-UART简介" class="headerlink" title="一、 UART简介"></a>一、 UART简介</h2><blockquote>
<p>UART: Universal Asynchronous Receiver Transmitter（通用异步收发器），</p>
<p>通用的<em>串行、异步</em>通信总线，它有<strong>两条</strong>数据线，实现<strong>全双工</strong>发送和接收。</p>
</blockquote>
<h3 id="1-1-通信基础"><a href="#1-1-通信基础" class="headerlink" title="1.1 通信基础"></a>1.1 通信基础</h3><p>串行、并行：</p>
<ul>
<li>并行通信：总线在传递数据的时候，可以一次性收发多个位的数据。并行虽然快，但是要考虑多个线的<em>资源占用</em>，以及多条线<em>互相干扰</em>的问题；</li>
<li>串行通信：每一位数据逐次传递；（<strong>IIC\SPI都是串行通信</strong>）</li>
</ul>
<p>单工、双工：</p>
<ul>
<li>单工通信：只能是单向的，<mark>发送器给接收器发送数据</mark>，而不能反过来；</li>
<li>双工通信：可以是A到B，也可以是B到A；<ul>
<li>半双工：不能同时发生；只有一根线，发送时就不能接收；</li>
<li>全双工：可以同时发送和接收，有两根线；</li>
</ul>
</li>
</ul>
<p>波特率：</p>
<ul>
<li><p>波特率：描述UART通信速度，单位<strong>bps</strong>，(bit per second)，每秒传送的bit的数量；</p>
<ul>
<li>每秒的波特数，波特等于单个信号包含的码元数量</li>
</ul>
</li>
<li><p>比特率：是指每秒传送的比特(bit)数。单位为 bps(Bit Per Second)，比特率越高，每秒传送数据就越多。</p>
</li>
<li><p>波特率：表示每秒钟传送码元符号的个数，是衡量数据传送速率的指标。</p>
<ul>
<li>在信息传输通道中，携带数据信息的信号单元叫码元，每秒钟通过信道传输的码元数称为码元传输速率，简称<strong>波特率</strong>。波特率是传输通道频宽的指标。</li>
<li>比特率=波特率x单个调制状态对应的二进制位数</li>
<li>两相调制(单个调制状态对应1个二进制位)的比特率等于波特率;四相调制(单个调制状态对应2个二进制位)的比特率为波特率的两倍;八相调制(单个调制状态对应3个二进制位)的比特率为波特率的三倍;依次类推。</li>
</ul>
</li>
</ul>
<h3 id="1-2-UART帧格式"><a href="#1-2-UART帧格式" class="headerlink" title="1.2 UART帧格式"></a>1.2 UART帧格式</h3><p><img src="/./UART%E6%80%BB%E7%BB%93/frame_struct.JPG" alt="UART帧格式"></p>
<ul>
<li><input disabled="" type="checkbox"> 起始位：1bit的0，标志发送开始；因为空闲时为1，所以开始为0；</li>
<li><input checked="" disabled="" type="checkbox"> 数据位： 5-8bit，<strong>先发低位，后发高位</strong>；</li>
<li><input disabled="" type="checkbox"> 校验位：可有可无；奇偶校验，是校验奇数还是偶数个1； </li>
<li><input disabled="" type="checkbox"> 停止位：高电平1；</li>
<li><input disabled="" type="checkbox"> 空闲位：</li>
</ul>
<blockquote>
<p>注意： UART<strong>空闲</strong>的时候，用<strong>高电平</strong>表示；</p>
<p>串口协议从低位先发，最后发高位；</p>
<p><mark>串口每次都只发一个byte，下一个byte又重新开始起始位，是因为它是<strong>异步的</strong>，发送方和接收方的时钟不是同一个，防止由于时钟不同步导致误差累积；</mark></p>
<p>IIC和SPI都是同步通信，可以发多个字节；</p>
</blockquote>
<h3 id="1-3-Tx-Rx"><a href="#1-3-Tx-Rx" class="headerlink" title="1.3 Tx &amp; Rx"></a>1.3 Tx &amp; Rx</h3><blockquote>
<p>串口的信号一般较弱，通信距离短，容易被干扰，所以增加了一块专有芯片用来增加抗干扰能力，使发送距离更远；(TTL信号转为232信号)</p>
</blockquote>
<p>发送STEPs：</p>
<ol>
<li>待发送数据放入FIFO</li>
<li>增加了UART协议的各种头，比如起始和校验，然后拷贝放入shifter；</li>
<li>shifter每个bit依次移位到引脚来发送，<strong>先发低位，后发高位</strong>；</li>
</ol>
<p><em>即发送时：      FIFO –&gt; shifter –&gt; TxD;</em></p>
<p><em>接收时顺序相反，RxD –&gt; shifter –&gt; FIFO;</em></p>
<h3 id="1-4-UART工作模式"><a href="#1-4-UART工作模式" class="headerlink" title="1.4 UART工作模式"></a>1.4 UART工作模式</h3><p><em><strong>CPU会通过总线，和接收和发送的BUFFer相连，用来读写数据，另外，也和控制单元相连，对控制单元的设置进行修改；</strong></em></p>
<blockquote>
<p>look-back: <strong>回环模式look-back</strong>是在内部将Tx和Rx短接，一般用于测试；</p>
</blockquote>
<p><img src="/./UART%E6%80%BB%E7%BB%93/workMode.JPG" alt="几种工作模式"></p>
<p>三种常见的工作模式：</p>
<ol>
<li>polling  轮询<ul>
<li>CPU不断地对FIFO进行访问，查询需要的数据有没有发过来；</li>
<li>CPU的状态： 工作 –&gt; 轮询 –&gt; 工作 –&gt; 轮询 …</li>
<li>直到查找到需要的数据；</li>
<li>费时费力，消耗资源</li>
</ul>
</li>
<li>interrupt  中断<ul>
<li>CPU和FIFO约定，CPU<strong>不主动</strong>去查询，当FIFO收到数据要发送过来的时候，给CPU发送<strong>中断信号</strong>，CPU中断当前工作，接收FIFO的数据；</li>
<li><strong>比polling模式省资源</strong>；</li>
</ul>
</li>
<li>DMA  直接存储器访问<ul>
<li>CPU收到FIFO的数据，最终也是要放入某一块内存中去使用的；</li>
<li>DMA模式<strong>跳过CPU</strong>，当FIFO数据过来时，直接放入需要的内存中；</li>
</ul>
</li>
</ol>
<h2 id="二、-polling模式实验（以qn9090为例）"><a href="#二、-polling模式实验（以qn9090为例）" class="headerlink" title="二、 polling模式实验（以qn9090为例）"></a>二、 polling模式实验（以qn9090为例）</h2><h3 id="2-1-主函数"><a href="#2-1-主函数" class="headerlink" title="2.1 主函数"></a>2.1 主函数</h3><blockquote>
<p>usart_polling.c</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint8_t</span> ch;</span><br><span class="line">    <span class="type">usart_config_t</span> config;                              <span class="comment">// 配置波特率、帧格式、上升下降沿、奇偶校验、停止位等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Security code to allow debug access */</span></span><br><span class="line">    SYSCON-&gt;CODESECURITYPROT = <span class="number">0x87654320</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* attach clock for USART(debug console) */</span></span><br><span class="line">    CLOCK_AttachClk(BOARD_DEBUG_UART_CLK_ATTACH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reset FLEXCOMM for USART */</span></span><br><span class="line">    RESET_PeripheralReset(kFC0_RST_SHIFT_RSTn);</span><br><span class="line"></span><br><span class="line">    BOARD_BootClockRUN();</span><br><span class="line">    BOARD_InitDebugConsole();</span><br><span class="line">    BOARD_InitPins();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * config.baudRate_Bps = 115200U;</span></span><br><span class="line"><span class="comment">     * config.parityMode = kUSART_ParityDisabled;</span></span><br><span class="line"><span class="comment">     * config.stopBitCount = kUSART_OneStopBit;</span></span><br><span class="line"><span class="comment">     * config.loopback = false;</span></span><br><span class="line"><span class="comment">     * config.enableTx = false;</span></span><br><span class="line"><span class="comment">     * config.enableRx = false;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    USART_GetDefaultConfig(&amp;config);                    <span class="comment">// 使用默认配置，传入config的引用</span></span><br><span class="line">    config.baudRate_Bps = BOARD_DEBUG_UART_BAUDRATE;    <span class="comment">// 客制化usart配置</span></span><br><span class="line">    config.enableTx     = <span class="literal">true</span>;</span><br><span class="line">    config.enableRx     = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    USART_Init(DEMO_USART, &amp;config, DEMO_USART_CLK_FREQ);           <span class="comment">// 使用config和外部时钟初始化USART实例，其中外部时钟只在设置波特率时使用</span></span><br><span class="line"></span><br><span class="line">    USART_WriteBlocking(DEMO_USART, txbuff, <span class="keyword">sizeof</span>(txbuff) - <span class="number">1</span>);    <span class="comment">// 将数组中的值写入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        PRINTF(<span class="string">"READ:\n\r"</span>);</span><br><span class="line">        USART_ReadBlocking(DEMO_USART, &amp;ch, <span class="number">1</span>);                     <span class="comment">// 数据逐个从FIFORD读入ch，这里只读入一位</span></span><br><span class="line">        PRINTF(<span class="string">"\n\rWRITE:\n\r"</span>);</span><br><span class="line">        USART_WriteBlocking(DEMO_USART, &amp;ch, <span class="number">1</span>);                    <span class="comment">// 数据逐个从ch写入FIFOWR，这里只读入一位，等待TX进入IDLE模式结束</span></span><br><span class="line">        PRINTF(<span class="string">"\n\r"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-2-只接收一个char"><a href="#2-2-只接收一个char" class="headerlink" title="2.2 只接收一个char"></a>2.2 只接收一个char</h3><p>实验结果：</p>
<p><img src="/./UART%E6%80%BB%E7%BB%93/%E5%8D%95%E5%AD%97%E7%AC%A6%E5%AE%9E%E9%AA%8C.jpg" alt="单字符实验"></p>
<h2 id="接收字符串"><a href="#接收字符串" class="headerlink" title="接收字符串"></a>接收字符串</h2><p>原始代码修改为接收一个定长5的array，代码：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint8_t</span> <span class="built_in">array</span>[<span class="number">6</span>];</span><br><span class="line">    <span class="type">usart_config_t</span> config;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Security code to allow debug access */</span></span><br><span class="line">    SYSCON-&gt;CODESECURITYPROT = <span class="number">0x87654320</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* attach clock for USART(debug console) */</span></span><br><span class="line">    CLOCK_AttachClk(BOARD_DEBUG_UART_CLK_ATTACH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reset FLEXCOMM for USART */</span></span><br><span class="line">    RESET_PeripheralReset(kFC0_RST_SHIFT_RSTn);</span><br><span class="line"></span><br><span class="line">    BOARD_BootClockRUN();</span><br><span class="line">    BOARD_InitDebugConsole();</span><br><span class="line">    BOARD_InitPins();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * config.baudRate_Bps = 115200U;</span></span><br><span class="line"><span class="comment">     * config.parityMode = kUSART_ParityDisabled;</span></span><br><span class="line"><span class="comment">     * config.stopBitCount = kUSART_OneStopBit;</span></span><br><span class="line"><span class="comment">     * config.loopback = false;</span></span><br><span class="line"><span class="comment">     * config.enableTx = false;</span></span><br><span class="line"><span class="comment">     * config.enableRx = false;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    USART_GetDefaultConfig(&amp;config);</span><br><span class="line">    config.baudRate_Bps = BOARD_DEBUG_UART_BAUDRATE;</span><br><span class="line">    config.enableTx     = <span class="literal">true</span>;</span><br><span class="line">    config.enableRx     = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    USART_Init(DEMO_USART, &amp;config, DEMO_USART_CLK_FREQ);</span><br><span class="line"></span><br><span class="line">    USART_WriteBlocking(DEMO_USART, txbuff, <span class="keyword">sizeof</span>(txbuff) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        PRINTF(<span class="string">"READ:\n\r"</span>);</span><br><span class="line">        USART_ReadBlocking(DEMO_USART, &amp;<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>) - <span class="number">1</span>);</span><br><span class="line">        PRINTF(<span class="string">"\n\rWRITE:\n\r"</span>);</span><br><span class="line">        USART_WriteBlocking(DEMO_USART, &amp;<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>) - <span class="number">1</span>);</span><br><span class="line">        PRINTF(<span class="string">"\n\r"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>实验结果：</p>
<p><img src="/./UART%E6%80%BB%E7%BB%93/%E5%AE%9A%E9%95%BFarray%E5%AE%9E%E9%AA%8C.jpg" alt="定长array实验"></p>
<h2 id="三、补充"><a href="#三、补充" class="headerlink" title="三、补充"></a>三、补充</h2><h3 id="3-1-SDK中典型使用"><a href="#3-1-SDK中典型使用" class="headerlink" title="3.1 SDK中典型使用"></a>3.1 SDK中典型使用</h3><p>在NXP的QN9090的SDK中，提供了丰富的示例：</p>
<ul>
<li>polling method 收发</li>
<li>interrupt method 收发</li>
<li>ringbuffer接收数据</li>
<li>DMA method 收发</li>
</ul>
<p>文档 ： <code>MCUXpresso SDK API Reference Manual.pdf</code></p>
<p><img src="/./UART%E6%80%BB%E7%BB%93/%E5%85%B8%E5%9E%8B%E7%A4%BA%E4%BE%8B.jpg" alt="典型示例"></p>
<h3 id="3-2-串口的工作原理"><a href="#3-2-串口的工作原理" class="headerlink" title="3.2 串口的工作原理"></a>3.2 串口的工作原理</h3><p>一个byte的数据，如何转为串口输出的bit？ 通过移位寄存器原理实现</p>
<p>移位寄存器原理：</p>
<p><img src="/./UART%E6%80%BB%E7%BB%93/%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8.jpg" alt="移位寄存器"></p>
<p>初始状态： A3A2A1A0＝ 1011</p>
<p>然后Q3的输出，是在每个时钟节拍，按照这个先后顺序，把A3A2A1A0串行的输出出去。(小端)</p>
<p>其实利用的就是D触发器的特性。</p>
<p>如果我们使用8位的移位寄存器，就可以利用8个clk的时间，发一组8bit的数据通过一根导线传输出去。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-10-17T06:37:01.000Z" title="10/17/2022, 6:37:01 AM">2022-10-17</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/NXP/">NXP</a></span><span class="level-item">3 分钟读完 (大约462个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/NXP/uart-polling%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81/">UART_Polling模式代码</a></p><div class="content"><h1 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h1><blockquote>
<p>usart_polling.c</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint8_t</span> ch;</span><br><span class="line">    <span class="type">usart_config_t</span> config;                              <span class="comment">// 配置波特率、帧格式、上升下降沿、奇偶校验、停止位等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Security code to allow debug access */</span></span><br><span class="line">    SYSCON-&gt;CODESECURITYPROT = <span class="number">0x87654320</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* attach clock for USART(debug console) */</span></span><br><span class="line">    CLOCK_AttachClk(BOARD_DEBUG_UART_CLK_ATTACH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reset FLEXCOMM for USART */</span></span><br><span class="line">    RESET_PeripheralReset(kFC0_RST_SHIFT_RSTn);</span><br><span class="line"></span><br><span class="line">    BOARD_BootClockRUN();</span><br><span class="line">    BOARD_InitDebugConsole();</span><br><span class="line">    BOARD_InitPins();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * config.baudRate_Bps = 115200U;</span></span><br><span class="line"><span class="comment">     * config.parityMode = kUSART_ParityDisabled;</span></span><br><span class="line"><span class="comment">     * config.stopBitCount = kUSART_OneStopBit;</span></span><br><span class="line"><span class="comment">     * config.loopback = false;</span></span><br><span class="line"><span class="comment">     * config.enableTx = false;</span></span><br><span class="line"><span class="comment">     * config.enableRx = false;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    USART_GetDefaultConfig(&amp;config);                    <span class="comment">// 使用默认配置，传入config的引用</span></span><br><span class="line">    config.baudRate_Bps = BOARD_DEBUG_UART_BAUDRATE;    <span class="comment">// 客制化usart配置</span></span><br><span class="line">    config.enableTx     = <span class="literal">true</span>;</span><br><span class="line">    config.enableRx     = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    USART_Init(DEMO_USART, &amp;config, DEMO_USART_CLK_FREQ);           <span class="comment">// 使用config和外部时钟初始化USART实例，其中外部时钟只在设置波特率时使用</span></span><br><span class="line"></span><br><span class="line">    USART_WriteBlocking(DEMO_USART, txbuff, <span class="keyword">sizeof</span>(txbuff) - <span class="number">1</span>);    <span class="comment">// 将数组中的值写入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        PRINTF(<span class="string">"READ:\n\r"</span>);</span><br><span class="line">        USART_ReadBlocking(DEMO_USART, &amp;ch, <span class="number">1</span>);                     <span class="comment">// 数据逐个从FIFORD读入ch，这里只读入一位</span></span><br><span class="line">        PRINTF(<span class="string">"\n\rWRITE:\n\r"</span>);</span><br><span class="line">        USART_WriteBlocking(DEMO_USART, &amp;ch, <span class="number">1</span>);                    <span class="comment">// 数据逐个从ch写入FIFOWR，这里只读入一位，等待TX进入IDLE模式结束</span></span><br><span class="line">        PRINTF(<span class="string">"\n\r"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="只接收一个char"><a href="#只接收一个char" class="headerlink" title="只接收一个char"></a>只接收一个char</h2><p>实验结果：</p>
<p><img src="/./UART_Polling%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81/%E5%8D%95%E5%AD%97%E7%AC%A6%E5%AE%9E%E9%AA%8C.jpg" alt="单字符实验"></p>
<h2 id="接收字符串"><a href="#接收字符串" class="headerlink" title="接收字符串"></a>接收字符串</h2><p>原始代码修改为接收一个定长5的array，代码：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint8_t</span> <span class="built_in">array</span>[<span class="number">6</span>];</span><br><span class="line">    <span class="type">usart_config_t</span> config;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Security code to allow debug access */</span></span><br><span class="line">    SYSCON-&gt;CODESECURITYPROT = <span class="number">0x87654320</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* attach clock for USART(debug console) */</span></span><br><span class="line">    CLOCK_AttachClk(BOARD_DEBUG_UART_CLK_ATTACH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reset FLEXCOMM for USART */</span></span><br><span class="line">    RESET_PeripheralReset(kFC0_RST_SHIFT_RSTn);</span><br><span class="line"></span><br><span class="line">    BOARD_BootClockRUN();</span><br><span class="line">    BOARD_InitDebugConsole();</span><br><span class="line">    BOARD_InitPins();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * config.baudRate_Bps = 115200U;</span></span><br><span class="line"><span class="comment">     * config.parityMode = kUSART_ParityDisabled;</span></span><br><span class="line"><span class="comment">     * config.stopBitCount = kUSART_OneStopBit;</span></span><br><span class="line"><span class="comment">     * config.loopback = false;</span></span><br><span class="line"><span class="comment">     * config.enableTx = false;</span></span><br><span class="line"><span class="comment">     * config.enableRx = false;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    USART_GetDefaultConfig(&amp;config);</span><br><span class="line">    config.baudRate_Bps = BOARD_DEBUG_UART_BAUDRATE;</span><br><span class="line">    config.enableTx     = <span class="literal">true</span>;</span><br><span class="line">    config.enableRx     = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    USART_Init(DEMO_USART, &amp;config, DEMO_USART_CLK_FREQ);</span><br><span class="line"></span><br><span class="line">    USART_WriteBlocking(DEMO_USART, txbuff, <span class="keyword">sizeof</span>(txbuff) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        PRINTF(<span class="string">"READ:\n\r"</span>);</span><br><span class="line">        USART_ReadBlocking(DEMO_USART, &amp;<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>) - <span class="number">1</span>);</span><br><span class="line">        PRINTF(<span class="string">"\n\rWRITE:\n\r"</span>);</span><br><span class="line">        USART_WriteBlocking(DEMO_USART, &amp;<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>) - <span class="number">1</span>);</span><br><span class="line">        PRINTF(<span class="string">"\n\r"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>实验结果：</p>
<p><img src="/./UART_Polling%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81/%E5%AE%9A%E9%95%BFarray%E5%AE%9E%E9%AA%8C.jpg" alt="定长array实验"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-09-21T07:31:59.000Z" title="9/21/2022, 7:31:59 AM">2022-09-21</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/NXP/">NXP</a></span><span class="level-item">10 分钟读完 (大约1456个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/NXP/%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE%E4%B9%8B-uart/">总线协议之 -- UART</a></p><div class="content"><h1 id="总线协议之-–-UART"><a href="#总线协议之-–-UART" class="headerlink" title="总线协议之 – UART"></a>总线协议之 – UART</h1><h2 id="UART简介"><a href="#UART简介" class="headerlink" title="UART简介"></a>UART简介</h2><blockquote>
<p>UART: Universal Asynchronous Receiver Transmitter（通用异步收发器），</p>
<p>通用的<em>串行、异步</em>通信总线，它有<strong>两条</strong>数据线，实现<strong>全双工</strong>发送和接收。</p>
</blockquote>
<h3 id="通信基础"><a href="#通信基础" class="headerlink" title="通信基础"></a>通信基础</h3><p>串行、并行：</p>
<ul>
<li>并行通信：总线在传递数据的时候，可以一次性收发多个位的数据。并行虽然快，但是要考虑多个线的<em>资源占用</em>，以及多条线<em>互相干扰</em>的问题；</li>
<li>串行通信：每一位数据逐次传递；（<strong>IIC\SPI都是串行通信</strong>）</li>
</ul>
<p>单工、双工：</p>
<ul>
<li>单工通信：只能是单向的，<mark>发送器给接收器发送数据</mark>，而不能反过来；</li>
<li>双工通信：可以是A到B，也可以是B到A；<ul>
<li>半双工：不能同时发生；只有一根线，发送时就不能接收；</li>
<li>全双工：可以同时发送和接收，有两根线；</li>
</ul>
</li>
</ul>
<p>波特率：</p>
<ul>
<li><p>波特率：描述UART通信速度，单位<strong>bps</strong>，(bit per second)，每秒传送的bit的数量；</p>
<ul>
<li>每秒的波特数，波特等于单个信号包含的码元数量</li>
</ul>
</li>
<li><p>比特率：是指每秒传送的比特(bit)数。单位为 bps(Bit Per Second)，比特率越高，每秒传送数据就越多。</p>
</li>
<li><p>波特率：表示每秒钟传送码元符号的个数，是衡量数据传送速率的指标。</p>
<ul>
<li>在信息传输通道中，携带数据信息的信号单元叫码元，每秒钟通过信道传输的码元数称为码元传输速率，简称<strong>波特率</strong>。波特率是传输通道频宽的指标。</li>
<li>比特率=波特率x单个调制状态对应的二进制位数</li>
<li>两相调制(单个调制状态对应1个二进制位)的比特率等于波特率;四相调制(单个调制状态对应2个二进制位)的比特率为波特率的两倍;八相调制(单个调制状态对应3个二进制位)的比特率为波特率的三倍;依次类推。</li>
</ul>
</li>
</ul>
<h2 id="UART帧格式"><a href="#UART帧格式" class="headerlink" title="UART帧格式"></a>UART帧格式</h2><p><img src="/./%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE1_UART/frame_struct.JPG" alt="UART帧格式"></p>
<ul>
<li><input disabled="" type="checkbox"> 起始位：1bit的0，标志发送开始；因为空闲时为1，所以开始为0；</li>
<li><input checked="" disabled="" type="checkbox"> 数据位： 5-8bit，<strong>先发低位，后发高位</strong>；</li>
<li><input disabled="" type="checkbox"> 校验位：可有可无；奇偶校验，是校验奇数还是偶数个1； </li>
<li><input disabled="" type="checkbox"> 停止位：高电平1；</li>
<li><input disabled="" type="checkbox"> 空闲位：</li>
</ul>
<blockquote>
<p>注意： UART<strong>空闲</strong>的时候，用<strong>高电平</strong>表示；</p>
<p>串口协议从低位先发，最后发高位；</p>
<p><mark>串口每次都只发一个byte，下一个byte又重新开始起始位，是因为它是<strong>异步的</strong>，发送方和接收方的时钟不是同一个，防止由于时钟不同步导致误差累积；</mark></p>
<p>IIC和SPI都是同步通信，可以发多个字节；</p>
</blockquote>
<h2 id="Exynos4412下的UART控制器"><a href="#Exynos4412下的UART控制器" class="headerlink" title="Exynos4412下的UART控制器"></a>Exynos4412下的UART控制器</h2><blockquote>
<p>串口的信号一般较弱，通信距离短，容易被干扰，所以增加了一块专有芯片用来增加抗干扰能力，使发送距离更远；(TTL信号转为232信号)</p>
</blockquote>
<p><img src="/./%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE1_UART/shifter.JPG" alt="shifter"></p>
<p>STEPs：</p>
<ol>
<li>待发送数据放入FIFO</li>
<li>增加了UART协议的各种头，比如起始和校验，然后拷贝放入shifter；</li>
<li>shifter每个bit依次移位到引脚来发送，<strong>先发低位，后发高位</strong>；</li>
</ol>
<p><em>接收时顺序相反，RxD –&gt; shifter –&gt; FIFO;</em></p>
<h3 id="UART控制器的总体框图"><a href="#UART控制器的总体框图" class="headerlink" title="UART控制器的总体框图"></a>UART控制器的总体框图</h3><p><img src="/./%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE1_UART/diagram.JPG" alt="框图"></p>
<p><em><strong>CPU会通过总线，和接收和发送的BUFFer相连，用来读写数据，另外，也和控制单元相连，对控制单元的设置进行修改；</strong></em></p>
<h2 id="UART寄存器详解"><a href="#UART寄存器详解" class="headerlink" title="UART寄存器详解"></a>UART寄存器详解</h2><blockquote>
<p>补充一个细节，<strong>回环模式look-back</strong>是在内部将Tx和Rx短接，一般用于测试；</p>
</blockquote>
<p><img src="/./%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE1_UART/workMode.JPG" alt="几种工作模式"></p>
<p>三种工作模式：</p>
<ol>
<li>polling  轮询<ul>
<li>CPU不断地对FIFO进行访问，查询需要的数据有没有发过来；</li>
<li>CPU的状态： 工作 –&gt; 轮询 –&gt; 工作 –&gt; 轮询 …</li>
<li>直到查找到需要的数据；</li>
<li>费时费力，消耗资源</li>
</ul>
</li>
<li>interrupt  中断<ul>
<li>CPU和FIFO约定，CPU<strong>不主动</strong>去查询，当FIFO收到数据要发送过来的时候，给CPU发送<strong>中断信号</strong>，CPU中断当前工作，接收FIFO的数据；</li>
<li><strong>比polling模式省资源</strong>；</li>
</ul>
</li>
<li>DMA  直接存储器访问<ul>
<li>CPU收到FIFO的数据，最终也是要放入某一块内存中去使用的；</li>
<li>DMA模式<strong>跳过CPU</strong>，当FIFO数据过来时，直接放入需要的内存中；</li>
</ul>
</li>
</ol>
<p><mark>UART编程之前，设置需要的寄存器，以及顺序：</mark></p>
<p><img src="/./%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE1_UART/regSet.JPG" alt="regSet"></p>
<h2 id="UART编程"><a href="#UART编程" class="headerlink" title="UART编程"></a>UART编程</h2><h3 id="STEP-1：-串口初始化"><a href="#STEP-1：-串口初始化" class="headerlink" title="STEP 1： 串口初始化"></a>STEP 1： 串口初始化</h3><p><img src="/./%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE1_UART/uartInit.JPG" alt="uartInit"></p>
<h3 id="STEP-2：-main函数"><a href="#STEP-2：-main函数" class="headerlink" title="STEP 2： main函数"></a>STEP 2： main函数</h3><p><img src="/./%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE1_UART/UATRmain.JPG" alt="UATRmain"></p>
<h3 id="STEP-3：-收发函数封装"><a href="#STEP-3：-收发函数封装" class="headerlink" title="STEP 3： 收发函数封装"></a>STEP 3： 收发函数封装</h3><ul>
<li>发送数据：</li>
</ul>
<p><img src="/./%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE1_UART/uartSend.JPG" alt="uartSend"></p>
<ul>
<li>接收数据：</li>
</ul>
<p><img src="/./%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE1_UART/uartRec.JPG" alt="uartRec"></p>
<h3 id="STEP-4：-优化"><a href="#STEP-4：-优化" class="headerlink" title="STEP 4： 优化"></a>STEP 4： 优化</h3><blockquote>
<p>电脑 – &gt; 开发板， 然后开发板收到数据+1，再返回给电脑；</p>
</blockquote>
<p><img src="/./%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE1_UART/uartAdd1.JPG" alt="uartAdd1"></p>
<h2 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h2><blockquote>
<p>这种通过判断发送寄存器是不是空，来把数据放入UART的寄存器中，就是相当于printf重定向到UART串口，而其他操作系统中，是重定向到显卡或者磁盘；</p>
</blockquote>
<p>尝试写一个发送字符串的函数：</p>
<p><img src="/./%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE1_UART/uartSendStr.JPG" alt="uartSendStr"></p>
<p><img src="/./%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE1_UART/uartSend.JPG" alt="uartSend"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-08-29T07:02:05.000Z" title="8/29/2022, 7:02:05 AM">2022-08-29</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/NXP/">NXP</a></span><span class="level-item">28 分钟读完 (大约4195个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/NXP/ble%E7%9A%84%E5%88%86%E5%B1%82%E4%BB%8B%E7%BB%8D/">BLE的分层介绍</a></p><div class="content"><h1 id="深入浅出低功耗蓝牙-BLE-协议栈"><a href="#深入浅出低功耗蓝牙-BLE-协议栈" class="headerlink" title="深入浅出低功耗蓝牙(BLE)协议栈"></a>深入浅出低功耗蓝牙(BLE)协议栈</h1><blockquote>
<p>BLE协议栈为什么要分层？怎么理解BLE“连接”？如果BLE协议只有ATT层没有GATT层会发生什么？</p>
</blockquote>
<h2 id="1-协议栈框架"><a href="#1-协议栈框架" class="headerlink" title="1.协议栈框架"></a>1.协议栈框架</h2><p>一般而言，我们把某个协议的实现代码称为协议栈（protocol stack），BLE协议栈就是实现低功耗蓝牙协议的代码，理解和掌握BLE协议是实现BLE协议栈的前提。在深入BLE协议栈各个组成部分之前，我们先看一下BLE协议栈整体架构。</p>
<p>要实现一个BLE应用，首先需要一个支持BLE射频的芯片，然后还需要提供一个与此芯片配套的BLE协议栈，最后在协议栈上开发自己的应用。可以看出BLE协议栈是连接芯片和应用的桥梁，是实现整个BLE应用的关键。</p>
<p>那BLE协议栈具体包含哪些功能呢？简单来说，<strong>BLE协议栈主要用来对你的应用数据进行层层封包，以生成一个满足BLE协议的空中数据包，也就是说，把应用数据包裹在一系列的帧头（header）和帧尾（tail）中。具体来说，BLE协议栈主要由如下几部分组成：</strong></p>
<ul>
<li>PHY层（Physical layer物理层）。<strong>PHY层用来指定BLE所用的无线频段，调制解调方式和方法等</strong>。PHY层做得好不好，直接决定整个BLE芯片的功耗，灵敏度以及selectivity等射频指标。</li>
<li>LL层（Link Layer链路层）。LL层是整个BLE协议栈的核心，也是BLE协议栈的难点和重点。像Nordic的BLE协议栈能同时支持20个link（连接），就是LL层的功劳。LL层要做的事情非常多，比如<strong>具体选择哪个射频通道进行通信，怎么识别空中数据包，具体在哪个时间点把数据包发送出去，怎么保证数据的完整性，ACK如何接收，如何进行重传，以及如何对链路进行管理和控制等等。LL层只负责把数据发出去或者收回来，对数据进行怎样的解析则交给上面的GAP或者ATT</strong>。</li>
<li>HCI（Host controller interface）。HCI是可选的（具体请参考文章： <a target="_blank" rel="noopener" href="https://www.cnblogs.com/iini/p/8834970.html">三种蓝牙架构实现方案（蓝牙协议栈方案）</a>），<strong>HCI主要用于2颗芯片实现BLE协议栈的场合，用来规范两者之间的通信协议和通信命令等</strong>。</li>
<li>GAP层（Generic access profile）。GAP是对LL层payload（有效数据包）如何进行解析的两种方式中的一种，而且是最简单的那一种。GAP简单的对LL payload进行一些规范和定义，因此GAP能实现的功能极其有限。<strong>GAP目前主要用来进行广播，扫描和发起连接等</strong>。</li>
<li>L2CAP层（Logic link control and adaptation protocol）。L2CAP对LL进行了一次简单封装，<strong>LL只关心传输的数据本身，L2CAP就要区分是加密通道还是普通通道，同时还要对连接间隔进行管理</strong>。</li>
<li>SMP（Secure manager protocol）。SMP用来管理BLE连接的加密和安全的，如何保证连接的安全性，同时不影响用户的体验，这些都是SMP要考虑的工作。</li>
<li>ATT（Attribute protocol）。简单来说，<strong>ATT层用来定义用户命令及命令操作的数据，比如读取某个数据或者写某个数据</strong>。BLE协议栈中，<strong>开发者接触最多的就是ATT</strong>。BLE引入了attribute概念，用来描述一条一条的数据。Attribute除了定义数据，同时定义该数据可以使用的ATT命令，因此这一层被称为ATT层。</li>
<li>GATT（Generic attribute profile ）。<strong>GATT用来规范attribute中的数据内容，并运用group（分组）的概念对attribute进行分类管理。没有GATT，BLE协议栈也能跑，但互联互通就会出问题，也正是因为有了GATT和各种各样的应用profile，BLE摆脱了ZigBee等无线协议的兼容性困境，成了出货量最大的2.4G无线通信产品</strong>。</li>
</ul>
<p>我相信很多人看了上面的介绍，还是不懂BLE协议栈的工作原理，以及每一层具体干什么的，为什么要这么分层。下面我以如何发送一个数据包为例来讲解BLE协议栈各层是如何紧密配合，以完成发送任务的。</p>
<h2 id="2-如何通过无线发送一个数据包"><a href="#2-如何通过无线发送一个数据包" class="headerlink" title="2. 如何通过无线发送一个数据包"></a>2. 如何通过无线发送一个数据包</h2><p>假设有设备A和设备B，设备A要把自己目前的电量状态83%（十六进制表示为0x53）发给设备B，该怎么做呢？作为一个开发者，他希望越简单越好，对他而言，他希望调用一个简单的API就能完成这件事，比如<code>send(0x53)</code>，实际上我们的BLE协议栈就是这样设计的，开发者只需调用<code>send(0x53)</code>就可以把数据发送出去了，其余的事情BLE协议栈帮你搞定。很多人会想，BLE协议栈是不是直接在物理层就把0x53发出去?</p>
<p>这种方式初看起来挺美的，但由于很多细节没有考虑到，实际是不可行的。首先，它没有考虑用哪一个<strong>射频信道</strong>来进行传输，在不更改API的情况下，我们只能对协议栈进行分层，为此引入<strong>LL层</strong>，开发者还是调用<code>send(0x53)</code>，<code>send(0x53)</code>再调用<code>send_LL(0x53,2402M)</code>（注：2402M为信道频率）。这里还有一个问题，设备B怎么知道这个数据包是发给自己的还是其他人的，为此BLE引入<strong>access address</strong>概念，<strong>用来指明接收者身份</strong>，其中，<code>0x8E89BED6</code>这个access address比较特殊，它表示要发给周边所有设备，即<strong>广播</strong>。如果你要<strong>一对一的进行通信（BLE协议将其称为连接）</strong>，即设备A的数据包只能设备B接收，同样设备B的数据包只能设备A接收，那么就必须<strong>生成一个独特的随机access address以标识设备A和设备B两者之间的连接</strong>。</p>
<h3 id="2-1-广播方式"><a href="#2-1-广播方式" class="headerlink" title="2.1 广播方式"></a>2.1 广播方式</h3><p>我们先来看一下简单的广播情况，这种情况下，我们把设备A叫<strong>advertiser</strong>（广播者），设备B叫<strong>scanner</strong>或者<strong>observer</strong>（扫描者）。</p>
<p>广播状态下设备A的LL层API将变成<code>send_LL(0x53,2402M, 0x8E89BED6)</code>。由于设备B可以同时接收到很多设备的广播，因此数据包还必须包含设备A的<code>device address（0xE1022AAB753B）</code>以确认该广播包来自设备A，为此<code>send_LL</code>参数需要变成<code>(0x53,2402M, 0x8E89BED6, 0xE1022AAB753B)</code>。</p>
<p>LL层还要<strong>检查数据的完整性</strong>，即数据在传输过程中有没有发生窜改，为此引入<strong>CRC24</strong>对数据包进行检验 (假设为0xB2C78E) 。同时为了调制解调电路工作更高效，<em>每一个数据包的最前面会加上1个字节的preamble（前导帧）</em>，preamble一般为0x55或者0xAA。这样，整个空中包就变成（注：空中包用小端模式表示！）：??</p>
<p>上面这个数据包还有如下问题：</p>
<ul>
<li><strong>没有对数据包进行分类组织</strong>，设备B无法找到自己想要的数据0x53。为此我们需要在<code>access address</code>之后加入两个字段：<strong>LL header和长度字节</strong>。<ul>
<li>LL header用来表示数据包的LL类型，</li>
<li>长度字节用来指明payload的长度</li>
</ul>
</li>
<li>设备B什么时候开启射频窗口以接收空中数据包？当设备A的数据包在空中传输的时候，设备B把接收窗口关闭，此时通信将失败；当设备A没有在空中发送数据包时，设备B把接收窗口打开，此时通信也将失败。只有设备A的数据包在空中传输时，设备B正好打开射频接收窗口，此时通信才能成功，换句话说，<strong>LL层还必须定义通信时序</strong>。</li>
<li>当设备B拿到数据0x53后，该<strong>如何解析这个数据呢</strong>？它到底表示湿度还是电量，还是别的意思？<strong>这个就是GAP层要做的工作，GAP层引入了LTV（Length-Type-Value）结构来定义数据</strong>，比如020105，02-长度，01-类型（强制字段，表示广播flag，广播包必须包含该字段），05-值。由于广播包最大只能为31个字节，它能定义的数据类型极其有限，像这里说的电量，GAP就没有定义，因此要通过广播方式把电量数据发出去，<strong>只能使用供应商自定义数据类型0xFF，即04FF590053，其中04表示长度，FF表示数据类型（自定义数据），0x0059是供应商ID（自定义数据中的强制字段），0x53就是我们的数据(设备双方约定0x53就是表示电量，而不是其他意思)。</strong></li>
</ul>
<p>最终空中传输的数据包将变成：<code>AAD6BE898E600E3B75AB2A02E102010504FF5900538EC7B2</code></p>
<ul>
<li>AA – 前导帧(preamble)</li>
<li>D6BE898E – 访问地址(access address)</li>
<li>60 – LL帧头字段(LL header)</li>
<li>0E – 有效数据包长度(payload length)</li>
<li>3B75AB2A02E1 – 广播者设备地址(advertiser address)</li>
<li>02010504FF590053 – 广播数据</li>
<li>8EC7B2 – CRC24值</li>
</ul>
<p>有了PHY，LL和GAP，就可以发送广播包了，但广播包携带的信息极其有限，而且还有如下几大限制：</p>
<ul>
<li>无法进行一对一通信 （广播是一对多通信，而且是单方向的通信）</li>
<li>由于不支持组包和拆包，因此无法传输大数据</li>
<li>通信不可靠。广播信道不能太多，否则将导致扫描端效率低下。为此，BLE只使用37(2402MHz) /38(2426MHz) /39(2480MHz)三个信道进行广播和扫描，因此广播不支持跳频。由于广播是一对多的，所以广播也无法支持ACK。这些都使广播通信变得不可靠。</li>
<li>扫描端功耗高。由于扫描端不知道设备端何时广播，也不知道设备端选用哪个频道进行广播，扫描端只能拉长扫描窗口时间，并同时对37/38/39三个通道进行扫描，这样功耗就会比较高。</li>
</ul>
<p>而<strong>连接</strong>则可以很好解决上述问题，下面我们就来看看连接是如何将0x53发送出去的。</p>
<h3 id="2-2-连接方式"><a href="#2-2-连接方式" class="headerlink" title="2.2 连接方式"></a>2.2 连接方式</h3><p>到底什么叫连接(connection)？像有线UART，很容易理解，就是用线（Rx和Tx等）把设备A和设备B相连，即为连接。用“线”把两个设备相连，实际是让2个设备有共同的通信媒介，并让两者时钟同步起来。蓝牙连接有何尝不是这个道理，<strong>所谓设备A和设备B建立蓝牙连接，就是指设备A和设备B两者“同步”成功</strong>，其具体包含以下几方面：</p>
<ul>
<li>设备A和设备B对接下来要使用的<strong>物理信道</strong>达成一致</li>
<li>设备A和设备B双方<strong>建立一个共同的时间锚点</strong>，也就是说，把双方的时间原点变成同一个点</li>
<li>设备A和设备B两者<strong>时钟同步成功</strong>，即双方都知道对方什么时候发送数据包什么时候接收数据包</li>
<li>连接成功后，设备A和设备B通信流程如下所示：</li>
</ul>
<p>一旦设备A和设备B连接成功（此种情况下，我们把设备A称为Master或者Central，把设备B称为Slave或者Peripheral），<strong>设备A将周期性以CI（connection interval）为间隔向设备B发送数据包，而设备B也周期性地以CI为间隔打开射频接收窗口以接收设备A的数据包</strong>。</p>
<p>同时按照蓝牙spec要求，<strong>设备B收到设备A数据包<code>150us</code>后，设备B切换到发送状态，把自己的数据发给设备A；设备A则切换到接收状态，接收设备B发过来的数据</strong>。</p>
<p>由此可见，连接状态下，设备A和设备B的射频发送和接收窗口都是周期性地有计划地开和关，而且开的时间非常短，从而大大减低系统功耗并大大提高系统效率。</p>
<p>现在我们看看连接状态下是如何把数据0x53发送出去的，从中大家可以体会到蓝牙协议栈分层的妙处。</p>
<ul>
<li><p>对开发者来说，很简单，他只需要调用<code>send(0x53)</code></p>
</li>
<li><p>GATT层<strong>定义数据的类型和分组</strong>，方便起见，我们用0x0013表示电量这种数据类型，这样GATT层把数据打包成130053（<em><strong>小端模式！</strong></em>）</p>
</li>
<li><p>ATT层用来<strong>选择具体的通信命令</strong>，比如读/写/notify/indicate等，这里选择notify命令0x1B，这样数据包变成了：<code>1B130053</code></p>
</li>
<li><p>L2CAP用来<strong>指定connection interval（连接间隔）</strong>，比如每10ms同步一次（CI不体现在数据包中），同时<strong>指定逻辑通道编号</strong>0004（表示ATT命令），最后把ATT数据长度0x0004加在包头，这样数据就变为：040004001B130053</p>
</li>
<li><p>LL层要做的工作很多，首先LL层需要<strong>指定用哪个物理信道进行传输</strong>（物理信道不体现在数据包中），然后再给此连接<strong>分配一个Access address</strong>（0x50655DAB）以标识此连接只为设备A和设备B直连服务，然后加上<code>LL header</code>和<code>payload length</code>字段，LL header标识此packet为数据packet，而不是control packet等，payload length为整个L2CAP字段的长度，最后加上CRC24字段，以保证整个packet的数据完整性，所以数据包最后变成：<code>AAAB5D65501E08040004001B130053D550F6</code></p>
</li>
<li><p>AA – 前导帧(preamble)</p>
</li>
<li><p>0x50655DAB – 访问地址(access address)</p>
</li>
<li><p>1E – LL帧头字段(LL header)</p>
</li>
<li><p>08 – 有效数据包长度(payload length)</p>
</li>
<li><p>04000400 – ATT数据长度，以及L2CAP通道编号</p>
</li>
<li><p>1B – notify command</p>
</li>
<li><p>0x0013 – 电量数据handle</p>
</li>
<li><p>0x53 – 真正要发送的电量数据</p>
</li>
<li><p>0xF650D5 – CRC24值</p>
</li>
</ul>
<p>虽然开发者只调用了 <code>send(0x53)</code>，但由于低功耗蓝牙协议栈层层打包，最后空中实际传输的数据将变成上面所示的模样，这就既满足了低功耗蓝牙通信的需求，又让用户API变得简单，可谓一箭双雕！</p>
<p>上面只是对BLE协议栈实现原理做了一个简单概述，即便如此，由于都是关于BLE协议栈底层的东西，很多开发者还是会觉得比较枯燥和晦涩，而且对很多开发者来说，他们也不关心BLE协议栈是如何实现的，他们更关心的是BLE协议栈的使用，即怎么开发一个BLE应用。BLE应用是实打实的东西，不能像上面讲述协议栈一样泛泛而谈，必须结合具体的蓝牙芯片和蓝牙协议栈来讲解，为此后面将以Nordic芯片及协议栈作为范例，来具体讲解如何开发BLE应用，以及如何通过代码去理解BLE协议中定义的一些概念和术语。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-08-02T05:55:05.000Z" title="8/2/2022, 5:55:05 AM">2022-08-02</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/NXP/">NXP</a></span><span class="level-item">10 分钟读完 (大约1563个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/NXP/thread%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/">Thread协议基础</a></p><div class="content"><h2 id="General-Thread-introduction"><a href="#General-Thread-introduction" class="headerlink" title="General Thread introduction"></a>General Thread introduction</h2><h3 id="1-1-家用无线网络的要求"><a href="#1-1-家用无线网络的要求" class="headerlink" title="1.1 家用无线网络的要求"></a>1.1 家用无线网络的要求</h3><p>✔低功耗</p>
<p>✔弹性（网状）</p>
<p>✔基于IP</p>
<p>✔开放协议</p>
<p>✔安全和用户友好</p>
<p>✔快速上市</p>
<p>✔现有无线电芯片</p>
<h4 id="关于弹性组网：-Resilient-mesh"><a href="#关于弹性组网：-Resilient-mesh" class="headerlink" title="关于弹性组网： Resilient (mesh)"></a>关于弹性组网： Resilient (mesh)</h4><ul>
<li>No single point of failure 无单点故障</li>
<li>Self-healing 自我修复</li>
<li>Interference robustness 干扰鲁棒性</li>
<li>Self-extending 自我扩展</li>
<li>Reliable enough for critical infrastructure 足够可靠，适用于关键基础设施</li>
</ul>
<h3 id="1-2-What-is-THREAD-？"><a href="#1-2-What-is-THREAD-？" class="headerlink" title="1.2 What is THREAD ？"></a>1.2 What is THREAD ？</h3><ul>
<li>为家庭及其连接产品提供安全的无线网状网络</li>
<li>基于久经考验的现有技术构建<ul>
<li>在现有 802.15.4 芯片上运行</li>
<li>使用 6LoWPAN 和 IPv6 寻址</li>
<li>UDP Transport</li>
</ul>
</li>
<li>新的强制性安全体系结构</li>
<li>添加/删除产品简单且安全</li>
<li>可扩展到每个网络 250 多个产品</li>
<li>设计用于超低功耗操作</li>
<li>适用于关键基础设施</li>
</ul>
<img src="/NXP/thread%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/thread.PNG" class="" title="thread">

<h3 id="1-3-THREAD-target-applocations"><a href="#1-3-THREAD-target-applocations" class="headerlink" title="1.3 THREAD target applocations"></a>1.3 THREAD target applocations</h3><p>Thread专为家庭中的各种产品而设计</p>
<ul>
<li>Appliances</li>
<li>Access control</li>
<li>Climate control</li>
<li>Energy management</li>
<li>Lighting</li>
<li>Safety</li>
<li>Security</li>
</ul>
<h2 id="Thread-networking-architecture"><a href="#Thread-networking-architecture" class="headerlink" title="Thread networking architecture"></a>Thread networking architecture</h2><h3 id="2-1-网络拓扑"><a href="#2-1-网络拓扑" class="headerlink" title="2.1 网络拓扑"></a>2.1 网络拓扑</h3><p><em>Many</em> <strong>Border Router</strong> +</p>
<p><em>One</em> <strong>Thread Leader</strong> +</p>
<p><em>Up to 31</em> <strong>Thread Active Router</strong> +</p>
<p><em>Up to 512 per Active Router</em> <strong>End Device</strong> =</p>
<p><strong>Thousands of Devices Per Network (16K)</strong></p>
<p><img src="/./Thread/Border%20Router.PNG" alt="Border Router"></p>
<p><img src="/./Thread/Thread%20Leader.PNG" alt="Thread Leader"></p>
<p><img src="/./Thread/Thread%20Active%20Router.PNG" alt="Thread Active Router"></p>
<p><img src="/./Thread/End%20Device.PNG" alt="End Device"></p>
<p>可路由设备：</p>
<ul>
<li>Active Router : 当网络的连接性相对有限时，REED 请求领导者使其成为活动路由器。 例如：当现有活动路由器的总数小于 &lt; 16</li>
<li>Router Eligible End Device (REED) : 在最初通过现有的Active Routers加入网络后，或在网络有足够的连接性时，立即加入网络。</li>
<li>Leader : 如果它是网络分区中的初始设备，或者当当前的领导者不可用时;</li>
</ul>
<p><strong>The Border Router</strong> :</p>
<ul>
<li>Usually is a subset of Router Eligible Device</li>
<li>Has at least one more different interface than IEEE 802.15.4 (e.g.: Wi-Fi, Ethernet,  USB)</li>
<li>Facilitates IP packet forwarding to and from the Thread network to home LAN or upstream IP infrastructure</li>
<li>Can be a specialized networking device:<ul>
<li>wireless access point</li>
<li>home gateway</li>
</ul>
</li>
<li>Or can be embedded in a consumer product:<ul>
<li>thermostat</li>
<li>appliance</li>
</ul>
</li>
</ul>
<p><img src="/./Thread/Border%20Router2.PNG" alt="Board Router2"></p>
<h3 id="2-2-flexible-network"><a href="#2-2-flexible-network" class="headerlink" title="2.2 flexible network"></a>2.2 flexible network</h3><ul>
<li>Devices join as <em>Router Eligible End Devices</em> or <em>End Devices</em>;</li>
<li>REED 可以成为一个<em>Router</em>，如果<em>Leader</em>确定需要更好的覆盖范围；</li>
<li>所有<em>Router</em>通过<em>Trickle</em>机制和<em>MLE</em>向所有其他路由器保持状态；</li>
<li>所有<em>Router</em>通过<em>Trickle</em>机制和<em>MLE</em>维持<em>Border Router</em>的状态；</li>
<li>Sleeping End Devices route through parent Router</li>
<li>Router Eligible Devices can also maintain state</li>
<li><em>Leader</em> used to make decisions within network；</li>
</ul>
<h3 id="2-3-No-single-point-of-failure-无单点故障"><a href="#2-3-No-single-point-of-failure-无单点故障" class="headerlink" title="2.3 No single point of failure 无单点故障"></a>2.3 No single point of failure 无单点故障</h3><ul>
<li>不需要识别网络中的专门设备；</li>
<li><em>Leader</em>作出决定，但一旦失败，另一个<em>Router</em>将成为<em>Leader</em></li>
<li>网络将在需要时增加<em>Active Routers</em>以改善连接性。</li>
</ul>
<h3 id="2-4-Low-Power-End-Devices"><a href="#2-4-Low-Power-End-Devices" class="headerlink" title="2.4 Low-Power End Devices"></a>2.4 Low-Power End Devices</h3><ul>
<li>睡眠设备轮询父母的信息（或远程设备，如果应用程序已配置）</li>
<li>睡眠设备不需要与父母设备check in，从而实现低功耗操作</li>
<li>父母为睡眠设备<strong>保留信息</strong></li>
<li>睡眠设备在失去连接时自动切换parent</li>
</ul>
<h2 id="Thread-IP-addressing-architecture"><a href="#Thread-IP-addressing-architecture" class="headerlink" title="Thread IP addressing architecture"></a>Thread IP addressing architecture</h2><h3 id="3-1-IP地址分配"><a href="#3-1-IP地址分配" class="headerlink" title="3.1 IP地址分配"></a>3.1 IP地址分配</h3><ul>
<li>IP Addresses are assigned at the border between the IP layer and each specific Media Interface below the IP stack（IP地址是在IP层和IP堆栈下面的每个特定媒体接口之间的边界上分配的）</li>
<li>Multiple IP address can be assigned to the same Media Interface（多个IP地址可以分配给同一个媒体接口）</li>
<li>The same address can be assigned to the multiple Media Interfaces on the same device or on different devices（同一个地址可以分配给同一个设备上的多个媒体接口，也可以分配给不同设备上的多个媒体接口。）</li>
</ul>
<h3 id="3-2-IPV6地址符号基础"><a href="#3-2-IPV6地址符号基础" class="headerlink" title="3.2 IPV6地址符号基础"></a>3.2 IPV6地址符号基础</h3><ul>
<li>An IPv6 address has <strong>16 bytes (128 bits)</strong>, represented as eight 2-byte groups:<ul>
<li><code>2001:3344:5566:7788:99AA:BBCC:DDEE:0000</code></li>
</ul>
</li>
<li>All <code>0000</code> groups can be represented as a single <code>0</code></li>
<li>每个group开头的0可以省略</li>
<li>所有0组的最长连续集合可表示为2个冒号:<ul>
<li><code>2001:0044:0000:0000:0000:BBCC:00EE:0000</code> is equivalent to <code>2001:44::BBCC:EE:0</code></li>
</ul>
</li>
<li>Addresses 分为 <em>Network Prefix</em> and <em>Network Address</em> 网络前缀和网络地址:</li>
<li>Representing the length  of the network prefix can be done with a <code>/prefixlen notation</code><ul>
<li><code>2001:3344:5566:7788:99AA:BBCC:DDEE:FF00/64</code></li>
</ul>
</li>
</ul>
<h3 id="3-3-IPV6-ADDRESS-CLASSES"><a href="#3-3-IPV6-ADDRESS-CLASSES" class="headerlink" title="3.3 IPV6 ADDRESS CLASSES"></a>3.3 IPV6 ADDRESS CLASSES</h3><ul>
<li><strong>Unicast</strong> –Identifies a single Media Interface on a single network host(识别单一网络主机上的单一媒体接口):<ul>
<li>Network Prefix: 64 bits</li>
<li>Network Address = Interface Identifier (IID): 64 bits</li>
</ul>
</li>
<li><strong>Multicast</strong>–Identifies all network hosts which have assigned a multicast group to one or more Media Interfaces(识别已将multicast group分配给一个或多个媒体接口的所有network hosts)<ul>
<li>Multicast Prefix: 8 bits all 1s (multicast address format FF::)</li>
<li>Flags: 4 bits</li>
<li>Scope: 4 bits</li>
<li>Multicast Group: 112 bits</li>
</ul>
</li>
<li><strong>Anycast</strong>–Identifies a unicast-like address assigned to multiple interfaces where the final destination of packets can be any of the nodes using the address(标识分配给多个接口的类似单播的地址，其中数据包的最终目的地可以是使用该地址的任何节点)</li>
</ul>
<h3 id="3-4-HOW-MANY-ADDRESSES-DOES-A-THREAD-DEVICE-GET"><a href="#3-4-HOW-MANY-ADDRESSES-DOES-A-THREAD-DEVICE-GET" class="headerlink" title="3.4 HOW MANY ADDRESSES DOES A THREAD DEVICE GET?"></a>3.4 HOW MANY ADDRESSES DOES A THREAD DEVICE GET?</h3><p>Once joined to a network, a Thread  device will get:</p>
<ul>
<li>At least 3 Unicast IPv6 addresses to the Thread Interface:<ul>
<li>Link local address (LL64): </li>
<li>Mesh local address (ML16, RLOC): </li>
<li>Mesh local address (ML64, ML-EID):</li>
</ul>
</li>
<li>Two All Thread Nodes multicast addresses:<ul>
<li>Link local all Thread  Nodes(Multicast):</li>
<li>Realm  local all Thread  Nodes(Multicast):</li>
</ul>
</li>
<li>Optional  will  also get:<ul>
<li>Unique  local address (ULA):</li>
<li>Global  unique  address (GUA):</li>
</ul>
</li>
</ul>
<h3 id="3-5-THREAD-SCOPES"><a href="#3-5-THREAD-SCOPES" class="headerlink" title="3.5 THREAD SCOPES"></a>3.5 THREAD SCOPES</h3><ul>
<li><strong>SCOPES</strong>在使用和转发地址的数据包时指定网络的边界;</li>
<li><strong>Link Local</strong> single-hop within radio range</li>
<li><strong>Mesh Local</strong> multi-hop within the PAN</li>
<li><strong>Unique Local</strong> multi-hop within the PAN and inter-PAN for the same network</li>
<li><strong>Global</strong> internet addressable</li>
</ul>
<h4 id="UNICAST-LINK-LOCAL-ADDRESS-LL64"><a href="#UNICAST-LINK-LOCAL-ADDRESS-LL64" class="headerlink" title="UNICAST LINK LOCAL ADDRESS LL64"></a>UNICAST LINK LOCAL ADDRESS LL64</h4><ul>
<li>允许在IEEE802.15.4无线电范围内的<strong>直接邻居之间</strong>进行通信，换句话说，就是那些相距一跳的链接。</li>
<li>LL64接口标识符被设置为MAC扩展地址（$thr get randomaddr），universal/local bit被颠倒。</li>
</ul>
<h4 id="UNICAST-MESH-LOCAL-ADDRESS-ML16"><a href="#UNICAST-MESH-LOCAL-ADDRESS-ML16" class="headerlink" title="UNICAST MESH LOCAL ADDRESS ML16"></a>UNICAST MESH LOCAL ADDRESS ML16</h4><ul>
<li>到达 Thread 网络中的任何设备，供 Thread 堆栈内部使用。</li>
<li>RLOC 嵌入了Router ID（分配了leader）和Child ID（分配了路由器）</li>
<li>每当 Thread Network 分区拓扑发生变化时，ML16 都会发生变化</li>
</ul>
<h4 id="UNICAST-MESH-LOCAL-ADDRESS"><a href="#UNICAST-MESH-LOCAL-ADDRESS" class="headerlink" title="UNICAST MESH LOCAL ADDRESS"></a>UNICAST MESH LOCAL ADDRESS</h4><ul>
<li>到达 Thread 网络中的任何节点</li>
<li>强烈推荐application使用</li>
<li>Mesh Local Endpoint Identifier (ML-EID)由 Thread Stack 随机生成，并在重启后保持不变</li>
</ul>
<h4 id="Multicast"><a href="#Multicast" class="headerlink" title="Multicast"></a>Multicast</h4><p><strong>Link local all Thread nodes</strong></p>
<p>执行Multicast而不重试数据包，消息包将只被IEEE 802.15.4无线电范围内的邻居接收。</p>
<p><strong>Realm local all Thread nodes</strong></p>
<ul>
<li>数据包可以到达网络的每个节点，<em>只要节点距离请求者最多 2 个“跳”</em></li>
<li>每次到达路由器时，数据包都会被转发 3 次。</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-07-28T06:21:11.000Z" title="7/28/2022, 6:21:11 AM">2022-07-28</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/NXP/">NXP</a></span><span class="level-item">7 分钟读完 (大约1086个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/NXP/rom-ram-flash%E5%82%BB%E5%82%BB%E5%88%86%E4%B8%8D%E6%B8%85%E6%A5%9A/">ROM_RAM_FLASH傻傻分不清楚</a></p><div class="content"><h2 id="ROM-Read-Only-Memory-程序存储器"><a href="#ROM-Read-Only-Memory-程序存储器" class="headerlink" title="ROM (Read Only Memory)程序存储器"></a>ROM (Read Only Memory)程序存储器</h2><p>是一种只能读出<strong>事先所存的数据</strong>的固态半导体存储器。ROM中所存数据稳定，<strong>一旦存储数据就再也无法将之改变或者删除，断电后所存数据也不会消失</strong>。其结构简单，因而<strong>常用于存储各种固化程序和数据</strong>。</p>
<p>在单片机中<strong>用来存储程序数据及常量数据或变量数据，凡是c文件及h文件中所有代码、全局变量、局部变量、‘const’限定符定义的常量数据、startup.asm文件中的代码（类似ARM中的bootloader或者X86中的BIOS，一些低端的单片机是没有这个的）通通都存储在ROM中</strong>。</p>
<p>为了便于使用和大批量生产，进一步发展出了可编程只读存储器（PROM）、可擦除可编程只读存储器（EPROM）。EPROM需要用紫外线长时间照射才能擦除，使用很不方便。1980s又出现了电可擦除可编程只读存储器（EEPROM），它克服了EPROM的不足，但是集成度不高、价格较贵。于是又发展出了一种新型的存储单元结构同EPROM类似的快闪存储器（FLASH MEMORY）。FLASH集成度高、功耗低、体积小，又能在线快速擦除，因而获得了快速发展。</p>
<h2 id="FLASH-存储器"><a href="#FLASH-存储器" class="headerlink" title="FLASH 存储器"></a>FLASH 存储器</h2><p>Flash 存储器（FLASH EEPROM）又称<strong>闪存，快闪</strong>。它是EEPROM的一种。它结合了ROM和RAM的长处。不仅具备电子可擦除可编辑（EEPROM）的性能，还<strong>不会断电丢失数据同时可以快速读取数据</strong>。它于EEPROM的最大区别是，<strong>FLASH按扇区（block）操作，而EEPROM按照字节操作</strong>。FLASH的电路结构较简单，同样容量占芯片面积较小，成本自然比EEPROM低，因此适合用于做程序存储器。</p>
<h2 id="RAM-Random-Access-Memory-随机访问存储器"><a href="#RAM-Random-Access-Memory-随机访问存储器" class="headerlink" title="RAM (Random Access Memory)随机访问存储器"></a>RAM (Random Access Memory)随机访问存储器</h2><p>RAM又称<strong>随机存取存储器</strong>，存储单元的内容<strong>可按照需要随机取出或存入，且存取的速度与存储单元的位置无关。这种存储器在断电时，将丢失其存储内容，所以主要用于存储短时间使用的程序</strong>。</p>
<p>它主要用来存储程序中用到的变量。<strong>凡是整个程序中，所用到的需要被改写的量（包括全局变量、局部变量、堆栈段等），都存储在RAM中</strong>。</p>
<h2 id="ROM-FLASH和RAM的区别"><a href="#ROM-FLASH和RAM的区别" class="headerlink" title="ROM, FLASH和RAM的区别"></a>ROM, FLASH和RAM的区别</h2><p>对于RAM, ROM以及FLASH的区别，简单地说，在计算机中，<strong>RAM 、ROM都是数据存储器。RAM 是随机存取存储器，它的特点是易挥发性，即掉电失忆。ROM 通常指固化存储器(一次写入，反复读取)，它的特点与RAM 相反。ROM又分一次性固化、光擦除和电擦除重写两种类型。</strong></p>
<p>在应用中，<strong>常规上ROM是用来存储固化程序的，RAM是用来存放数据的。</strong>由于<strong>FLASH ROM比普通的ROM读写速度快，擦写方便，一般用来存储用户程序和需要永久保存的数据。</strong></p>
<p>譬如说，现在家用的电子式电度表，它的内核是一款单片机，该单片机的程序就是存放在ROM里的。电度表在工作过程中，是要运算数据的，要采集电压和电流，并根据电压和电流计算出电度来。电压和电流是一个实时的数据，用户不关心，它只是用来计算电度用，计算完后该次采集的数据就用完了，然后再采集下一次，因此这些值就没必要永久存储，就把它放在RAM里边。<strong>然而计算完的电度，是需要永久保存的，单片机会定时或者在停电的瞬间将电度数存入到FLASH里</strong>。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-07-28T06:19:05.000Z" title="7/28/2022, 6:19:05 AM">2022-07-28</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/NXP/">NXP</a></span><span class="level-item">18 分钟读完 (大约2732个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/NXP/zigbeepro-fundamentals-training/">ZigBeePRO-Fundamentals_Training</a></p><div class="content"><h1 id="1-ZigBeePRO-Fundamentals-Training"><a href="#1-ZigBeePRO-Fundamentals-Training" class="headerlink" title="1_ZigBeePRO-Fundamentals_Training"></a>1_ZigBeePRO-Fundamentals_Training</h1><h2 id="0-Agend"><a href="#0-Agend" class="headerlink" title="0 Agend"></a>0 Agend</h2><ul>
<li>Zigbee Basics</li>
<li>Zigbee Architecture</li>
<li>ZigBee PRO Networks</li>
<li>ZigBee Profiles, Devices and Clusters</li>
<li>Network Commissioning</li>
<li>Network Security</li>
</ul>
<h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><ul>
<li>低功耗：将传输范围限制在0-10m line-of-sight.</li>
<li>ZigBee 通常用于需要较长电池寿命和安全网络的<strong>低数据速率</strong>应用。</li>
<li>ZigBee 的定义速率为 250 Kbit/s，最适合来自传感器或输入设备的间歇性数据传输intermittent data transmissions</li>
<li>10 kbps to 115 kbps data throughput </li>
<li>10 to 75 m coverage range</li>
</ul>
<ul>
<li>Up to 100 collocated networks</li>
</ul>
<ul>
<li>Up to 2 years of battery life on standard alkaline  batteries</li>
</ul>
<h2 id="1-Basic"><a href="#1-Basic" class="headerlink" title="1. Basic"></a>1. Basic</h2><h3 id="1-1-ZigBee的理想应用"><a href="#1-1-ZigBee的理想应用" class="headerlink" title="1.1 ZigBee的理想应用"></a>1.1 ZigBee的理想应用</h3><ul>
<li>点对点cable  replacement（例如，无线鼠标、遥控器、玩具） </li>
<li>安全系统（例如，火灾和入侵者）</li>
<li>环境控制（例如，供暖和空调）</li>
<li>医院病人监控</li>
<li>照明控制</li>
<li>家庭自动化（例如，家庭娱乐、门、大门、窗帘和百叶窗）</li>
<li>自动抄表 (AMR)</li>
<li>工业自动化（例如，工厂监控）</li>
</ul>
<p><img src="/./ZigBee/different.PNG" alt="different"></p>
<h2 id="2-Architecture"><a href="#2-Architecture" class="headerlink" title="2. Architecture"></a>2. Architecture</h2><h3 id="2-1-适用于-ZigBee-堆栈的-OSI-模型"><a href="#2-1-适用于-ZigBee-堆栈的-OSI-模型" class="headerlink" title="2.1 适用于 ZigBee 堆栈的 OSI 模型"></a>2.1 适用于 ZigBee 堆栈的 OSI 模型</h3><p><img src="/./ZigBee/OSI.PNG" alt="OSI"></p>
<h3 id="2-2-软件架构"><a href="#2-2-软件架构" class="headerlink" title="2.2 软件架构"></a>2.2 软件架构</h3><p><img src="/./ZigBee/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84.jpg" alt="软件架构"></p>
<h2 id="3-ZigBee-Pro-Networks"><a href="#3-ZigBee-Pro-Networks" class="headerlink" title="3. ZigBee Pro Networks"></a>3. ZigBee Pro Networks</h2><h3 id="3-1-网络节点"><a href="#3-1-网络节点" class="headerlink" title="3.1 网络节点"></a>3.1 网络节点</h3><ul>
<li>Coordinator ：<ul>
<li>每个网络都必须有一个Co-ordinator；</li>
<li>开启整个网络；</li>
<li>允许子节点通过它加入网络；</li>
<li>能作为父节点，允许有children Coordinator；</li>
</ul>
</li>
<li>Router ： <ul>
<li>网络可以有多个router；</li>
<li>router有路由能力；</li>
<li>允许其他节点通过它加入网络；</li>
<li>能作为parent，也能作为child；</li>
</ul>
</li>
<li>End Device ： <ul>
<li>网络可以有很多终端设备；</li>
<li>只有收发数据的能力；</li>
<li>不能做parents，不能有child；</li>
</ul>
</li>
</ul>
<h3 id="3-2-Network-Identity"><a href="#3-2-Network-Identity" class="headerlink" title="3.2 Network Identity"></a>3.2 Network Identity</h3><ul>
<li>PAN ID<ul>
<li>16位的值，叫做PAN ID （Personal Area Network Identifier).</li>
<li>网络运行时，由Cooridnator随机选择；</li>
<li>新安装的网络生成的PAN ID可能与同一radio channel同一neighborhood的已有的网络存在冲突；</li>
</ul>
</li>
<li>Extended PAN ID： 64位的值，叫做EPID；</li>
</ul>
<h3 id="3-2-Network-Addressing"><a href="#3-2-Network-Addressing" class="headerlink" title="3.2 Network Addressing"></a>3.2 Network Addressing</h3><ul>
<li>IEEE (MAC) 地址：<ul>
<li>这是一个 64 位地址，由 IEEE 分配，唯一标识设备</li>
<li>在 ZigBee 网络中，有时称为“extended”地址。</li>
</ul>
</li>
<li>网络地址：<ul>
<li>此16位地址标识网络中的节点</li>
<li>有时称为“short”地址。</li>
<li>当节点首次加入网络时，由父节点动态分配为随机 16 位值。</li>
</ul>
</li>
<li>协调器始终拥有网络地址 0x0000</li>
</ul>
<h3 id="3-3-NerghborTables"><a href="#3-3-NerghborTables" class="headerlink" title="3.3 NerghborTables"></a>3.3 NerghborTables</h3><blockquote>
<p>路由节点（Router 或 Coordinator）保存有关其相邻节点的信息，该信息存储在 Neighbor 表中，其中包含节点的直接子节点的条目.</p>
</blockquote>
<h3 id="3-4-网络创建的过程"><a href="#3-4-网络创建的过程" class="headerlink" title="3.4 网络创建的过程"></a>3.4 网络创建的过程</h3><ol>
<li>初始化IEEE 802.15.4 stack</li>
<li>创建PAN Coordinator</li>
<li>设置网络的PAN ID</li>
<li>设置PAN Coordinator的short地址；</li>
<li>选择radio frequency channel</li>
<li>start网络</li>
<li>加入其他设备</li>
<li>开始传输数据</li>
</ol>
<h3 id="3-5-Descriptors"><a href="#3-5-Descriptors" class="headerlink" title="3.5 Descriptors"></a>3.5 Descriptors</h3><ul>
<li>Node Descriptor<ul>
<li>类型（End Device, Router or Coordinator) </li>
<li>使用的频段（868 MHz、902 MHz 或 2400 MHHz）</li>
</ul>
</li>
<li>Node Power Descriptor<ul>
<li>Power mode</li>
<li>Available power sources</li>
</ul>
</li>
<li>Simple Descriptor<ul>
<li>The endpoint on which the application communicates</li>
<li>Lists of input and output clusters</li>
</ul>
</li>
</ul>
<h2 id="4-ZIGBEE-PROFILES-DEVICES-AND-CLUSTER"><a href="#4-ZIGBEE-PROFILES-DEVICES-AND-CLUSTER" class="headerlink" title="4. ZIGBEE PROFILES, DEVICES AND CLUSTER"></a>4. ZIGBEE PROFILES, DEVICES AND CLUSTER</h2><h3 id="4-1-ZigBee-Endpoints"><a href="#4-1-ZigBee-Endpoints" class="headerlink" title="4.1 ZigBee Endpoints"></a>4.1 ZigBee Endpoints</h3><ul>
<li>一个设备可以运行多个应用程序或同一应用程序的多个实例</li>
<li>endpoint是为应用程序实例提供通信端口的软件实体</li>
<li>endpoint number用于在向node发送消息时标识目标应用程序</li>
<li>256 个endpoints，编号0 到 255：<ul>
<li>0 保留给 ZDO（ZigBee Device Objects</li>
<li>1 到 240 可用于应用程序实例</li>
<li>241 到 254 保留，242 保留给 ZigBee Green Power</li>
<li>255 用于广播到所有应用程序实例</li>
</ul>
</li>
</ul>
<h3 id="4-2-Application-Profiles"><a href="#4-2-Application-Profiles" class="headerlink" title="4.2 Application Profiles"></a>4.2 Application Profiles</h3><ul>
<li>应用程序配置文件定义了一组设备，这些设备可以一起用于实现特定市场领域的应用程序——例如：<ul>
<li>照明系统的开/关 switch、调光开关和占用传感器用于光照系统；</li>
</ul>
</li>
<li>ZigBee 联盟定义了许多“公共”配置文件-例如：<ul>
<li>智能能源</li>
<li>家庭自动化</li>
</ul>
</li>
<li><strong>公共配置文件确保来自不同制造商的 ZigBee 设备的互操作性</strong> -例如：<ul>
<li>允许一个供应商的开关与另一个供应商的灯具（包含负载控制器）一起工作</li>
</ul>
</li>
<li>可互操作的产品必须经过测试和认证，以符合相关的 ZigBee 应用规范</li>
</ul>
<h3 id="4-3-Device-Types"><a href="#4-3-Device-Types" class="headerlink" title="4.3 Device Types"></a>4.3 Device Types</h3><ul>
<li>ZigBee 配置文件（例如家庭自动化）包含许多设备类型</li>
<li>设备类型是：<ul>
<li>对应于功能设备的软件实体（例如可调光）</li>
<li>在节点上作为具有相应端点的应用程序实施</li>
</ul>
</li>
<li>设备类型由许多功能“集群”支持：<ul>
<li>一些集群是强制性的（例如基本集群），一些是可选的</li>
<li>一些集群是特定于配置文件的</li>
<li>一些集群由配置文件共享并来自 ZigBee Cluster Library (ZCL)</li>
</ul>
</li>
<li>在设备结构中启用了所需的集群</li>
<li>可以在同一节点上实现多个设备类型（或同一设备类型的多个实例）</li>
</ul>
<h3 id="4-4-Clusters-and-Attributes"><a href="#4-4-Clusters-and-Attributes" class="headerlink" title="4.4 Clusters and Attributes"></a>4.4 Clusters and Attributes</h3><ul>
<li>集群是最小的功能构建块，对应于特定功能（例如开/关、可调光、恒温器</li>
<li>集群包含<strong>属性和用于与它们交互的命令</strong></li>
<li>属性是保存的<strong>数据实体</strong>（例如温度）在设备上并且可以在设备之间进行通信</li>
<li>例如，恒温器集群包含与以下相关的属性：<ul>
<li>当前温度</li>
<li>最低温度</li>
<li>最高温度</li>
</ul>
</li>
<li>ZigBee 联盟已经定义了标准集群：<ul>
<li>在 ZigBee Cluster Library(ZCL)中收集的一组常见集群</li>
<li>作为公共应用程序配置文件一部分的特定集群，例如智能能源</li>
</ul>
</li>
<li>一个集群有两种形式——<strong>客户端和服务端</strong>——存在于两个通信设备上</li>
</ul>
<h3 id="4-5-Cluster-Servers-and-Clients"><a href="#4-5-Cluster-Servers-and-Clients" class="headerlink" title="4.5 Cluster Servers and Clients"></a>4.5 Cluster Servers and Clients</h3><p>一个集群有两种形式，服务器和客户端：</p>
<ul>
<li>Cluster Server：<strong>用于存储属性并接收命令来操作它们</strong></li>
<li>Cluster Client：用于通过<strong>发送命令</strong>来操作相应集群server中的属性（通常是“写”命令设置属性值，“读”命令获取属性值）</li>
</ul>
<h2 id="5-NETWORK-COMMISSIONING"><a href="#5-NETWORK-COMMISSIONING" class="headerlink" title="5. NETWORK COMMISSIONING"></a>5. NETWORK COMMISSIONING</h2><h3 id="5-1-Service-Discovery-服务发现"><a href="#5-1-Service-Discovery-服务发现" class="headerlink" title="5.1 Service Discovery  服务发现"></a>5.1 Service Discovery  服务发现</h3><ul>
<li>允许加入设备找到与之操作的兼容节点（例如，调光开关可能需要找到可调光）</li>
<li>有关节点的信息保存在节点的“descriptors”中<ul>
<li>根据兼容的集群进行匹配</li>
<li>集群信息是保存在节点上的简单描述符中</li>
</ul>
</li>
<li>加入节点broadcast一个匹配描述符请求（Match Descriptor Request），列出感兴趣的集群</li>
<li>具有相关集群的节点单播unicast一个Match Descriptor Response，包含地址和端点信息<ul>
<li>加入节点可能会收到多个响应</li>
<li>加入节点上的应用程序，必须确定它将与哪个响应节点一起工作</li>
</ul>
</li>
</ul>
<p><img src="/./ZigBee/Service%20Discovery.PNG" alt="Service Discovery"></p>
<h3 id="5-2-Direct-Addressing-Grouping-and-Binding-直接寻址、分组和绑定"><a href="#5-2-Direct-Addressing-Grouping-and-Binding-直接寻址、分组和绑定" class="headerlink" title="5.2 Direct Addressing, Grouping and Binding 直接寻址、分组和绑定"></a>5.2 Direct Addressing, Grouping and Binding 直接寻址、分组和绑定</h3><p>节点可以通过直接寻址、分组或绑定与compatible node进行通信：</p>
<ul>
<li>Direct Addressing 涉及使用其地址向各个节点发送消息。</li>
<li>Grouping 涉及创建具有关联 16 位组地址的一组节点：<ul>
<li>Group Table保存在每个远程（目标）节点</li>
<li>此表包含节点所属组的组的地址</li>
<li>组的消息发送到相应的组地址</li>
<li>当一个group的消息已经receive，仅当组地址在表中时才接受此消息</li>
</ul>
</li>
<li>Binding 涉及创建一组预定义的链接或与远程节点的绑定：<ul>
<li>将本地端点（应用程序）与远程节点上的端点（应用程序）绑定</li>
<li>包含这些链路的绑定表保存在本地（源）节点上</li>
<li>来自本地端点的所有后续通信都自动发送到绑定的远程端点</li>
<li>可以本地或远程创建绑定</li>
</ul>
</li>
</ul>
<h3 id="5-3-Sending-Data-Packets-by-Direct-Addressing-通过直接寻址发送数据包"><a href="#5-3-Sending-Data-Packets-by-Direct-Addressing-通过直接寻址发送数据包" class="headerlink" title="5.3 Sending Data Packets by Direct Addressing 通过直接寻址发送数据包"></a>5.3 Sending Data Packets by Direct Addressing 通过直接寻址发送数据包</h3><p><img src="/./ZigBee/send.PNG" alt="send"></p>
<h3 id="5-4-Sending-Data-Packets-by-Group-Addressing-通过组寻址发送数据包"><a href="#5-4-Sending-Data-Packets-by-Group-Addressing-通过组寻址发送数据包" class="headerlink" title="5.4 Sending Data Packets by Group Addressing  通过组寻址发送数据包"></a>5.4 Sending Data Packets by Group Addressing  通过组寻址发送数据包</h3><p>要在group中包括node，必须使用“Add Group”命令将group address添加到node上的“Group Table”中。</p>
<h3 id="5-5-Local-and-Remote-Binding"><a href="#5-5-Local-and-Remote-Binding" class="headerlink" title="5.5 Local and Remote Binding"></a>5.5 Local and Remote Binding</h3><h4 id="Local-Binding"><a href="#Local-Binding" class="headerlink" title="Local Binding"></a>Local Binding</h4><p>Local device writes details of bound endpoint into its Binding Table.</p>
<p><img src="/./ZigBee/local.PNG" alt="local"></p>
<h4 id="Remote-Binding-Watch-Trap"><a href="#Remote-Binding-Watch-Trap" class="headerlink" title="Remote Binding(Watch,  Trap)"></a>Remote Binding(Watch,  Trap)</h4><p>Local device requests remote devices to write its details into their Binding Tables.</p>
<p><img src="/./ZigBee/remote.PNG" alt="remote"></p>
<h3 id="5-6-Sending-Data-Packets-to-Bound-Endpoints"><a href="#5-6-Sending-Data-Packets-to-Bound-Endpoints" class="headerlink" title="5.6 Sending Data Packets to Bound Endpoints"></a>5.6 Sending Data Packets to Bound Endpoints</h3><p><img src="/./ZigBee/send2.PNG" alt="send2"></p>
<h3 id="5-6-Attribute-Reporting"><a href="#5-6-Attribute-Reporting" class="headerlink" title="5.6 Attribute Reporting"></a>5.6 Attribute Reporting</h3><ul>
<li>一个节点可能需要向另一个节点发送regular/periodic报告。比如，一个开/关灯将其状态报告给Control Bridge（用于物联网）</li>
<li>属性报告涉及从集群服务器主动向客户端发送属性值（而不是客户端轮询polling服务器）： <ul>
<li>减少网络流量</li>
<li>允许休眠服务器报告唤醒时的属性值</li>
</ul>
</li>
<li>“属性报告”可以通过以下方式发出：<ul>
<li>通过用户应用程序中的函数调用（在服务器设备上）</li>
<li>由 ZCL 自动发出</li>
</ul>
</li>
<li>自动属性报告涉及两种机制：<ul>
<li>报告由属性值变化触发</li>
<li>定期为属性发布报告</li>
<li>这些机制可以同时运行</li>
</ul>
</li>
</ul>
<p>必须首先使用Configure Reporting命令配置属性报告。</p>
<h2 id="6-NETWORK-SECURITY"><a href="#6-NETWORK-SECURITY" class="headerlink" title="6. NETWORK SECURITY"></a>6. NETWORK SECURITY</h2><h2 id="6-1-Security-Schemes-安全方案"><a href="#6-1-Security-Schemes-安全方案" class="headerlink" title="6.1 Security Schemes 安全方案"></a>6.1 Security Schemes 安全方案</h2><p>安全措施由信任中心管理：</p>
<ul>
<li>Trust Center Policy 信任中心策略<ul>
<li>White Listing白名单：仅允许预定义的“友好”节点加入网络</li>
<li>Security Key Distribution安全密钥分发：生成和传输用于加密的密钥</li>
</ul>
</li>
<li>Encryption Schemes加密方案<ul>
<li>高度安全的基于 AES 的加密系统</li>
<li>128 位加密密钥</li>
<li>可应用于两个级别：<ul>
<li>Network Level网络级别：相同的“网络密钥”用于所有网络通信</li>
<li>Application Level应用级别（可选）：每对应用程序之间的唯一“Link key”</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-2-Network-Key-Provisioning"><a href="#6-2-Network-Key-Provisioning" class="headerlink" title="6.2 Network Key Provisioning"></a>6.2 Network Key Provisioning</h3><ul>
<li>下图说明了从Trust Centre到joining node的Network Key的提供。</li>
<li>该过程假定预配置的Link Key（全局或唯一）可用。</li>
<li>使用唯一link key，Trust Centre检查其是否具有与joining node的 MAC 地址相对应的密钥。</li>
</ul>
<p><img src="/./ZigBee/key.PNG" alt="key"></p>
<h3 id="6-3-Application-level-Security"><a href="#6-3-Application-level-Security" class="headerlink" title="6.3 Application-level Security"></a>6.3 Application-level Security</h3><ul>
<li>可以为一对节点设置</li>
<li>允许两个节点之间的专用通信，使用application link key进行加密/解密</li>
<li>link key是唯一的，一对节点独占的</li>
<li>link key由信任中心颁发：<ul>
<li>来自 TC 的一个请求节点链接密钥</li>
<li>TC 将密钥发送到两个节点</li>
<li>密钥的传输使用Network Key和TC和target node中间的link key加密（如果适用的话）</li>
</ul>
</li>
</ul>
<img src="/NXP/zigbeepro-fundamentals-training/Application-level.png" class="" title="Application-level">

<h3 id="6-4-Data-Encryption-Decryption-in-Stack"><a href="#6-4-Data-Encryption-Decryption-in-Stack" class="headerlink" title="6.4 Data Encryption/Decryption in Stack"></a>6.4 Data Encryption/Decryption in Stack</h3><img src="/NXP/zigbeepro-fundamentals-training/Encryption_Decryption.png" class="" title="Encryption_Decryption">


<h2 id="7-ZIGBEE-CERTIFICATION"><a href="#7-ZIGBEE-CERTIFICATION" class="headerlink" title="7. ZIGBEE CERTIFICATION"></a>7. ZIGBEE CERTIFICATION</h2><p>Zigbee 3.0</p>
<ul>
<li>完整的 loT solution — 从mesh network到允许智能对象协同工作的通用语言。</li>
<li>Zigbee增加了用户和开发人员的选择和灵活性;并让人们相信产品和服务将协同工作。</li>
<li>Zigbee服务于智能家居和商业建筑市场。</li>
</ul>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/tags/NXP/">上一页</a></div><div class="pagination-next is-invisible is-hidden-mobile"><a href="/tags/NXP/page/3/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/tags/NXP/">1</a></li><li><a class="pagination-link is-current" href="/tags/NXP/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.png" alt="Gavin"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Gavin</p><p class="is-size-6 is-block">Embedded &amp; IC Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shanghai, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">122</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">35</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">58</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/DustOfStars/" target="_blank" rel="me noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/DustOfStars/"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Configuration/"><span class="level-start"><span class="level-item">Configuration</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/IC%E9%AA%8C%E8%AF%81/"><span class="level-start"><span class="level-item">IC验证</span></span><span class="level-end"><span class="level-item tag">15</span></span></a><ul><li><a class="level is-mobile" href="/categories/IC%E9%AA%8C%E8%AF%81/%E8%B7%AF%E7%A7%91V0/"><span class="level-start"><span class="level-item">路科V0</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Leetcode/"><span class="level-start"><span class="level-item">Leetcode</span></span><span class="level-end"><span class="level-item tag">8</span></span></a><ul><li><a class="level is-mobile" href="/categories/Leetcode/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="level-start"><span class="level-item">数据结构</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/NLP/"><span class="level-start"><span class="level-item">NLP</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/NLP/EDA/"><span class="level-start"><span class="level-item">EDA</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/NLP/Numpy/"><span class="level-start"><span class="level-item">Numpy</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/NLP/Torch/"><span class="level-start"><span class="level-item">Torch</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/NLP/Torch/Model/"><span class="level-start"><span class="level-item">Model</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/NLP%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/"><span class="level-start"><span class="level-item">NLP代码详解</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/NXP/"><span class="level-start"><span class="level-item">NXP</span></span><span class="level-end"><span class="level-item tag">16</span></span></a><ul><li><a class="level is-mobile" href="/categories/NXP/KW38/"><span class="level-start"><span class="level-item">KW38</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/NXP/RT1050/"><span class="level-start"><span class="level-item">RT1050</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/NXP/RT1052/"><span class="level-start"><span class="level-item">RT1052</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/NXP/RT1052/%E9%87%8E%E7%81%AB/"><span class="level-start"><span class="level-item">野火</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/Plugins/"><span class="level-start"><span class="level-item">Plugins</span></span><span class="level-end"><span class="level-item tag">12</span></span></a><ul><li><a class="level is-mobile" href="/categories/Plugins/Analytics/"><span class="level-start"><span class="level-item">Analytics</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Plugins/Comment/"><span class="level-start"><span class="level-item">Comment</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Plugins/Donation/"><span class="level-start"><span class="level-item">Donation</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Plugins/Other/"><span class="level-start"><span class="level-item">Other</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Plugins/Search/"><span class="level-start"><span class="level-item">Search</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Plugins/Share/"><span class="level-start"><span class="level-item">Share</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ReferenceManual/"><span class="level-start"><span class="level-item">ReferenceManual</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/STL/"><span class="level-start"><span class="level-item">STL</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/STL/forward-list/"><span class="level-start"><span class="level-item">forward_list</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/STL/vector/"><span class="level-start"><span class="level-item">vector</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Widgets/"><span class="level-start"><span class="level-item">Widgets</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"><span class="level-start"><span class="level-item">嵌入式</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"><span class="level-start"><span class="level-item">代码解读</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/%E4%B8%AD%E6%96%AD/"><span class="level-start"><span class="level-item">中断</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">工具</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7/vim/"><span class="level-start"><span class="level-item">vim</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E5%AD%97IC/"><span class="level-start"><span class="level-item">数字IC</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%8B%B1%E8%AF%AD/"><span class="level-start"><span class="level-item">英语</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-11T06:11:12.000Z">2023-12-11</time></p><p class="title"><a href="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/">RT1050开发--第7节 RT1050 硬件启动模式</a></p><p class="categories"><a href="/categories/NXP/">NXP</a> / <a href="/categories/NXP/RT1050/">RT1050</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-11T05:37:29.000Z">2023-12-11</time></p><p class="title"><a href="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC6%E8%8A%82-rt1050-memory-mapping/">RT1050开发--第6节 RT1050 Memory Mapping</a></p><p class="categories"><a href="/categories/NXP/">NXP</a> / <a href="/categories/NXP/RT1050/">RT1050</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-05T14:28:25.000Z">2023-12-05</time></p><p class="title"><a href="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC5%E8%8A%82-rt1050-hello-world-%EF%BC%88keil-v5%EF%BC%89/">RT1050开发--第5节 RT1050 Hello World （Keil V5）</a></p><p class="categories"><a href="/categories/NXP/">NXP</a> / <a href="/categories/NXP/RT1050/">RT1050</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-04T14:33:36.000Z">2023-12-04</time></p><p class="title"><a href="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC4%E8%8A%82-rt1050%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">RT1050开发--第4节 RT1050开发环境搭建</a></p><p class="categories"><a href="/categories/NXP/">NXP</a> / <a href="/categories/NXP/RT1050/">RT1050</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-04T14:31:32.000Z">2023-12-04</time></p><p class="title"><a href="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC3%E8%8A%82-rt1050%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/">RT1050开发--第3节 RT1050硬件平台</a></p><p class="categories"><a href="/categories/NXP/">NXP</a> / <a href="/categories/NXP/RT1050/">RT1050</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/12/"><span class="level-start"><span class="level-item">十二月 2023</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/11/"><span class="level-start"><span class="level-item">十一月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/03/"><span class="level-start"><span class="level-item">三月 2023</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">十月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/09/"><span class="level-start"><span class="level-item">九月 2022</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/08/"><span class="level-start"><span class="level-item">八月 2022</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/07/"><span class="level-start"><span class="level-item">七月 2022</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">五月 2022</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">四月 2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">三月 2022</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/02/"><span class="level-start"><span class="level-item">二月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/01/"><span class="level-start"><span class="level-item">一月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/01/"><span class="level-start"><span class="level-item">一月 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/01/"><span class="level-start"><span class="level-item">一月 2017</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/01/"><span class="level-start"><span class="level-item">一月 2016</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/01/"><span class="level-start"><span class="level-item">一月 2015</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2014/01/"><span class="level-start"><span class="level-item">一月 2014</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2013/01/"><span class="level-start"><span class="level-item">一月 2013</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/ARM/"><span class="tag">ARM</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BLE/"><span class="tag">BLE</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BOARD/"><span class="tag">BOARD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Demo/"><span class="tag">Demo</span><span class="tag">19</span></a></div><div class="control"><a class="tags has-addons" href="/tags/FLASH/"><span class="tag">FLASH</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GPIO/"><span class="tag">GPIO</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GPIO%E4%B8%AD%E6%96%AD/"><span class="tag">GPIO中断</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Getting-Started/"><span class="tag">Getting Started</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/IC%E9%AA%8C%E8%AF%81/"><span class="tag">IC验证</span><span class="tag">15</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Icarus-User-Guide/"><span class="tag">Icarus User Guide</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/"><span class="tag">Icarus用户指南</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LED/"><span class="tag">LED</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Leetcode/"><span class="tag">Leetcode</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Model/"><span class="tag">Model</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NLP/"><span class="tag">NLP</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NXP/"><span class="tag">NXP</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Numpy/"><span class="tag">Numpy</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PDF/"><span class="tag">PDF</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RAM/"><span class="tag">RAM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ROM/"><span class="tag">ROM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RT1050/"><span class="tag">RT1050</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RT1052/"><span class="tag">RT1052</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ReferenceManual/"><span class="tag">ReferenceManual</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/STL/"><span class="tag">STL</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/System-Verilog/"><span class="tag">System Verilog</span><span class="tag">15</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Thread/"><span class="tag">Thread</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Torch/"><span class="tag">Torch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/UART/"><span class="tag">UART</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/UVM/"><span class="tag">UVM</span><span class="tag">15</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ZigBee/"><span class="tag">ZigBee</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pyTorch/"><span class="tag">pyTorch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vector/"><span class="tag">vector</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vim/"><span class="tag">vim</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"><span class="tag">二分查找</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"><span class="tag">代码解读</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"><span class="tag">代码随想录</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BD%8E%E5%8A%9F%E8%80%97%E8%AE%A1%E6%97%B6%E5%99%A8LPTMR/"><span class="tag">低功耗计时器LPTMR</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"><span class="tag">双指针</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%91%A8%E6%9C%9F%E4%B8%AD%E6%96%AD%E8%AE%A1%E6%97%B6%E5%99%A8PIT/"><span class="tag">周期中断计时器PIT</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9F%BA%E7%A1%80/"><span class="tag">基础</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AE%9E%E6%97%B6%E6%97%B6%E9%92%9FRTC/"><span class="tag">实时时钟RTC</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"><span class="tag">嵌入式</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B7%A5%E5%85%B7/"><span class="tag">工具</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%80%BB%E7%BB%93/"><span class="tag">总结</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E6%8E%A2%E7%B4%A2/"><span class="tag">数据探索</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E7%BB%84/"><span class="tag">数组</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/"><span class="tag">有序数组的平方</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"><span class="tag">滑动窗口</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"><span class="tag">移除元素</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD100%E5%8F%A5/"><span class="tag">考研英语100句</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%8B%B1%E8%AF%AD/"><span class="tag">英语</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%E2%85%A1/"><span class="tag">螺旋矩阵Ⅱ</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E6%97%B6%E5%99%A8PWM%E6%A8%A1%E5%9D%97TPM/"><span class="tag">计时器PWM模块TPM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B/"><span class="tag">设计流程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%93%BE%E8%A1%A8/"><span class="tag">链表</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"><span class="tag">长度最小的子数组</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="DustOfStars" height="28"></a><p class="is-size-7"><span>&copy; 2024 Gavin</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Discuss on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus/discussions"><i class="fas fa-comments"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>