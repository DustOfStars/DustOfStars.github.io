{"name":"LCDIF","description":"LCDIF Register Reference Index","groupName":"LCDIF","baseAddress":"0x402B8000","registers":[{"name":"CTRL","description":"LCDIF General Control Register","addressOffset":0,"size":32,"access":"read-write","resetValue":"0xC0000000","resetMask":"0xFFFFFFFF","fields":[{"name":"RUN","description":"When this bit is set by software, the LCDIF will begin transferring data between the SoC and the display","bitOffset":0,"bitWidth":1,"access":"read-write"},{"name":"DATA_FORMAT_24_BIT","description":"Used only when WORD_LENGTH = 3, i","bitOffset":1,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"ALL_24_BITS_VALID","description":"Data input to the block is in 24 bpp format, such that all RGB 888 data is contained in 24 bits.","value":0},{"name":"DROP_UPPER_2_BITS_PER_BYTE","description":"Data input to the block is actually RGB 18 bpp, but there is 1 color per byte, hence the upper 2 bits in each byte do not contain any useful data, and should be dropped.","value":1}]},{"name":"DATA_FORMAT_18_BIT","description":"Used only when WORD_LENGTH = 2, i.e. 18-bit.","bitOffset":2,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"LOWER_18_BITS_VALID","description":"Data input to the block is in 18 bpp format, such that lower 18 bits contain RGB 666 and upper 14 bits do not contain any useful data.","value":0},{"name":"UPPER_18_BITS_VALID","description":"Data input to the block is in 18 bpp format, such that upper 18 bits contain RGB 666 and lower 14 bits do not contain any useful data.","value":1}]},{"name":"DATA_FORMAT_16_BIT","description":"When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit data is in ARGB555 format","bitOffset":3,"bitWidth":1,"access":"read-write"},{"name":"MASTER","description":"Set this bit to make the LCDIF act as a bus master","bitOffset":5,"bitWidth":1,"access":"read-write"},{"name":"ENABLE_PXP_HANDSHAKE","description":"If this bit is set and LCDIF_MASTER bit is set, the LCDIF will act as bus master and the handshake mechanism between LCDIF and PXP will be turned on","bitOffset":6,"bitWidth":1,"access":"read-write"},{"name":"WORD_LENGTH","description":"Input data format.","bitOffset":8,"bitWidth":2,"access":"read-write","enumeratedValues":[{"name":"16_BIT","description":"Input data is 16 bits per pixel.","value":0},{"name":"8_BIT","description":"Input data is 8 bits wide.","value":1},{"name":"18_BIT","description":"Input data is 18 bits per pixel.","value":2},{"name":"24_BIT","description":"Input data is 24 bits per pixel.","value":3}]},{"name":"LCD_DATABUS_WIDTH","description":"LCD Data bus transfer width. When LUT enabled, this field should be set to 0x01.","bitOffset":10,"bitWidth":2,"access":"read-write","enumeratedValues":[{"name":"16_BIT","description":"16-bit data bus mode.","value":0},{"name":"8_BIT","description":"8-bit data bus mode.","value":1},{"name":"18_BIT","description":"18-bit data bus mode.","value":2},{"name":"24_BIT","description":"24-bit data bus mode.","value":3}]},{"name":"CSC_DATA_SWIZZLE","description":"This field specifies how to swap the bytes after the data has been converted into an internal representation of 24 bits per pixel and before it is transmitted over the LCD interface bus","bitOffset":12,"bitWidth":2,"access":"read-write","enumeratedValues":[{"name":"NO_SWAP","description":"No byte swapping.(Little endian)","value":0},{"name":"BIG_ENDIAN_SWAP","description":"Big Endian swap (swap bytes 0,3 and 1,2).","value":1},{"name":"HWD_SWAP","description":"Swap half-words.","value":2},{"name":"HWD_BYTE_SWAP","description":"Swap bytes within each half-word.","value":3}]},{"name":"INPUT_DATA_SWIZZLE","description":"This field specifies how to swap the bytes fetched by the bus master interface","bitOffset":14,"bitWidth":2,"access":"read-write","enumeratedValues":[{"name":"NO_SWAP","description":"No byte swapping.(Little endian)","value":0},{"name":"BIG_ENDIAN_SWAP","description":"Big Endian swap (swap bytes 0,3 and 1,2).","value":1},{"name":"HWD_SWAP","description":"Swap half-words.","value":2},{"name":"HWD_BYTE_SWAP","description":"Swap bytes within each half-word.","value":3}]},{"name":"DOTCLK_MODE","description":"Set this bit to 1 to make the hardware go into the DOTCLK mode, i","bitOffset":17,"bitWidth":1,"access":"read-write"},{"name":"BYPASS_COUNT","description":"When this bit is 0, it means that LCDIF will stop the block operation and turn off the RUN bit after the amount of data indicated by the LCDIF_TRANSFER_COUNT register has been transferred out","bitOffset":19,"bitWidth":1,"access":"read-write"},{"name":"SHIFT_NUM_BITS","description":"The data to be transmitted is shifted left or right by this number of bits.","bitOffset":21,"bitWidth":5,"access":"read-write"},{"name":"DATA_SHIFT_DIR","description":"Use this bit to determine the direction of shift of transmit data.","bitOffset":26,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"TXDATA_SHIFT_LEFT","description":"Data to be transmitted is shifted LEFT by SHIFT_NUM_BITS bits.","value":0},{"name":"TXDATA_SHIFT_RIGHT","description":"Data to be transmitted is shifted RIGHT by SHIFT_NUM_BITS bits.","value":1}]},{"name":"CLKGATE","description":"This bit must be set to zero for normal operation","bitOffset":30,"bitWidth":1,"access":"read-write"},{"name":"SFTRST","description":"This bit must be set to zero to enable normal operation of the LCDIF","bitOffset":31,"bitWidth":1,"access":"read-write"}]},{"name":"CTRL_SET","description":"LCDIF General Control Register","addressOffset":4,"size":32,"access":"read-write","resetValue":"0xC0000000","resetMask":"0xFFFFFFFF","fields":[{"name":"RUN","description":"When this bit is set by software, the LCDIF will begin transferring data between the SoC and the display","bitOffset":0,"bitWidth":1,"access":"read-write"},{"name":"DATA_FORMAT_24_BIT","description":"Used only when WORD_LENGTH = 3, i","bitOffset":1,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"ALL_24_BITS_VALID","description":"Data input to the block is in 24 bpp format, such that all RGB 888 data is contained in 24 bits.","value":0},{"name":"DROP_UPPER_2_BITS_PER_BYTE","description":"Data input to the block is actually RGB 18 bpp, but there is 1 color per byte, hence the upper 2 bits in each byte do not contain any useful data, and should be dropped.","value":1}]},{"name":"DATA_FORMAT_18_BIT","description":"Used only when WORD_LENGTH = 2, i.e. 18-bit.","bitOffset":2,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"LOWER_18_BITS_VALID","description":"Data input to the block is in 18 bpp format, such that lower 18 bits contain RGB 666 and upper 14 bits do not contain any useful data.","value":0},{"name":"UPPER_18_BITS_VALID","description":"Data input to the block is in 18 bpp format, such that upper 18 bits contain RGB 666 and lower 14 bits do not contain any useful data.","value":1}]},{"name":"DATA_FORMAT_16_BIT","description":"When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit data is in ARGB555 format","bitOffset":3,"bitWidth":1,"access":"read-write"},{"name":"MASTER","description":"Set this bit to make the LCDIF act as a bus master","bitOffset":5,"bitWidth":1,"access":"read-write"},{"name":"ENABLE_PXP_HANDSHAKE","description":"If this bit is set and LCDIF_MASTER bit is set, the LCDIF will act as bus master and the handshake mechanism between LCDIF and PXP will be turned on","bitOffset":6,"bitWidth":1,"access":"read-write"},{"name":"WORD_LENGTH","description":"Input data format.","bitOffset":8,"bitWidth":2,"access":"read-write","enumeratedValues":[{"name":"16_BIT","description":"Input data is 16 bits per pixel.","value":0},{"name":"8_BIT","description":"Input data is 8 bits wide.","value":1},{"name":"18_BIT","description":"Input data is 18 bits per pixel.","value":2},{"name":"24_BIT","description":"Input data is 24 bits per pixel.","value":3}]},{"name":"LCD_DATABUS_WIDTH","description":"LCD Data bus transfer width. When LUT enabled, this field should be set to 0x01.","bitOffset":10,"bitWidth":2,"access":"read-write","enumeratedValues":[{"name":"16_BIT","description":"16-bit data bus mode.","value":0},{"name":"8_BIT","description":"8-bit data bus mode.","value":1},{"name":"18_BIT","description":"18-bit data bus mode.","value":2},{"name":"24_BIT","description":"24-bit data bus mode.","value":3}]},{"name":"CSC_DATA_SWIZZLE","description":"This field specifies how to swap the bytes after the data has been converted into an internal representation of 24 bits per pixel and before it is transmitted over the LCD interface bus","bitOffset":12,"bitWidth":2,"access":"read-write","enumeratedValues":[{"name":"NO_SWAP","description":"No byte swapping.(Little endian)","value":0},{"name":"BIG_ENDIAN_SWAP","description":"Big Endian swap (swap bytes 0,3 and 1,2).","value":1},{"name":"HWD_SWAP","description":"Swap half-words.","value":2},{"name":"HWD_BYTE_SWAP","description":"Swap bytes within each half-word.","value":3}]},{"name":"INPUT_DATA_SWIZZLE","description":"This field specifies how to swap the bytes fetched by the bus master interface","bitOffset":14,"bitWidth":2,"access":"read-write","enumeratedValues":[{"name":"NO_SWAP","description":"No byte swapping.(Little endian)","value":0},{"name":"BIG_ENDIAN_SWAP","description":"Big Endian swap (swap bytes 0,3 and 1,2).","value":1},{"name":"HWD_SWAP","description":"Swap half-words.","value":2},{"name":"HWD_BYTE_SWAP","description":"Swap bytes within each half-word.","value":3}]},{"name":"DOTCLK_MODE","description":"Set this bit to 1 to make the hardware go into the DOTCLK mode, i","bitOffset":17,"bitWidth":1,"access":"read-write"},{"name":"BYPASS_COUNT","description":"When this bit is 0, it means that LCDIF will stop the block operation and turn off the RUN bit after the amount of data indicated by the LCDIF_TRANSFER_COUNT register has been transferred out","bitOffset":19,"bitWidth":1,"access":"read-write"},{"name":"SHIFT_NUM_BITS","description":"The data to be transmitted is shifted left or right by this number of bits.","bitOffset":21,"bitWidth":5,"access":"read-write"},{"name":"DATA_SHIFT_DIR","description":"Use this bit to determine the direction of shift of transmit data.","bitOffset":26,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"TXDATA_SHIFT_LEFT","description":"Data to be transmitted is shifted LEFT by SHIFT_NUM_BITS bits.","value":0},{"name":"TXDATA_SHIFT_RIGHT","description":"Data to be transmitted is shifted RIGHT by SHIFT_NUM_BITS bits.","value":1}]},{"name":"CLKGATE","description":"This bit must be set to zero for normal operation","bitOffset":30,"bitWidth":1,"access":"read-write"},{"name":"SFTRST","description":"This bit must be set to zero to enable normal operation of the LCDIF","bitOffset":31,"bitWidth":1,"access":"read-write"}]},{"name":"CTRL_CLR","description":"LCDIF General Control Register","addressOffset":8,"size":32,"access":"read-write","resetValue":"0xC0000000","resetMask":"0xFFFFFFFF","fields":[{"name":"RUN","description":"When this bit is set by software, the LCDIF will begin transferring data between the SoC and the display","bitOffset":0,"bitWidth":1,"access":"read-write"},{"name":"DATA_FORMAT_24_BIT","description":"Used only when WORD_LENGTH = 3, i","bitOffset":1,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"ALL_24_BITS_VALID","description":"Data input to the block is in 24 bpp format, such that all RGB 888 data is contained in 24 bits.","value":0},{"name":"DROP_UPPER_2_BITS_PER_BYTE","description":"Data input to the block is actually RGB 18 bpp, but there is 1 color per byte, hence the upper 2 bits in each byte do not contain any useful data, and should be dropped.","value":1}]},{"name":"DATA_FORMAT_18_BIT","description":"Used only when WORD_LENGTH = 2, i.e. 18-bit.","bitOffset":2,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"LOWER_18_BITS_VALID","description":"Data input to the block is in 18 bpp format, such that lower 18 bits contain RGB 666 and upper 14 bits do not contain any useful data.","value":0},{"name":"UPPER_18_BITS_VALID","description":"Data input to the block is in 18 bpp format, such that upper 18 bits contain RGB 666 and lower 14 bits do not contain any useful data.","value":1}]},{"name":"DATA_FORMAT_16_BIT","description":"When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit data is in ARGB555 format","bitOffset":3,"bitWidth":1,"access":"read-write"},{"name":"MASTER","description":"Set this bit to make the LCDIF act as a bus master","bitOffset":5,"bitWidth":1,"access":"read-write"},{"name":"ENABLE_PXP_HANDSHAKE","description":"If this bit is set and LCDIF_MASTER bit is set, the LCDIF will act as bus master and the handshake mechanism between LCDIF and PXP will be turned on","bitOffset":6,"bitWidth":1,"access":"read-write"},{"name":"WORD_LENGTH","description":"Input data format.","bitOffset":8,"bitWidth":2,"access":"read-write","enumeratedValues":[{"name":"16_BIT","description":"Input data is 16 bits per pixel.","value":0},{"name":"8_BIT","description":"Input data is 8 bits wide.","value":1},{"name":"18_BIT","description":"Input data is 18 bits per pixel.","value":2},{"name":"24_BIT","description":"Input data is 24 bits per pixel.","value":3}]},{"name":"LCD_DATABUS_WIDTH","description":"LCD Data bus transfer width. When LUT enabled, this field should be set to 0x01.","bitOffset":10,"bitWidth":2,"access":"read-write","enumeratedValues":[{"name":"16_BIT","description":"16-bit data bus mode.","value":0},{"name":"8_BIT","description":"8-bit data bus mode.","value":1},{"name":"18_BIT","description":"18-bit data bus mode.","value":2},{"name":"24_BIT","description":"24-bit data bus mode.","value":3}]},{"name":"CSC_DATA_SWIZZLE","description":"This field specifies how to swap the bytes after the data has been converted into an internal representation of 24 bits per pixel and before it is transmitted over the LCD interface bus","bitOffset":12,"bitWidth":2,"access":"read-write","enumeratedValues":[{"name":"NO_SWAP","description":"No byte swapping.(Little endian)","value":0},{"name":"BIG_ENDIAN_SWAP","description":"Big Endian swap (swap bytes 0,3 and 1,2).","value":1},{"name":"HWD_SWAP","description":"Swap half-words.","value":2},{"name":"HWD_BYTE_SWAP","description":"Swap bytes within each half-word.","value":3}]},{"name":"INPUT_DATA_SWIZZLE","description":"This field specifies how to swap the bytes fetched by the bus master interface","bitOffset":14,"bitWidth":2,"access":"read-write","enumeratedValues":[{"name":"NO_SWAP","description":"No byte swapping.(Little endian)","value":0},{"name":"BIG_ENDIAN_SWAP","description":"Big Endian swap (swap bytes 0,3 and 1,2).","value":1},{"name":"HWD_SWAP","description":"Swap half-words.","value":2},{"name":"HWD_BYTE_SWAP","description":"Swap bytes within each half-word.","value":3}]},{"name":"DOTCLK_MODE","description":"Set this bit to 1 to make the hardware go into the DOTCLK mode, i","bitOffset":17,"bitWidth":1,"access":"read-write"},{"name":"BYPASS_COUNT","description":"When this bit is 0, it means that LCDIF will stop the block operation and turn off the RUN bit after the amount of data indicated by the LCDIF_TRANSFER_COUNT register has been transferred out","bitOffset":19,"bitWidth":1,"access":"read-write"},{"name":"SHIFT_NUM_BITS","description":"The data to be transmitted is shifted left or right by this number of bits.","bitOffset":21,"bitWidth":5,"access":"read-write"},{"name":"DATA_SHIFT_DIR","description":"Use this bit to determine the direction of shift of transmit data.","bitOffset":26,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"TXDATA_SHIFT_LEFT","description":"Data to be transmitted is shifted LEFT by SHIFT_NUM_BITS bits.","value":0},{"name":"TXDATA_SHIFT_RIGHT","description":"Data to be transmitted is shifted RIGHT by SHIFT_NUM_BITS bits.","value":1}]},{"name":"CLKGATE","description":"This bit must be set to zero for normal operation","bitOffset":30,"bitWidth":1,"access":"read-write"},{"name":"SFTRST","description":"This bit must be set to zero to enable normal operation of the LCDIF","bitOffset":31,"bitWidth":1,"access":"read-write"}]},{"name":"CTRL_TOG","description":"LCDIF General Control Register","addressOffset":12,"size":32,"access":"read-write","resetValue":"0xC0000000","resetMask":"0xFFFFFFFF","fields":[{"name":"RUN","description":"When this bit is set by software, the LCDIF will begin transferring data between the SoC and the display","bitOffset":0,"bitWidth":1,"access":"read-write"},{"name":"DATA_FORMAT_24_BIT","description":"Used only when WORD_LENGTH = 3, i","bitOffset":1,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"ALL_24_BITS_VALID","description":"Data input to the block is in 24 bpp format, such that all RGB 888 data is contained in 24 bits.","value":0},{"name":"DROP_UPPER_2_BITS_PER_BYTE","description":"Data input to the block is actually RGB 18 bpp, but there is 1 color per byte, hence the upper 2 bits in each byte do not contain any useful data, and should be dropped.","value":1}]},{"name":"DATA_FORMAT_18_BIT","description":"Used only when WORD_LENGTH = 2, i.e. 18-bit.","bitOffset":2,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"LOWER_18_BITS_VALID","description":"Data input to the block is in 18 bpp format, such that lower 18 bits contain RGB 666 and upper 14 bits do not contain any useful data.","value":0},{"name":"UPPER_18_BITS_VALID","description":"Data input to the block is in 18 bpp format, such that upper 18 bits contain RGB 666 and lower 14 bits do not contain any useful data.","value":1}]},{"name":"DATA_FORMAT_16_BIT","description":"When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit data is in ARGB555 format","bitOffset":3,"bitWidth":1,"access":"read-write"},{"name":"MASTER","description":"Set this bit to make the LCDIF act as a bus master","bitOffset":5,"bitWidth":1,"access":"read-write"},{"name":"ENABLE_PXP_HANDSHAKE","description":"If this bit is set and LCDIF_MASTER bit is set, the LCDIF will act as bus master and the handshake mechanism between LCDIF and PXP will be turned on","bitOffset":6,"bitWidth":1,"access":"read-write"},{"name":"WORD_LENGTH","description":"Input data format.","bitOffset":8,"bitWidth":2,"access":"read-write","enumeratedValues":[{"name":"16_BIT","description":"Input data is 16 bits per pixel.","value":0},{"name":"8_BIT","description":"Input data is 8 bits wide.","value":1},{"name":"18_BIT","description":"Input data is 18 bits per pixel.","value":2},{"name":"24_BIT","description":"Input data is 24 bits per pixel.","value":3}]},{"name":"LCD_DATABUS_WIDTH","description":"LCD Data bus transfer width. When LUT enabled, this field should be set to 0x01.","bitOffset":10,"bitWidth":2,"access":"read-write","enumeratedValues":[{"name":"16_BIT","description":"16-bit data bus mode.","value":0},{"name":"8_BIT","description":"8-bit data bus mode.","value":1},{"name":"18_BIT","description":"18-bit data bus mode.","value":2},{"name":"24_BIT","description":"24-bit data bus mode.","value":3}]},{"name":"CSC_DATA_SWIZZLE","description":"This field specifies how to swap the bytes after the data has been converted into an internal representation of 24 bits per pixel and before it is transmitted over the LCD interface bus","bitOffset":12,"bitWidth":2,"access":"read-write","enumeratedValues":[{"name":"NO_SWAP","description":"No byte swapping.(Little endian)","value":0},{"name":"BIG_ENDIAN_SWAP","description":"Big Endian swap (swap bytes 0,3 and 1,2).","value":1},{"name":"HWD_SWAP","description":"Swap half-words.","value":2},{"name":"HWD_BYTE_SWAP","description":"Swap bytes within each half-word.","value":3}]},{"name":"INPUT_DATA_SWIZZLE","description":"This field specifies how to swap the bytes fetched by the bus master interface","bitOffset":14,"bitWidth":2,"access":"read-write","enumeratedValues":[{"name":"NO_SWAP","description":"No byte swapping.(Little endian)","value":0},{"name":"BIG_ENDIAN_SWAP","description":"Big Endian swap (swap bytes 0,3 and 1,2).","value":1},{"name":"HWD_SWAP","description":"Swap half-words.","value":2},{"name":"HWD_BYTE_SWAP","description":"Swap bytes within each half-word.","value":3}]},{"name":"DOTCLK_MODE","description":"Set this bit to 1 to make the hardware go into the DOTCLK mode, i","bitOffset":17,"bitWidth":1,"access":"read-write"},{"name":"BYPASS_COUNT","description":"When this bit is 0, it means that LCDIF will stop the block operation and turn off the RUN bit after the amount of data indicated by the LCDIF_TRANSFER_COUNT register has been transferred out","bitOffset":19,"bitWidth":1,"access":"read-write"},{"name":"SHIFT_NUM_BITS","description":"The data to be transmitted is shifted left or right by this number of bits.","bitOffset":21,"bitWidth":5,"access":"read-write"},{"name":"DATA_SHIFT_DIR","description":"Use this bit to determine the direction of shift of transmit data.","bitOffset":26,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"TXDATA_SHIFT_LEFT","description":"Data to be transmitted is shifted LEFT by SHIFT_NUM_BITS bits.","value":0},{"name":"TXDATA_SHIFT_RIGHT","description":"Data to be transmitted is shifted RIGHT by SHIFT_NUM_BITS bits.","value":1}]},{"name":"CLKGATE","description":"This bit must be set to zero for normal operation","bitOffset":30,"bitWidth":1,"access":"read-write"},{"name":"SFTRST","description":"This bit must be set to zero to enable normal operation of the LCDIF","bitOffset":31,"bitWidth":1,"access":"read-write"}]},{"name":"CTRL1","description":"LCDIF General Control1 Register","addressOffset":16,"size":32,"access":"read-write","resetValue":"0xF0000","resetMask":"0xFFFFFFFF","fields":[{"name":"VSYNC_EDGE_IRQ","description":"This bit is set to indicate that an interrupt is requested by the LCDIF block","bitOffset":8,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"NO_REQUEST","description":"No Interrupt Request Pending.","value":0},{"name":"REQUEST","description":"Interrupt Request Pending.","value":1}]},{"name":"CUR_FRAME_DONE_IRQ","description":"This bit is set to indicate that an interrupt is requested by the LCDIF block","bitOffset":9,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"NO_REQUEST","description":"No Interrupt Request Pending.","value":0},{"name":"REQUEST","description":"Interrupt Request Pending.","value":1}]},{"name":"UNDERFLOW_IRQ","description":"This bit is set to indicate that an interrupt is requested by the LCDIF block","bitOffset":10,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"NO_REQUEST","description":"No Interrupt Request Pending.","value":0},{"name":"REQUEST","description":"Interrupt Request Pending.","value":1}]},{"name":"OVERFLOW_IRQ","description":"This bit is set to indicate that an interrupt is requested by the LCDIF block","bitOffset":11,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"NO_REQUEST","description":"No Interrupt Request Pending.","value":0},{"name":"REQUEST","description":"Interrupt Request Pending.","value":1}]},{"name":"VSYNC_EDGE_IRQ_EN","description":"This bit is set to enable an interrupt every time the hardware encounters the leading VSYNC edge in the VSYNC and DOTCLK modes, or the beginning of every field in DVI mode","bitOffset":12,"bitWidth":1,"access":"read-write"},{"name":"CUR_FRAME_DONE_IRQ_EN","description":"This bit is set to 1 enable an interrupt every time the hardware enters in the vertical blanking state","bitOffset":13,"bitWidth":1,"access":"read-write"},{"name":"UNDERFLOW_IRQ_EN","description":"This bit is set to enable an underflow interrupt in the TXFIFO in the write mode.","bitOffset":14,"bitWidth":1,"access":"read-write"},{"name":"OVERFLOW_IRQ_EN","description":"This bit is set to enable an overflow interrupt in the TXFIFO in the write mode.","bitOffset":15,"bitWidth":1,"access":"read-write"},{"name":"BYTE_PACKING_FORMAT","description":"This bitfield is used to show which data bytes in a 32-bit word are valid","bitOffset":16,"bitWidth":4,"access":"read-write"},{"name":"IRQ_ON_ALTERNATE_FIELDS","description":"If this bit is set, the LCDIF block will assert the cur_frame_done interrupt only on alternate fields, otherwise it will issue the interrupt on both odd and even field","bitOffset":20,"bitWidth":1,"access":"read-write"},{"name":"FIFO_CLEAR","description":"Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO and the RXFIFO.","bitOffset":21,"bitWidth":1,"access":"read-write"},{"name":"START_INTERLACE_FROM_SECOND_FIELD","description":"The default is to grab the odd lines first and then the even lines","bitOffset":22,"bitWidth":1,"access":"read-write"},{"name":"INTERLACE_FIELDS","description":"Set this bit if it is required that the LCDIF block fetches odd lines in one field and even lines in the other field","bitOffset":23,"bitWidth":1,"access":"read-write"},{"name":"RECOVER_ON_UNDERFLOW","description":"Set this bit to enable the LCDIF block to recover in the next field/frame if there was an underflow in the current field/frame","bitOffset":24,"bitWidth":1,"access":"read-write"},{"name":"BM_ERROR_IRQ","description":"This bit is set to indicate that an interrupt is requested by the LCDIF block","bitOffset":25,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"NO_REQUEST","description":"No Interrupt Request Pending.","value":0},{"name":"REQUEST","description":"Interrupt Request Pending.","value":1}]},{"name":"BM_ERROR_IRQ_EN","description":"This bit is set to enable bus master error interrupt in the LCDIF master mode.","bitOffset":26,"bitWidth":1,"access":"read-write"},{"name":"CS_OUT_SELECT","description":"This bit is CS0/CS1 valid select signals","bitOffset":30,"bitWidth":1,"access":"read-write"},{"name":"IMAGE_DATA_SELECT","description":"Command Mode MIPI image data select bit","bitOffset":31,"bitWidth":1,"access":"read-write"}]},{"name":"CTRL1_SET","description":"LCDIF General Control1 Register","addressOffset":20,"size":32,"access":"read-write","resetValue":"0xF0000","resetMask":"0xFFFFFFFF","fields":[{"name":"VSYNC_EDGE_IRQ","description":"This bit is set to indicate that an interrupt is requested by the LCDIF block","bitOffset":8,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"NO_REQUEST","description":"No Interrupt Request Pending.","value":0},{"name":"REQUEST","description":"Interrupt Request Pending.","value":1}]},{"name":"CUR_FRAME_DONE_IRQ","description":"This bit is set to indicate that an interrupt is requested by the LCDIF block","bitOffset":9,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"NO_REQUEST","description":"No Interrupt Request Pending.","value":0},{"name":"REQUEST","description":"Interrupt Request Pending.","value":1}]},{"name":"UNDERFLOW_IRQ","description":"This bit is set to indicate that an interrupt is requested by the LCDIF block","bitOffset":10,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"NO_REQUEST","description":"No Interrupt Request Pending.","value":0},{"name":"REQUEST","description":"Interrupt Request Pending.","value":1}]},{"name":"OVERFLOW_IRQ","description":"This bit is set to indicate that an interrupt is requested by the LCDIF block","bitOffset":11,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"NO_REQUEST","description":"No Interrupt Request Pending.","value":0},{"name":"REQUEST","description":"Interrupt Request Pending.","value":1}]},{"name":"VSYNC_EDGE_IRQ_EN","description":"This bit is set to enable an interrupt every time the hardware encounters the leading VSYNC edge in the VSYNC and DOTCLK modes, or the beginning of every field in DVI mode","bitOffset":12,"bitWidth":1,"access":"read-write"},{"name":"CUR_FRAME_DONE_IRQ_EN","description":"This bit is set to 1 enable an interrupt every time the hardware enters in the vertical blanking state","bitOffset":13,"bitWidth":1,"access":"read-write"},{"name":"UNDERFLOW_IRQ_EN","description":"This bit is set to enable an underflow interrupt in the TXFIFO in the write mode.","bitOffset":14,"bitWidth":1,"access":"read-write"},{"name":"OVERFLOW_IRQ_EN","description":"This bit is set to enable an overflow interrupt in the TXFIFO in the write mode.","bitOffset":15,"bitWidth":1,"access":"read-write"},{"name":"BYTE_PACKING_FORMAT","description":"This bitfield is used to show which data bytes in a 32-bit word are valid","bitOffset":16,"bitWidth":4,"access":"read-write"},{"name":"IRQ_ON_ALTERNATE_FIELDS","description":"If this bit is set, the LCDIF block will assert the cur_frame_done interrupt only on alternate fields, otherwise it will issue the interrupt on both odd and even field","bitOffset":20,"bitWidth":1,"access":"read-write"},{"name":"FIFO_CLEAR","description":"Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO and the RXFIFO.","bitOffset":21,"bitWidth":1,"access":"read-write"},{"name":"START_INTERLACE_FROM_SECOND_FIELD","description":"The default is to grab the odd lines first and then the even lines","bitOffset":22,"bitWidth":1,"access":"read-write"},{"name":"INTERLACE_FIELDS","description":"Set this bit if it is required that the LCDIF block fetches odd lines in one field and even lines in the other field","bitOffset":23,"bitWidth":1,"access":"read-write"},{"name":"RECOVER_ON_UNDERFLOW","description":"Set this bit to enable the LCDIF block to recover in the next field/frame if there was an underflow in the current field/frame","bitOffset":24,"bitWidth":1,"access":"read-write"},{"name":"BM_ERROR_IRQ","description":"This bit is set to indicate that an interrupt is requested by the LCDIF block","bitOffset":25,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"NO_REQUEST","description":"No Interrupt Request Pending.","value":0},{"name":"REQUEST","description":"Interrupt Request Pending.","value":1}]},{"name":"BM_ERROR_IRQ_EN","description":"This bit is set to enable bus master error interrupt in the LCDIF master mode.","bitOffset":26,"bitWidth":1,"access":"read-write"},{"name":"CS_OUT_SELECT","description":"This bit is CS0/CS1 valid select signals","bitOffset":30,"bitWidth":1,"access":"read-write"},{"name":"IMAGE_DATA_SELECT","description":"Command Mode MIPI image data select bit","bitOffset":31,"bitWidth":1,"access":"read-write"}]},{"name":"CTRL1_CLR","description":"LCDIF General Control1 Register","addressOffset":24,"size":32,"access":"read-write","resetValue":"0xF0000","resetMask":"0xFFFFFFFF","fields":[{"name":"VSYNC_EDGE_IRQ","description":"This bit is set to indicate that an interrupt is requested by the LCDIF block","bitOffset":8,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"NO_REQUEST","description":"No Interrupt Request Pending.","value":0},{"name":"REQUEST","description":"Interrupt Request Pending.","value":1}]},{"name":"CUR_FRAME_DONE_IRQ","description":"This bit is set to indicate that an interrupt is requested by the LCDIF block","bitOffset":9,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"NO_REQUEST","description":"No Interrupt Request Pending.","value":0},{"name":"REQUEST","description":"Interrupt Request Pending.","value":1}]},{"name":"UNDERFLOW_IRQ","description":"This bit is set to indicate that an interrupt is requested by the LCDIF block","bitOffset":10,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"NO_REQUEST","description":"No Interrupt Request Pending.","value":0},{"name":"REQUEST","description":"Interrupt Request Pending.","value":1}]},{"name":"OVERFLOW_IRQ","description":"This bit is set to indicate that an interrupt is requested by the LCDIF block","bitOffset":11,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"NO_REQUEST","description":"No Interrupt Request Pending.","value":0},{"name":"REQUEST","description":"Interrupt Request Pending.","value":1}]},{"name":"VSYNC_EDGE_IRQ_EN","description":"This bit is set to enable an interrupt every time the hardware encounters the leading VSYNC edge in the VSYNC and DOTCLK modes, or the beginning of every field in DVI mode","bitOffset":12,"bitWidth":1,"access":"read-write"},{"name":"CUR_FRAME_DONE_IRQ_EN","description":"This bit is set to 1 enable an interrupt every time the hardware enters in the vertical blanking state","bitOffset":13,"bitWidth":1,"access":"read-write"},{"name":"UNDERFLOW_IRQ_EN","description":"This bit is set to enable an underflow interrupt in the TXFIFO in the write mode.","bitOffset":14,"bitWidth":1,"access":"read-write"},{"name":"OVERFLOW_IRQ_EN","description":"This bit is set to enable an overflow interrupt in the TXFIFO in the write mode.","bitOffset":15,"bitWidth":1,"access":"read-write"},{"name":"BYTE_PACKING_FORMAT","description":"This bitfield is used to show which data bytes in a 32-bit word are valid","bitOffset":16,"bitWidth":4,"access":"read-write"},{"name":"IRQ_ON_ALTERNATE_FIELDS","description":"If this bit is set, the LCDIF block will assert the cur_frame_done interrupt only on alternate fields, otherwise it will issue the interrupt on both odd and even field","bitOffset":20,"bitWidth":1,"access":"read-write"},{"name":"FIFO_CLEAR","description":"Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO and the RXFIFO.","bitOffset":21,"bitWidth":1,"access":"read-write"},{"name":"START_INTERLACE_FROM_SECOND_FIELD","description":"The default is to grab the odd lines first and then the even lines","bitOffset":22,"bitWidth":1,"access":"read-write"},{"name":"INTERLACE_FIELDS","description":"Set this bit if it is required that the LCDIF block fetches odd lines in one field and even lines in the other field","bitOffset":23,"bitWidth":1,"access":"read-write"},{"name":"RECOVER_ON_UNDERFLOW","description":"Set this bit to enable the LCDIF block to recover in the next field/frame if there was an underflow in the current field/frame","bitOffset":24,"bitWidth":1,"access":"read-write"},{"name":"BM_ERROR_IRQ","description":"This bit is set to indicate that an interrupt is requested by the LCDIF block","bitOffset":25,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"NO_REQUEST","description":"No Interrupt Request Pending.","value":0},{"name":"REQUEST","description":"Interrupt Request Pending.","value":1}]},{"name":"BM_ERROR_IRQ_EN","description":"This bit is set to enable bus master error interrupt in the LCDIF master mode.","bitOffset":26,"bitWidth":1,"access":"read-write"},{"name":"CS_OUT_SELECT","description":"This bit is CS0/CS1 valid select signals","bitOffset":30,"bitWidth":1,"access":"read-write"},{"name":"IMAGE_DATA_SELECT","description":"Command Mode MIPI image data select bit","bitOffset":31,"bitWidth":1,"access":"read-write"}]},{"name":"CTRL1_TOG","description":"LCDIF General Control1 Register","addressOffset":28,"size":32,"access":"read-write","resetValue":"0xF0000","resetMask":"0xFFFFFFFF","fields":[{"name":"VSYNC_EDGE_IRQ","description":"This bit is set to indicate that an interrupt is requested by the LCDIF block","bitOffset":8,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"NO_REQUEST","description":"No Interrupt Request Pending.","value":0},{"name":"REQUEST","description":"Interrupt Request Pending.","value":1}]},{"name":"CUR_FRAME_DONE_IRQ","description":"This bit is set to indicate that an interrupt is requested by the LCDIF block","bitOffset":9,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"NO_REQUEST","description":"No Interrupt Request Pending.","value":0},{"name":"REQUEST","description":"Interrupt Request Pending.","value":1}]},{"name":"UNDERFLOW_IRQ","description":"This bit is set to indicate that an interrupt is requested by the LCDIF block","bitOffset":10,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"NO_REQUEST","description":"No Interrupt Request Pending.","value":0},{"name":"REQUEST","description":"Interrupt Request Pending.","value":1}]},{"name":"OVERFLOW_IRQ","description":"This bit is set to indicate that an interrupt is requested by the LCDIF block","bitOffset":11,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"NO_REQUEST","description":"No Interrupt Request Pending.","value":0},{"name":"REQUEST","description":"Interrupt Request Pending.","value":1}]},{"name":"VSYNC_EDGE_IRQ_EN","description":"This bit is set to enable an interrupt every time the hardware encounters the leading VSYNC edge in the VSYNC and DOTCLK modes, or the beginning of every field in DVI mode","bitOffset":12,"bitWidth":1,"access":"read-write"},{"name":"CUR_FRAME_DONE_IRQ_EN","description":"This bit is set to 1 enable an interrupt every time the hardware enters in the vertical blanking state","bitOffset":13,"bitWidth":1,"access":"read-write"},{"name":"UNDERFLOW_IRQ_EN","description":"This bit is set to enable an underflow interrupt in the TXFIFO in the write mode.","bitOffset":14,"bitWidth":1,"access":"read-write"},{"name":"OVERFLOW_IRQ_EN","description":"This bit is set to enable an overflow interrupt in the TXFIFO in the write mode.","bitOffset":15,"bitWidth":1,"access":"read-write"},{"name":"BYTE_PACKING_FORMAT","description":"This bitfield is used to show which data bytes in a 32-bit word are valid","bitOffset":16,"bitWidth":4,"access":"read-write"},{"name":"IRQ_ON_ALTERNATE_FIELDS","description":"If this bit is set, the LCDIF block will assert the cur_frame_done interrupt only on alternate fields, otherwise it will issue the interrupt on both odd and even field","bitOffset":20,"bitWidth":1,"access":"read-write"},{"name":"FIFO_CLEAR","description":"Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO and the RXFIFO.","bitOffset":21,"bitWidth":1,"access":"read-write"},{"name":"START_INTERLACE_FROM_SECOND_FIELD","description":"The default is to grab the odd lines first and then the even lines","bitOffset":22,"bitWidth":1,"access":"read-write"},{"name":"INTERLACE_FIELDS","description":"Set this bit if it is required that the LCDIF block fetches odd lines in one field and even lines in the other field","bitOffset":23,"bitWidth":1,"access":"read-write"},{"name":"RECOVER_ON_UNDERFLOW","description":"Set this bit to enable the LCDIF block to recover in the next field/frame if there was an underflow in the current field/frame","bitOffset":24,"bitWidth":1,"access":"read-write"},{"name":"BM_ERROR_IRQ","description":"This bit is set to indicate that an interrupt is requested by the LCDIF block","bitOffset":25,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"NO_REQUEST","description":"No Interrupt Request Pending.","value":0},{"name":"REQUEST","description":"Interrupt Request Pending.","value":1}]},{"name":"BM_ERROR_IRQ_EN","description":"This bit is set to enable bus master error interrupt in the LCDIF master mode.","bitOffset":26,"bitWidth":1,"access":"read-write"},{"name":"CS_OUT_SELECT","description":"This bit is CS0/CS1 valid select signals","bitOffset":30,"bitWidth":1,"access":"read-write"},{"name":"IMAGE_DATA_SELECT","description":"Command Mode MIPI image data select bit","bitOffset":31,"bitWidth":1,"access":"read-write"}]},{"name":"CTRL2","description":"LCDIF General Control2 Register","addressOffset":32,"size":32,"access":"read-write","resetValue":"0x200000","resetMask":"0xFFFFFFFF","fields":[{"name":"EVEN_LINE_PATTERN","description":"This field determines the order of the RGB components of each pixel in EVEN lines (line numbers 2,4,6,","bitOffset":12,"bitWidth":3,"access":"read-write","enumeratedValues":[{"name":"RGB","description":"RGB","value":0},{"name":"RBG","description":"RBG","value":1},{"name":"GBR","description":"GBR","value":2},{"name":"GRB","description":"GRB","value":3},{"name":"BRG","description":"BRG","value":4},{"name":"BGR","description":"BGR","value":5}]},{"name":"ODD_LINE_PATTERN","description":"This field determines the order of the RGB components of each pixel in ODD lines (line numbers 1,3,5,","bitOffset":16,"bitWidth":3,"access":"read-write","enumeratedValues":[{"name":"RGB","description":"RGB","value":0},{"name":"RBG","description":"RBG","value":1},{"name":"GBR","description":"GBR","value":2},{"name":"GRB","description":"GRB","value":3},{"name":"BRG","description":"BRG","value":4},{"name":"BGR","description":"BGR","value":5}]},{"name":"BURST_LEN_8","description":"By default, when the LCDIF is in the bus master mode, it will issue AXI bursts of length 16 (except when in packed 24 bpp mode, it will issue bursts of length 15)","bitOffset":20,"bitWidth":1,"access":"read-write"},{"name":"OUTSTANDING_REQS","description":"This bitfield indicates the maximum number of outstanding transactions that LCDIF should request when it is acting as a bus master","bitOffset":21,"bitWidth":3,"access":"read-write","enumeratedValues":[{"name":"REQ_1","description":"REQ_1","value":0},{"name":"REQ_2","description":"REQ_2","value":1},{"name":"REQ_4","description":"REQ_4","value":2},{"name":"REQ_8","description":"REQ_8","value":3},{"name":"REQ_16","description":"REQ_16","value":4}]}]},{"name":"CTRL2_SET","description":"LCDIF General Control2 Register","addressOffset":36,"size":32,"access":"read-write","resetValue":"0x200000","resetMask":"0xFFFFFFFF","fields":[{"name":"EVEN_LINE_PATTERN","description":"This field determines the order of the RGB components of each pixel in EVEN lines (line numbers 2,4,6,","bitOffset":12,"bitWidth":3,"access":"read-write","enumeratedValues":[{"name":"RGB","description":"RGB","value":0},{"name":"RBG","description":"RBG","value":1},{"name":"GBR","description":"GBR","value":2},{"name":"GRB","description":"GRB","value":3},{"name":"BRG","description":"BRG","value":4},{"name":"BGR","description":"BGR","value":5}]},{"name":"ODD_LINE_PATTERN","description":"This field determines the order of the RGB components of each pixel in ODD lines (line numbers 1,3,5,","bitOffset":16,"bitWidth":3,"access":"read-write","enumeratedValues":[{"name":"RGB","description":"RGB","value":0},{"name":"RBG","description":"RBG","value":1},{"name":"GBR","description":"GBR","value":2},{"name":"GRB","description":"GRB","value":3},{"name":"BRG","description":"BRG","value":4},{"name":"BGR","description":"BGR","value":5}]},{"name":"BURST_LEN_8","description":"By default, when the LCDIF is in the bus master mode, it will issue AXI bursts of length 16 (except when in packed 24 bpp mode, it will issue bursts of length 15)","bitOffset":20,"bitWidth":1,"access":"read-write"},{"name":"OUTSTANDING_REQS","description":"This bitfield indicates the maximum number of outstanding transactions that LCDIF should request when it is acting as a bus master","bitOffset":21,"bitWidth":3,"access":"read-write","enumeratedValues":[{"name":"REQ_1","description":"REQ_1","value":0},{"name":"REQ_2","description":"REQ_2","value":1},{"name":"REQ_4","description":"REQ_4","value":2},{"name":"REQ_8","description":"REQ_8","value":3},{"name":"REQ_16","description":"REQ_16","value":4}]}]},{"name":"CTRL2_CLR","description":"LCDIF General Control2 Register","addressOffset":40,"size":32,"access":"read-write","resetValue":"0x200000","resetMask":"0xFFFFFFFF","fields":[{"name":"EVEN_LINE_PATTERN","description":"This field determines the order of the RGB components of each pixel in EVEN lines (line numbers 2,4,6,","bitOffset":12,"bitWidth":3,"access":"read-write","enumeratedValues":[{"name":"RGB","description":"RGB","value":0},{"name":"RBG","description":"RBG","value":1},{"name":"GBR","description":"GBR","value":2},{"name":"GRB","description":"GRB","value":3},{"name":"BRG","description":"BRG","value":4},{"name":"BGR","description":"BGR","value":5}]},{"name":"ODD_LINE_PATTERN","description":"This field determines the order of the RGB components of each pixel in ODD lines (line numbers 1,3,5,","bitOffset":16,"bitWidth":3,"access":"read-write","enumeratedValues":[{"name":"RGB","description":"RGB","value":0},{"name":"RBG","description":"RBG","value":1},{"name":"GBR","description":"GBR","value":2},{"name":"GRB","description":"GRB","value":3},{"name":"BRG","description":"BRG","value":4},{"name":"BGR","description":"BGR","value":5}]},{"name":"BURST_LEN_8","description":"By default, when the LCDIF is in the bus master mode, it will issue AXI bursts of length 16 (except when in packed 24 bpp mode, it will issue bursts of length 15)","bitOffset":20,"bitWidth":1,"access":"read-write"},{"name":"OUTSTANDING_REQS","description":"This bitfield indicates the maximum number of outstanding transactions that LCDIF should request when it is acting as a bus master","bitOffset":21,"bitWidth":3,"access":"read-write","enumeratedValues":[{"name":"REQ_1","description":"REQ_1","value":0},{"name":"REQ_2","description":"REQ_2","value":1},{"name":"REQ_4","description":"REQ_4","value":2},{"name":"REQ_8","description":"REQ_8","value":3},{"name":"REQ_16","description":"REQ_16","value":4}]}]},{"name":"CTRL2_TOG","description":"LCDIF General Control2 Register","addressOffset":44,"size":32,"access":"read-write","resetValue":"0x200000","resetMask":"0xFFFFFFFF","fields":[{"name":"EVEN_LINE_PATTERN","description":"This field determines the order of the RGB components of each pixel in EVEN lines (line numbers 2,4,6,","bitOffset":12,"bitWidth":3,"access":"read-write","enumeratedValues":[{"name":"RGB","description":"RGB","value":0},{"name":"RBG","description":"RBG","value":1},{"name":"GBR","description":"GBR","value":2},{"name":"GRB","description":"GRB","value":3},{"name":"BRG","description":"BRG","value":4},{"name":"BGR","description":"BGR","value":5}]},{"name":"ODD_LINE_PATTERN","description":"This field determines the order of the RGB components of each pixel in ODD lines (line numbers 1,3,5,","bitOffset":16,"bitWidth":3,"access":"read-write","enumeratedValues":[{"name":"RGB","description":"RGB","value":0},{"name":"RBG","description":"RBG","value":1},{"name":"GBR","description":"GBR","value":2},{"name":"GRB","description":"GRB","value":3},{"name":"BRG","description":"BRG","value":4},{"name":"BGR","description":"BGR","value":5}]},{"name":"BURST_LEN_8","description":"By default, when the LCDIF is in the bus master mode, it will issue AXI bursts of length 16 (except when in packed 24 bpp mode, it will issue bursts of length 15)","bitOffset":20,"bitWidth":1,"access":"read-write"},{"name":"OUTSTANDING_REQS","description":"This bitfield indicates the maximum number of outstanding transactions that LCDIF should request when it is acting as a bus master","bitOffset":21,"bitWidth":3,"access":"read-write","enumeratedValues":[{"name":"REQ_1","description":"REQ_1","value":0},{"name":"REQ_2","description":"REQ_2","value":1},{"name":"REQ_4","description":"REQ_4","value":2},{"name":"REQ_8","description":"REQ_8","value":3},{"name":"REQ_16","description":"REQ_16","value":4}]}]},{"name":"TRANSFER_COUNT","description":"LCDIF Horizontal and Vertical Valid Data Count Register","addressOffset":48,"size":32,"access":"read-write","resetValue":"0x10000","resetMask":"0xFFFFFFFF","fields":[{"name":"H_COUNT","description":"Total valid data (pixels) in each horizontal line","bitOffset":0,"bitWidth":16,"access":"read-write"},{"name":"V_COUNT","description":"Number of horizontal lines per frame which contain valid data","bitOffset":16,"bitWidth":16,"access":"read-write"}]},{"name":"CUR_BUF","description":"LCD Interface Current Buffer Address Register","addressOffset":64,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"ADDR","description":"Address of the current frame being transmitted by LCDIF.","bitOffset":0,"bitWidth":32,"access":"read-write"}]},{"name":"NEXT_BUF","description":"LCD Interface Next Buffer Address Register","addressOffset":80,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"ADDR","description":"Address of the next frame that will be transmitted by LCDIF.","bitOffset":0,"bitWidth":32,"access":"read-write"}]},{"name":"VDCTRL0","description":"LCDIF VSYNC Mode and Dotclk Mode Control Register0","addressOffset":112,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"VSYNC_PULSE_WIDTH","description":"Number of units for which VSYNC signal is active","bitOffset":0,"bitWidth":18,"access":"read-write"},{"name":"HALF_LINE_MODE","description":"When this bit is 0, the first field (VSYNC period) will end in half a horizontal line and the second field will begin with half a horizontal line","bitOffset":18,"bitWidth":1,"access":"read-write"},{"name":"HALF_LINE","description":"Setting this bit to 1 will make the total VSYNC period equal to the VSYNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i","bitOffset":19,"bitWidth":1,"access":"read-write"},{"name":"VSYNC_PULSE_WIDTH_UNIT","description":"Default 0 for counting VSYNC_PULSE_WIDTH in terms of DISPLAY CLOCK (pix_clk) cycles","bitOffset":20,"bitWidth":1,"access":"read-write"},{"name":"VSYNC_PERIOD_UNIT","description":"Default 0 for counting VSYNC_PERIOD in terms of DISPLAY CLOCK (pix_clk) cycles","bitOffset":21,"bitWidth":1,"access":"read-write"},{"name":"ENABLE_POL","description":"Default 0 active low during valid data transfer on each horizontal line.","bitOffset":24,"bitWidth":1,"access":"read-write"},{"name":"DOTCLK_POL","description":"Default is data launched at negative edge of DOTCLK and captured at positive edge","bitOffset":25,"bitWidth":1,"access":"read-write"},{"name":"HSYNC_POL","description":"Default 0 active low during HSYNC_PULSE_WIDTH time and will be high during the rest of the HSYNC period","bitOffset":26,"bitWidth":1,"access":"read-write"},{"name":"VSYNC_POL","description":"Default 0 active low during VSYNC_PULSE_WIDTH time and will be high during the rest of the VSYNC period","bitOffset":27,"bitWidth":1,"access":"read-write"},{"name":"ENABLE_PRESENT","description":"Setting this bit to 1 will make the hardware generate the ENABLE signal in the DOTCLK mode, thereby making it the true RGB interface along with the remaining three signals VSYNC, HSYNC and DOTCLK","bitOffset":28,"bitWidth":1,"access":"read-write"}]},{"name":"VDCTRL0_SET","description":"LCDIF VSYNC Mode and Dotclk Mode Control Register0","addressOffset":116,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"VSYNC_PULSE_WIDTH","description":"Number of units for which VSYNC signal is active","bitOffset":0,"bitWidth":18,"access":"read-write"},{"name":"HALF_LINE_MODE","description":"When this bit is 0, the first field (VSYNC period) will end in half a horizontal line and the second field will begin with half a horizontal line","bitOffset":18,"bitWidth":1,"access":"read-write"},{"name":"HALF_LINE","description":"Setting this bit to 1 will make the total VSYNC period equal to the VSYNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i","bitOffset":19,"bitWidth":1,"access":"read-write"},{"name":"VSYNC_PULSE_WIDTH_UNIT","description":"Default 0 for counting VSYNC_PULSE_WIDTH in terms of DISPLAY CLOCK (pix_clk) cycles","bitOffset":20,"bitWidth":1,"access":"read-write"},{"name":"VSYNC_PERIOD_UNIT","description":"Default 0 for counting VSYNC_PERIOD in terms of DISPLAY CLOCK (pix_clk) cycles","bitOffset":21,"bitWidth":1,"access":"read-write"},{"name":"ENABLE_POL","description":"Default 0 active low during valid data transfer on each horizontal line.","bitOffset":24,"bitWidth":1,"access":"read-write"},{"name":"DOTCLK_POL","description":"Default is data launched at negative edge of DOTCLK and captured at positive edge","bitOffset":25,"bitWidth":1,"access":"read-write"},{"name":"HSYNC_POL","description":"Default 0 active low during HSYNC_PULSE_WIDTH time and will be high during the rest of the HSYNC period","bitOffset":26,"bitWidth":1,"access":"read-write"},{"name":"VSYNC_POL","description":"Default 0 active low during VSYNC_PULSE_WIDTH time and will be high during the rest of the VSYNC period","bitOffset":27,"bitWidth":1,"access":"read-write"},{"name":"ENABLE_PRESENT","description":"Setting this bit to 1 will make the hardware generate the ENABLE signal in the DOTCLK mode, thereby making it the true RGB interface along with the remaining three signals VSYNC, HSYNC and DOTCLK","bitOffset":28,"bitWidth":1,"access":"read-write"}]},{"name":"VDCTRL0_CLR","description":"LCDIF VSYNC Mode and Dotclk Mode Control Register0","addressOffset":120,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"VSYNC_PULSE_WIDTH","description":"Number of units for which VSYNC signal is active","bitOffset":0,"bitWidth":18,"access":"read-write"},{"name":"HALF_LINE_MODE","description":"When this bit is 0, the first field (VSYNC period) will end in half a horizontal line and the second field will begin with half a horizontal line","bitOffset":18,"bitWidth":1,"access":"read-write"},{"name":"HALF_LINE","description":"Setting this bit to 1 will make the total VSYNC period equal to the VSYNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i","bitOffset":19,"bitWidth":1,"access":"read-write"},{"name":"VSYNC_PULSE_WIDTH_UNIT","description":"Default 0 for counting VSYNC_PULSE_WIDTH in terms of DISPLAY CLOCK (pix_clk) cycles","bitOffset":20,"bitWidth":1,"access":"read-write"},{"name":"VSYNC_PERIOD_UNIT","description":"Default 0 for counting VSYNC_PERIOD in terms of DISPLAY CLOCK (pix_clk) cycles","bitOffset":21,"bitWidth":1,"access":"read-write"},{"name":"ENABLE_POL","description":"Default 0 active low during valid data transfer on each horizontal line.","bitOffset":24,"bitWidth":1,"access":"read-write"},{"name":"DOTCLK_POL","description":"Default is data launched at negative edge of DOTCLK and captured at positive edge","bitOffset":25,"bitWidth":1,"access":"read-write"},{"name":"HSYNC_POL","description":"Default 0 active low during HSYNC_PULSE_WIDTH time and will be high during the rest of the HSYNC period","bitOffset":26,"bitWidth":1,"access":"read-write"},{"name":"VSYNC_POL","description":"Default 0 active low during VSYNC_PULSE_WIDTH time and will be high during the rest of the VSYNC period","bitOffset":27,"bitWidth":1,"access":"read-write"},{"name":"ENABLE_PRESENT","description":"Setting this bit to 1 will make the hardware generate the ENABLE signal in the DOTCLK mode, thereby making it the true RGB interface along with the remaining three signals VSYNC, HSYNC and DOTCLK","bitOffset":28,"bitWidth":1,"access":"read-write"}]},{"name":"VDCTRL0_TOG","description":"LCDIF VSYNC Mode and Dotclk Mode Control Register0","addressOffset":124,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"VSYNC_PULSE_WIDTH","description":"Number of units for which VSYNC signal is active","bitOffset":0,"bitWidth":18,"access":"read-write"},{"name":"HALF_LINE_MODE","description":"When this bit is 0, the first field (VSYNC period) will end in half a horizontal line and the second field will begin with half a horizontal line","bitOffset":18,"bitWidth":1,"access":"read-write"},{"name":"HALF_LINE","description":"Setting this bit to 1 will make the total VSYNC period equal to the VSYNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i","bitOffset":19,"bitWidth":1,"access":"read-write"},{"name":"VSYNC_PULSE_WIDTH_UNIT","description":"Default 0 for counting VSYNC_PULSE_WIDTH in terms of DISPLAY CLOCK (pix_clk) cycles","bitOffset":20,"bitWidth":1,"access":"read-write"},{"name":"VSYNC_PERIOD_UNIT","description":"Default 0 for counting VSYNC_PERIOD in terms of DISPLAY CLOCK (pix_clk) cycles","bitOffset":21,"bitWidth":1,"access":"read-write"},{"name":"ENABLE_POL","description":"Default 0 active low during valid data transfer on each horizontal line.","bitOffset":24,"bitWidth":1,"access":"read-write"},{"name":"DOTCLK_POL","description":"Default is data launched at negative edge of DOTCLK and captured at positive edge","bitOffset":25,"bitWidth":1,"access":"read-write"},{"name":"HSYNC_POL","description":"Default 0 active low during HSYNC_PULSE_WIDTH time and will be high during the rest of the HSYNC period","bitOffset":26,"bitWidth":1,"access":"read-write"},{"name":"VSYNC_POL","description":"Default 0 active low during VSYNC_PULSE_WIDTH time and will be high during the rest of the VSYNC period","bitOffset":27,"bitWidth":1,"access":"read-write"},{"name":"ENABLE_PRESENT","description":"Setting this bit to 1 will make the hardware generate the ENABLE signal in the DOTCLK mode, thereby making it the true RGB interface along with the remaining three signals VSYNC, HSYNC and DOTCLK","bitOffset":28,"bitWidth":1,"access":"read-write"}]},{"name":"VDCTRL1","description":"LCDIF VSYNC Mode and Dotclk Mode Control Register1","addressOffset":128,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"VSYNC_PERIOD","description":"Total number of units between two positive or two negative edges of the VSYNC signal","bitOffset":0,"bitWidth":32,"access":"read-write"}]},{"name":"VDCTRL2","description":"LCDIF VSYNC Mode and Dotclk Mode Control Register2","addressOffset":144,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"HSYNC_PERIOD","description":"Total number of DISPLAY CLOCK (pix_clk) cycles between two positive or two negative edges of the HSYNC signal","bitOffset":0,"bitWidth":18,"access":"read-write"},{"name":"HSYNC_PULSE_WIDTH","description":"Number of DISPLAY CLOCK (pix_clk) cycles for which HSYNC signal is active.","bitOffset":18,"bitWidth":14,"access":"read-write"}]},{"name":"VDCTRL3","description":"LCDIF VSYNC Mode and Dotclk Mode Control Register3","addressOffset":160,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"VERTICAL_WAIT_CNT","description":"In the VSYNC interface mode, wait for this number of DISPLAY CLOCK (pix_clk) cycles from the falling VSYNC edge (or rising if VSYNC_POL is 1) before starting LCD transactions and is applicable only if WAIT_FOR_VSYNC_EDGE is set","bitOffset":0,"bitWidth":16,"access":"read-write"},{"name":"HORIZONTAL_WAIT_CNT","description":"In the DOTCLK mode, wait for this number of clocks from falling edge (or rising if HSYNC_POL is 1) of HSYNC signal to account for horizontal back porch plus the number of DOTCLKs before the moving picture information begins","bitOffset":16,"bitWidth":12,"access":"read-write"},{"name":"VSYNC_ONLY","description":"This bit must be set to 1 in the VSYNC mode of operation, and 0 in the DOTCLK mode of operation.","bitOffset":28,"bitWidth":1,"access":"read-write"},{"name":"MUX_SYNC_SIGNALS","description":"When this bit is set, the LCDIF block will internally mux HSYNC with LCD_D14, DOTCLK with LCD_D13 and ENABLE with LCD_D12, otherwise these signals will go out on separate pins","bitOffset":29,"bitWidth":1,"access":"read-write"}]},{"name":"VDCTRL4","description":"LCDIF VSYNC Mode and Dotclk Mode Control Register4","addressOffset":176,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"DOTCLK_H_VALID_DATA_CNT","description":"Total number of DISPLAY CLOCK (pix_clk) cycles on each horizontal line that carry valid data in DOTCLK mode","bitOffset":0,"bitWidth":18,"access":"read-write"},{"name":"SYNC_SIGNALS_ON","description":"Set this field to 1 if the LCD controller requires that the VSYNC or VSYNC/HSYNC/DOTCLK control signals should be active at least one frame before the data transfers actually start and remain active at least one frame after the data transfers end","bitOffset":18,"bitWidth":1,"access":"read-write"},{"name":"DOTCLK_DLY_SEL","description":"This bitfield selects the amount of time by which the DOTCLK signal should be delayed before coming out of the LCD_DOTCK pin","bitOffset":29,"bitWidth":3,"access":"read-write"}]},{"name":"BM_ERROR_STAT","description":"Bus Master Error Status Register","addressOffset":400,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"ADDR","description":"Virtual address at which bus master error occurred.","bitOffset":0,"bitWidth":32,"access":"read-write"}]},{"name":"CRC_STAT","description":"CRC Status Register","addressOffset":416,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"CRC_VALUE","description":"Calculated CRC value","bitOffset":0,"bitWidth":32,"access":"read-write"}]},{"name":"STAT","description":"LCD Interface Status Register","addressOffset":432,"size":32,"access":"read-only","resetValue":"0x95000000","resetMask":"0xFFFFFFFF","fields":[{"name":"LFIFO_COUNT","description":"Read only view of the current count in Latency buffer (LFIFO).","bitOffset":0,"bitWidth":9,"access":"read-only"},{"name":"TXFIFO_EMPTY","description":"Read only view of the signals that indicates LCD TXFIFO is empty.","bitOffset":26,"bitWidth":1,"access":"read-only"},{"name":"TXFIFO_FULL","description":"Read only view of the signals that indicates LCD TXFIFO is full.","bitOffset":27,"bitWidth":1,"access":"read-only"},{"name":"LFIFO_EMPTY","description":"Read only view of the signals that indicates LCD LFIFO is empty.","bitOffset":28,"bitWidth":1,"access":"read-only"},{"name":"LFIFO_FULL","description":"Read only view of the signals that indicates LCD LFIFO is full.","bitOffset":29,"bitWidth":1,"access":"read-only"},{"name":"DMA_REQ","description":"Reflects the current state of the DMA Request line for the LCDIF","bitOffset":30,"bitWidth":1,"access":"read-only"},{"name":"PRESENT","description":"0: LCDIF not present on this product 1: LCDIF is present.","bitOffset":31,"bitWidth":1,"access":"read-only"}]},{"name":"PIGEONCTRL0","description":"LCDIF Pigeon Mode Control0 Register","addressOffset":896,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"FD_PERIOD","description":"Period of line counter during FD phase","bitOffset":0,"bitWidth":12,"access":"read-write"},{"name":"LD_PERIOD","description":"Period of pclk counter during LD phase","bitOffset":16,"bitWidth":12,"access":"read-write"}]},{"name":"PIGEONCTRL0_SET","description":"LCDIF Pigeon Mode Control0 Register","addressOffset":900,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"FD_PERIOD","description":"Period of line counter during FD phase","bitOffset":0,"bitWidth":12,"access":"read-write"},{"name":"LD_PERIOD","description":"Period of pclk counter during LD phase","bitOffset":16,"bitWidth":12,"access":"read-write"}]},{"name":"PIGEONCTRL0_CLR","description":"LCDIF Pigeon Mode Control0 Register","addressOffset":904,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"FD_PERIOD","description":"Period of line counter during FD phase","bitOffset":0,"bitWidth":12,"access":"read-write"},{"name":"LD_PERIOD","description":"Period of pclk counter during LD phase","bitOffset":16,"bitWidth":12,"access":"read-write"}]},{"name":"PIGEONCTRL0_TOG","description":"LCDIF Pigeon Mode Control0 Register","addressOffset":908,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"FD_PERIOD","description":"Period of line counter during FD phase","bitOffset":0,"bitWidth":12,"access":"read-write"},{"name":"LD_PERIOD","description":"Period of pclk counter during LD phase","bitOffset":16,"bitWidth":12,"access":"read-write"}]},{"name":"PIGEONCTRL1","description":"LCDIF Pigeon Mode Control1 Register","addressOffset":912,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"FRAME_CNT_PERIOD","description":"Period of frame counter","bitOffset":0,"bitWidth":12,"access":"read-write"},{"name":"FRAME_CNT_CYCLES","description":"Max cycles of frame counter","bitOffset":16,"bitWidth":12,"access":"read-write"}]},{"name":"PIGEONCTRL1_SET","description":"LCDIF Pigeon Mode Control1 Register","addressOffset":916,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"FRAME_CNT_PERIOD","description":"Period of frame counter","bitOffset":0,"bitWidth":12,"access":"read-write"},{"name":"FRAME_CNT_CYCLES","description":"Max cycles of frame counter","bitOffset":16,"bitWidth":12,"access":"read-write"}]},{"name":"PIGEONCTRL1_CLR","description":"LCDIF Pigeon Mode Control1 Register","addressOffset":920,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"FRAME_CNT_PERIOD","description":"Period of frame counter","bitOffset":0,"bitWidth":12,"access":"read-write"},{"name":"FRAME_CNT_CYCLES","description":"Max cycles of frame counter","bitOffset":16,"bitWidth":12,"access":"read-write"}]},{"name":"PIGEONCTRL1_TOG","description":"LCDIF Pigeon Mode Control1 Register","addressOffset":924,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"FRAME_CNT_PERIOD","description":"Period of frame counter","bitOffset":0,"bitWidth":12,"access":"read-write"},{"name":"FRAME_CNT_CYCLES","description":"Max cycles of frame counter","bitOffset":16,"bitWidth":12,"access":"read-write"}]},{"name":"PIGEONCTRL2","description":"LCDIF Pigeon Mode Control2 Register","addressOffset":928,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"PIGEON_DATA_EN","description":"Pigeon mode data enable","bitOffset":0,"bitWidth":1,"access":"read-write"},{"name":"PIGEON_CLK_GATE","description":"Pigeon mode dot clock gate enable","bitOffset":1,"bitWidth":1,"access":"read-write"}]},{"name":"PIGEONCTRL2_SET","description":"LCDIF Pigeon Mode Control2 Register","addressOffset":932,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"PIGEON_DATA_EN","description":"Pigeon mode data enable","bitOffset":0,"bitWidth":1,"access":"read-write"},{"name":"PIGEON_CLK_GATE","description":"Pigeon mode dot clock gate enable","bitOffset":1,"bitWidth":1,"access":"read-write"}]},{"name":"PIGEONCTRL2_CLR","description":"LCDIF Pigeon Mode Control2 Register","addressOffset":936,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"PIGEON_DATA_EN","description":"Pigeon mode data enable","bitOffset":0,"bitWidth":1,"access":"read-write"},{"name":"PIGEON_CLK_GATE","description":"Pigeon mode dot clock gate enable","bitOffset":1,"bitWidth":1,"access":"read-write"}]},{"name":"PIGEONCTRL2_TOG","description":"LCDIF Pigeon Mode Control2 Register","addressOffset":940,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"PIGEON_DATA_EN","description":"Pigeon mode data enable","bitOffset":0,"bitWidth":1,"access":"read-write"},{"name":"PIGEON_CLK_GATE","description":"Pigeon mode dot clock gate enable","bitOffset":1,"bitWidth":1,"access":"read-write"}]},{"name":"PIGEON_0_0","description":"Panel Interface Signal Generator Register","addressOffset":2048,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"EN","description":"Enable pigeon Mode on this signal","bitOffset":0,"bitWidth":1,"access":"read-write"},{"name":"POL","description":"Polarity of signal output","bitOffset":1,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"ACTIVE_HIGH","description":"Normal Signal (Active high)","value":0},{"name":"ACTIVE_LOW","description":"Inverted signal (Active low)","value":1}]},{"name":"INC_SEL","description":"Event to incrment local counter","bitOffset":2,"bitWidth":2,"access":"read-write","enumeratedValues":[{"name":"PCLK","description":"pclk","value":0},{"name":"LINE","description":"Line start pulse","value":1},{"name":"FRAME","description":"Frame start pulse","value":2},{"name":"SIG_ANOTHER","description":"Use another signal as tick event","value":3}]},{"name":"OFFSET","description":"offset on pclk unit","bitOffset":4,"bitWidth":4,"access":"read-write"},{"name":"MASK_CNT_SEL","description":"select global counters as mask condition, use together with MASK_CNT","bitOffset":8,"bitWidth":4,"access":"read-write","enumeratedValues":[{"name":"HSTATE_CNT","description":"pclk counter within one hscan state","value":0},{"name":"HSTATE_CYCLE","description":"pclk cycle within one hscan state","value":1},{"name":"VSTATE_CNT","description":"line counter within one vscan state","value":2},{"name":"VSTATE_CYCLE","description":"line cycle within one vscan state","value":3},{"name":"FRAME_CNT","description":"frame counter","value":4},{"name":"FRAME_CYCLE","description":"frame cycle","value":5},{"name":"HCNT","description":"horizontal counter (pclk counter within one line )","value":6},{"name":"VCNT","description":"vertical counter (line counter within one frame)","value":7}]},{"name":"MASK_CNT","description":"When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking","bitOffset":12,"bitWidth":12,"access":"read-write"},{"name":"STATE_MASK","description":"state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking","bitOffset":24,"bitWidth":8,"access":"read-write","enumeratedValues":[{"name":"FS","description":"FRAME SYNC","value":1},{"name":"FB","description":"FRAME BEGIN","value":2},{"name":"FD","description":"FRAME DATA","value":4},{"name":"FE","description":"FRAME END","value":8},{"name":"LS","description":"LINE SYNC","value":16},{"name":"LB","description":"LINE BEGIN","value":32},{"name":"LD","description":"LINE DATA","value":64},{"name":"LE","description":"LINE END","value":128}]}]},{"name":"PIGEON_0_1","description":"Panel Interface Signal Generator Register","addressOffset":2064,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"SET_CNT","description":"Assert signal output when counter match this value","bitOffset":0,"bitWidth":16,"access":"read-write","enumeratedValues":[{"name":"START_ACTIVE","description":"Start as active","value":0}]},{"name":"CLR_CNT","description":"Deassert signal output when counter match this value","bitOffset":16,"bitWidth":16,"access":"read-write","enumeratedValues":[{"name":"CLEAR_USING_MASK","description":"Keep active until mask off","value":0}]}]},{"name":"PIGEON_0_2","description":"Panel Interface Signal Generator Register","addressOffset":2080,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"SIG_LOGIC","description":"Logic operation with another signal: DIS/AND/OR/COND","bitOffset":0,"bitWidth":4,"access":"read-write","enumeratedValues":[{"name":"DIS","description":"No logic operation","value":0},{"name":"AND","description":"sigout = sig_another AND this_sig","value":1},{"name":"OR","description":"sigout = sig_another OR this_sig","value":2},{"name":"MASK","description":"mask = sig_another AND other_masks","value":3}]},{"name":"SIG_ANOTHER","description":"Select another signal for logic operation or as mask or counter tick event","bitOffset":4,"bitWidth":5,"access":"read-write","enumeratedValues":[{"name":"CLEAR_USING_MASK","description":"Keep active until mask off","value":0}]}]},{"name":"PIGEON_1_0","description":"Panel Interface Signal Generator Register","addressOffset":2112,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"EN","description":"Enable pigeon Mode on this signal","bitOffset":0,"bitWidth":1,"access":"read-write"},{"name":"POL","description":"Polarity of signal output","bitOffset":1,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"ACTIVE_HIGH","description":"Normal Signal (Active high)","value":0},{"name":"ACTIVE_LOW","description":"Inverted signal (Active low)","value":1}]},{"name":"INC_SEL","description":"Event to incrment local counter","bitOffset":2,"bitWidth":2,"access":"read-write","enumeratedValues":[{"name":"PCLK","description":"pclk","value":0},{"name":"LINE","description":"Line start pulse","value":1},{"name":"FRAME","description":"Frame start pulse","value":2},{"name":"SIG_ANOTHER","description":"Use another signal as tick event","value":3}]},{"name":"OFFSET","description":"offset on pclk unit","bitOffset":4,"bitWidth":4,"access":"read-write"},{"name":"MASK_CNT_SEL","description":"select global counters as mask condition, use together with MASK_CNT","bitOffset":8,"bitWidth":4,"access":"read-write","enumeratedValues":[{"name":"HSTATE_CNT","description":"pclk counter within one hscan state","value":0},{"name":"HSTATE_CYCLE","description":"pclk cycle within one hscan state","value":1},{"name":"VSTATE_CNT","description":"line counter within one vscan state","value":2},{"name":"VSTATE_CYCLE","description":"line cycle within one vscan state","value":3},{"name":"FRAME_CNT","description":"frame counter","value":4},{"name":"FRAME_CYCLE","description":"frame cycle","value":5},{"name":"HCNT","description":"horizontal counter (pclk counter within one line )","value":6},{"name":"VCNT","description":"vertical counter (line counter within one frame)","value":7}]},{"name":"MASK_CNT","description":"When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking","bitOffset":12,"bitWidth":12,"access":"read-write"},{"name":"STATE_MASK","description":"state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking","bitOffset":24,"bitWidth":8,"access":"read-write","enumeratedValues":[{"name":"FS","description":"FRAME SYNC","value":1},{"name":"FB","description":"FRAME BEGIN","value":2},{"name":"FD","description":"FRAME DATA","value":4},{"name":"FE","description":"FRAME END","value":8},{"name":"LS","description":"LINE SYNC","value":16},{"name":"LB","description":"LINE BEGIN","value":32},{"name":"LD","description":"LINE DATA","value":64},{"name":"LE","description":"LINE END","value":128}]}]},{"name":"PIGEON_1_1","description":"Panel Interface Signal Generator Register","addressOffset":2128,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"SET_CNT","description":"Assert signal output when counter match this value","bitOffset":0,"bitWidth":16,"access":"read-write","enumeratedValues":[{"name":"START_ACTIVE","description":"Start as active","value":0}]},{"name":"CLR_CNT","description":"Deassert signal output when counter match this value","bitOffset":16,"bitWidth":16,"access":"read-write","enumeratedValues":[{"name":"CLEAR_USING_MASK","description":"Keep active until mask off","value":0}]}]},{"name":"PIGEON_1_2","description":"Panel Interface Signal Generator Register","addressOffset":2144,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"SIG_LOGIC","description":"Logic operation with another signal: DIS/AND/OR/COND","bitOffset":0,"bitWidth":4,"access":"read-write","enumeratedValues":[{"name":"DIS","description":"No logic operation","value":0},{"name":"AND","description":"sigout = sig_another AND this_sig","value":1},{"name":"OR","description":"sigout = sig_another OR this_sig","value":2},{"name":"MASK","description":"mask = sig_another AND other_masks","value":3}]},{"name":"SIG_ANOTHER","description":"Select another signal for logic operation or as mask or counter tick event","bitOffset":4,"bitWidth":5,"access":"read-write","enumeratedValues":[{"name":"CLEAR_USING_MASK","description":"Keep active until mask off","value":0}]}]},{"name":"PIGEON_2_0","description":"Panel Interface Signal Generator Register","addressOffset":2176,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"EN","description":"Enable pigeon Mode on this signal","bitOffset":0,"bitWidth":1,"access":"read-write"},{"name":"POL","description":"Polarity of signal output","bitOffset":1,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"ACTIVE_HIGH","description":"Normal Signal (Active high)","value":0},{"name":"ACTIVE_LOW","description":"Inverted signal (Active low)","value":1}]},{"name":"INC_SEL","description":"Event to incrment local counter","bitOffset":2,"bitWidth":2,"access":"read-write","enumeratedValues":[{"name":"PCLK","description":"pclk","value":0},{"name":"LINE","description":"Line start pulse","value":1},{"name":"FRAME","description":"Frame start pulse","value":2},{"name":"SIG_ANOTHER","description":"Use another signal as tick event","value":3}]},{"name":"OFFSET","description":"offset on pclk unit","bitOffset":4,"bitWidth":4,"access":"read-write"},{"name":"MASK_CNT_SEL","description":"select global counters as mask condition, use together with MASK_CNT","bitOffset":8,"bitWidth":4,"access":"read-write","enumeratedValues":[{"name":"HSTATE_CNT","description":"pclk counter within one hscan state","value":0},{"name":"HSTATE_CYCLE","description":"pclk cycle within one hscan state","value":1},{"name":"VSTATE_CNT","description":"line counter within one vscan state","value":2},{"name":"VSTATE_CYCLE","description":"line cycle within one vscan state","value":3},{"name":"FRAME_CNT","description":"frame counter","value":4},{"name":"FRAME_CYCLE","description":"frame cycle","value":5},{"name":"HCNT","description":"horizontal counter (pclk counter within one line )","value":6},{"name":"VCNT","description":"vertical counter (line counter within one frame)","value":7}]},{"name":"MASK_CNT","description":"When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking","bitOffset":12,"bitWidth":12,"access":"read-write"},{"name":"STATE_MASK","description":"state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking","bitOffset":24,"bitWidth":8,"access":"read-write","enumeratedValues":[{"name":"FS","description":"FRAME SYNC","value":1},{"name":"FB","description":"FRAME BEGIN","value":2},{"name":"FD","description":"FRAME DATA","value":4},{"name":"FE","description":"FRAME END","value":8},{"name":"LS","description":"LINE SYNC","value":16},{"name":"LB","description":"LINE BEGIN","value":32},{"name":"LD","description":"LINE DATA","value":64},{"name":"LE","description":"LINE END","value":128}]}]},{"name":"PIGEON_2_1","description":"Panel Interface Signal Generator Register","addressOffset":2192,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"SET_CNT","description":"Assert signal output when counter match this value","bitOffset":0,"bitWidth":16,"access":"read-write","enumeratedValues":[{"name":"START_ACTIVE","description":"Start as active","value":0}]},{"name":"CLR_CNT","description":"Deassert signal output when counter match this value","bitOffset":16,"bitWidth":16,"access":"read-write","enumeratedValues":[{"name":"CLEAR_USING_MASK","description":"Keep active until mask off","value":0}]}]},{"name":"PIGEON_2_2","description":"Panel Interface Signal Generator Register","addressOffset":2208,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"SIG_LOGIC","description":"Logic operation with another signal: DIS/AND/OR/COND","bitOffset":0,"bitWidth":4,"access":"read-write","enumeratedValues":[{"name":"DIS","description":"No logic operation","value":0},{"name":"AND","description":"sigout = sig_another AND this_sig","value":1},{"name":"OR","description":"sigout = sig_another OR this_sig","value":2},{"name":"MASK","description":"mask = sig_another AND other_masks","value":3}]},{"name":"SIG_ANOTHER","description":"Select another signal for logic operation or as mask or counter tick event","bitOffset":4,"bitWidth":5,"access":"read-write","enumeratedValues":[{"name":"CLEAR_USING_MASK","description":"Keep active until mask off","value":0}]}]},{"name":"PIGEON_3_0","description":"Panel Interface Signal Generator Register","addressOffset":2240,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"EN","description":"Enable pigeon Mode on this signal","bitOffset":0,"bitWidth":1,"access":"read-write"},{"name":"POL","description":"Polarity of signal output","bitOffset":1,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"ACTIVE_HIGH","description":"Normal Signal (Active high)","value":0},{"name":"ACTIVE_LOW","description":"Inverted signal (Active low)","value":1}]},{"name":"INC_SEL","description":"Event to incrment local counter","bitOffset":2,"bitWidth":2,"access":"read-write","enumeratedValues":[{"name":"PCLK","description":"pclk","value":0},{"name":"LINE","description":"Line start pulse","value":1},{"name":"FRAME","description":"Frame start pulse","value":2},{"name":"SIG_ANOTHER","description":"Use another signal as tick event","value":3}]},{"name":"OFFSET","description":"offset on pclk unit","bitOffset":4,"bitWidth":4,"access":"read-write"},{"name":"MASK_CNT_SEL","description":"select global counters as mask condition, use together with MASK_CNT","bitOffset":8,"bitWidth":4,"access":"read-write","enumeratedValues":[{"name":"HSTATE_CNT","description":"pclk counter within one hscan state","value":0},{"name":"HSTATE_CYCLE","description":"pclk cycle within one hscan state","value":1},{"name":"VSTATE_CNT","description":"line counter within one vscan state","value":2},{"name":"VSTATE_CYCLE","description":"line cycle within one vscan state","value":3},{"name":"FRAME_CNT","description":"frame counter","value":4},{"name":"FRAME_CYCLE","description":"frame cycle","value":5},{"name":"HCNT","description":"horizontal counter (pclk counter within one line )","value":6},{"name":"VCNT","description":"vertical counter (line counter within one frame)","value":7}]},{"name":"MASK_CNT","description":"When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking","bitOffset":12,"bitWidth":12,"access":"read-write"},{"name":"STATE_MASK","description":"state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking","bitOffset":24,"bitWidth":8,"access":"read-write","enumeratedValues":[{"name":"FS","description":"FRAME SYNC","value":1},{"name":"FB","description":"FRAME BEGIN","value":2},{"name":"FD","description":"FRAME DATA","value":4},{"name":"FE","description":"FRAME END","value":8},{"name":"LS","description":"LINE SYNC","value":16},{"name":"LB","description":"LINE BEGIN","value":32},{"name":"LD","description":"LINE DATA","value":64},{"name":"LE","description":"LINE END","value":128}]}]},{"name":"PIGEON_3_1","description":"Panel Interface Signal Generator Register","addressOffset":2256,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"SET_CNT","description":"Assert signal output when counter match this value","bitOffset":0,"bitWidth":16,"access":"read-write","enumeratedValues":[{"name":"START_ACTIVE","description":"Start as active","value":0}]},{"name":"CLR_CNT","description":"Deassert signal output when counter match this value","bitOffset":16,"bitWidth":16,"access":"read-write","enumeratedValues":[{"name":"CLEAR_USING_MASK","description":"Keep active until mask off","value":0}]}]},{"name":"PIGEON_3_2","description":"Panel Interface Signal Generator Register","addressOffset":2272,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"SIG_LOGIC","description":"Logic operation with another signal: DIS/AND/OR/COND","bitOffset":0,"bitWidth":4,"access":"read-write","enumeratedValues":[{"name":"DIS","description":"No logic operation","value":0},{"name":"AND","description":"sigout = sig_another AND this_sig","value":1},{"name":"OR","description":"sigout = sig_another OR this_sig","value":2},{"name":"MASK","description":"mask = sig_another AND other_masks","value":3}]},{"name":"SIG_ANOTHER","description":"Select another signal for logic operation or as mask or counter tick event","bitOffset":4,"bitWidth":5,"access":"read-write","enumeratedValues":[{"name":"CLEAR_USING_MASK","description":"Keep active until mask off","value":0}]}]},{"name":"PIGEON_4_0","description":"Panel Interface Signal Generator Register","addressOffset":2304,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"EN","description":"Enable pigeon Mode on this signal","bitOffset":0,"bitWidth":1,"access":"read-write"},{"name":"POL","description":"Polarity of signal output","bitOffset":1,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"ACTIVE_HIGH","description":"Normal Signal (Active high)","value":0},{"name":"ACTIVE_LOW","description":"Inverted signal (Active low)","value":1}]},{"name":"INC_SEL","description":"Event to incrment local counter","bitOffset":2,"bitWidth":2,"access":"read-write","enumeratedValues":[{"name":"PCLK","description":"pclk","value":0},{"name":"LINE","description":"Line start pulse","value":1},{"name":"FRAME","description":"Frame start pulse","value":2},{"name":"SIG_ANOTHER","description":"Use another signal as tick event","value":3}]},{"name":"OFFSET","description":"offset on pclk unit","bitOffset":4,"bitWidth":4,"access":"read-write"},{"name":"MASK_CNT_SEL","description":"select global counters as mask condition, use together with MASK_CNT","bitOffset":8,"bitWidth":4,"access":"read-write","enumeratedValues":[{"name":"HSTATE_CNT","description":"pclk counter within one hscan state","value":0},{"name":"HSTATE_CYCLE","description":"pclk cycle within one hscan state","value":1},{"name":"VSTATE_CNT","description":"line counter within one vscan state","value":2},{"name":"VSTATE_CYCLE","description":"line cycle within one vscan state","value":3},{"name":"FRAME_CNT","description":"frame counter","value":4},{"name":"FRAME_CYCLE","description":"frame cycle","value":5},{"name":"HCNT","description":"horizontal counter (pclk counter within one line )","value":6},{"name":"VCNT","description":"vertical counter (line counter within one frame)","value":7}]},{"name":"MASK_CNT","description":"When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking","bitOffset":12,"bitWidth":12,"access":"read-write"},{"name":"STATE_MASK","description":"state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking","bitOffset":24,"bitWidth":8,"access":"read-write","enumeratedValues":[{"name":"FS","description":"FRAME SYNC","value":1},{"name":"FB","description":"FRAME BEGIN","value":2},{"name":"FD","description":"FRAME DATA","value":4},{"name":"FE","description":"FRAME END","value":8},{"name":"LS","description":"LINE SYNC","value":16},{"name":"LB","description":"LINE BEGIN","value":32},{"name":"LD","description":"LINE DATA","value":64},{"name":"LE","description":"LINE END","value":128}]}]},{"name":"PIGEON_4_1","description":"Panel Interface Signal Generator Register","addressOffset":2320,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"SET_CNT","description":"Assert signal output when counter match this value","bitOffset":0,"bitWidth":16,"access":"read-write","enumeratedValues":[{"name":"START_ACTIVE","description":"Start as active","value":0}]},{"name":"CLR_CNT","description":"Deassert signal output when counter match this value","bitOffset":16,"bitWidth":16,"access":"read-write","enumeratedValues":[{"name":"CLEAR_USING_MASK","description":"Keep active until mask off","value":0}]}]},{"name":"PIGEON_4_2","description":"Panel Interface Signal Generator Register","addressOffset":2336,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"SIG_LOGIC","description":"Logic operation with another signal: DIS/AND/OR/COND","bitOffset":0,"bitWidth":4,"access":"read-write","enumeratedValues":[{"name":"DIS","description":"No logic operation","value":0},{"name":"AND","description":"sigout = sig_another AND this_sig","value":1},{"name":"OR","description":"sigout = sig_another OR this_sig","value":2},{"name":"MASK","description":"mask = sig_another AND other_masks","value":3}]},{"name":"SIG_ANOTHER","description":"Select another signal for logic operation or as mask or counter tick event","bitOffset":4,"bitWidth":5,"access":"read-write","enumeratedValues":[{"name":"CLEAR_USING_MASK","description":"Keep active until mask off","value":0}]}]},{"name":"PIGEON_5_0","description":"Panel Interface Signal Generator Register","addressOffset":2368,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"EN","description":"Enable pigeon Mode on this signal","bitOffset":0,"bitWidth":1,"access":"read-write"},{"name":"POL","description":"Polarity of signal output","bitOffset":1,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"ACTIVE_HIGH","description":"Normal Signal (Active high)","value":0},{"name":"ACTIVE_LOW","description":"Inverted signal (Active low)","value":1}]},{"name":"INC_SEL","description":"Event to incrment local counter","bitOffset":2,"bitWidth":2,"access":"read-write","enumeratedValues":[{"name":"PCLK","description":"pclk","value":0},{"name":"LINE","description":"Line start pulse","value":1},{"name":"FRAME","description":"Frame start pulse","value":2},{"name":"SIG_ANOTHER","description":"Use another signal as tick event","value":3}]},{"name":"OFFSET","description":"offset on pclk unit","bitOffset":4,"bitWidth":4,"access":"read-write"},{"name":"MASK_CNT_SEL","description":"select global counters as mask condition, use together with MASK_CNT","bitOffset":8,"bitWidth":4,"access":"read-write","enumeratedValues":[{"name":"HSTATE_CNT","description":"pclk counter within one hscan state","value":0},{"name":"HSTATE_CYCLE","description":"pclk cycle within one hscan state","value":1},{"name":"VSTATE_CNT","description":"line counter within one vscan state","value":2},{"name":"VSTATE_CYCLE","description":"line cycle within one vscan state","value":3},{"name":"FRAME_CNT","description":"frame counter","value":4},{"name":"FRAME_CYCLE","description":"frame cycle","value":5},{"name":"HCNT","description":"horizontal counter (pclk counter within one line )","value":6},{"name":"VCNT","description":"vertical counter (line counter within one frame)","value":7}]},{"name":"MASK_CNT","description":"When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking","bitOffset":12,"bitWidth":12,"access":"read-write"},{"name":"STATE_MASK","description":"state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking","bitOffset":24,"bitWidth":8,"access":"read-write","enumeratedValues":[{"name":"FS","description":"FRAME SYNC","value":1},{"name":"FB","description":"FRAME BEGIN","value":2},{"name":"FD","description":"FRAME DATA","value":4},{"name":"FE","description":"FRAME END","value":8},{"name":"LS","description":"LINE SYNC","value":16},{"name":"LB","description":"LINE BEGIN","value":32},{"name":"LD","description":"LINE DATA","value":64},{"name":"LE","description":"LINE END","value":128}]}]},{"name":"PIGEON_5_1","description":"Panel Interface Signal Generator Register","addressOffset":2384,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"SET_CNT","description":"Assert signal output when counter match this value","bitOffset":0,"bitWidth":16,"access":"read-write","enumeratedValues":[{"name":"START_ACTIVE","description":"Start as active","value":0}]},{"name":"CLR_CNT","description":"Deassert signal output when counter match this value","bitOffset":16,"bitWidth":16,"access":"read-write","enumeratedValues":[{"name":"CLEAR_USING_MASK","description":"Keep active until mask off","value":0}]}]},{"name":"PIGEON_5_2","description":"Panel Interface Signal Generator Register","addressOffset":2400,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"SIG_LOGIC","description":"Logic operation with another signal: DIS/AND/OR/COND","bitOffset":0,"bitWidth":4,"access":"read-write","enumeratedValues":[{"name":"DIS","description":"No logic operation","value":0},{"name":"AND","description":"sigout = sig_another AND this_sig","value":1},{"name":"OR","description":"sigout = sig_another OR this_sig","value":2},{"name":"MASK","description":"mask = sig_another AND other_masks","value":3}]},{"name":"SIG_ANOTHER","description":"Select another signal for logic operation or as mask or counter tick event","bitOffset":4,"bitWidth":5,"access":"read-write","enumeratedValues":[{"name":"CLEAR_USING_MASK","description":"Keep active until mask off","value":0}]}]},{"name":"PIGEON_6_0","description":"Panel Interface Signal Generator Register","addressOffset":2432,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"EN","description":"Enable pigeon Mode on this signal","bitOffset":0,"bitWidth":1,"access":"read-write"},{"name":"POL","description":"Polarity of signal output","bitOffset":1,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"ACTIVE_HIGH","description":"Normal Signal (Active high)","value":0},{"name":"ACTIVE_LOW","description":"Inverted signal (Active low)","value":1}]},{"name":"INC_SEL","description":"Event to incrment local counter","bitOffset":2,"bitWidth":2,"access":"read-write","enumeratedValues":[{"name":"PCLK","description":"pclk","value":0},{"name":"LINE","description":"Line start pulse","value":1},{"name":"FRAME","description":"Frame start pulse","value":2},{"name":"SIG_ANOTHER","description":"Use another signal as tick event","value":3}]},{"name":"OFFSET","description":"offset on pclk unit","bitOffset":4,"bitWidth":4,"access":"read-write"},{"name":"MASK_CNT_SEL","description":"select global counters as mask condition, use together with MASK_CNT","bitOffset":8,"bitWidth":4,"access":"read-write","enumeratedValues":[{"name":"HSTATE_CNT","description":"pclk counter within one hscan state","value":0},{"name":"HSTATE_CYCLE","description":"pclk cycle within one hscan state","value":1},{"name":"VSTATE_CNT","description":"line counter within one vscan state","value":2},{"name":"VSTATE_CYCLE","description":"line cycle within one vscan state","value":3},{"name":"FRAME_CNT","description":"frame counter","value":4},{"name":"FRAME_CYCLE","description":"frame cycle","value":5},{"name":"HCNT","description":"horizontal counter (pclk counter within one line )","value":6},{"name":"VCNT","description":"vertical counter (line counter within one frame)","value":7}]},{"name":"MASK_CNT","description":"When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking","bitOffset":12,"bitWidth":12,"access":"read-write"},{"name":"STATE_MASK","description":"state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking","bitOffset":24,"bitWidth":8,"access":"read-write","enumeratedValues":[{"name":"FS","description":"FRAME SYNC","value":1},{"name":"FB","description":"FRAME BEGIN","value":2},{"name":"FD","description":"FRAME DATA","value":4},{"name":"FE","description":"FRAME END","value":8},{"name":"LS","description":"LINE SYNC","value":16},{"name":"LB","description":"LINE BEGIN","value":32},{"name":"LD","description":"LINE DATA","value":64},{"name":"LE","description":"LINE END","value":128}]}]},{"name":"PIGEON_6_1","description":"Panel Interface Signal Generator Register","addressOffset":2448,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"SET_CNT","description":"Assert signal output when counter match this value","bitOffset":0,"bitWidth":16,"access":"read-write","enumeratedValues":[{"name":"START_ACTIVE","description":"Start as active","value":0}]},{"name":"CLR_CNT","description":"Deassert signal output when counter match this value","bitOffset":16,"bitWidth":16,"access":"read-write","enumeratedValues":[{"name":"CLEAR_USING_MASK","description":"Keep active until mask off","value":0}]}]},{"name":"PIGEON_6_2","description":"Panel Interface Signal Generator Register","addressOffset":2464,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"SIG_LOGIC","description":"Logic operation with another signal: DIS/AND/OR/COND","bitOffset":0,"bitWidth":4,"access":"read-write","enumeratedValues":[{"name":"DIS","description":"No logic operation","value":0},{"name":"AND","description":"sigout = sig_another AND this_sig","value":1},{"name":"OR","description":"sigout = sig_another OR this_sig","value":2},{"name":"MASK","description":"mask = sig_another AND other_masks","value":3}]},{"name":"SIG_ANOTHER","description":"Select another signal for logic operation or as mask or counter tick event","bitOffset":4,"bitWidth":5,"access":"read-write","enumeratedValues":[{"name":"CLEAR_USING_MASK","description":"Keep active until mask off","value":0}]}]},{"name":"PIGEON_7_0","description":"Panel Interface Signal Generator Register","addressOffset":2496,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"EN","description":"Enable pigeon Mode on this signal","bitOffset":0,"bitWidth":1,"access":"read-write"},{"name":"POL","description":"Polarity of signal output","bitOffset":1,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"ACTIVE_HIGH","description":"Normal Signal (Active high)","value":0},{"name":"ACTIVE_LOW","description":"Inverted signal (Active low)","value":1}]},{"name":"INC_SEL","description":"Event to incrment local counter","bitOffset":2,"bitWidth":2,"access":"read-write","enumeratedValues":[{"name":"PCLK","description":"pclk","value":0},{"name":"LINE","description":"Line start pulse","value":1},{"name":"FRAME","description":"Frame start pulse","value":2},{"name":"SIG_ANOTHER","description":"Use another signal as tick event","value":3}]},{"name":"OFFSET","description":"offset on pclk unit","bitOffset":4,"bitWidth":4,"access":"read-write"},{"name":"MASK_CNT_SEL","description":"select global counters as mask condition, use together with MASK_CNT","bitOffset":8,"bitWidth":4,"access":"read-write","enumeratedValues":[{"name":"HSTATE_CNT","description":"pclk counter within one hscan state","value":0},{"name":"HSTATE_CYCLE","description":"pclk cycle within one hscan state","value":1},{"name":"VSTATE_CNT","description":"line counter within one vscan state","value":2},{"name":"VSTATE_CYCLE","description":"line cycle within one vscan state","value":3},{"name":"FRAME_CNT","description":"frame counter","value":4},{"name":"FRAME_CYCLE","description":"frame cycle","value":5},{"name":"HCNT","description":"horizontal counter (pclk counter within one line )","value":6},{"name":"VCNT","description":"vertical counter (line counter within one frame)","value":7}]},{"name":"MASK_CNT","description":"When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking","bitOffset":12,"bitWidth":12,"access":"read-write"},{"name":"STATE_MASK","description":"state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking","bitOffset":24,"bitWidth":8,"access":"read-write","enumeratedValues":[{"name":"FS","description":"FRAME SYNC","value":1},{"name":"FB","description":"FRAME BEGIN","value":2},{"name":"FD","description":"FRAME DATA","value":4},{"name":"FE","description":"FRAME END","value":8},{"name":"LS","description":"LINE SYNC","value":16},{"name":"LB","description":"LINE BEGIN","value":32},{"name":"LD","description":"LINE DATA","value":64},{"name":"LE","description":"LINE END","value":128}]}]},{"name":"PIGEON_7_1","description":"Panel Interface Signal Generator Register","addressOffset":2512,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"SET_CNT","description":"Assert signal output when counter match this value","bitOffset":0,"bitWidth":16,"access":"read-write","enumeratedValues":[{"name":"START_ACTIVE","description":"Start as active","value":0}]},{"name":"CLR_CNT","description":"Deassert signal output when counter match this value","bitOffset":16,"bitWidth":16,"access":"read-write","enumeratedValues":[{"name":"CLEAR_USING_MASK","description":"Keep active until mask off","value":0}]}]},{"name":"PIGEON_7_2","description":"Panel Interface Signal Generator Register","addressOffset":2528,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"SIG_LOGIC","description":"Logic operation with another signal: DIS/AND/OR/COND","bitOffset":0,"bitWidth":4,"access":"read-write","enumeratedValues":[{"name":"DIS","description":"No logic operation","value":0},{"name":"AND","description":"sigout = sig_another AND this_sig","value":1},{"name":"OR","description":"sigout = sig_another OR this_sig","value":2},{"name":"MASK","description":"mask = sig_another AND other_masks","value":3}]},{"name":"SIG_ANOTHER","description":"Select another signal for logic operation or as mask or counter tick event","bitOffset":4,"bitWidth":5,"access":"read-write","enumeratedValues":[{"name":"CLEAR_USING_MASK","description":"Keep active until mask off","value":0}]}]},{"name":"PIGEON_8_0","description":"Panel Interface Signal Generator Register","addressOffset":2560,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"EN","description":"Enable pigeon Mode on this signal","bitOffset":0,"bitWidth":1,"access":"read-write"},{"name":"POL","description":"Polarity of signal output","bitOffset":1,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"ACTIVE_HIGH","description":"Normal Signal (Active high)","value":0},{"name":"ACTIVE_LOW","description":"Inverted signal (Active low)","value":1}]},{"name":"INC_SEL","description":"Event to incrment local counter","bitOffset":2,"bitWidth":2,"access":"read-write","enumeratedValues":[{"name":"PCLK","description":"pclk","value":0},{"name":"LINE","description":"Line start pulse","value":1},{"name":"FRAME","description":"Frame start pulse","value":2},{"name":"SIG_ANOTHER","description":"Use another signal as tick event","value":3}]},{"name":"OFFSET","description":"offset on pclk unit","bitOffset":4,"bitWidth":4,"access":"read-write"},{"name":"MASK_CNT_SEL","description":"select global counters as mask condition, use together with MASK_CNT","bitOffset":8,"bitWidth":4,"access":"read-write","enumeratedValues":[{"name":"HSTATE_CNT","description":"pclk counter within one hscan state","value":0},{"name":"HSTATE_CYCLE","description":"pclk cycle within one hscan state","value":1},{"name":"VSTATE_CNT","description":"line counter within one vscan state","value":2},{"name":"VSTATE_CYCLE","description":"line cycle within one vscan state","value":3},{"name":"FRAME_CNT","description":"frame counter","value":4},{"name":"FRAME_CYCLE","description":"frame cycle","value":5},{"name":"HCNT","description":"horizontal counter (pclk counter within one line )","value":6},{"name":"VCNT","description":"vertical counter (line counter within one frame)","value":7}]},{"name":"MASK_CNT","description":"When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking","bitOffset":12,"bitWidth":12,"access":"read-write"},{"name":"STATE_MASK","description":"state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking","bitOffset":24,"bitWidth":8,"access":"read-write","enumeratedValues":[{"name":"FS","description":"FRAME SYNC","value":1},{"name":"FB","description":"FRAME BEGIN","value":2},{"name":"FD","description":"FRAME DATA","value":4},{"name":"FE","description":"FRAME END","value":8},{"name":"LS","description":"LINE SYNC","value":16},{"name":"LB","description":"LINE BEGIN","value":32},{"name":"LD","description":"LINE DATA","value":64},{"name":"LE","description":"LINE END","value":128}]}]},{"name":"PIGEON_8_1","description":"Panel Interface Signal Generator Register","addressOffset":2576,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"SET_CNT","description":"Assert signal output when counter match this value","bitOffset":0,"bitWidth":16,"access":"read-write","enumeratedValues":[{"name":"START_ACTIVE","description":"Start as active","value":0}]},{"name":"CLR_CNT","description":"Deassert signal output when counter match this value","bitOffset":16,"bitWidth":16,"access":"read-write","enumeratedValues":[{"name":"CLEAR_USING_MASK","description":"Keep active until mask off","value":0}]}]},{"name":"PIGEON_8_2","description":"Panel Interface Signal Generator Register","addressOffset":2592,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"SIG_LOGIC","description":"Logic operation with another signal: DIS/AND/OR/COND","bitOffset":0,"bitWidth":4,"access":"read-write","enumeratedValues":[{"name":"DIS","description":"No logic operation","value":0},{"name":"AND","description":"sigout = sig_another AND this_sig","value":1},{"name":"OR","description":"sigout = sig_another OR this_sig","value":2},{"name":"MASK","description":"mask = sig_another AND other_masks","value":3}]},{"name":"SIG_ANOTHER","description":"Select another signal for logic operation or as mask or counter tick event","bitOffset":4,"bitWidth":5,"access":"read-write","enumeratedValues":[{"name":"CLEAR_USING_MASK","description":"Keep active until mask off","value":0}]}]},{"name":"PIGEON_9_0","description":"Panel Interface Signal Generator Register","addressOffset":2624,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"EN","description":"Enable pigeon Mode on this signal","bitOffset":0,"bitWidth":1,"access":"read-write"},{"name":"POL","description":"Polarity of signal output","bitOffset":1,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"ACTIVE_HIGH","description":"Normal Signal (Active high)","value":0},{"name":"ACTIVE_LOW","description":"Inverted signal (Active low)","value":1}]},{"name":"INC_SEL","description":"Event to incrment local counter","bitOffset":2,"bitWidth":2,"access":"read-write","enumeratedValues":[{"name":"PCLK","description":"pclk","value":0},{"name":"LINE","description":"Line start pulse","value":1},{"name":"FRAME","description":"Frame start pulse","value":2},{"name":"SIG_ANOTHER","description":"Use another signal as tick event","value":3}]},{"name":"OFFSET","description":"offset on pclk unit","bitOffset":4,"bitWidth":4,"access":"read-write"},{"name":"MASK_CNT_SEL","description":"select global counters as mask condition, use together with MASK_CNT","bitOffset":8,"bitWidth":4,"access":"read-write","enumeratedValues":[{"name":"HSTATE_CNT","description":"pclk counter within one hscan state","value":0},{"name":"HSTATE_CYCLE","description":"pclk cycle within one hscan state","value":1},{"name":"VSTATE_CNT","description":"line counter within one vscan state","value":2},{"name":"VSTATE_CYCLE","description":"line cycle within one vscan state","value":3},{"name":"FRAME_CNT","description":"frame counter","value":4},{"name":"FRAME_CYCLE","description":"frame cycle","value":5},{"name":"HCNT","description":"horizontal counter (pclk counter within one line )","value":6},{"name":"VCNT","description":"vertical counter (line counter within one frame)","value":7}]},{"name":"MASK_CNT","description":"When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking","bitOffset":12,"bitWidth":12,"access":"read-write"},{"name":"STATE_MASK","description":"state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking","bitOffset":24,"bitWidth":8,"access":"read-write","enumeratedValues":[{"name":"FS","description":"FRAME SYNC","value":1},{"name":"FB","description":"FRAME BEGIN","value":2},{"name":"FD","description":"FRAME DATA","value":4},{"name":"FE","description":"FRAME END","value":8},{"name":"LS","description":"LINE SYNC","value":16},{"name":"LB","description":"LINE BEGIN","value":32},{"name":"LD","description":"LINE DATA","value":64},{"name":"LE","description":"LINE END","value":128}]}]},{"name":"PIGEON_9_1","description":"Panel Interface Signal Generator Register","addressOffset":2640,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"SET_CNT","description":"Assert signal output when counter match this value","bitOffset":0,"bitWidth":16,"access":"read-write","enumeratedValues":[{"name":"START_ACTIVE","description":"Start as active","value":0}]},{"name":"CLR_CNT","description":"Deassert signal output when counter match this value","bitOffset":16,"bitWidth":16,"access":"read-write","enumeratedValues":[{"name":"CLEAR_USING_MASK","description":"Keep active until mask off","value":0}]}]},{"name":"PIGEON_9_2","description":"Panel Interface Signal Generator Register","addressOffset":2656,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"SIG_LOGIC","description":"Logic operation with another signal: DIS/AND/OR/COND","bitOffset":0,"bitWidth":4,"access":"read-write","enumeratedValues":[{"name":"DIS","description":"No logic operation","value":0},{"name":"AND","description":"sigout = sig_another AND this_sig","value":1},{"name":"OR","description":"sigout = sig_another OR this_sig","value":2},{"name":"MASK","description":"mask = sig_another AND other_masks","value":3}]},{"name":"SIG_ANOTHER","description":"Select another signal for logic operation or as mask or counter tick event","bitOffset":4,"bitWidth":5,"access":"read-write","enumeratedValues":[{"name":"CLEAR_USING_MASK","description":"Keep active until mask off","value":0}]}]},{"name":"PIGEON_10_0","description":"Panel Interface Signal Generator Register","addressOffset":2688,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"EN","description":"Enable pigeon Mode on this signal","bitOffset":0,"bitWidth":1,"access":"read-write"},{"name":"POL","description":"Polarity of signal output","bitOffset":1,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"ACTIVE_HIGH","description":"Normal Signal (Active high)","value":0},{"name":"ACTIVE_LOW","description":"Inverted signal (Active low)","value":1}]},{"name":"INC_SEL","description":"Event to incrment local counter","bitOffset":2,"bitWidth":2,"access":"read-write","enumeratedValues":[{"name":"PCLK","description":"pclk","value":0},{"name":"LINE","description":"Line start pulse","value":1},{"name":"FRAME","description":"Frame start pulse","value":2},{"name":"SIG_ANOTHER","description":"Use another signal as tick event","value":3}]},{"name":"OFFSET","description":"offset on pclk unit","bitOffset":4,"bitWidth":4,"access":"read-write"},{"name":"MASK_CNT_SEL","description":"select global counters as mask condition, use together with MASK_CNT","bitOffset":8,"bitWidth":4,"access":"read-write","enumeratedValues":[{"name":"HSTATE_CNT","description":"pclk counter within one hscan state","value":0},{"name":"HSTATE_CYCLE","description":"pclk cycle within one hscan state","value":1},{"name":"VSTATE_CNT","description":"line counter within one vscan state","value":2},{"name":"VSTATE_CYCLE","description":"line cycle within one vscan state","value":3},{"name":"FRAME_CNT","description":"frame counter","value":4},{"name":"FRAME_CYCLE","description":"frame cycle","value":5},{"name":"HCNT","description":"horizontal counter (pclk counter within one line )","value":6},{"name":"VCNT","description":"vertical counter (line counter within one frame)","value":7}]},{"name":"MASK_CNT","description":"When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking","bitOffset":12,"bitWidth":12,"access":"read-write"},{"name":"STATE_MASK","description":"state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking","bitOffset":24,"bitWidth":8,"access":"read-write","enumeratedValues":[{"name":"FS","description":"FRAME SYNC","value":1},{"name":"FB","description":"FRAME BEGIN","value":2},{"name":"FD","description":"FRAME DATA","value":4},{"name":"FE","description":"FRAME END","value":8},{"name":"LS","description":"LINE SYNC","value":16},{"name":"LB","description":"LINE BEGIN","value":32},{"name":"LD","description":"LINE DATA","value":64},{"name":"LE","description":"LINE END","value":128}]}]},{"name":"PIGEON_10_1","description":"Panel Interface Signal Generator Register","addressOffset":2704,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"SET_CNT","description":"Assert signal output when counter match this value","bitOffset":0,"bitWidth":16,"access":"read-write","enumeratedValues":[{"name":"START_ACTIVE","description":"Start as active","value":0}]},{"name":"CLR_CNT","description":"Deassert signal output when counter match this value","bitOffset":16,"bitWidth":16,"access":"read-write","enumeratedValues":[{"name":"CLEAR_USING_MASK","description":"Keep active until mask off","value":0}]}]},{"name":"PIGEON_10_2","description":"Panel Interface Signal Generator Register","addressOffset":2720,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"SIG_LOGIC","description":"Logic operation with another signal: DIS/AND/OR/COND","bitOffset":0,"bitWidth":4,"access":"read-write","enumeratedValues":[{"name":"DIS","description":"No logic operation","value":0},{"name":"AND","description":"sigout = sig_another AND this_sig","value":1},{"name":"OR","description":"sigout = sig_another OR this_sig","value":2},{"name":"MASK","description":"mask = sig_another AND other_masks","value":3}]},{"name":"SIG_ANOTHER","description":"Select another signal for logic operation or as mask or counter tick event","bitOffset":4,"bitWidth":5,"access":"read-write","enumeratedValues":[{"name":"CLEAR_USING_MASK","description":"Keep active until mask off","value":0}]}]},{"name":"PIGEON_11_0","description":"Panel Interface Signal Generator Register","addressOffset":2752,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"EN","description":"Enable pigeon Mode on this signal","bitOffset":0,"bitWidth":1,"access":"read-write"},{"name":"POL","description":"Polarity of signal output","bitOffset":1,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"ACTIVE_HIGH","description":"Normal Signal (Active high)","value":0},{"name":"ACTIVE_LOW","description":"Inverted signal (Active low)","value":1}]},{"name":"INC_SEL","description":"Event to incrment local counter","bitOffset":2,"bitWidth":2,"access":"read-write","enumeratedValues":[{"name":"PCLK","description":"pclk","value":0},{"name":"LINE","description":"Line start pulse","value":1},{"name":"FRAME","description":"Frame start pulse","value":2},{"name":"SIG_ANOTHER","description":"Use another signal as tick event","value":3}]},{"name":"OFFSET","description":"offset on pclk unit","bitOffset":4,"bitWidth":4,"access":"read-write"},{"name":"MASK_CNT_SEL","description":"select global counters as mask condition, use together with MASK_CNT","bitOffset":8,"bitWidth":4,"access":"read-write","enumeratedValues":[{"name":"HSTATE_CNT","description":"pclk counter within one hscan state","value":0},{"name":"HSTATE_CYCLE","description":"pclk cycle within one hscan state","value":1},{"name":"VSTATE_CNT","description":"line counter within one vscan state","value":2},{"name":"VSTATE_CYCLE","description":"line cycle within one vscan state","value":3},{"name":"FRAME_CNT","description":"frame counter","value":4},{"name":"FRAME_CYCLE","description":"frame cycle","value":5},{"name":"HCNT","description":"horizontal counter (pclk counter within one line )","value":6},{"name":"VCNT","description":"vertical counter (line counter within one frame)","value":7}]},{"name":"MASK_CNT","description":"When the global counter selected through MASK_CNT_SEL matches value in this reg, pigeon local counter start ticking","bitOffset":12,"bitWidth":12,"access":"read-write"},{"name":"STATE_MASK","description":"state_mask = (FS|FB|FD|FE) and (LS|LB|LD|LE) , select any combination of scan states as reference point for local counter to start ticking","bitOffset":24,"bitWidth":8,"access":"read-write","enumeratedValues":[{"name":"FS","description":"FRAME SYNC","value":1},{"name":"FB","description":"FRAME BEGIN","value":2},{"name":"FD","description":"FRAME DATA","value":4},{"name":"FE","description":"FRAME END","value":8},{"name":"LS","description":"LINE SYNC","value":16},{"name":"LB","description":"LINE BEGIN","value":32},{"name":"LD","description":"LINE DATA","value":64},{"name":"LE","description":"LINE END","value":128}]}]},{"name":"PIGEON_11_1","description":"Panel Interface Signal Generator Register","addressOffset":2768,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"SET_CNT","description":"Assert signal output when counter match this value","bitOffset":0,"bitWidth":16,"access":"read-write","enumeratedValues":[{"name":"START_ACTIVE","description":"Start as active","value":0}]},{"name":"CLR_CNT","description":"Deassert signal output when counter match this value","bitOffset":16,"bitWidth":16,"access":"read-write","enumeratedValues":[{"name":"CLEAR_USING_MASK","description":"Keep active until mask off","value":0}]}]},{"name":"PIGEON_11_2","description":"Panel Interface Signal Generator Register","addressOffset":2784,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"SIG_LOGIC","description":"Logic operation with another signal: DIS/AND/OR/COND","bitOffset":0,"bitWidth":4,"access":"read-write","enumeratedValues":[{"name":"DIS","description":"No logic operation","value":0},{"name":"AND","description":"sigout = sig_another AND this_sig","value":1},{"name":"OR","description":"sigout = sig_another OR this_sig","value":2},{"name":"MASK","description":"mask = sig_another AND other_masks","value":3}]},{"name":"SIG_ANOTHER","description":"Select another signal for logic operation or as mask or counter tick event","bitOffset":4,"bitWidth":5,"access":"read-write","enumeratedValues":[{"name":"CLEAR_USING_MASK","description":"Keep active until mask off","value":0}]}]},{"name":"LUT_CTRL","description":"Look Up Table Control Register","addressOffset":2816,"size":32,"access":"read-write","resetValue":"0x1","resetMask":"0xFFFFFFFF","fields":[{"name":"LUT_BYPASS","description":"Setting this bit will bypass the LUT memory resource completely","bitOffset":0,"bitWidth":1,"access":"read-write"}]},{"name":"LUT0_ADDR","description":"Lookup Table 0 Index Register","addressOffset":2832,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"ADDR","description":"LUT indexed address pointer","bitOffset":0,"bitWidth":8,"access":"read-write"}]},{"name":"LUT0_DATA","description":"Lookup Table 0 Data Register","addressOffset":2848,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"DATA","description":"Writing this field will load 4 bytes, aligned to four byte boundaries, of data indexed by the ADDR field of the REG_LUT_CTRL register","bitOffset":0,"bitWidth":32,"access":"read-write"}]},{"name":"LUT1_ADDR","description":"Lookup Table 1 Index Register","addressOffset":2864,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"ADDR","description":"LUT indexed address pointer","bitOffset":0,"bitWidth":8,"access":"read-write"}]},{"name":"LUT1_DATA","description":"Lookup Table 1 Data Register","addressOffset":2880,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"DATA","description":"Writing this field will load 4 bytes, aligned to four byte boundaries, of data indexed by the ADDR field of the REG_LUT_CTRL register","bitOffset":0,"bitWidth":32,"access":"read-write"}]}],"addressBlock":{"offset":"0","size":"0xB44","usage":"registers"}}