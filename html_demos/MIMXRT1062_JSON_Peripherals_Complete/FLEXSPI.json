{"name":"FLEXSPI","description":"FlexSPI","groupName":"FlexSPI","baseAddress":"0x402A8000","registers":[{"name":"MCR0","description":"Module Control Register 0","addressOffset":0,"size":32,"access":"read-write","resetValue":"0xFFFF8002","resetMask":"0xFFFFFFFF","fields":[{"name":"SWRESET","description":"Software Reset","bitOffset":0,"bitWidth":1,"access":"read-write"},{"name":"MDIS","description":"Module Disable","bitOffset":1,"bitWidth":1,"access":"read-write"},{"name":"RXCLKSRC","description":"Sample Clock source selection for Flash Reading","bitOffset":4,"bitWidth":2,"access":"read-write","enumeratedValues":[{"name":"val0","description":"Dummy Read strobe generated by FlexSPI Controller and loopback internally.","value":0},{"name":"val1","description":"Dummy Read strobe generated by FlexSPI Controller and loopback from DQS pad.","value":1},{"name":"val3","description":"Flash provided Read strobe and input from DQS pad","value":3}]},{"name":"ARDFEN","description":"Enable AHB bus Read Access to IP RX FIFO.","bitOffset":6,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"val0","description":"IP RX FIFO should be read by IP Bus. AHB Bus read access to IP RX FIFO memory space will get bus error response.","value":0},{"name":"val1","description":"IP RX FIFO should be read by AHB Bus. IP Bus read access to IP RX FIFO memory space will always return data zero but no bus error response.","value":1}]},{"name":"ATDFEN","description":"Enable AHB bus Write Access to IP TX FIFO.","bitOffset":7,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"val0","description":"IP TX FIFO should be written by IP Bus. AHB Bus write access to IP TX FIFO memory space will get bus error response.","value":0},{"name":"val1","description":"IP TX FIFO should be written by AHB Bus. IP Bus write access to IP TX FIFO memory space will be ignored but no bus error response.","value":1}]},{"name":"SERCLKDIV","description":"Serial root clock","bitOffset":8,"bitWidth":3,"access":"read-write","enumeratedValues":[{"name":"val0","description":"Divided by 1","value":0},{"name":"val1","description":"Divided by 2","value":1},{"name":"val2","description":"Divided by 3","value":2},{"name":"val3","description":"Divided by 4","value":3},{"name":"val4","description":"Divided by 5","value":4},{"name":"val5","description":"Divided by 6","value":5},{"name":"val6","description":"Divided by 7","value":6},{"name":"val7","description":"Divided by 8","value":7}]},{"name":"HSEN","description":"Half Speed Serial Flash Access Enable.","bitOffset":11,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"val0","description":"Disable divide by 2 of serial flash clock for half speed commands.","value":0},{"name":"val1","description":"Enable divide by 2 of serial flash clock for half speed commands.","value":1}]},{"name":"DOZEEN","description":"Doze mode enable bit","bitOffset":12,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"val0","description":"Doze mode support disabled. AHB clock and serial clock will not be gated off when there is doze mode request from system.","value":0},{"name":"val1","description":"Doze mode support enabled. AHB clock and serial clock will be gated off when there is doze mode request from system.","value":1}]},{"name":"COMBINATIONEN","description":"This bit is to support Flash Octal mode access by combining Port A and B Data pins (A_DATA[3:0] and B_DATA[3:0]), when Port A and Port B are of 4 bit data width.","bitOffset":13,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"DISABLE","description":"Disable.","value":0},{"name":"ENABLE","description":"Enable.","value":1}]},{"name":"SCKFREERUNEN","description":"This bit is used to enable SCLK output free-running. For FPGA applications, the external device may use SCLK as reference clock to its internal PLL.","bitOffset":14,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"DISABLE","description":"Disable.","value":0},{"name":"ENABLE","description":"Enable.","value":1}]},{"name":"IPGRANTWAIT","description":"Timeout wait cycle for IP command grant.","bitOffset":16,"bitWidth":8,"access":"read-write"},{"name":"AHBGRANTWAIT","description":"Timeout wait cycle for AHB command grant.","bitOffset":24,"bitWidth":8,"access":"read-write"}]},{"name":"MCR1","description":"Module Control Register 1","addressOffset":4,"size":32,"access":"read-write","resetValue":"0xFFFFFFFF","resetMask":"0xFFFFFFFF","fields":[{"name":"AHBBUSWAIT","description":"AHB Bus wait","bitOffset":0,"bitWidth":16,"access":"read-write"},{"name":"SEQWAIT","description":"Command Sequence Execution will timeout and abort after SEQWAIT * 1024 Serial Root Clock cycles. When sequence execution timeout occurs, there will be an interrupt generated (INTR[SEQTIMEOUT]) if this interrupt is enabled (INTEN[SEQTIMEOUTEN] is set 0x1) and AHB command is ignored by arbitrator.","bitOffset":16,"bitWidth":16,"access":"read-write"}]},{"name":"MCR2","description":"Module Control Register 2","addressOffset":8,"size":32,"access":"read-write","resetValue":"0x200081F7","resetMask":"0xFFFFFFFF","fields":[{"name":"CLRAHBBUFOPT","description":"Clear AHB buffer","bitOffset":11,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"val0","description":"AHB RX/TX Buffer will not be cleared automatically when FlexSPI returns Stop mode ACK.","value":0},{"name":"val1","description":"AHB RX/TX Buffer will be cleared automatically when FlexSPI returns Stop mode ACK.","value":1}]},{"name":"SAMEDEVICEEN","description":"All external devices are same devices (both in type and size) for A1/A2/B1/B2.","bitOffset":15,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"individual_parallel","description":"In Individual mode, FLSHA1CRx/FLSHA2CRx/FLSHB1CRx/FLSHB2CRx register setting will be applied to Flash A1/A2/B1/B2 separately. In Parallel mode, FLSHA1CRx register setting will be applied to Flash A1 and B1, FLSHA2CRx register setting will be applied to Flash A2 and B2. FLSHB1CRx/FLSHB2CRx register setting will be ignored.","value":0},{"name":"ENABLE","description":"FLSHA1CR0/FLSHA1CR1/FLSHA1CR2 register setting will be applied to Flash A1/A2/B1/B2. FLSHA2CRx/FLSHB1CRx/FLSHB2CRx will be ignored.","value":1}]},{"name":"SCKBDIFFOPT","description":"B_SCLK pad can be used as A_SCLK differential clock output (inverted clock to A_SCLK). In this case, port B flash access is not available. After changing the value of this field, MCR0[SWRESET] should be set.","bitOffset":19,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"val1","description":"B_SCLK pad is used as port B SCLK clock output. Port B flash access is available.","value":0},{"name":"val0","description":"B_SCLK pad is used as port A SCLK inverted clock output (Differential clock to A_SCLK). Port B flash access is not available.","value":1}]},{"name":"RESUMEWAIT","description":"Wait cycle (in AHB clock cycle) for idle state before suspended command sequence resumed.","bitOffset":24,"bitWidth":8,"access":"read-write"}]},{"name":"AHBCR","description":"AHB Bus Control Register","addressOffset":12,"size":32,"access":"read-write","resetValue":"0x18","resetMask":"0xFFFFFFFF","fields":[{"name":"APAREN","description":"Parallel mode enabled for AHB triggered Command (both read and write).","bitOffset":0,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"individual","description":"Flash will be accessed in Individual mode.","value":0},{"name":"ENABLE","description":"Flash will be accessed in Parallel mode.","value":1}]},{"name":"CLRAHBRXBUF","description":"Clear the status/pointers of AHB RX Buffer. Auto-cleared.","bitOffset":1,"bitWidth":1,"access":"read-write"},{"name":"CLRAHBTXBUF","description":"Clear the status/pointers of AHB TX Buffer. Auto-cleared.","bitOffset":2,"bitWidth":1,"access":"read-write"},{"name":"CACHABLEEN","description":"Enable AHB bus cachable read access support.","bitOffset":3,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"val0","description":"Disabled. When there is AHB bus cachable read access, FlexSPI will not check whether it hit AHB TX Buffer.","value":0},{"name":"val1","description":"Enabled. When there is AHB bus cachable read access, FlexSPI will check whether it hit AHB TX Buffer first.","value":1}]},{"name":"BUFFERABLEEN","description":"Enable AHB bus bufferable write access support.","bitOffset":4,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"val0","description":"Disabled. For all AHB write accesses (bufferable or non-bufferable), FlexSPI will return AHB Bus ready after all data is transmitted to external device and AHB command finished.","value":0},{"name":"val1","description":"Enabled. For AHB bufferable write access, FlexSPI will return AHB Bus ready when the AHB command is granted by arbitrator and will not wait for AHB command finished.","value":1}]},{"name":"PREFETCHEN","description":"AHB Read Prefetch Enable.","bitOffset":5,"bitWidth":1,"access":"read-write"},{"name":"READADDROPT","description":"AHB Read Address option bit. This option bit is intended to remove AHB burst start address alignment limitation.","bitOffset":6,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"val0","description":"There is AHB read burst start address alignment limitation when flash is accessed in parallel mode or flash is word-addressable.","value":0},{"name":"val1","description":"There is no AHB read burst start address alignment limitation. FlexSPI will fetch more data than AHB burst required to meet the alignment requirement.","value":1}]},{"name":"READSZALIGN","description":"AHB Read Size Alignment","bitOffset":10,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"val0","description":"AHB read size will be decided by other register setting like PREFETCH_EN","value":0},{"name":"val1","description":"AHB read size to up size to 8 bytes aligned, no prefetching","value":1}]}]},{"name":"INTEN","description":"Interrupt Enable Register","addressOffset":16,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"IPCMDDONEEN","description":"IP triggered Command Sequences Execution finished interrupt enable.","bitOffset":0,"bitWidth":1,"access":"read-write"},{"name":"IPCMDGEEN","description":"IP triggered Command Sequences Grant Timeout interrupt enable.","bitOffset":1,"bitWidth":1,"access":"read-write"},{"name":"AHBCMDGEEN","description":"AHB triggered Command Sequences Grant Timeout interrupt enable.","bitOffset":2,"bitWidth":1,"access":"read-write"},{"name":"IPCMDERREN","description":"IP triggered Command Sequences Error Detected interrupt enable.","bitOffset":3,"bitWidth":1,"access":"read-write"},{"name":"AHBCMDERREN","description":"AHB triggered Command Sequences Error Detected interrupt enable.","bitOffset":4,"bitWidth":1,"access":"read-write"},{"name":"IPRXWAEN","description":"IP RX FIFO WaterMark available interrupt enable.","bitOffset":5,"bitWidth":1,"access":"read-write"},{"name":"IPTXWEEN","description":"IP TX FIFO WaterMark empty interrupt enable.","bitOffset":6,"bitWidth":1,"access":"read-write"},{"name":"SCKSTOPBYRDEN","description":"SCLK is stopped during command sequence because Async RX FIFO full interrupt enable.","bitOffset":8,"bitWidth":1,"access":"read-write"},{"name":"SCKSTOPBYWREN","description":"SCLK is stopped during command sequence because Async TX FIFO empty interrupt enable.","bitOffset":9,"bitWidth":1,"access":"read-write"},{"name":"AHBBUSTIMEOUTEN","description":"AHB Bus timeout interrupt.","bitOffset":10,"bitWidth":1,"access":"read-write"},{"name":"SEQTIMEOUTEN","description":"Sequence execution timeout interrupt enable.","bitOffset":11,"bitWidth":1,"access":"read-write"}]},{"name":"INTR","description":"Interrupt Register","addressOffset":20,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"IPCMDDONE","description":"IP triggered Command Sequences Execution finished interrupt. This interrupt is also generated when there is IPCMDGE or IPCMDERR interrupt generated.","bitOffset":0,"bitWidth":1,"access":"read-write"},{"name":"IPCMDGE","description":"IP triggered Command Sequences Grant Timeout interrupt.","bitOffset":1,"bitWidth":1,"access":"read-write"},{"name":"AHBCMDGE","description":"AHB triggered Command Sequences Grant Timeout interrupt.","bitOffset":2,"bitWidth":1,"access":"read-write"},{"name":"IPCMDERR","description":"IP triggered Command Sequences Error Detected interrupt. When an error detected for IP command, this command will be ignored and not executed at all.","bitOffset":3,"bitWidth":1,"access":"read-write"},{"name":"AHBCMDERR","description":"AHB triggered Command Sequences Error Detected interrupt. When an error detected for AHB command, this command will be ignored and not executed at all.","bitOffset":4,"bitWidth":1,"access":"read-write"},{"name":"IPRXWA","description":"IP RX FIFO watermark available interrupt.","bitOffset":5,"bitWidth":1,"access":"read-write"},{"name":"IPTXWE","description":"IP TX FIFO watermark empty interrupt.","bitOffset":6,"bitWidth":1,"access":"read-write"},{"name":"SCKSTOPBYRD","description":"SCLK is stopped during command sequence because Async RX FIFO full interrupt.","bitOffset":8,"bitWidth":1,"access":"read-write"},{"name":"SCKSTOPBYWR","description":"SCLK is stopped during command sequence because Async TX FIFO empty interrupt.","bitOffset":9,"bitWidth":1,"access":"read-write"},{"name":"AHBBUSTIMEOUT","description":"AHB Bus timeout interrupt.","bitOffset":10,"bitWidth":1,"access":"read-write"},{"name":"SEQTIMEOUT","description":"Sequence execution timeout interrupt.","bitOffset":11,"bitWidth":1,"access":"read-write"}]},{"name":"LUTKEY","description":"LUT Key Register","addressOffset":24,"size":32,"access":"read-write","resetValue":"0x5AF05AF0","resetMask":"0xFFFFFFFF","fields":[{"name":"KEY","description":"The Key to lock or unlock LUT.","bitOffset":0,"bitWidth":32,"access":"read-write"}]},{"name":"LUTCR","description":"LUT Control Register","addressOffset":28,"size":32,"access":"read-write","resetValue":"0x2","resetMask":"0xFFFFFFFF","fields":[{"name":"LOCK","description":"Lock LUT","bitOffset":0,"bitWidth":1,"access":"read-write"},{"name":"UNLOCK","description":"Unlock LUT","bitOffset":1,"bitWidth":1,"access":"read-write"}]},{"name":"AHBRXBUF0CR0","description":"AHB RX Buffer 0 Control Register 0","addressOffset":32,"size":32,"access":"read-write","resetValue":"0x80000020","resetMask":"0xFFFFFFFF","fields":[{"name":"BUFSZ","description":"AHB RX Buffer Size in 64 bits.","bitOffset":0,"bitWidth":8,"access":"read-write"},{"name":"MSTRID","description":"This AHB RX Buffer is assigned according to AHB Master with ID (MSTR_ID).","bitOffset":16,"bitWidth":4,"access":"read-write"},{"name":"PRIORITY","description":"This priority for AHB Master Read which this AHB RX Buffer is assigned. 7 is the highest priority, 0 the lowest.","bitOffset":24,"bitWidth":2,"access":"read-write"},{"name":"REGIONEN","description":"AHB RX Buffer address region function enable","bitOffset":30,"bitWidth":1,"access":"read-write"},{"name":"PREFETCHEN","description":"AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.","bitOffset":31,"bitWidth":1,"access":"read-write"}]},{"name":"AHBRXBUF1CR0","description":"AHB RX Buffer 1 Control Register 0","addressOffset":36,"size":32,"access":"read-write","resetValue":"0x80010020","resetMask":"0xFFFFFFFF","fields":[{"name":"BUFSZ","description":"AHB RX Buffer Size in 64 bits.","bitOffset":0,"bitWidth":8,"access":"read-write"},{"name":"MSTRID","description":"This AHB RX Buffer is assigned according to AHB Master with ID (MSTR_ID).","bitOffset":16,"bitWidth":4,"access":"read-write"},{"name":"PRIORITY","description":"This priority for AHB Master Read which this AHB RX Buffer is assigned. 7 is the highest priority, 0 the lowest.","bitOffset":24,"bitWidth":2,"access":"read-write"},{"name":"REGIONEN","description":"AHB RX Buffer address region function enable","bitOffset":30,"bitWidth":1,"access":"read-write"},{"name":"PREFETCHEN","description":"AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.","bitOffset":31,"bitWidth":1,"access":"read-write"}]},{"name":"AHBRXBUF2CR0","description":"AHB RX Buffer 2 Control Register 0","addressOffset":40,"size":32,"access":"read-write","resetValue":"0x80020020","resetMask":"0xFFFFFFFF","fields":[{"name":"BUFSZ","description":"AHB RX Buffer Size in 64 bits.","bitOffset":0,"bitWidth":8,"access":"read-write"},{"name":"MSTRID","description":"This AHB RX Buffer is assigned according to AHB Master with ID (MSTR_ID).","bitOffset":16,"bitWidth":4,"access":"read-write"},{"name":"PRIORITY","description":"This priority for AHB Master Read which this AHB RX Buffer is assigned. 7 is the highest priority, 0 the lowest.","bitOffset":24,"bitWidth":2,"access":"read-write"},{"name":"REGIONEN","description":"AHB RX Buffer address region function enable","bitOffset":30,"bitWidth":1,"access":"read-write"},{"name":"PREFETCHEN","description":"AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.","bitOffset":31,"bitWidth":1,"access":"read-write"}]},{"name":"AHBRXBUF3CR0","description":"AHB RX Buffer 3 Control Register 0","addressOffset":44,"size":32,"access":"read-write","resetValue":"0x80030020","resetMask":"0xFFFFFFFF","fields":[{"name":"BUFSZ","description":"AHB RX Buffer Size in 64 bits.","bitOffset":0,"bitWidth":8,"access":"read-write"},{"name":"MSTRID","description":"This AHB RX Buffer is assigned according to AHB Master with ID (MSTR_ID).","bitOffset":16,"bitWidth":4,"access":"read-write"},{"name":"PRIORITY","description":"This priority for AHB Master Read which this AHB RX Buffer is assigned. 7 is the highest priority, 0 the lowest.","bitOffset":24,"bitWidth":2,"access":"read-write"},{"name":"REGIONEN","description":"AHB RX Buffer address region function enable","bitOffset":30,"bitWidth":1,"access":"read-write"},{"name":"PREFETCHEN","description":"AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.","bitOffset":31,"bitWidth":1,"access":"read-write"}]},{"name":"FLSHA1CR0","description":"Flash Control Register 0","addressOffset":96,"size":32,"access":"read-write","resetValue":"0x10000","resetMask":"0xFFFFFFFF","fields":[{"name":"FLSHSZ","description":"Flash Size in KByte.","bitOffset":0,"bitWidth":23,"access":"read-write"}]},{"name":"FLSHA2CR0","description":"Flash Control Register 0","addressOffset":100,"size":32,"access":"read-write","resetValue":"0x10000","resetMask":"0xFFFFFFFF","fields":[{"name":"FLSHSZ","description":"Flash Size in KByte.","bitOffset":0,"bitWidth":23,"access":"read-write"}]},{"name":"FLSHB1CR0","description":"Flash Control Register 0","addressOffset":104,"size":32,"access":"read-write","resetValue":"0x10000","resetMask":"0xFFFFFFFF","fields":[{"name":"FLSHSZ","description":"Flash Size in KByte.","bitOffset":0,"bitWidth":23,"access":"read-write"}]},{"name":"FLSHB2CR0","description":"Flash Control Register 0","addressOffset":108,"size":32,"access":"read-write","resetValue":"0x10000","resetMask":"0xFFFFFFFF","fields":[{"name":"FLSHSZ","description":"Flash Size in KByte.","bitOffset":0,"bitWidth":23,"access":"read-write"}]},{"name":"FLSHCR1%s","description":"Flash Control Register 1","addressOffset":112,"size":32,"access":"read-write","resetValue":"0x63","resetMask":"0xFFFFFFFF","fields":[{"name":"TCSS","description":"Serial Flash CS setup time.","bitOffset":0,"bitWidth":5,"access":"read-write"},{"name":"TCSH","description":"Serial Flash CS Hold time.","bitOffset":5,"bitWidth":5,"access":"read-write"},{"name":"WA","description":"Word Addressable.","bitOffset":10,"bitWidth":1,"access":"read-write"},{"name":"CAS","description":"Column Address Size.","bitOffset":11,"bitWidth":4,"access":"read-write"},{"name":"CSINTERVALUNIT","description":"CS interval unit","bitOffset":15,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"val0","description":"The CS interval unit is 1 serial clock cycle","value":0},{"name":"val1","description":"The CS interval unit is 256 serial clock cycle","value":1}]},{"name":"CSINTERVAL","description":"This field is used to set the minimum interval between flash device chip select deassertion and flash device chip select assertion. If external flash has a limitation on the interval between command sequences, this field should be set accordingly. If there is no limitation, set this field with value 0x0.","bitOffset":16,"bitWidth":16,"access":"read-write"}]},{"name":"FLSHCR2%s","description":"Flash Control Register 2","addressOffset":128,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"ARDSEQID","description":"Sequence Index for AHB Read triggered Command in LUT.","bitOffset":0,"bitWidth":4,"access":"read-write"},{"name":"ARDSEQNUM","description":"Sequence Number for AHB Read triggered Command in LUT.","bitOffset":5,"bitWidth":3,"access":"read-write"},{"name":"AWRSEQID","description":"Sequence Index for AHB Write triggered Command.","bitOffset":8,"bitWidth":4,"access":"read-write"},{"name":"AWRSEQNUM","description":"Sequence Number for AHB Write triggered Command.","bitOffset":13,"bitWidth":3,"access":"read-write"},{"name":"AWRWAIT","description":"For certain devices (such as FPGA), it need some time to write data into internal memory after the command sequences finished on FlexSPI interface. If another Read command sequence comes before previous programming finished internally, the read data may be wrong. This field is used to hold AHB Bus ready for AHB write access to wait the programming finished in external device. Then there will be no AHB read command triggered before the programming finished in external device. The Wait cycle between AHB triggered command sequences finished on FlexSPI interface and AHB return Bus ready: AWRWAIT * AWRWAITUNIT","bitOffset":16,"bitWidth":12,"access":"read-write"},{"name":"AWRWAITUNIT","description":"AWRWAIT unit","bitOffset":28,"bitWidth":3,"access":"read-write","enumeratedValues":[{"name":"val0","description":"The AWRWAIT unit is 2 AHB clock cycle","value":0},{"name":"val1","description":"The AWRWAIT unit is 8 AHB clock cycle","value":1},{"name":"val2","description":"The AWRWAIT unit is 32 AHB clock cycle","value":2},{"name":"val3","description":"The AWRWAIT unit is 128 AHB clock cycle","value":3},{"name":"val4","description":"The AWRWAIT unit is 512 AHB clock cycle","value":4},{"name":"val5","description":"The AWRWAIT unit is 2048 AHB clock cycle","value":5},{"name":"val6","description":"The AWRWAIT unit is 8192 AHB clock cycle","value":6},{"name":"val7","description":"The AWRWAIT unit is 32768 AHB clock cycle","value":7}]},{"name":"CLRINSTRPTR","description":"Clear the instruction pointer which is internally saved pointer by JMP_ON_CS.","bitOffset":31,"bitWidth":1,"access":"read-write"}]},{"name":"FLSHCR4","description":"Flash Control Register 4","addressOffset":148,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"WMOPT1","description":"Write mask option bit 1. This option bit could be used to remove AHB and IP write burst start address alignment limitation.","bitOffset":0,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"DISABLE","description":"DQS pin will be used as Write Mask when writing to external device. There is no limitation on AHB/IP write burst start address alignment when flash is accessed in individual mode.","value":0},{"name":"ENABLE","description":"DQS pin will not be used as Write Mask when writing to external device. There is limitation on AHB/IP write burst start address alignment when flash is accessed in individual mode.","value":1}]},{"name":"WMENA","description":"Write mask enable bit for flash device on port A. When write mask function is needed for memory device on port A, this bit must be set.","bitOffset":2,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"val0","description":"Write mask is disabled, DQS(RWDS) pin will not be driven when writing to external device.","value":0},{"name":"val1","description":"Write mask is enabled, DQS(RWDS) pin will be driven by FlexSPI as write mask output when writing to external device.","value":1}]},{"name":"WMENB","description":"Write mask enable bit for flash device on port B. When write mask function is needed for memory device on port B, this bit must be set.","bitOffset":3,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"val0","description":"Write mask is disabled, DQS(RWDS) pin will not be driven when writing to external device.","value":0},{"name":"val1","description":"Write mask is enabled, DQS(RWDS) pin will be driven by FlexSPI as write mask output when writing to external device.","value":1}]}]},{"name":"IPCR0","description":"IP Control Register 0","addressOffset":160,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"SFAR","description":"Serial Flash Address for IP command.","bitOffset":0,"bitWidth":32,"access":"read-write"}]},{"name":"IPCR1","description":"IP Control Register 1","addressOffset":164,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"IDATSZ","description":"Flash Read/Program Data Size (in Bytes) for IP command.","bitOffset":0,"bitWidth":16,"access":"read-write"},{"name":"ISEQID","description":"Sequence Index in LUT for IP command.","bitOffset":16,"bitWidth":4,"access":"read-write"},{"name":"ISEQNUM","description":"Sequence Number for IP command: ISEQNUM+1.","bitOffset":24,"bitWidth":3,"access":"read-write"},{"name":"IPAREN","description":"Parallel mode Enabled for IP command.","bitOffset":31,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"DISABLE","description":"Flash will be accessed in Individual mode.","value":0},{"name":"ENABLE","description":"Flash will be accessed in Parallel mode.","value":1}]}]},{"name":"IPCMD","description":"IP Command Register","addressOffset":176,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"TRG","description":"Setting this bit will trigger an IP Command.","bitOffset":0,"bitWidth":1,"access":"read-write"}]},{"name":"IPRXFCR","description":"IP RX FIFO Control Register","addressOffset":184,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"CLRIPRXF","description":"Clear all valid data entries in IP RX FIFO.","bitOffset":0,"bitWidth":1,"access":"read-write"},{"name":"RXDMAEN","description":"IP RX FIFO reading by DMA enabled.","bitOffset":1,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"val0","description":"IP RX FIFO would be read by processor.","value":0},{"name":"val1","description":"IP RX FIFO would be read by DMA.","value":1}]},{"name":"RXWMRK","description":"Watermark level is (RXWMRK+1)*64 bits.","bitOffset":2,"bitWidth":4,"access":"read-write"}]},{"name":"IPTXFCR","description":"IP TX FIFO Control Register","addressOffset":188,"size":32,"access":"read-write","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"CLRIPTXF","description":"Clear all valid data entries in IP TX FIFO.","bitOffset":0,"bitWidth":1,"access":"read-write"},{"name":"TXDMAEN","description":"IP TX FIFO filling by DMA enabled.","bitOffset":1,"bitWidth":1,"access":"read-write","enumeratedValues":[{"name":"val0","description":"IP TX FIFO would be filled by processor.","value":0},{"name":"val1","description":"IP TX FIFO would be filled by DMA.","value":1}]},{"name":"TXWMRK","description":"Watermark level is (TXWMRK+1)*64 Bits.","bitOffset":2,"bitWidth":4,"access":"read-write"}]},{"name":"DLLCR%s","description":"DLL Control Register 0","addressOffset":192,"size":32,"access":"read-write","resetValue":"0x100","resetMask":"0xFFFFFFFF","fields":[{"name":"DLLEN","description":"DLL calibration enable.","bitOffset":0,"bitWidth":1,"access":"read-write"},{"name":"DLLRESET","description":"DLL reset","bitOffset":1,"bitWidth":1,"access":"read-write"},{"name":"SLVDLYTARGET","description":"The delay target for slave delay line is: ((SLVDLYTARGET+1) * 1/32 * clock cycle of reference clock (serial root clock). If serial root clock is >= 100 MHz, DLLEN set to 0x1, OVRDEN set to =0x0, then SLVDLYTARGET setting of 0xF is recommended.","bitOffset":3,"bitWidth":4,"access":"read-write"},{"name":"OVRDEN","description":"Slave clock delay line delay cell number selection override enable.","bitOffset":8,"bitWidth":1,"access":"read-write"},{"name":"OVRDVAL","description":"Slave clock delay line delay cell number selection override value.","bitOffset":9,"bitWidth":6,"access":"read-write"}]},{"name":"STS0","description":"Status Register 0","addressOffset":224,"size":32,"access":"read-only","resetValue":"0x2","resetMask":"0xFFFFFFFF","fields":[{"name":"SEQIDLE","description":"This status bit indicates the state machine in SEQ_CTL is idle and there is command sequence executing on FlexSPI interface.","bitOffset":0,"bitWidth":1,"access":"read-only"},{"name":"ARBIDLE","description":"This status bit indicates the state machine in ARB_CTL is busy and there is command sequence granted by arbitrator and not finished yet on FlexSPI interface. When ARB_CTL state (ARBIDLE=0x1) is idle, there will be no transaction on FlexSPI interface also (SEQIDLE=0x1). So this bit should be polled to wait for FlexSPI controller become idle instead of SEQIDLE.","bitOffset":1,"bitWidth":1,"access":"read-only"},{"name":"ARBCMDSRC","description":"This status field indicates the trigger source of current command sequence granted by arbitrator. This field value is meaningless when ARB_CTL is not busy (STS0[ARBIDLE]=0x1).","bitOffset":2,"bitWidth":2,"access":"read-only","enumeratedValues":[{"name":"val0","description":"Triggered by AHB read command.","value":0},{"name":"val1","description":"Triggered by AHB write command.","value":1},{"name":"val2","description":"Triggered by IP command (triggered by setting register bit IPCMD[TRG]).","value":2},{"name":"val3","description":"Triggered by suspended command (resumed).","value":3}]}]},{"name":"STS1","description":"Status Register 1","addressOffset":228,"size":32,"access":"read-only","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"AHBCMDERRID","description":"Indicates the sequence index when an AHB command error is detected. This field will be cleared when INTR[AHBCMDERR] is write-1-clear(w1c).","bitOffset":0,"bitWidth":4,"access":"read-only"},{"name":"AHBCMDERRCODE","description":"Indicates the Error Code when AHB command Error detected. This field will be cleared when INTR[AHBCMDERR] is write-1-clear(w1c).","bitOffset":8,"bitWidth":4,"access":"read-only","enumeratedValues":[{"name":"val0","description":"No error.","value":0},{"name":"val2","description":"AHB Write command with JMP_ON_CS instruction used in the sequence.","value":2},{"name":"val3","description":"There is unknown instruction opcode in the sequence.","value":3},{"name":"val4","description":"Instruction DUMMY_SDR/DUMMY_RWDS_SDR used in DDR sequence.","value":4},{"name":"val5","description":"Instruction DUMMY_DDR/DUMMY_RWDS_DDR used in SDR sequence.","value":5},{"name":"val6","description":"Sequence execution timeout.","value":14}]},{"name":"IPCMDERRID","description":"Indicates the sequence Index when IP command error detected.","bitOffset":16,"bitWidth":4,"access":"read-only"},{"name":"IPCMDERRCODE","description":"Indicates the Error Code when IP command Error detected. This field will be cleared when INTR[IPCMDERR] is write-1-clear(w1c).","bitOffset":24,"bitWidth":4,"access":"read-only","enumeratedValues":[{"name":"val0","description":"No error.","value":0},{"name":"val2","description":"IP command with JMP_ON_CS instruction used in the sequence.","value":2},{"name":"val3","description":"There is unknown instruction opcode in the sequence.","value":3},{"name":"val4","description":"Instruction DUMMY_SDR/DUMMY_RWDS_SDR used in DDR sequence.","value":4},{"name":"val5","description":"Instruction DUMMY_DDR/DUMMY_RWDS_DDR used in SDR sequence.","value":5},{"name":"val6","description":"Flash access start address exceed the whole flash address range (A1/A2/B1/B2).","value":6},{"name":"val7","description":"Sequence execution timeout.","value":14},{"name":"val8","description":"Flash boundary crossed.","value":15}]}]},{"name":"STS2","description":"Status Register 2","addressOffset":232,"size":32,"access":"read-only","resetValue":"0x1000100","resetMask":"0xFFFFFFFF","fields":[{"name":"ASLVLOCK","description":"Flash A sample clock slave delay line locked.","bitOffset":0,"bitWidth":1,"access":"read-only"},{"name":"AREFLOCK","description":"Flash A sample clock reference delay line locked.","bitOffset":1,"bitWidth":1,"access":"read-only"},{"name":"ASLVSEL","description":"Flash A sample clock slave delay line delay cell number selection .","bitOffset":2,"bitWidth":6,"access":"read-only"},{"name":"AREFSEL","description":"Flash A sample clock reference delay line delay cell number selection.","bitOffset":8,"bitWidth":6,"access":"read-only"},{"name":"BSLVLOCK","description":"Flash B sample clock slave delay line locked.","bitOffset":16,"bitWidth":1,"access":"read-only"},{"name":"BREFLOCK","description":"Flash B sample clock reference delay line locked.","bitOffset":17,"bitWidth":1,"access":"read-only"},{"name":"BSLVSEL","description":"Flash B sample clock slave delay line delay cell number selection.","bitOffset":18,"bitWidth":6,"access":"read-only"},{"name":"BREFSEL","description":"Flash B sample clock reference delay line delay cell number selection.","bitOffset":24,"bitWidth":6,"access":"read-only"}]},{"name":"AHBSPNDSTS","description":"AHB Suspend Status Register","addressOffset":236,"size":32,"access":"read-only","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"ACTIVE","description":"Indicates if an AHB read prefetch command sequence has been suspended.","bitOffset":0,"bitWidth":1,"access":"read-only"},{"name":"BUFID","description":"AHB RX BUF ID for suspended command sequence.","bitOffset":1,"bitWidth":3,"access":"read-only"},{"name":"DATLFT","description":"Left Data size for suspended command sequence (in byte).","bitOffset":16,"bitWidth":16,"access":"read-only"}]},{"name":"IPRXFSTS","description":"IP RX FIFO Status Register","addressOffset":240,"size":32,"access":"read-only","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"FILL","description":"Fill level of IP RX FIFO.","bitOffset":0,"bitWidth":8,"access":"read-only"},{"name":"RDCNTR","description":"Total Read Data Counter: RDCNTR * 64 Bits.","bitOffset":16,"bitWidth":16,"access":"read-only"}]},{"name":"IPTXFSTS","description":"IP TX FIFO Status Register","addressOffset":244,"size":32,"access":"read-only","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"FILL","description":"Fill level of IP TX FIFO.","bitOffset":0,"bitWidth":8,"access":"read-only"},{"name":"WRCNTR","description":"Total Write Data Counter: WRCNTR * 64 Bits.","bitOffset":16,"bitWidth":16,"access":"read-only"}]},{"name":"RFDR[%s]","description":"IP RX FIFO Data Register x","addressOffset":256,"size":32,"access":"read-only","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"RXDATA","description":"RX Data","bitOffset":0,"bitWidth":32,"access":"read-only"}]},{"name":"TFDR[%s]","description":"IP TX FIFO Data Register x","addressOffset":384,"size":32,"access":"write-only","resetValue":"0","resetMask":"0xFFFFFFFF","fields":[{"name":"TXDATA","description":"TX Data","bitOffset":0,"bitWidth":32,"access":"write-only"}]},{"name":"LUT[%s]","description":"LUT x","addressOffset":512,"size":32,"access":"read-write","resetValue":"0","resetMask":"0","fields":[{"name":"OPERAND0","description":"OPERAND0","bitOffset":0,"bitWidth":8,"access":"read-write"},{"name":"NUM_PADS0","description":"NUM_PADS0","bitOffset":8,"bitWidth":2,"access":"read-write"},{"name":"OPCODE0","description":"OPCODE","bitOffset":10,"bitWidth":6,"access":"read-write"},{"name":"OPERAND1","description":"OPERAND1","bitOffset":16,"bitWidth":8,"access":"read-write"},{"name":"NUM_PADS1","description":"NUM_PADS1","bitOffset":24,"bitWidth":2,"access":"read-write"},{"name":"OPCODE1","description":"OPCODE1","bitOffset":26,"bitWidth":6,"access":"read-write"}]}],"addressBlock":{"offset":"0","size":"0x300","usage":"registers"}}