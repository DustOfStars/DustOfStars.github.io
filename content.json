{"posts":[{"title":"Cyberpunk Theme Variant","text":"Icarus includes a new variant called Cyberpunk starting from version 3.0.0. The theme is inspired by the video game Cyberpunk 2077 developed by CD PROJEKT RED. This variant aims at providing a different Icarus experience to these who like dark-themed blogs. It should be noted that it uses recent web styling features that are not working correctlyin some legacy browsers, including Internet Explorer and legacy Microsoft Edge. To enable the Cyberpunk theme, open _config.icarus.yml and make the following change: _config.icarus.yml12- variant: default+ variant: cyberpunk You may also want to change the theme of highlighted code blocks. In that case, you can find some dark highlight.js themes here. Copy the file name, excluding the .css extension, and put it in the article.highlight.theme option in _config.icarus.yml. For example, if you want to change the theme to xt256, make the following change: _config.icarus.yml12345# Article related configurationsarticle: highlight:- theme: atom-one-light+ theme: xt256 Apart from the color palette, Icarus also used two image resources that are placed on the top navigation bar and bottom page footer from the official Cyberpunk 2077 website. If you wish to make further modifications to this theme variant, you can take a look at &lt;icarus_directory&gt;/source/css/cyberpunk.styl.","link":"/uncategorized/cyberpunk-theme-variant/"},{"title":"Hexo Built-in Tag Helpers","text":"The following content is taken from Hexo documentation with minor revisions. Tag plugins are different from post tags. They are ported from Octopress and provide a useful way for you to quickly add specific content to your posts. Block QuotePerfect for adding quotes to your post, with optional author, source and title information. Alias: quote 123{% blockquote [author[, source]] [link] [source_link_title] %}content{% endblockquote %} ExamplesNo arguments. Plain blockquote. 123{% blockquote %}Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.{% endblockquote %} Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem. Quote from a book 123{% blockquote David Levithan, Wide Awake %}Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.{% endblockquote %} Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake Quote from Twitter 123{% blockquote @DevDocs https://twitter.com/devdocs/status/356095192085962752 %}NEW: DevDocs now comes with syntax highlighting. http://devdocs.io{% endblockquote %} NEW: DevDocs now comes with syntax highlighting. http://devdocs.io @DevDocstwitter.com/devdocs/status/356095192085962752 Quote from an article on the web 123{% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %}Every interaction is both precious and an opportunity to delight.{% endblockquote %} Every interaction is both precious and an opportunity to delight. Seth GodinWelcome to Island Marketing Code BlockUseful feature for adding code snippets to your post. Alias: code 123{% codeblock [title] [lang:language] [url] [link text] %}code snippet{% endcodeblock %} ExamplesA plain code block 123{% codeblock %}alert('Hello World!');{% endcodeblock %} 1alert('Hello World!'); Specifying the language 123{% codeblock lang:objc %}[rectangle setX: 10 y: 10 width: 20 height: 20];{% endcodeblock %} 1[rectangle setX: 10 y: 10 width: 20 height: 20]; Adding a caption to the code block 123{% codeblock Array.map %}array.map(callback[, thisArg]){% endcodeblock %} Array.map1array.map(callback[, thisArg]) Adding a caption and a URL 1234{% codeblock _.compact http://underscorejs.org/#compact Underscore.js %}_.compact([0, 1, false, 2, '', 3]);=&gt; [1, 2, 3]{% endcodeblock %} _.compactUnderscore.js12_.compact([0, 1, false, 2, '', 3]);=&gt; [1, 2, 3] Backtick Code BlockThis is identical to using a code block, but instead uses three backticks to delimit the block. 123``` [language] [title] [url] [link text]code snippet``` Pull QuoteLorem ipsum dolor sit amet, consectetur adipiscing elit. Morbi semper auctor nulla, a mollis nibh congue luctus. Mauris sagittis dui sit amet scelerisque gravida. Proin porttitor convallis libero. To add pull quotes to your posts: 123{% pullquote [CSS class] %}content{% endpullquote %} jsFiddleTo embed a jsFiddle snippet: 1{% jsfiddle shorttag [tabs] [skin] [width] [height] %} GistTo embed a Gist snippet: 1{% gist gist_id [filename] %} iframeTo embed an iframe: 1{% iframe url [width] [height] %} ImageInserts an image with specified size. 1{% img [class names] /path/to/image [width] [height] [title text [alt text]] %} LinkInserts a link with target=\"_blank\" attribute. 1{% link text url [external] [title] %} Hexo.io Include CodeInserts code snippets in source/downloads/code folder. 1{% include_code [title] [lang:language] path/to/file %} YouTubeInserts a YouTube video. 1{% youtube video_id %} VimeoInserts a Vimeo video. 1{% vimeo video_id %} Include PostsInclude links to other posts. 12{% post_path slug %}{% post_link slug [title] %} Include AssetsInclude post assets. 123{% asset_path slug %}{% asset_img slug [title] %}{% asset_link slug [title] %} RawIf certain content is causing processing issues in your posts, wrap it with the raw tag to avoid rendering errors. 123{% raw %}content{% endraw %} Post ExcerptUse text placed before the &lt;!-- more --&gt; tag as an excerpt for the post. Examples: 123Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.&lt;!-- more --&gt;Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.","link":"/uncategorized/hexo-built-in-tag-helpers/"},{"title":"1_数据探索","text":"第一步：简单观察训练集和测试集 使用pyplot做直方图观察句子长度分布情况 123456789101112131415161718192021222324252627282930313233343536373839404142# -*- coding:utf-8 -*-import osfrom re import Simport numpy as npimport matplotlib.pyplot as pltdef length_process(data_dir): train_dir = data_dir with open(train_dir, \"r\", encoding=\"utf-8\") as f: tmp_x = [] for i, line in enumerate(f): if i == 0: continue # skip the first line # line 的格式为：0,7442 27878 9601 235 4004 ， 9601 4004 ， 8194 2281 10893,5-30 # 行号 英文逗号 短句 中文逗号 短句 英文逗号 行号 sent_ = line.strip().split(\",\")[1] sent_ = [item.strip() for item in sent_.split(\"，\")] sent_ = \" \".join(item for item in sent_).strip().split(\" \") tmp_x.append(len(sent_)) n, bins, patches = plt.hist(x=tmp_x, bins=\"auto\", alpha=0.7, rwidth=0.85) plt.grid(axis=\"y\", alpha=0.75) plt.xlabel(\"sentence length\") plt.ylabel(\"Frequency\") plt.title(\"Histogram: sentence length\") maxfreq = n.max() # 设置y轴的上限 plt.ylim(ymax=np.ceil(maxfreq / 10) * 10 if maxfreq % 10 else maxfreq + 10) print(\"maxfreq = {0}\".format(maxfreq)) plt.show()if __name__ == \"__main__\": rootdir = os.sep.join(os.path.dirname(__file__).strip().split(os.sep)[:-2]) train_dir = os.path.join(rootdir, \"dataset/datagrand_2021_train.csv\") test_dir = os.path.join(rootdir, \"dataset/datagrand_2021_test.csv\") length_process(train_dir) length_process(test_dir)","link":"/NLP/Python/1-%E6%95%B0%E6%8D%AE%E6%8E%A2%E7%B4%A2/"},{"title":"2_数据集制作","text":"第二步：数据集分割制作 提前做个5折交叉的准备，注意代码中zip的使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# -*- coding:utf-8 -*-import osimport randomfrom collections import defaultdictdef split_train(train_file, dev_ratio=0.2, to_folder=None): # split train into train &amp; dev with open(train_file, \"r\", encoding=\"utf-8\") as f: dict_label_name2sents = defaultdict(list) for i, line in enumerate(f): if i == 0: continue line = line.strip() if not line: continue id, sent, label_name = line.split(\",\") dict_label_name2sents[label_name].append(sent) # 这里的sent包括逗号，是几个短句的组合 to_train_file = os.path.join(to_folder, \"train.txt\") to_dev_file = os.path.join(to_folder, \"dev.txt\") to_test_file = os.path.join(to_folder, \"test.txt\") train_samples = [] dev_samples = [] for label_name, sents in dict_label_name2sents.items(): random.shuffle(sents) # 把每个lable下的sents随机打乱 train_sents_ = sents[int(dev_ratio * len(sents)) + 1 :] dev_sents_ = sents[: int(dev_ratio * len(sents)) + 1] train_samples.extend([(w, label_name) for w in train_sents_]) dev_samples.extend([(w, label_name) for w in dev_sents_]) for samps, file_path in zip( [train_samples, dev_samples], [to_train_file, to_dev_file] ): f_out = open(file_path, \"w\", encoding=\"utf-8\") for i, samp in enumerate(samps): f_out.write( \"%d,%s,%s\" % (i, samp[0], samp[1]) + \"\\n\" ) # samp[0]是sent，samp[1]是label_name f_out.close()def split_train_to_5folds(train_file, to_folder, num_folds=5): os.makedirs(to_folder, exist_ok=True) for i in range(num_folds): to_folder_i = os.path.join(to_folder, \"fold_%d\" % i) os.makedirs(to_folder_i, exist_ok=True) split_train(train_file, dev_ratio=0.2, to_folder=to_folder_i)if __name__ == \"__main__\": rootdir = os.sep.join(os.path.dirname(__file__).strip().split(os.sep)[:-2]) train_dir = os.path.join(rootdir, \"dataset/datagrand_2021_train.csv\") # test_dir = os.path.join(rootdir, \"dataset/datagrand_2021_test.csv\") to_folder = os.path.join(rootdir, \"dataset/phase_1/splits\") split_train_to_5folds(train_dir, to_folder, num_folds=5)","link":"/NLP/Python/2-%E6%95%B0%E6%8D%AE%E9%9B%86%E5%88%B6%E4%BD%9C/"},{"title":"3_lable词表制作","text":"第三步：制作lable词表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# -*- coding:utf-8 -*-import jsonimport osdef vocab_process(data_dir, to_folder): # label, 注意这个模型，标签是分为两层的， level_1是大类， level_2是全部的lable，算作小类 vocab_file_level_1 = os.path.join(to_folder, \"labels_level_1.txt\") vocab_file_level_2 = os.path.join(to_folder, \"labels_level_2.txt\") # label2freq label2freq_level_1_file = os.path.join(to_folder, \"label2freq_level_1.json\") label2freq_level_2_file = os.path.join(to_folder, \"label2freq_level_2.json\") with open(data_dir, \"r\", encoding=\"utf-8\") as f: vocab_level_1 = {} vocab_level_2 = {} for i, line in enumerate(f): if i == 0: continue label_ = line.strip().split(\",\")[-1] label_level_1 = label_.strip().split(\"-\")[0] label_level_2 = label_ if label_level_1 not in vocab_level_1: vocab_level_1[label_level_1] = 0 vocab_level_1[label_level_1] += 1 if label_level_2 not in vocab_file_level_2: vocab_level_2[label_level_2] = 0 vocab_level_2[label_level_2] += 1 json.dump(vocab_level_1, open(label2freq_level_1_file, \"w\", encoding=\"utf-8\")) json.dump(vocab_level_2, open(label2freq_level_2_file, \"w\", encoding=\"utf-8\")) vocab_level_1 = list(vocab_level_1.items()) # dict.items() 输出所有的(k, v)元组组成的list vocab_level_1 = sorted( vocab_level_1, key=lambda x: x[1], reverse=True ) # 按照lable的数量进行排序，从大到小 print(\"vocab_level_1:\", vocab_level_1) vocab_level_1 = [w[0] for w in vocab_level_1] vocab_level_2 = list(vocab_level_2.items()) vocab_level_2 = sorted(vocab_level_2, key=lambda x: x[1], reverse=True) print(\"vocab_level_2:\", vocab_level_2) vocab_level_2 = [w[0] for w in vocab_level_2] with open(vocab_file_level_1, \"w\", encoding=\"utf-8\") as f_out: for lab in vocab_level_1: f_out.write(lab + \"\\n\") with open(vocab_file_level_2, \"w\", encoding=\"utf-8\") as f_out: for lab in vocab_level_2: f_out.write(lab + \"\\n\")if __name__ == \"__main__\": rootdir = os.sep.join(os.path.dirname(__file__).strip().split(os.sep)[:-2]) train_dir = os.path.join(rootdir, \"dataset/datagrand_2021_train.csv\") # test_dir = os.path.join(rootdir, \"dataset/datagrand_2021_test.csv\") phase_1_dir = os.path.join(rootdir, \"dataset/phase_1\") vocab_process(train_dir, phase_1_dir) 生成的文件及内容","link":"/NLP/Python/3-lable%E8%AF%8D%E8%A1%A8%E5%88%B6%E4%BD%9C/"},{"title":"4_模型入口","text":"第四步：模型入口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264# -*- coding:utf-8 -*-import argparseimport sysimport randomimport loggingimport torchimport numpy as npfrom models.model_utils import get_embedding_matrix_and_vocabfrom src.classic_models.training.trainer import Trainerfrom src.classic_models.training.data_loader import load_and_cache_examplessys.path.append(\"./\")def init_logger(): logging.basicConfig( format=\"%(asctime)s - %(levelname)s - %(name)s - %(message)s\", datefmt=\"%m/%d/%Y %H:%M:%S\", level=logging.INFO, )def set_seed(args): random.seed(args.seed) np.random.seed(args.seed) torch.manual_seed(args.seed) if not args.no_cuda and torch.cuda.is_available(): torch.cuda.manual_seed_all(args.seed)def main(args): init_logger() set_seed(args) # load vocab and w2v vocab_list, vector_list = get_embedding_matrix_and_vocab( args.w2v_file, skip_first_line=True ) train_dataset = load_and_cache_examples(args, mode=\"train\", vocab_list=vocab_list) dev_dataset = load_and_cache_examples(args, mode=\"dev\", vocab_list=vocab_list) test_dataset = load_and_cache_examples(args, mode=\"test\", vocab_list=vocab_list) print(\"train_dataset: \", len(train_dataset)) print(\"dev_dataset: \", len(dev_dataset)) print(\"test_dataset: \", len(test_dataset)) trainer = Trainer(args, train_dataset, dev_dataset, test_dataset) if args.do_train: trainer.train() if args.do_eval: trainer.load_model() trainer.evaluate(\"dev\") trainer.evaluate(\"test\")\"\"\"python src/classic_models/training/main.py --data_dir ./datasets/phase_1/splits/fold_0 --label_file_level_1 datasets/phase_1/labels_level_1.txt --label_file_level_2 datasets/phase_1/labels_level_2.txt --task daguan --random_init_w2v --encoder lstm --aggregator max_pool --model_dir ./experiments/outputs/daguan/lstm_0815_1 --do_train --do_eval --train_batch_size 32 --num_train_epochs 50 --embeddings_learning_rate 6e-4 --learning_rate 20e-4 --classifier_learning_rate 20e-4 --warmup_steps 200 --max_seq_len 128 --hidden_dim 256 --embed_dim 256 --w2v_file resources/word2vec/dim_256/w2v.vectors --dropout_rate 0.2 --metric_key_for_early_stop \"macro avg__f1-score__level_2\" --logging_steps 400 --patience 5 \"\"\"if __name__ == \"__main__\": parser = argparse.ArgumentParser() parser.add_argument( \"--task\", default=\"daguan\", type=str, help=\"The name of the task to train\" ) parser.add_argument( \"--model_dir\", default=\"/data2/code/DaguanFengxian/baseline/experiments/outputs/lstm_max_pool_wv256_epoch100\", type=str, help=\"Path to save, load models\", ) parser.add_argument( \"--data_dir\", default=\"/data2/nlpData/daguanfengxian/phase_1/splits/fold_0\", type=str, help=\"The input dataload dir\", ) parser.add_argument( \"--label_file_level_1\", default=\"/data2/nlpData/daguanfengxian/phase_1/labels_level_1.txt\", type=str, help=\"Label file for level 1 label\", ) parser.add_argument( \"--label_file_level_2\", default=\"/data2/nlpData/daguanfengxian/phase_1/labels_level_2.txt\", type=str, help=\"Label file for level 2 label\", ) parser.add_argument( \"--seed\", type=int, default=41, help=\"random seed for initialization\" ) parser.add_argument( \"--train_batch_size\", default=32, type=int, help=\"Batch size for training.\" ) parser.add_argument( \"--eval_batch_size\", default=64, type=int, help=\"Batch size for evaluation.\" ) parser.add_argument( \"--max_seq_len\", default=128, type=int, help=\"The maximum total input sequence length after tokenization.\", ) parser.add_argument( \"--num_train_epochs\", default=100.0, type=float, help=\"Total number of training epochs to perform.\", ) parser.add_argument( \"--weight_decay\", default=0.0, type=float, help=\"Weight decay if we apply some.\" ) parser.add_argument( \"--gradient_accumulation_steps\", type=int, default=1, help=\"Number of updates steps to accumulate before performing a backward/update pass.\", ) parser.add_argument( \"--adam_epsilon\", default=1e-8, type=float, help=\"Epsilon for Adam optimizer.\" ) parser.add_argument( \"--max_grad_norm\", default=1.0, type=float, help=\"Max gradient norm.\" ) parser.add_argument( \"--max_steps\", default=-1, type=int, help=\"If &gt; 0: set total number of training steps to perform. Override num_train_epochs.\", ) parser.add_argument( \"--warmup_steps\", default=200, type=int, help=\"Linear warmup over warmup_steps.\" ) parser.add_argument( \"--logging_steps\", type=int, default=400, help=\"Log every X updates steps.\" ) parser.add_argument( \"--save_steps\", type=int, default=200, help=\"Save checkpoint every X updates steps.\", ) parser.add_argument( \"--do_train\", action=\"store_true\", help=\"Whether to run training.\" ) parser.add_argument( \"--do_eval\", action=\"store_true\", help=\"Whether to run eval on the test set.\" ) parser.add_argument( \"--no_cuda\", action=\"store_true\", help=\"Avoid using CUDA when available\" ) # ---------------------------------------------------------------------- # embedding: 随机初始化； parser.add_argument( \"--random_init_w2v\", action=\"store_true\", help=\"是否直接随机初始化embedding； \" ) parser.add_argument( \"--encoder\", default=\"lstm\", type=str, help=\"Model type selected in the list: [textcnn, lstm] \", ) parser.add_argument( \"--aggregator\", default=\"max_pool\", type=str, help=\"Model type selected in the list: [slf_attn_pool, max_pool, avg_pool, dr_pool, ] \", ) parser.add_argument( \"--embed_dim\", default=256, type=int, help=\"dims for embedding layer.\" ) parser.add_argument( \"--hidden_dim\", default=256, type=int, help=\"dims for intermediate layers.\" ) parser.add_argument( \"--embeddings_learning_rate\", default=6e-4, type=float, help=\"The learning rate for Adam.\", ) parser.add_argument( \"--learning_rate\", default=20e-4, type=float, help=\"The learning rate for Adam.\" ) parser.add_argument( \"--classifier_learning_rate\", default=20e-4, type=float, help=\"The learning rate for Adam.\", ) parser.add_argument( \"--w2v_file\", default=\"/data2/nlpData/daguanfengxian/word2vec/dim_256_sg_0_hs_1_epochs_30/w2v.vectors\", type=str, help=\"path to pretrained word2vec file\", ) parser.add_argument(\"--dropout_rate\", default=0.2, type=float, help=\"dropout_rate \") parser.add_argument( \"--patience\", default=5, type=int, help=\"patience for early stopping \" ) parser.add_argument( \"--metric_key_for_early_stop\", default=\"macro avg__f1-score__level_2\", type=str, help=\"metric name for early stopping \", ) # prediction_output_file parser.add_argument( \"--prediction_output_file\", default=None, type=str, help=\"file for writing out the predictions \", ) # 针对不均衡样本 parser.add_argument( \"--class_weights_level_1\", default=None, type=str, help=\"class_weights, written in string like '1.0,2.0,2.0,5.0,200.0,300.0,400.0,500.0,500.0' \", ) # parser.add_argument( \"--class_weights_level_2\", default=None, type=str, help=\"class_weights, written in string like '0.828,1.241,1.465,1.622,1.963,2.002,2.173,2.507,2.564,2.572,2.707,4.244,4.469,4.953,5.460,5.693,6.477,6.694,7.174,7.804,8.648,8.988,9.090,10.06,10.25,11.94,15.53,25.80,32.65,48.48,50.0,80.0,84.21,88.88,100.0' \", ) parser.add_argument(\"--use_focal_loss\", default=\"True\", help=\"use focal loss\") parser.add_argument( \"--focal_loss_gamma\", default=2.0, type=float, help=\"gamma in focal loss\" ) # ---------------------------------------------------------------------- args = parser.parse_args() main(args) 这一部分非常需要展开来看，先从models/model_untils.py开始： model_untils.py 存放功能组件函数1. 加载w2v生成的embedding1234567891011121314151617181920212223242526272829303132333435363738394041424344def get_embedding_matrix_and_vocab(w2v_file, skip_first_line=True, include_special_tokens=True): \"\"\" Construct embedding matrix Args: embed_dic : word-embedding dictionary skip_first_line : 是否跳过第一行 Returns: embedding_matrix: return embedding matrix (numpy) embedding_matrix: return embedding matrix \"\"\" embedding_dim = None # 先遍历一次，得到一个vocab list 和向量list vocab_list = [] vector_list = [] with open(w2v_file, 'r', encoding='utf-8') as f_in: for i, line in tqdm.tqdm(enumerate(f_in)): if skip_first_line: if i == 0: continue line = line.strip() if not line: continue line = line.split(\" \") w_ = line[0] vec_ = line[1:] vec_ = [float(w.strip()) for w in vec_] if embedding_dim == None: embedding_dim = len(vec_) else: assert embedding_dim == len(vec_) vocab_list.append(w_) vector_list.append(vec_) # 添加两个特殊字符：PAD和UNK if include_special_tokens: vocab_list = ['pad', 'unk'] + vocab_list # 随机初始化两个向量 pad_vec_ = (np.random.rand(embedding_dim).astype(np.float32) * 0.05).tolist() unk_vec_ = (np.random.rand(embedding_dim).astype(np.float32) * 0.05).tolist() vector_list = [pad_vec_, unk_vec_] + vector_list return vocab_list, vector_list models/training/data_loader.py 部分 data_loader.py 加载数据的函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849def load_and_cache_examples(args, mode, vocab_list=None): processor = processors[args.task](args) cached_features_file = os.path.join( args.data_dir, \"cached_{}_{}_{}\".format(mode, args.task, args.max_seq_len) ) if os.path.exists(cached_features_file): logger.info(\"Loading features from cached file %s\", cached_features_file) features = torch.load(cached_features_file) else: logger.info(\"Creating features from dataset file at %s\", args.data_dir) if mode == \"train\": examples = processor.get_examples(\"train\") elif mode == \"dev\": examples = processor.get_examples(\"dev\") elif mode == \"test\": examples = processor.get_examples(\"test\") else: raise Exception(\"For mode, Only train, dev, test is available\") # Use cross entropy ignore index as padding label id so that only real label ids contribute to the loss later features = convert_examples_to_features( examples, args.max_seq_len, vocab_list=vocab_list ) logger.info(\"Saving features into cached file %s\", cached_features_file) torch.save(features, cached_features_file) # Convert to Tensors and build dataset all_input_ids = torch.tensor([f.input_ids for f in features], dtype=torch.long) all_attention_mask = torch.tensor( [f.attention_mask for f in features], dtype=torch.long ) all_label_id_level_1s = torch.tensor( [f.label_id_level_1 for f in features], dtype=torch.long ) all_label_id_level_2s = torch.tensor( [f.label_id_level_2 for f in features], dtype=torch.long ) dataset = TensorDataset( all_input_ids, all_attention_mask, all_label_id_level_1s, all_label_id_level_2s, ) return dataset","link":"/NLP/PyTorch/4-%E6%A8%A1%E5%9E%8B%E5%85%A5%E5%8F%A3/"},{"title":"BLE的分层介绍","text":"深入浅出低功耗蓝牙(BLE)协议栈 BLE协议栈为什么要分层？怎么理解BLE“连接”？如果BLE协议只有ATT层没有GATT层会发生什么？ 1.协议栈框架一般而言，我们把某个协议的实现代码称为协议栈（protocol stack），BLE协议栈就是实现低功耗蓝牙协议的代码，理解和掌握BLE协议是实现BLE协议栈的前提。在深入BLE协议栈各个组成部分之前，我们先看一下BLE协议栈整体架构。 要实现一个BLE应用，首先需要一个支持BLE射频的芯片，然后还需要提供一个与此芯片配套的BLE协议栈，最后在协议栈上开发自己的应用。可以看出BLE协议栈是连接芯片和应用的桥梁，是实现整个BLE应用的关键。 那BLE协议栈具体包含哪些功能呢？简单来说，BLE协议栈主要用来对你的应用数据进行层层封包，以生成一个满足BLE协议的空中数据包，也就是说，把应用数据包裹在一系列的帧头（header）和帧尾（tail）中。具体来说，BLE协议栈主要由如下几部分组成： PHY层（Physical layer物理层）。PHY层用来指定BLE所用的无线频段，调制解调方式和方法等。PHY层做得好不好，直接决定整个BLE芯片的功耗，灵敏度以及selectivity等射频指标。 LL层（Link Layer链路层）。LL层是整个BLE协议栈的核心，也是BLE协议栈的难点和重点。像Nordic的BLE协议栈能同时支持20个link（连接），就是LL层的功劳。LL层要做的事情非常多，比如具体选择哪个射频通道进行通信，怎么识别空中数据包，具体在哪个时间点把数据包发送出去，怎么保证数据的完整性，ACK如何接收，如何进行重传，以及如何对链路进行管理和控制等等。LL层只负责把数据发出去或者收回来，对数据进行怎样的解析则交给上面的GAP或者ATT。 HCI（Host controller interface）。HCI是可选的（具体请参考文章： 三种蓝牙架构实现方案（蓝牙协议栈方案）），HCI主要用于2颗芯片实现BLE协议栈的场合，用来规范两者之间的通信协议和通信命令等。 GAP层（Generic access profile）。GAP是对LL层payload（有效数据包）如何进行解析的两种方式中的一种，而且是最简单的那一种。GAP简单的对LL payload进行一些规范和定义，因此GAP能实现的功能极其有限。GAP目前主要用来进行广播，扫描和发起连接等。 L2CAP层（Logic link control and adaptation protocol）。L2CAP对LL进行了一次简单封装，LL只关心传输的数据本身，L2CAP就要区分是加密通道还是普通通道，同时还要对连接间隔进行管理。 SMP（Secure manager protocol）。SMP用来管理BLE连接的加密和安全的，如何保证连接的安全性，同时不影响用户的体验，这些都是SMP要考虑的工作。 ATT（Attribute protocol）。简单来说，ATT层用来定义用户命令及命令操作的数据，比如读取某个数据或者写某个数据。BLE协议栈中，开发者接触最多的就是ATT。BLE引入了attribute概念，用来描述一条一条的数据。Attribute除了定义数据，同时定义该数据可以使用的ATT命令，因此这一层被称为ATT层。 GATT（Generic attribute profile ）。GATT用来规范attribute中的数据内容，并运用group（分组）的概念对attribute进行分类管理。没有GATT，BLE协议栈也能跑，但互联互通就会出问题，也正是因为有了GATT和各种各样的应用profile，BLE摆脱了ZigBee等无线协议的兼容性困境，成了出货量最大的2.4G无线通信产品。 我相信很多人看了上面的介绍，还是不懂BLE协议栈的工作原理，以及每一层具体干什么的，为什么要这么分层。下面我以如何发送一个数据包为例来讲解BLE协议栈各层是如何紧密配合，以完成发送任务的。 2. 如何通过无线发送一个数据包假设有设备A和设备B，设备A要把自己目前的电量状态83%（十六进制表示为0x53）发给设备B，该怎么做呢？作为一个开发者，他希望越简单越好，对他而言，他希望调用一个简单的API就能完成这件事，比如send(0x53)，实际上我们的BLE协议栈就是这样设计的，开发者只需调用send(0x53)就可以把数据发送出去了，其余的事情BLE协议栈帮你搞定。很多人会想，BLE协议栈是不是直接在物理层就把0x53发出去? 这种方式初看起来挺美的，但由于很多细节没有考虑到，实际是不可行的。首先，它没有考虑用哪一个射频信道来进行传输，在不更改API的情况下，我们只能对协议栈进行分层，为此引入LL层，开发者还是调用send(0x53)，send(0x53)再调用send_LL(0x53,2402M)（注：2402M为信道频率）。这里还有一个问题，设备B怎么知道这个数据包是发给自己的还是其他人的，为此BLE引入access address概念，用来指明接收者身份，其中，0x8E89BED6这个access address比较特殊，它表示要发给周边所有设备，即广播。如果你要一对一的进行通信（BLE协议将其称为连接），即设备A的数据包只能设备B接收，同样设备B的数据包只能设备A接收，那么就必须生成一个独特的随机access address以标识设备A和设备B两者之间的连接。 2.1 广播方式我们先来看一下简单的广播情况，这种情况下，我们把设备A叫advertiser（广播者），设备B叫scanner或者observer（扫描者）。 广播状态下设备A的LL层API将变成send_LL(0x53,2402M, 0x8E89BED6)。由于设备B可以同时接收到很多设备的广播，因此数据包还必须包含设备A的device address（0xE1022AAB753B）以确认该广播包来自设备A，为此send_LL参数需要变成(0x53,2402M, 0x8E89BED6, 0xE1022AAB753B)。 LL层还要检查数据的完整性，即数据在传输过程中有没有发生窜改，为此引入CRC24对数据包进行检验 (假设为0xB2C78E) 。同时为了调制解调电路工作更高效，每一个数据包的最前面会加上1个字节的preamble（前导帧），preamble一般为0x55或者0xAA。这样，整个空中包就变成（注：空中包用小端模式表示！）：?? 上面这个数据包还有如下问题： 没有对数据包进行分类组织，设备B无法找到自己想要的数据0x53。为此我们需要在access address之后加入两个字段：LL header和长度字节。 LL header用来表示数据包的LL类型， 长度字节用来指明payload的长度 设备B什么时候开启射频窗口以接收空中数据包？当设备A的数据包在空中传输的时候，设备B把接收窗口关闭，此时通信将失败；当设备A没有在空中发送数据包时，设备B把接收窗口打开，此时通信也将失败。只有设备A的数据包在空中传输时，设备B正好打开射频接收窗口，此时通信才能成功，换句话说，LL层还必须定义通信时序。 当设备B拿到数据0x53后，该如何解析这个数据呢？它到底表示湿度还是电量，还是别的意思？这个就是GAP层要做的工作，GAP层引入了LTV（Length-Type-Value）结构来定义数据，比如020105，02-长度，01-类型（强制字段，表示广播flag，广播包必须包含该字段），05-值。由于广播包最大只能为31个字节，它能定义的数据类型极其有限，像这里说的电量，GAP就没有定义，因此要通过广播方式把电量数据发出去，只能使用供应商自定义数据类型0xFF，即04FF590053，其中04表示长度，FF表示数据类型（自定义数据），0x0059是供应商ID（自定义数据中的强制字段），0x53就是我们的数据(设备双方约定0x53就是表示电量，而不是其他意思)。 最终空中传输的数据包将变成：AAD6BE898E600E3B75AB2A02E102010504FF5900538EC7B2 AA – 前导帧(preamble) D6BE898E – 访问地址(access address) 60 – LL帧头字段(LL header) 0E – 有效数据包长度(payload length) 3B75AB2A02E1 – 广播者设备地址(advertiser address) 02010504FF590053 – 广播数据 8EC7B2 – CRC24值 有了PHY，LL和GAP，就可以发送广播包了，但广播包携带的信息极其有限，而且还有如下几大限制： 无法进行一对一通信 （广播是一对多通信，而且是单方向的通信） 由于不支持组包和拆包，因此无法传输大数据 通信不可靠。广播信道不能太多，否则将导致扫描端效率低下。为此，BLE只使用37(2402MHz) /38(2426MHz) /39(2480MHz)三个信道进行广播和扫描，因此广播不支持跳频。由于广播是一对多的，所以广播也无法支持ACK。这些都使广播通信变得不可靠。 扫描端功耗高。由于扫描端不知道设备端何时广播，也不知道设备端选用哪个频道进行广播，扫描端只能拉长扫描窗口时间，并同时对37/38/39三个通道进行扫描，这样功耗就会比较高。 而连接则可以很好解决上述问题，下面我们就来看看连接是如何将0x53发送出去的。 2.2 连接方式到底什么叫连接(connection)？像有线UART，很容易理解，就是用线（Rx和Tx等）把设备A和设备B相连，即为连接。用“线”把两个设备相连，实际是让2个设备有共同的通信媒介，并让两者时钟同步起来。蓝牙连接有何尝不是这个道理，所谓设备A和设备B建立蓝牙连接，就是指设备A和设备B两者“同步”成功，其具体包含以下几方面： 设备A和设备B对接下来要使用的物理信道达成一致 设备A和设备B双方建立一个共同的时间锚点，也就是说，把双方的时间原点变成同一个点 设备A和设备B两者时钟同步成功，即双方都知道对方什么时候发送数据包什么时候接收数据包 连接成功后，设备A和设备B通信流程如下所示： 一旦设备A和设备B连接成功（此种情况下，我们把设备A称为Master或者Central，把设备B称为Slave或者Peripheral），设备A将周期性以CI（connection interval）为间隔向设备B发送数据包，而设备B也周期性地以CI为间隔打开射频接收窗口以接收设备A的数据包。 同时按照蓝牙spec要求，设备B收到设备A数据包150us后，设备B切换到发送状态，把自己的数据发给设备A；设备A则切换到接收状态，接收设备B发过来的数据。 由此可见，连接状态下，设备A和设备B的射频发送和接收窗口都是周期性地有计划地开和关，而且开的时间非常短，从而大大减低系统功耗并大大提高系统效率。 现在我们看看连接状态下是如何把数据0x53发送出去的，从中大家可以体会到蓝牙协议栈分层的妙处。 对开发者来说，很简单，他只需要调用send(0x53) GATT层定义数据的类型和分组，方便起见，我们用0x0013表示电量这种数据类型，这样GATT层把数据打包成130053（小端模式！） ATT层用来选择具体的通信命令，比如读/写/notify/indicate等，这里选择notify命令0x1B，这样数据包变成了：1B130053 L2CAP用来指定connection interval（连接间隔），比如每10ms同步一次（CI不体现在数据包中），同时指定逻辑通道编号0004（表示ATT命令），最后把ATT数据长度0x0004加在包头，这样数据就变为：040004001B130053 LL层要做的工作很多，首先LL层需要指定用哪个物理信道进行传输（物理信道不体现在数据包中），然后再给此连接分配一个Access address（0x50655DAB）以标识此连接只为设备A和设备B直连服务，然后加上LL header和payload length字段，LL header标识此packet为数据packet，而不是control packet等，payload length为整个L2CAP字段的长度，最后加上CRC24字段，以保证整个packet的数据完整性，所以数据包最后变成：AAAB5D65501E08040004001B130053D550F6 AA – 前导帧(preamble) 0x50655DAB – 访问地址(access address) 1E – LL帧头字段(LL header) 08 – 有效数据包长度(payload length) 04000400 – ATT数据长度，以及L2CAP通道编号 1B – notify command 0x0013 – 电量数据handle 0x53 – 真正要发送的电量数据 0xF650D5 – CRC24值 虽然开发者只调用了 send(0x53)，但由于低功耗蓝牙协议栈层层打包，最后空中实际传输的数据将变成上面所示的模样，这就既满足了低功耗蓝牙通信的需求，又让用户API变得简单，可谓一箭双雕！ 上面只是对BLE协议栈实现原理做了一个简单概述，即便如此，由于都是关于BLE协议栈底层的东西，很多开发者还是会觉得比较枯燥和晦涩，而且对很多开发者来说，他们也不关心BLE协议栈是如何实现的，他们更关心的是BLE协议栈的使用，即怎么开发一个BLE应用。BLE应用是实打实的东西，不能像上面讲述协议栈一样泛泛而谈，必须结合具体的蓝牙芯片和蓝牙协议栈来讲解，为此后面将以Nordic芯片及协议栈作为范例，来具体讲解如何开发BLE应用，以及如何通过代码去理解BLE协议中定义的一些概念和术语。","link":"/IoT%E5%8D%8F%E8%AE%AE/BLE/ble%E7%9A%84%E5%88%86%E5%B1%82%E4%BB%8B%E7%BB%8D/"},{"title":"C++STL--单向链表&lt;forward_list&gt;","text":"头文件12#include&lt;forward_list&gt;using namespace std; 基础用法1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;forward_list&gt;using namespace std;int main(){ forward_list&lt;int&gt; l; //构造空的单向链表 //不提供size()的成员方法，使用算法distance()获取 cout &lt;&lt; l.max_size() &lt;&lt; endl; //最大的元素个数 forward_list&lt;int&gt; l2(5); //构造5个元素的单向链表，值为类型的默认值 cout &lt;&lt; \"第一个元素值：\" &lt;&lt; *l2.begin() &lt;&lt; endl; //最大的元素个数 forward_list&lt;int&gt; l3(5, 111); //构造5个元素的单向链表，每个元素值为111 cout &lt;&lt; \"第一个元素值：\" &lt;&lt; *l3.begin() &lt;&lt; endl; //最大的元素个数 forward_list&lt;int&gt; l4(l3); //拷贝构造 cout &lt;&lt; \"第一个元素值：\" &lt;&lt; *l4.begin() &lt;&lt; endl; //最大的元素个数 //验证forward_list的内存结构(不连续) for (forward_list&lt;int&gt;::iterator it = l3.begin(); it != l3.end(); ++it) { cout &lt;&lt; &amp;(*it) &lt;&lt; \" \"; } cout &lt;&lt; endl; return 0;// 576460752303423487// 第一个元素值：0// 第一个元素值：111// 第一个元素值：111// 0x55555556d368 0x55555556d388 0x55555556d3a8 0x55555556d3c8 0x55555556d3e8 } 迭代器使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;forward_list&gt;using namespace std;template &lt;class T&gt;void Print(T begin, T end){ for (T p = begin; p != end; ++p) { cout &lt;&lt; *p &lt;&lt; \" \"; } cout &lt;&lt; endl;}int main(){ forward_list&lt;int&gt; l3(5, 111); //构造5个元素的单向链表，每个元素值为111 cout &lt;&lt; \"第一个元素值：\" &lt;&lt; *l3.begin() &lt;&lt; endl; //最大的元素个数 //验证迭代器类别,forward iterator 前向迭代器 cout &lt;&lt; typeid(forward_list&lt;int&gt;::iterator::iterator_category).name() &lt;&lt; endl; //前向迭代器 比 双向迭代器 功能更少一些，支持++、= 、！= 、 == 、 * ，不支持 -- // 支持++ * = forward_list&lt;int&gt;::iterator it = l3.begin(); *(++it) = 222; *(++it) = 333; *(++it) = 444; *(++it) = 555; //指向最后一个 ++it; //指向最后一个的下一个 cout &lt;&lt; \"是否指向最后一个的下一个: \" &lt;&lt; (it == l3.end()) &lt;&lt; endl; //--it;//不可以--，因为是单向的 // const_iterator指向的元素不可赋值 forward_list&lt;int&gt;::const_iterator it2 = l3.cbegin(); //*it2 = 1;//const_iterator指向的元素不可赋值 //正向遍历forward_list for (forward_list&lt;int&gt;::iterator it = l3.begin(); it != l3.end(); ++it) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; //没有反向的迭代器，不支持，因为是单向链表 // forward_list&lt;int&gt;::reverse_iterator //验证Print ,迭代器带来的好处，让算法无需知道容器的细节 Print&lt;forward_list&lt;int&gt;::iterator&gt;(l3.begin(), l3.end()); return 0;// --- 输出 ---// 第一个元素值：111// St20forward_iterator_tag// 是否指向最后一个的下一个: 1// 111 222 333 444 555 // 111 222 333 444 555} 增加、删除、插入元素12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;forward_list&gt;using namespace std;int main(){ forward_list&lt;int&gt; l; /* 温习一下单链表的插入 pNew-&gt;next = pHead -&gt;next;//新节点的下一个指向插入前的第一个节点 pHead -&gt;next= pNew;//将头指针指向新节点 */ l.push_front(111); //从头部插入元素 l.push_front(222); //从头部插入元素 l.push_front(333); //从头部插入元素 /* 为什么没有insert_before() ？ pInsert -&gt;next; 你无法知道当前节点的前一个节点的地址，所以，你就无法将前一个的pLast-&gt;next=pNew 为什么insert_after()可以？ pNew-&gt;next= pInsert-&gt;next; pInsert-&gt;next = pNew; */ l.insert_after(l.begin(), 444); //在某个迭代器后面插入 for (forward_list&lt;int&gt;::iterator it = l.begin(); it != l.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; //访问头结点 cout &lt;&lt; \"front(): \" &lt;&lt; l.front() &lt;&lt; endl; /* 温习一下单链表的删除 pHead -&gt;next= pDelete-&gt;next;//将头指针指向删除节点的下一个 delete pDelete；//删除当前节点 */ l.pop_front(); //删除头结点 /* 为什么没有erase_before(),还是因为，你无法知道pDelete的前一个， 你就无法将前一个的pLast-&gt;next= pDelete-&gt;next; 为什么erase_after()可以? pTemp= pDelete-&gt;next; pDelete-&gt;next= pDelete-&gt;next-&gt;next; delete pTemp; */ l.erase_after(l.begin()); //删除迭代器节点的下一个 l.erase_after(l.begin(), l.end()); //删除迭代器区间 l.clear(); //删除所有元素 for (forward_list&lt;int&gt;::iterator it = l.begin(); it != l.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; return 0;} 尝试运行LeetCode206.反转链表","link":"/C/STL/c-stl-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8-forward-list/"},{"title":"Icarus用户指南 - CDN提供商","text":"选择合适的CDN提供商可以大幅度减少网站访客的网页加载时间。 Icarus为你提供了几种内置的CDN提供商来承载Icaurs所用到的第三方库和资源文件的加载。 本文同时提供以下语言的翻译：English。 下面的CDN功能由ppoffice/hexo-component-inferno提供，完整的支持提供商列表和配置详情以其为准。 内置CDN提供商目前，Icarus提供如下的内置CDN服务提供商： JavaScript库CDN cdnjs.com (cdnjs) jsDelivr (jsdelivr) UNPKG (unpkg) loli.net (loli) Web字体CDN Google Fonts (google) loli.net (loli) font.im (fontim) 中国科学技术大学 (ustc) FontAwesome图标CDN FontAwesome 5 (fontawesome) loli.net (loli) 默认的CDN服务提供商配置为： _config.icarus.yml1234providers: cdn: jsdelivr fontcdn: google iconcdn: fontawesome 自定义CDN提供商除此之外，你还可以通过URL模板来自定义CDN提供商。 每种类别提供商的模板格式如下所示： JavaScript库CDNCDN URL模板1https://some.cdn.domain.name/${package}/${version}/${filename} 你需要将实际的包名称，包版本号，和文件相对路径替换为${package}， ${version}，和${filename}占位符。 例如，如下JavaScript库的URL地址： UNPKG CDN URL示例1https://unpkg.com/d3@5.7.0/dist/d3.min.js 可以被概括成： UNPKG CDN URL模板1https://unpkg.com/${package}@${version}/${filename} 一些CDN提供商可能采用不同的URL形式。 例如，moment.js库在CDN.js上有着如下的URL形式： CDN.js CDN URL示例1https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment.js 但在UNPKG上有着这样的URL形式： UNPKG CDN URL示例1https://unpkg.com/moment@2.22.2/min/moment.min.js 因此，你需要注意你的自定义CDN提供商的URL格式。 默认情况下，Icarus向URL模板中传入的参数采用npm的包名称和文件相对路径（例如moment@2.22.2/min/moment.min.js）。 jsDelivr和UNPKG就采用这种npm形式。 否则，如果你采用如CDN.js这样的CDN提供商，请在URL模板前加上[cdnjs]： CDN.js-style URL模板1'[cdnjs]https://some.cdn.domain.name/${package}/${version}/${filename}' Web字体CDN你可以参入Google字体镜像站的URL或是与其兼容的网络字体CDN。 Icarus依赖Ubuntu，Oxanium，和Source Code Pro这三种字体，所以确保你使用的CDN提供这些字体。 自定义的URL模板需包含字体类型type（图标icon或是字体font）和字体名称fontname两个占位符： Webfont CDN URL模板1https://some.google.font.mirror/${type}?family=${fontname} FontAwesome图标CDN你可以传入自定义的FontAwesome CDN提供商的URL。 URL中不需要包含占位符。 本主题用到了一些FontAwesome 5图标，所以自定义的提供商需要至少提供它们。 Icon Font CDN URL模板1https://custom.fontawesome.mirror/some.stylesheet.css 以上自定义配置需放到主题配置中的providers部分： _config.icarus.yml1234providers: cdn: 'https://some.cdn.domain.name/${package}/${version}/${filename}' fontcdn: 'https://some.google.font.mirror/${type}?family=${fontname}' iconcdn: 'https://custom.fontawesome.mirror/some.stylesheet.css' CDN工具函数本主题定义了三个工具函数来帮助主题开发者轻松使用自定义CDN来引用第三方的前端资源。 详情请参见ppoffice/hexo-component-inferno. 文章内容有误？请点击此处提交修改。","link":"/Configuration/icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-cdn%E6%8F%90%E4%BE%9B%E5%95%86/"},{"title":"Chapter 34-37-TPM-PIT-LPTMR-RTC","text":"参考链接：https://blog.csdn.net/m0_45234510/article/details/114895429","link":"/NXP/ReferenceManual/chapter-34-37-tpm-pit-lptmr-rtc/"},{"title":"Icarus用户指南 - 主题配置","text":"Icarus的默认主题配置文件为_config.icarus.yml。 此文件定义了站点全局的布局与样式设置，同时也控制了例如插件与挂件等外部功能的配置。 本文详细介绍了本主题的一般配置，并且解释了Icarus使用哪些配置文件和它是如何生成并验证这些配置。 本文同时提供以下语言的翻译： English. .content ol:not([type]) { list-style-type: simp-chinese-informal; } 一般主题配置配置文件版本这个版本号与主题版本号相关却不总是相同。 Icarus使用此版本号来决定是否升级默认主题配置文件。 请不要自己更改这个版本号。 _config.icarus.yml1version: 5.0.0 主题变体通过此设置为Icarus更换”皮肤“。 此设置目前支持”default“和”cyberpunk“两种值。 你可以在此处查看Cyberpunk变体的效果。 _config.icarus.yml1variant: default Logo设置你站点的logo。 此logo会显示在导航栏和页脚。 logo配置的值既可以是你的logo图片的路径或URL地址： _config.icarus.yml1logo: /img/logo.svg 也可以像下面这样设置成文字： _config.icarus.yml12logo: text: My Beautiful Site Favicon你可以在head配置中指定你的网站favicon的路径或URL地址。 _config.icarus.yml12head: favicon: /img/favicon.svg Web App ManifestIcarus支持基本的PWAmanifest.json的生成与Meta标签。 要开启web app manifest，请再主题配置中使用如下的配置。 你也可以参考MDN来了解每个配置项的详情。 _config.icarus.yml &gt;folded1234567891011121314151617181920212223242526272829manifest: # Web应用的名称 (默认为站点标题) name: Icaurs - Hexo Theme # Web的显示名称 # 当没有空间显示全名时显示 short_name: Icarus # Web应用的初始URL start_url: https://ppoffice.github.io/ # 应用的默认主题颜色 theme_color: \"#3273dc\" # 在应用的样式表加载之前显示的应用页默认占位背景颜色 background_color: \"#3273dc\" # 网站首选的展示模式 display: standalone # 在不同上下文下用作应用图标的图片文件 icons: - # 图片文件的路径 src: icons/touch-icon-iphone.png # 空格分割的表示图标尺寸的字符串 sizes: 144x144 # 图片的媒体类型提示 (可选) type: image/png - src: icons/touch-icon-ipad.png sizes: 152x152 - src: icon/logo.ico sizes: 72x72 96x96 128x128 256x256 Open Graph你可以在head配置中设置Open Graph。 你应该在配置文件中将绝大部分配置留空。 仅在需要的时候在文章的front-matter中为这些设置赋值。 请参考Hexo文档来详细了解每个配置项。 _config.icarus.yml &gt;folded12345678910111213141516171819202122232425262728head: open_graph: # 页面标题 (og:title) (可选) title: # 页面类型 (og:type) (可选) type: blog # 页面URL地址 (og:url) (可选) url: # 页面封面图 (og:image) (可选) image: # 站点名称 (og:site_name) (可选) site_name: # 页面作者 (article:author) (可选) author: # 页面描述 (og:description) (可选) description: # Twitter卡片类型 (twitter:card) twitter_card: # Twitter ID (twitter:creator) twitter_id: # Twitter站点 (twitter:site) twitter_site: # Google+个人主页链接 (已弃用) google_plus: # Facebook admin ID fb_admins: # Facebook App ID fb_app_id: Google Structured Data你可以在head配置中设置Google Structured Data。 你应该在配置文件中将绝大部分配置留空。 仅在需要的时候在文章的front-matter中为这些设置赋值。 请参考Search for Developers来详细了解每个配置项。 _config.icarus.yml &gt;folded12345678910111213141516head: structured_data: # 页面标题 (可选) title: # 页面描述 (可选) description: # 页面URL地址 (可选) url: # 页面作者 (article:author) (可选) author: # 页面图片 (可选) image: # 文章发布者 (可选) publisher: # 发布者Logo (可选) publisher_logo: 页面元信息你可以通过head部分的meta设置来向生成的HTML中添加自定义&lt;meta&gt;标签。 每一个meta标签应作为meta数组中的一个元素出现。 meta设置每一个元素的值应为&lt;属性名&gt;=&lt;属性值&gt;的格式，其中属性名和属性值分别代表着&lt;meta&gt;标签的属性和值。 如果&lt;meta&gt;标签有多个属性和值，请使用;来分隔&lt;属性名&gt;=&lt;属性值&gt;。 _config.icarus.yml1234head: meta: - 'name=theme-color;content=#123456' - 'name=generator;content=\"Hexo 4.2.0\"' RSS你可以通过head部分的rss设置来添加RSS链接信息。 _config.icarus.yml12head: rss: /path/to/atom.xml 导航栏navbar部分定义了导航栏中的菜单与链接。 你可以通过向menu设置项中添加&lt;链接名&gt;: &lt;链接URL&gt;的方式添加任意导航栏菜单链接。 如要向导航栏右侧添加链接，请向links设置项中添加&lt;链接名&gt;: &lt;链接URL&gt;。 _config.icarus.yml1234567891011121314navbar: # 导航栏菜单项 menu: Home: / Archives: /archives Categories: /categories Tags: /tags About: /about # 导航栏右侧的链接 links: GitHub: 'https://github.com' Download on GitHub: icon: fab fa-github url: 'https://github.com/ppoffice/hexo-theme-icarus' 你也可以使用FontAwesome图标来作为纯文字链接的替换，格式如下： 链接格式123&lt;链接名&gt;: icon: &lt;FontAwesome图标的class名&gt; url: &lt;链接URL&gt; 页脚footer部分定义了页脚右侧的链接。 链接的配置格式与navbar中links的配置格式完全一致。 _config.icarus.yml1234567891011footer: links: Creative Commons: icon: fab fa-creative-commons url: 'https://creativecommons.org/' Attribution 4.0 International: icon: fab fa-creative-commons-by url: 'https://creativecommons.org/licenses/by/4.0/' Download on GitHub: icon: fab fa-github url: 'https://github.com/ppoffice/hexo-theme-icarus' 你也可以在页脚展示自定义版权文字： _config.icarus.yml12footer: copyright: 用💖发电 代码高亮如果你已在Hexo中启用了代码高亮功能，你可以通过article中的highlight设置来自定义代码块。 请从highlight.js/src/styles下列出的所有主题中 选择一个主题。 然后，复制文件名(不带.css后缀)到theme设置项中。 如要隐藏复制代码按钮，将clipboard设置为false。 如果你希望折叠或展开所有代码块，将fold设置为\"folded\"或\"unfolded\"。 你也可以将fold设置为空来禁止代码块折叠。 _config.icarus.yml123456789article: highlight: # 代码高亮主题 # https://github.com/highlightjs/highlight.js/tree/master/src/styles theme: atom-one-light # 显示复制代码按钮 clipboard: true # 代码块的默认折叠状态。可以是\"\", \"folded\", \"unfolded\" fold: unfolded 此外，你可以在Markdown文件中使用下面的语法来折叠单独的代码块： 123{% codeblock \"可选文件名\" lang:代码语言 &gt;folded %}...代码块内容...{% endcodeblock %} 封面 &amp; 缩略图若要为文章添加封面图，请在文章的front-matter中添加cover选项： post.md1234title: Icarus快速上手cover: /gallery/covers/cover.jpg---Post content... 类似地，你也可以在文章的front-matter中为文章设置缩略图： post.md1234title: Icarus快速上手thumbnail: /gallery/covers/thumbnail.jpg---Post content... 文章的缩略图会显示在归档页面和最新文章挂件中。 如果你在front-matter中使用的是图片的路径，你需要确保它是绝对或者相对于你的source目录的路径。 例如，为使用&lt;your blog&gt;/source/gallery/image.jpg作为缩略图，你需要在front-matter中使用/gallery/image.jpg作为图片路径。 文章阅读时间你可以将article部分的readtime设置为true来显示文章字数统计以及预计阅读时间。 _config.icarus.yml12article: readtime: true 文章更新时间若要显示文章的更新时间，请在文章的front_matter中设置updated时间： post.md1234title: Icarus快速上手updated: 2020-04-01 00:00:00---Post content... 然后，将主题配置文件的article部分的update_time设置为true： _config.icarus.yml12article: update_time: true 你也可以将update_time设置为false来隐藏所有文章的更新时间，或设置为auto而在文章的更新时间 与发布时间相同时隐藏更新时间。 文章许可协议你可以在你的文章/页面的底部展示你的作品的使用许可，许可链接可以是文字或者图标。 这里的配置与导航栏或者页脚的links配置一致： _config.icarus.yml1234567article: # 文章许可协议 licenses: Creative Commons: icon: fab fa-creative-commons url: 'https://creativecommons.org/' 'CC BY-NC-SA 4.0': 'https://creativecommons.org/licenses/by-nc-sa/4.0/' 侧边栏设置sidebar中某个侧边栏的sticky为true来让它的位置固定而不跟随页面滚动。 _config.icarus.yml12345sidebar: left: sticky: false right: sticky: true 其他配置你可以参考Icarus用户指南来了解更多第三方的插件、挂件、以及CDN提供商的配置。 配置文件与优先级除了在_config.icarus.yml的默认主题配置文件外，Icarus也会从如下位置获取替代配置： 位于_config.yml的站点配置文件 位于_config.post.yml和_config.page.yml的布局配置文件 文章/页面的front-matter (已弃用) 位于themes/icarus/_config.yml的旧主题配置文件 (已弃用) 位于themes/icarus/_config.post.yml和themes/icarus/_config.page.yml的旧布局配置文件 布局配置文件布局配置文件遵循着与主题配置文件相同的格式和定义。 _config.post.yml中的配置对所有文章生效，而_config.page.yml中的配置对所有自定义页面生效。 这两个文件将覆盖主题配置文件中的配置。 例如，你可以在_config.post.yml中把所有文章变为两栏布局： _config.post.yml12345678910widgets: - type: recent_posts position: left - type: categories position: left - type: tags position: left 同时所有其他页面仍保持三栏布局： _config.icarus.yml12345678910widgets: - type: recent_posts position: left - type: categories position: right - type: tags position: right 文章/页面的Front-matter如果你只想要在某个文章/页面中覆盖主题配置，你可以在那个文章/页面的front-matter中写下配置。 例如，你可以像下面这样在一篇文章的front-matter中更改某篇文章的代码高亮主题： source/_post/some-post.md1234567title: 我的第一篇文章date: '2015-01-01 00:00:01'article: highlight: theme: atom-one-dark---# 文章标题 上面的配置会为那篇文章覆盖掉_config.post.yml和_config.icarus.yml中的article.highlight。 这种层次化的配置系统对于页面个性化和不同访客间的差异化优化十分有效。 比如，你可以为根据你页面目标访客的国家和语言来开启更快的CDN或本地化的评论服务。 然而需要注意的是，一些Hexo定义的文章或页面属性不会覆盖掉其他配置源中的同名配置，如 title, date, updated, comments (not comment), layout, source, photos, 和excerpt。 站点配置文件上面列出的所有配置源，包括主题配置文件，布局配置文件，和文章/页面的front-matter，会覆盖掉站点配置文件中Icarus使用到的配置。 例如，_config.icarus.yml中的title设置会覆盖掉_config.yml中的title，但new_post_name却不会，因为 Icarus没有用到这个配置项。 另外，主题配置文件中的theme_config选项会与主题配置文件中的主题配置合并并覆盖掉同名配置。 然而，我们非常不推荐使用这个配置选项。 总结总而言之，配置源的作用范围和优先级如下： 对于某个文章或页面 文章/页面的front-matter覆盖所有下面的配置源。 布局配置文件覆盖所有下面的配置源。 站点配置文件中的theme_config选项覆盖所有下面的配置源。 主题配置文件覆盖所有下面的配置源。 站点配置文件。 对于所有的文章或页面 布局配置文件覆盖所有下面的配置源。 站点配置文件中的theme_config选项覆盖所有下面的配置源。 主题配置文件覆盖所有下面的配置源。 站点配置文件。 对于所有的文章，页面，和索引页 站点配置文件中的theme_config选项覆盖所有下面的配置源。 主题配置文件覆盖所有下面的配置源。 站点配置文件。 配置生成与校验所有的Icarus主题配置均使用YAML语言编写。 如果配置文件不存在，Icarus会通过一系列JSON Schema来自动生成默认的配置文件_config.icarus.yml。 这也是为什么你在主题目录下找不到示例配置文件(如_config.yml.example)。 大多数的JSON Schema存放在&lt;icarus_directory&gt;/include/schema目录下，而其他的则存放在 ppoffice/hexo-component-inferno仓库中。 你可以在你的hexo命令后附上--icarus-dont-generate-config来避免配置文件的自动生成。 当你每次运行hexo命令时，主题也会对比JSON Schema来校验你的配置文件。 如果校验中出现任何错误，Icarus会将错误位置与错误类型打印在屏幕上。 例如，如下的错误信息告诉我们logo配置值应该为字符串或是对象，而不是一个整型数。 你可以在你的hexo命令后附上--icarus-dont-check-config来跳过校验，但并不推荐这么做。 hexo日志1234567891011121314INFO === Checking package dependencies ===INFO === Checking the configuration file ===WARN Configuration file failed one or more checks.WARN Icarus may still run, but you will encounter unexcepted results.WARN Here is some information for you to correct the configuration file.WARN [ { keyword: 'type', dataPath: '.logo', schemaPath: '#/properties/logo/type', params: { type: 'string,object' }, message: 'should be string,object' }] 此外，如果你的默认主题配置文件不是最新版本的话，Icarus会运行迁移脚本将它升级到最新版本。 这些脚本存放在&lt;icarus_directory&gt;/include/migration目录。 你可以在你的hexo命令后附上--icarus-dont-upgrade-config来禁止配置升级。 最后，Icarus也会检查主题依赖的Node.js库是否安装并提醒你安装缺失的库。 文章内容有误？请点击此处提交修改。","link":"/Configuration/icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"title":"Icarus用户指南 - 用户评论插件","text":"本文介绍Icarus 5支持的用户评论插件的安装配置。 本文同时提供以下语言的翻译：English。 下面的用户评论插件由ppoffice/hexo-component-inferno提供，完整的支持插件列表和配置详情以其为准。 .content ol:not([type]) { list-style-type: simp-chinese-informal; } 畅言安装指南 首先，登录畅言云评， 并按照PC端通用代码接入文档获取评论HTML代码。 复制appid与conf的值到主题配置的对应配置项中。 例如，如下的HTML代码： 畅言安装代码 &gt;folded123456789&lt;!--PC版--&gt;&lt;div id=\"SOHUCS\" sid=\"...\"&gt;&lt;/div&gt;&lt;script charset=\"utf-8\" type=\"text/javascript\" src=\"https://cy-cdn.kuaizhan.com/upload/changyan.js\" &gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;window.changyan.api.config({ appid: '????appid????', conf: 'prod_xxxxxxxxxxxxxxxxxxxxxxx'});&lt;/script&gt; 对应到主题配置为： _config.icarus.yml1234comment: type: changyan app_id: ????appid???? conf: prod_xxxxxxxxxxxxxxxxxxxxxxx Disqus 安装指南在线预览 首先，登录Disqus。 点击首页的“开始”(GET STARTED)按钮或者访问 此处并点击“我想要将Disqus安装到我的站点” (I want to install Disqus on my site)来创建新的站点评论服务。 在创建新站点页面中填写“网站名称”(Website Name)以及“网站类型”(Category)，然后点击“创建站点”(Create Site)。 如果你愿意的话，选择一个付费订阅。 你也可以点击左侧的“安装Disqus”(Install Disqus)来跳过此步。 下一步，选择Disqus的安装平台。 此处选择页面底部的“上面没有列出我使用的平台，使用通用代码安装” (I don’t see my platform listed, install manually with Universal Code)。 点击页面底部的“配置”(Configure)按钮跳过“通用代码安装指南”(Universal Code install instructions)。 在“配置Disqus”(Configure Disqus)页面中按需填写Disqus个性化配置。 然后，点击“完成安装”(Complete Setup)和“关闭配置”(Dismiss Setup)按钮来结束配置。 下一步，在评论服务首页的右上角点击“编辑配置”(Edit Settings)按钮。 在“为你的站点配置Disqus”(Configure Disqus for Your Site)页面上找到“Shortname”的值， 复制到主题配置的评论配置项中。 例如，下面截图中的“Shortname”为my-hexo-blog-1： 对应的主题配置为： _config.icarus.yml123comment: type: disqus shortname: my-hexo-blog-1 （可选）你可以在文章的front-matter中加入disqusId来为文章添加Disqus唯一标识。 这样，你可以在未来更改文章的位置而不会丢失所有评论。 source/_post/some-post.md12345title: 我的第一篇文章date: 2015-01-01 00:00:01disqusId: some-disqus-id---# Hello world DisqusJS在Disqus服务访问受限的地区可使用DisqusJS作为替代。 关于DisqusJS的配置过程可参考https://github.com/SukkaW/DisqusJS。 安装指南在线预览 登录Disqus并访问此链接。 点击“注册新应用”(Register new application)或者“注册应用”(registering an application)来创建新的Disqus应用。 在下一页面中填写”应用名称“(Label)，”介绍“(Description)，以及”网站地址“(Website)。 然后点击“注册我的应用”(Register my application)。 应用创建完毕后，进入应用的”设置“(Settings)界面，在”域名“(Domains)输入框中填入你Hexo站点的域名，例如ppoffice.github.io。 然后点击页面底部的“保存更改”(Save Changes)按钮。 点击当前页面中的“详情”(Details)链接切换到当前应用的主页。 从”OAuth设置“(OAuth Settings)部分中复制”API Key“到相应的主题配置项中。 例如，下面截图中的”API Key“： 对应为下面的主题配置： _config.icarus.yml12345678comment: type: disqusjs shortname: my-hexo-blog-1 api_key: xxxxxxxxxxxxxxxxxxxxxxxxxxxxx api: https://disqus.skk.moe/disqus/ # 可选填 admin: ppoffice # 可选填 admin_label: Admin # 可选填 nesting: 4 # 可选填 如要更多了解DisqusJS和它的配置，请访问SukkaW/DisqusJS文档或 hexo-component-inferno。 Facebook 此评论插件可能会被部分广告拦截扩展拦截，请酌情使用。 安装指南在线预览 如要开启Facebook评论服务，将comment的type设置为facebook即可。 _config.icarus.yml12comment: type: facebook Giscus利用 GitHub Discussions 实现的评论系统。 安装指南在线预览 准备一个公开的 GitHub 仓库（Repository）。 访问GitHub Apps - giscus并点击”安装“(Install)。 (可选)如果你的账号下有组织账号，在下一页中选择需要安装 giscus 的用户。 在下一页面选择将 giscus 安装到”所有仓库“(All repositories)或是”选定的仓库“(Only select repositories)。 然后点击“安装”(Install)按钮。 若安装成功，网页将跳转到 giscus 官网。 你可以阅读每个的配置项的说明，并按照配置你的 giscus 安装。 完成配置后，转到页面上的”启用 giscus “(Enable giscus)并从 giscus 的 HTML 代码中复制属性值到主题配置的对应配置项中。 例如下面的 giscus 代码： giscus 安装代码 &gt;folded12345678910111213141516&lt;script src=\"https://giscus.app/client.js\" data-repo=\"usr/repo\" data-repo-id=\"X_xxxxxxxxxx\" data-category=\"Announcements\" data-category-id=\"XXX_xxxxxxxxxxxxxxxx\" data-mapping=\"pathname\" data-strict=\"0\" data-reactions-enabled=\"0\" data-emit-metadata=\"0\" data-input-position=\"top\" data-theme=\"noborder_light\" data-lang=\"zh-CN\" data-loading=\"lazy\" crossorigin=\"anonymous\" async&gt;&lt;/script&gt; 对应下面的主题配置： _config.icarus.yml1234567891011121314comment: type: giscus repo: usr/repo # 必填项 repoId: X_xxxxxxxxxx # 必填项 category: Announcements # 可选填，默认为 Announcements categoryId: XXX_xxxxxxxxxxxxxxxx # 必填项 mapping: pathname # 可选填，默认为 pathname strict: false # 可选填 reactionsEnabled: false # 可选填 emitMetadata: false # 可选填 inputPosition: top # 可选填，默认为 top theme: noborder_light # 可选填 lang: zh-CN # 可选填，默认为 en lazy: true # 可选填，默认为 false Gitalk 安装指南在线预览 登录GitHub并点此注册一个新的OAuth应用。 填写”应用名称“(Application name)，”应用主页“(Homepage URL)，”应用描述“(Application description)。 然后，在”认证回调地址“(Authorization callback URL)填写你的博客的根URL地址。 点击“注册应用”(Register application)按钮来跳转到应用详情界面。 复制”Client ID“与”Client Secret“的值并填入主题配置的相应配置项中。 例如，对于下面的”Client ID“和”Client Secret“： GitHub OAuth应用1234Client IDxxxxxxxxxxxxxxxxxxxxClient Secretxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 对应如下的Gitalk的配置： _config.icarus.yml12345678910111213141516comment: type: gitalk client_id: xxxxxxxxxxxxxxxxxxxx client_secret: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx repo: Some-of-Your-GitHub-Repo owner: you_github_name admin: - you_github_name per_page: 20 # 可选填 distraction_free_mode: false # 可选填 pager_direction: last # 可选填 create_issue_manually: false # 可选填 proxy: # 可选填 flip_move_options: # 可选填 enable_hotkey: true # 可选填 language: zh-CN # 可选填 关于上述配置的含义和可选值，请参考Gitalk文档或 hexo-component-inferno。 Gitment Gitment似乎已停止维护。你可以选择Gitalk或utterances作为基于GitHub Issues的评论系统的替代。 安装指南 参照Gitalk中的步骤注册GitHub OAuth应用。 复制”Client ID“与”Client Secret“的值到主题配置的相应配置项中。 下面是Gitment的示例配置： _config.icarus.yml123456789comment: type: gitment owner: you_github_name repo: Some-of-Your-GitHub-Repo client_id: xxxxxxxxxxxxxxxxxxxx client_secret: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx theme: gitment.defaultTheme # 可选填 per_page: 20 # 可选填 max_comment_height: 250 # 可选填 关于上述配置的含义，请参考Gitment文档或 hexo-component-inferno。 Isso如果你希望自己搭建一个评论系统而不是依赖第三方的评论服务时，Isso是一个可行的选择。 然而，不同于第三方评论系统，你需要准备一个Web服务器用来运行Isso服务端程序。 安装指南 请参照Isso文档安装并启动Isso服务器。 将Isso服务器的HTTP URL填入到主题配置的相应配置项中。 例如，如果你的Isso服务地址为https://posativ.org/isso/api/，你会有如下的评论配置： _config.icarus.yml123comment: type: isso url: posativ.org/isso/api LiveRe 此评论插件可能会被部分广告拦截扩展拦截，请酌情使用。 安装指南 首先，登录LiveRe。 点击导航栏上的“安装”(Install)链接，进入安装界面。 选择免费”City“选项下方的“现在安装”(Install Now)按钮。 在”获取LiveRe City代码“(Get LiveRe City code)页面填写”站点地址“(Site URL)，”网站名称“(Name of website)， 和”网站类别“(Choose site category)。 勾选“同意广告协议”(I have check the advertising terms…)并点击”获取代码“(Get code)按钮来跳转到LiveRe HTML代码页面。 复制data-uid=\"...\"引号内的值到主题配置中的相应配置项中。 例如，下方的LiveRe代码： LiveRe安装代码 &gt;folded123456789101112131415161718&lt;!-- LiveRe City install code --&gt;&lt;div id=\"lv-container\" data-id=\"city\" data-uid=\"ABCD1234O0OxxxxXXXX000==\"&gt; &lt;script type=\"text/javascript\"&gt; (function(d, s) { var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === 'function') { return; } j = d.createElement(s); j.src = 'https://cdn-city.livere.com/js/embed.dist.js'; j.async = true; e.parentNode.insertBefore(j, e); })(document, 'script'); &lt;/script&gt;&lt;noscript&gt; Please activate JavaScript for write a comment in LiveRe&lt;/noscript&gt;&lt;/div&gt;&lt;!-- completed City install code --&gt; 对应的主题配置为： _config.icarus.yml123comment: type: livere uid: ABCD1234O0OxxxxXXXX000== TwikooTwikoo是一个基于云函数的自建评论系统。 不同于其他第三方评论服务，在Icarus中设置和使用Twikoo之前，你需要将它的后端部署到云环境上。 安装指南在线预览 按照Twikoo文档，将Twikoo云函数部署到你指定的云服务商之上。 将你部署的env_id填入主题设置中的对应设置项之中。 _config.icarus.yml12345comment: type: twikoo env_id: xxxxxxxx region: ap-guangzhou # 可选填 lang: zh-CN # 可选填 utterances 安装指南在线预览 准备一个公开的GitHub仓库(Repository)。 访问GitHub Apps - utterances并点击”安装“(Install)。 (可选)如果你的账号下有组织账号，在下一页中选择需要安装utterances的用户。 在下一页面选择将utterances安装到”所有仓库“(All repositories)或是”选定的仓库“(Only select repositories)。 然后点击“安装”(Install)按钮。 若安装成功，网页将跳转到utterances官网。 你可以阅读每个的配置项的说明，并按照配置你的utterances安装。 完成配置后，转到页面上的”开启utterances“(Enable Utterances)并从utterances的HTML代码中复制属性值到主题配置的对应配置项中。 例如下面的utterances代码： utterances安装代码 &gt;folded1234567&lt;script src=\"https://utteranc.es/client.js\" repo=\"Your-GitHub-Username/Your-Public-Repo-Name\" issue-term=\"pathname\" theme=\"github-light\" crossorigin=\"anonymous\" async&gt;&lt;/script&gt; 对应下面的主题配置： _config.icarus.yml1234567comment: type: utterances repo: Your-GitHub-Username/Your-Public-Repo-Name issue_term: pathname # 必填项，与issue_number二选一填写 issue_number: 100 # 必填项，与issue_term二选一填写，每篇文章对应一个issue，填写前需要手动创建issue label: some-issue-label # 可选填 theme: github-light # 可选填 Valine 安装指南在线预览 有用户发现一个存在于Valine评论插件的漏洞会导致此评论服务暴露所有评论者的 IP地址 (xCss/Valine#336)。 请在此漏洞修复之前换用其他评论服务。 按照快速开始文档创建LeanCloud应用。 将你LeanCloud应用的”App ID“和”App Key“复制到主题配置的对应配置项中。 此外，你可以参考配置项来了解可选配置项的详情和可能的配置值。 下面是示例配置： _config.icarus.yml123456789101112131415161718comment: type: valine app_id: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx app_key: xxxxxxxxxxxxxxxxxxxxxx placeholder: \"\" # 可选填 avatar: mm # 可选填 avatar_force: false # 可选填 meta: [\"nick\", \"mail\", \"link\"] # 可选填 page_size: 10 # 可选填 lang: zh-CN # 可选填 visitor: false # 可选填 highlight: true # 可选填 record_ip: false # 可选填 server_urls: # 可选填 emoji_cdn: # 可选填 emoji_maps: # 可选填 enable_qq: false # 可选填 required_fields: [] # 可选填 Waline 安装指南在线预览 按照快速上手创建LeanCloud应用和Vercel项目。 将你Vercel项目的”服务器地址“(Server URL)复制到主题配置的对应配置项中。 通常它类似于https://your-domain.vercel.app。 此外，你可以参考前端配置来了解可选配置项的详情和可能的配置值。 下面是示例配置： _config.icarus.yml12345678910111213141516171819202122comment: type: waline server_url: https://your-domain.vercel.app path: window.location.pathname # 可选填 lang: zh-CN # 可选填 locale: # 可选填 placeholder: 'Comment here...' emoji: # 可选填 - '//unpkg.com/@waline/emojis@1.0.1/weibo' dark: auto # 可选填 meta: [\"nick\", \"mail\", \"link\"] # 可选填 required_meta: [] # 可选填 login: enable # 可选填 word_limit: 0 # 可选填 page_size: 10 # 可选填 image_uploader: false # 可选填 highlighter: true # 可选填 tex_renderer: false # 可选填 search: false # 可选填 pageview: false # 可选填 comment: false # 可选填 copyright: true # 可选填 文章内容有误？请点击此处提交修改。","link":"/Plugins/Comment/icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-%E7%94%A8%E6%88%B7%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/"},{"title":"自定义Hexo标签插件","text":"除了Hexo Built-in Tag Helpers中描述的Hexo原生支持的标签插件以外，Icarus也提供其他 几个用来定制内容显示的有用的标签插件。 本文同时提供以下语言的翻译：English。 下面的标签插件由ppoffice/hexo-component-inferno提供，完整的支持插件列表和配置详情以其为准。 .example-tab-container { margin: 0 0 20px 0; padding: 10px 20px 20px 20px; border-radius: 6px; box-shadow: 0 0.5em 0.75em -0.125em rgba(10,10,10,0.1), 0 0px 0 1px rgba(10,10,10,0.02); } 消息五颜六色的消息块可以用来强调你文章中的部分文本。 它的语法定义如下： 123{% message color:&lt;颜色&gt; size:&lt;大小&gt; icon:&lt;图标&gt; title:&lt;标题&gt; %} &lt;内容&gt;{% endmessage %} color此选项定义消息块的颜色。 其为可选项。 它可用的配置值与示例如下： default 一个没有设置颜色的代码块。 dark 一个深色(dark)的代码块。 primary 一个主题色(primary)的代码块。 info 一个提示色(info)的代码块。 success 一个成功色(success)的代码块。 warning 一个警示色(warning)的代码块。 danger 一个危险色(danger)的代码块。 size此选项定义消息块的大小。 其为可选项。 它可用的配置值与示例如下： small 一个小(small)的代码块。 default 一个没有设置大小的代码块。 medium 一个中等大小(small)的代码块。 large 一个大(small)的代码块。 icon此选项定义显示在消息块头部的图标。 其为可选项。 它的值应为FontAwesome的图标class name。 如果图标的class name含有空格，则配置名与配置值需要用引号包裹住。 一个有着GitHub图标的消息块 一个有着GitHub图标(\"icon:fa-brands fa-github\")的消息块。 一个有着Node.js图标的消息块 一个有着Node.js图标(\"icon:fa-brands fa-node-js\")的消息块。 一个有着NPM图标的消息块 一个有着NPM图标(\"icon:fa-brands fa-npm\")的消息块。 title此选项定义消息块的标题。 其为可选项。 如果标题含有空格，则配置名与配置值需要用引号包裹住。 有标题的消息块 有标题的消息块(\"title:有标题的消息块\")。 没有标题的消息块。 没有标题的消息块。 没有标题的消息块。 没有标题的消息块。 没有标题的消息块。 没有标题的消息块。 没有标题的消息块。 标签页标签页是一个功能强大的用于展示平行内容的标签插件。 同一时间内，只有活动的标签页内容才能展示给用户。 它的语法定义如下： 123456789{% tabs size:&lt;大小&gt; align:&lt;对齐&gt; style:&lt;样式&gt; %}&lt;!-- tab id:&lt;标签ID&gt; icon:&lt;图标&gt; title:&lt;标签标题&gt; active --&gt;&lt;标签内容&gt;&lt;!-- endtab --&gt;&lt;!-- tab id:&lt;标签ID&gt; icon:&lt;图标&gt; title:&lt;标签标题&gt; --&gt;&lt;标签内容&gt;&lt;!-- endtab --&gt;...{% endtabs %} 标签容器一个标签容器有着以下选项： size此选项定义标签页的大小。 其为可选项。 它可用的配置值与示例如下： 第一页 第二页 这是一个小(small)标签页容器的第一页。 这是一个小(small)标签页容器的第二页。 第一页 第二页 这是一个没有指定大小的标签页容器的第一页。 这是一个没有指定大小的标签页容器的第二页。 第一页 第二页 这是一个中等大小(medium)标签页容器的第一页。 这是一个中等大小(medium)标签页容器的第一页。 第一页 第二页 这是一个大(large)标签页容器的第一页。 这是一个大(large)标签页容器的第二页。 align此选项定义标签页按钮的对齐方式。 其为可选项。 它可用的配置值与示例如下： 第一页 第二页 这是一个没有指定对齐方式的标签页容器的第一页。 这是一个没有指定对齐方式的标签页容器的第二页。 第一页 第二页 这是一个居中对齐的(centered)标签页容器的第一页。 这是一个居中对齐的(centered)标签页容器的第二页。 第一页 第二页 这是一个右对齐的(right)标签页容器的第一页。 这是一个右对齐的(right)标签页容器的第二页。 第一页 第二页 这是一个全宽的(fullwidth)标签页容器的第一页。 这是一个全宽的(fullwidth)标签页容器的第二页。 style此选项定义标签页按钮的样式。 其为可选项。 此外你可以将样式与全宽(fullwidth)对齐方式结合。 它可用的配置值与示例如下： 第一页 第二页 这是一个盒状(boxed)标签页容器的第一页。 这是一个盒状(boxed)标签页容器的第二页。 第一页 第二页 这是一个拨动开关状(toggle)标签页容器的第一页。 这是一个拨动开关状(toggle)标签页容器的第二页。 第一页 第二页 这是一个圆角拨动开关状(toggle-rounded)标签页容器的第一页。 这是一个圆角拨动开关状(toggle-rounded)标签页容器的第二页。 第一页 第二页 这是一个全宽(fullwidth)盒状(boxed)标签页容器的第一页。 这是一个全宽(fullwidth)盒状(boxed)标签页容器的第二页。 第一页 第二页 这是一个全宽(fullwidth)拨动开关状(toggle)标签页容器的第一页。 这是一个全宽(fullwidth)拨动开关状(toggle)标签页容器的第二页。 第一页 第二页 这是一个全宽(fullwidth)圆角拨动开关状(toggle-rounded)标签页容器的第一页。 这是一个全宽(fullwidth)圆角拨动开关状(toggle-rounded)标签页容器的第二页。 Tab一个标签页有如下选项： id此选项为标签页元素的独特标识符(ID)。 此项为必填项。 一个标签页ID应当在整个页面内为独一无二的，这样Icarus才能定位、显示、和隐藏正确的标签页内容。 active此选项标记当前的标签页是否默认显示。 此项为选填项。 同一时刻一个标签组中只有一个标签页可以标记为活动(active)标签页。 icon此选项定义标签按钮中显示的图标。 此项为选填项。 它的值应为FontAwesome图标的class name。 如果图标的class name含有空格，则配置名与配置值需要用引号包裹住。 GitHub Node.js 这个标签页的图标(icon)为\"icon:fa-brands fa-github\"。 这个标签页的图标(icon)为\"icon:fa-brands fa-node-js\"。 GitHub Node.js 这个标签页的图标(icon)为\"icon:fa-brands fa-github\"。 这个标签页的图标(icon)为\"icon:fa-brands fa-node-js\"。 title此选项定义标签按钮的标题。 其为可选项。 如果标题含有空格，则配置名与配置值需要用引号包裹住。 有标题的标签页 另一个有标题的标签页 这个标签页的标题(title)为(\"title:有标题的标签页\")。 这个标签页的标题(title)为(\"title:另一个有标题的标签页\")。","link":"/uncategorized/%E8%87%AA%E5%AE%9A%E4%B9%89hexo%E6%A0%87%E7%AD%BE%E6%8F%92%E4%BB%B6/"},{"title":"常见问题","text":"本文解答了一些Icarus常见问题。 如果你的问题没有在这里得到解答，也请阅读 Icarus用户指南， Hexo中文文档， 以及GitHub Issues。 此外，你也可以在GitHub讨论组上向其他Icarus用户请求帮助。 本文同时提供以下语言的翻译：English。 站点 我无法生成我的站点。 / 我在生成站点时遇到错误。 Icarus 5运行在Node.js 12.4.0或更新的版本上。 它同时依赖Hexo 6.0.0或更高版本。 除此之外，请确保所有的Node.js依赖已安装。 你可以在&lt;icarus_directory&gt;/package.json 文件的dependencies部分下找到这些依赖。 同时，从你的站点中移除所有无用的Node.js依赖，否则它们可能会导致Icarus出现奇怪的问题。 如何更改我的站点的语言？ 打开站点根目录下的站点配置文件_config.yml，修改如下设置： _config.yml12- language: en+ language: &lt;语言名&gt; 你可以在&lt;icarus_directory&gt;/languages目录下找到所有可用的翻译。 &lt;语言名&gt;为不带后缀名的翻译文件名。 布局 我如何改变页面的宽度？我如何使用单栏/双栏/三栏布局？ 如要改变页面的宽度，编辑&lt;icarus_directory&gt;/include/style/responsive.styl这个样式文件。 此文件定义了不同屏幕尺寸下的页面容器宽度。 如要改变挂件或主内容宽度，编辑&lt;icarus_directory&gt;/layout/common/widgets.jsx和&lt;icarus_directory&gt;/layout/layout.jsx。 在这些文件中找到诸如is-12，is-8-tablet，和is-4-widescreen这样的CSS类名。 CSS类名中的数字标志着一个挂件或主内容所占据的栏数量。 数字后的屏幕尺寸，如tablet和widescreen，指代着栏数量生效的屏幕尺寸条件。 修改类名中的数字使主内容栏的栏数量和所有挂件栏的栏数量在相同屏幕尺寸下相加等于12。 例如，为使主内容栏在宽屏(widescreen)下更宽，你可以做出如下修改： &lt;icarus_directory&gt;/layout/layout.jsx &gt;folded12345678 &lt;div class={classname({ column: true, 'order-2': true, 'column-main': true, 'is-12': columnCount === 1,- 'is-8-tablet is-8-desktop is-8-widescreen': columnCount === 2,+ 'is-8-tablet is-8-desktop is-9-widescreen': columnCount === 2, 'is-8-tablet is-8-desktop is-6-widescreen': columnCount === 3 &lt;icarus_directory&gt;/layout/common/widgets.jsx &gt;folded1234567 function getColumnSizeClass(columnCount) { switch (columnCount) { case 2:- return 'is-4-tablet is-4-desktop is-4-widescreen';+ return 'is-4-tablet is-4-desktop is-3-widescreen'; case 3: return 'is-4-tablet is-4-desktop is-3-widescreen'; 你可以参考Bulma文档来获取更多关于布局系统的细节。 下面时一些创建单栏/双栏/三栏布局的提示： 你可以从主题配置中移除所有的挂件来创建单栏布局。 你可以将所有的挂件移动到页面的一侧来创建双栏布局。 你可以将挂件放在页面两边来创建三栏布局。 若要更改单个文章或页面的布局，请参考配置文件与优先级。 挂件/评论插件/分享按钮...的布局文件在哪里？我如何个性化内置的挂件/评论插件/分享按钮...？ 插件和挂件的布局文件已被移至一个单独的Node.js库中——hexo-component-inferno。 这样，主题开发者可以更好地在不同主题之间复用这些通用组件，并且普通用户可以更简便地覆盖这些内置组件。 若要自定义这些组件，从hexo-component-inferno仓库中拷贝布局文件并把它们放入&lt;icarus_directory&gt;/layout下的的相应目录中。 例如，如果你想要自定义Valine评论插件，你可以从hexo-component-inferno仓库中拷贝 src/view/comment/valine.jsx 到&lt;icarus_directory&gt;/layout/comment/valine.jsx。 同时像下面这样改正此文件头部的一些Node.js引用： &lt;icarus_directory&gt;/layout/comment/valine.jsx12- const { cacheComponent } = require('../../util/cache');+ const { cacheComponent } = require('hexo-component-inferno/lib/util/cache'); 最后，用hexo clean清理你的站点并重新生成HTML文件。 类似的，你可以用同样的方式覆盖主题内置的静态文件，如 asset/js/insight.js 。 为什么我的改变的布局文件在我刷新页面时没有生效（假设我正在使用hexo server）？ 当你使用hexo server启动本地Hexo服务器时，Icarus会缓存布局文件。 如要使布局文件的修改生效，请重启本地服务器。 其他情况下临时生成的数据会被Hexo缓存在内存或者db.json数据库中。 在运行hexo server或hexo generate之前执行hexo clean应该可以解决此问题。 内容 我的图片没有正确显示。 / 我的图片仅在首页显示，却无法在文章页面显示。 请确保你使用了图片的绝对路径。 例如，你的站点位于你域名的子目录下，如https://ppoffice.github.io/hexo-theme-icarus， 并且你的图片image.jpg放在了source/gallery/目录下。 那么你应该用/hexo-theme-icarus/gallery/image.jpg来引用你的图片。 你也可以像下面这样使用{% img %}这个Hexo标签来自动引用图片： 1{% img /gallery/image.jpg \"Image title\" %} 在这种情况下，你可以从图片路径中省略网站子目录。 你可以参考Hexo文档来了解更多详情。 如何为文章添加摘要？如何显示“阅读更多”按钮？ 在你的文章中添加&lt;!-- more --&gt;标签。 标签前面的文章内容会被标记为摘要，而其后的内容不会显示在文章列表上。 你也可以在文章的front-matter中设置自定义摘要。 some-post.md12345title: 一篇文章date: 2020-01-01excerpt: 这是一篇关于...---# 文章内容... 我如何加密文章？ 使用如hexo-blog-encrypt这样的第三方的Hexo插件。 我如何像这篇文章一样使用炫酷的页面元素？ 请参考Bulma文档来了解所有可选的元素和样式。 复制其中的HTML代码段并直接放入你的Markdown文件中。 挂件与插件 我如何才能移除页面上警告我一些配置值没有设置的红色警示信息？ 这些警示信息通常在你遗漏一些插件或挂件的配置设置时出现。 如果你不想开启某个插件或挂件，把它们从你的主题配置中删掉或注释掉。 例如，注释掉这几行来禁用掉评论插件： _config.icarus.yml123456- comment:- type: disqus- shortname: + # comment:+ # type: disqus+ # shortname: 文章内容有误？请点击此处提交修改。","link":"/uncategorized/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"title":"Icarus用户指南 - 赞赏按钮","text":"本文介绍Icarus 5支持的赞赏按钮的安装配置。 若需同时展示多个按钮，只需像如下这样在主题配置的donates数组中添加多个按钮配置： _config.icarus.yml1234567donates: - type: ... # 按钮1 ... - type: ... # 按钮2 ... 本文同时提供以下语言的翻译：English。 下面的赞赏按钮由ppoffice/hexo-component-inferno提供，完整的支持按钮列表和配置详情以其为准。 .content ol:not([type]) { list-style-type: simp-chinese-informal; } 爱发电安装指南 注册爱发电并复制个人页面的地址。 将如下配置添加到主题配置中： _config.icarus.yml12345donates: - type: afdian # 个人赞助页面的地址 url: /path/to/afdian/personal/page 支付宝安装指南 登录支付宝并导出个人支付二维码图片。 将二维码图片保存到你的Hexo网站的附件文件夹下，或将它上传至图床。 向主题配置中添加如下配置： _config.icarus.yml12345donates: - type: alipay # 支付宝二维码图片地址 qrcode: /path/to/alipay/qrcode.png Buy me a Coffee安装指南 注册Buy me a Coffee并复制个人页面的地址。 将如下配置添加到主题配置中： _config.icarus.yml12345donates: - type: buymeacoffee # 个人赞助页面的地址 url: /path/to/buymeacoffee/personal/page Paypal安装指南 登录Paypal，点击此处来创建一个Paypal捐赠按钮。 在“选择按钮样式”(Choose button style)页面选择“国家/地区”(Country/Region)和“语言”(Language)，点击“继续”(Continue) 进入下一页面。 在“添加机构详情”(Add organization details)页面中，选择“使用账号ID”(Use account ID)或“使用Email地址”(Use email address) 作为唯一账号标识符。 然后点击“继续”(Continue)进入下一页面。 在“设置捐赠数额”(Set donation amounts)页面选择“接收的货币种类”(Currency you’ll receive donations in)，捐赠数额选择 “任意数额”(Any amount)。 此捐赠按钮暂不支持“指定数额”的捐赠选项。 点击“结束并获取代码”(Finish and Get Code)按钮进入下一页面。 从“按钮HTML代码”(Button HTML)页面中复制business和currency_code两项的值。 将它们填写到主题配置的business和currency_code设置中。 例如，下方的Paypal捐赠按钮代码： Paypal按钮HTML代码123456&lt;form action=\"https://www.paypal.com/cgi-bin/webscr\" ...&gt;&lt;input type=\"hidden\" name=\"cmd\" value=\"_donations\" /&gt;&lt;input type=\"hidden\" name=\"business\" value=\"XXXXXXXXXXXXX\" /&gt;&lt;input type=\"hidden\" name=\"currency_code\" value=\"USD\" /&gt;...&lt;/form&gt; 对应的主题配置为: _config.icarus.yml12345donates: - type: paypal business: XXXXXXXXXXXXX currency_code: USD Patreon安装指南 注册Patreon并复制个人页面的URL地址。 将如下配置添加到主题配置中： _config.icarus.yml12345donate: - type: patreon # 个人赞助页面的地址 url: /path/to/patreon/personal/page 微信安装指南 登录微信并导出个人支付二维码图片。 将二维码图片保存到你的Hexo网站的附件文件夹下，或将它上传至图床。 向主题配置中添加如下配置： _config.icarus.yml12345donates: - type: wechat # 微信二维码图片地址 qrcode: /path/to/wechat/qrcode.png 文章内容有误？请点击此处提交修改。","link":"/Plugins/Donation/icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-%E8%B5%9E%E8%B5%8F%E6%8C%89%E9%92%AE/"},{"title":"Icarus快速上手","text":"欢迎使用Icarus！ Icarus是静态网站生成器Hexo的一款简单，精致，而现代的主题。 它力求设计上的优雅，但也不抛弃使用上的简单明了。 它灵活且多功能的配置系统让资深用户也能极尽细节地装饰他们的站点。 Icarus同时也提供了超多插件与挂件来满足你的多元的站点个性化和优化需求。 除此以外，它的崭新实现使得更好的IDE支持和第三方接入成为可能，并提供了更多未来的优化空间。 本文同时提供以下语言的翻译： English. 在你继续安装Icarus之前，请先花些时间阅览Hexo文档。 如要安装Icarus，你可以选择如下两种方式中的任意一种： 从源码安装 使用NPM安装 从GitHub的仓库中下载源码的压缩包并解压到你Hexo站点的主题目录中。 或者，你可以使用Git来克隆Icarus的代码仓库到themes目录下： Git Bash/命令行1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus -b &lt;version number&gt; --depth 1 你可以省略-b &lt;version number&gt;来获取Icarus的最新开发版本。 如果你想同时下载Git仓库的完整提交历史，请同时省略--depth 1。 另外，你也可以使用下面的命令将Icarus安装为Git子模块(submodule)： Git Bash/命令行1git submodule add https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 若要使用NPM将Icarus安装为Node包，在你的Hexo站点根目录运行如下命令： 命令行1npm install -S hexo-theme-icarus hexo-renderer-inferno 接下来，在你的站点的_config.yml文件中的开启Icarus： _config.yml1theme: icarus 或使用hexo命令修改主题为Icarus: 命令行1hexo config theme icarus 最后，使用如下命令来启动Hexo本地测试服务器并开始创作。 命令行1hexo server 如需了解更多主题、挂件、和插件相关的信息，请查看 Icarus用户指南。 你也可以参考本站的源代码来获取更多的使用示例。 本站源代码位于GitHub上Icarus代码仓库的site分支。 此外，你也可能在GitHub讨论组上获得其他Icarus用户的帮助。 额外资源 下面是一些帮助你进一步个性化你的站点的其他资源。 你也可以点击此处来提交你的Icarus教程。 Hexo中文文档 博客源码分享 by 辣椒の酱 hexo-theme-icarus 3 食用经验分享 by iMaeGoo 活用 Bulma 美化 Icarus 文章 by iMaeGoo icarus主题自定义 by kuzen Icarus4主题自定义记录 by BlakeNeko Icarus 主题自定义 by AlphaLxy 文章内容有误？点击此处提交修改。 unsplash-logo王希孟 千里江山图卷","link":"/uncategorized/icarus%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"},{"title":"Icarus用户指南 - 其他插件","text":"本文介绍Icarus 5支持的其他插件的安装配置。 本文同时提供以下语言的翻译：English。 下面的插件由ppoffice/hexo-component-inferno提供，完整的支持插件列表和配置详情以其为准。 画廊安装指南 Icarus的画廊插件同时包含了lightGallery与 Justified Gallery两种插件。 若要启用画廊插件，请将主题配置中plugins &gt; gallery的值设置为true。 _config.icarus.yml12plugins: gallery: true 此外，若要使用Justified Gallery，请将你的图片包裹在&lt;div class=\"justified-gallery\"&gt;与&lt;/div&gt;的HTML标签对中。 并且如果你使用的是Markdown语法来引用图片的话，请在HTML标签和Markdown之间添加空行。 例如，下方画廊预览的Markdown代码为： Justified-Gallery-Markdown.md &gt;folded12345678910&lt;div class=\"justified-gallery\"&gt;![Elephant](/hexo-theme-icarus/gallery/animals/elephant.jpeg)![Dog](/hexo-theme-icarus/gallery/animals/dog.jpeg)![Birds](/hexo-theme-icarus/gallery/animals/birds.jpeg)![Fox](/hexo-theme-icarus/gallery/animals/fox.jpeg)![Horse](/hexo-theme-icarus/gallery/animals/horse.jpeg)![Leopard](/hexo-theme-icarus/gallery/animals/leopard.jpeg)&lt;/div&gt; 同样，我们也可使用纯HTML来创建Justified Gallery。 这种情况下HTML标签之间就不需要添加空行了： Justified-Gallery-HTML.md &gt;folded12345678&lt;div class=\"justified-gallery\"&gt;&lt;img src=\"/hexo-theme-icarus/gallery/animals/elephant.jpeg\" alt=\"Elephant\" /&gt;&lt;img src=\"/hexo-theme-icarus/gallery/animals/dog.jpeg\" alt=\"Dog\" /&gt;&lt;img src=\"/hexo-theme-icarus/gallery/animals/birds.jpeg\" alt=\"Birds\" /&gt;&lt;img src=\"/hexo-theme-icarus/gallery/animals/fox.jpeg\" alt=\"Fox\" /&gt;&lt;img src=\"/hexo-theme-icarus/gallery/animals/horse.jpeg\" alt=\"Horse\" /&gt;&lt;img src=\"/hexo-theme-icarus/gallery/animals/leopard.jpeg\" alt=\"Leopard\" /&gt;&lt;/div&gt; 效果预览 下面是Justified Gallery实现的图片网格。 你也可以点击其中的任意图片查看lightGallery的全图展示效果。 下面的图片来源于pexel.com KaTeX安装指南 你可以使用KaTeX插件来渲染\\(\\TeX\\)数学公式。 若要启用KaTeX插件，请将主题配置中plugins &gt; katex的值设置为true。 _config.icarus.yml12plugins: katex: true 请使用\\\\(和\\\\)包裹你的行内公式，使用$$或\\\\[与\\\\]标签对包裹块状公式。 例如： Some-Post.md &gt;folded123456789这是一个行内公式：\\\\(ax^2+bx+c=0\\\\)。这是一个块状公式：$$\\displaystyle \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} = 1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}} {1+\\frac{e^{-8\\pi}} {1+\\cdots} } } }$$这是另一个块状公式：\\\\[f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)e^{2 \\pi i \\xi x}d\\xi\\\\] 有时你的\\(\\TeX\\)语法会被错认为Markdown语法而导致公式渲染异常。 例如，下面的公式不会渲染成功，因为其中包含多个_(下划线)而被Markdown渲染器错误的认成Markdown的斜体字语法： Some-Post.md123$$\\hat{x}_{k}=\\hat{x}_{k}^{-}+K_{t}\\left(y_{k}\\right)$$ 在这种情况下，你可以选择转义每个可能导致歧义的字符： Some-Post.md123$$\\hat{x}\\_{k}=\\hat{x}\\_{k}^{-}+K\\_{t}\\left(y\\_{k}\\right)$$ 或是简单地将整个公式用一个额外的HTML标签对包裹起来： Some-Post.md12345&lt;div&gt;$$\\hat{x}_{k}=\\hat{x}_{k}^{-}+K_{t}\\left(y_{k}\\right)$$&lt;/div&gt; MathJax安装指南 你可以使用MathJax插件来渲染\\(\\TeX\\)，MathML，或AsciiMath数学公式。 若要启用MathJax插件，请将主题配置中plugins &gt; mathjax的值设置为true。 _config.icarus.yml12plugins: mathjax: true 当使用\\(\\TeX\\)语法时，请使用$或\\\\(与\\\\)包裹行内公式，$$或\\\\[与\\\\]标签对包裹块状公式。 或者使用\\(\\LaTeX\\)环境。例如： Tex-Example.md &gt;folded123456789101112131415161718这是一个行内公式：\\\\(ax^2+bx+c=0\\\\)。这是另一个行内公式：$ax^2+bx+c&gt;0$。这是一个块状公式：$$\\displaystyle \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} = 1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}} {1+\\frac{e^{-8\\pi}} {1+\\cdots} } } }$$这是另一个块状公式：\\\\[f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)e^{2 \\pi i \\xi x}d\\xi\\\\]或者使用\\\\(\\LaTeX\\\\)环境：\\\\begin{equation}A =\\\\begin{bmatrix} a &amp; b \\\\\\\\ c &amp; c\\\\end{bmatrix}\\\\end{equation} 或者直接使用MathML语法。例如： MathML-Example.md &gt;folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950当&lt;math xmlns=\"http://www.w3.org/1998/Math/MathML\"&gt; &lt;mi&gt;a&lt;/mi&gt; &lt;mo&gt;≠&lt;/mo&gt; &lt;mn&gt;0&lt;/mn&gt;&lt;/math&gt;，方程&lt;math xmlns=\"http://www.w3.org/1998/Math/MathML\"&gt; &lt;mi&gt;a&lt;/mi&gt; &lt;msup&gt; &lt;mi&gt;x&lt;/mi&gt; &lt;mn&gt;2&lt;/mn&gt; &lt;/msup&gt; &lt;mo&gt;+&lt;/mo&gt; &lt;mi&gt;b&lt;/mi&gt; &lt;mi&gt;x&lt;/mi&gt; &lt;mo&gt;+&lt;/mo&gt; &lt;mi&gt;c&lt;/mi&gt; &lt;mo&gt;=&lt;/mo&gt; &lt;mn&gt;0&lt;/mn&gt;&lt;/math&gt; 有两个解，它们是&lt;math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"&gt; &lt;mi&gt;x&lt;/mi&gt; &lt;mo&gt;=&lt;/mo&gt; &lt;mrow&gt; &lt;mfrac&gt; &lt;mrow&gt; &lt;mo&gt;-&lt;/mo&gt; &lt;mi&gt;b&lt;/mi&gt; &lt;mo&gt;±&lt;/mo&gt; &lt;msqrt&gt; &lt;msup&gt; &lt;mi&gt;b&lt;/mi&gt; &lt;mn&gt;2&lt;/mn&gt; &lt;/msup&gt; &lt;mo&gt;-&lt;/mo&gt; &lt;mn&gt;4&lt;/mn&gt; &lt;mi&gt;a&lt;/mi&gt; &lt;mi&gt;c&lt;/mi&gt; &lt;/msqrt&gt; &lt;/mrow&gt; &lt;mrow&gt; &lt;mn&gt;2&lt;/mn&gt; &lt;mi&gt;a&lt;/mi&gt; &lt;/mrow&gt; &lt;/mfrac&gt; &lt;/mrow&gt; &lt;mtext&gt;.&lt;/mtext&gt;&lt;/math&gt; 同样地，你也可以使用MathJax支持的AsciiMath。 公式需包裹在\\`内。 AsciiMath-Example.md &gt;folded1当\\`a != 0\\`，方程\\`ax^2 + bx + c = 0\\`有两个解，它们是&lt;p style=\"text-align:center\"&gt;\\`x = (-b +- sqrt(b^2-4ac))/(2a)\\`.&lt;/p&gt; 有时你的\\(\\TeX\\)语法会被错认为Markdown语法而导致公式渲染异常。 请参照KaTeX一节来查看解决方案。 效果预览(\\(\\TeX\\) &amp; \\(\\LaTeX\\)) 这是一个行内公式：\\(ax^2+bx+c=0\\)。这是另一个行内公式：$ax^2+bx+c&gt;0$。 这是一个块状公式： $$\\displaystyle \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} = 1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}} {1+\\frac{e^{-8\\pi}} {1+\\cdots} } } }$$ 这是另一个块状公式： \\[f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)e^{2 \\pi i \\xi x}d\\xi\\] 或者使用\\(\\LaTeX\\)环境： \\begin{equation} A = \\begin{bmatrix} a &amp; b \\\\ c &amp; c \\end{bmatrix} \\end{equation} 效果预览(MathML) 当 a ≠ 0 ， 方程 a x 2 + b x + c = 0 有两个解，它们是 x = - b ± b 2 - 4 a c 2 a . 效果预览(AsciiMath) 当`a != 0`，方程`ax^2 + bx + c = 0`有两个解，它们是`x = (-b +- sqrt(b^2-4ac))/(2a)`. Cookie同意提示安装指南 你可以通过启用Cookie同意提示插件来向你的访客展示Cookie同意对话框。 请参考下载Cookie Consent和Cookie Consent插件文档来了解每个配置项的细节。 你也可以通过注释掉配置的方式来禁用Cookie同意对话框。 _config.icarus.yml123456789101112plugins: cookie_consent: # 同意对话框类型。可以为\"info\"，\"opt-in\"，或\"opt-out\" type: info # 弹出框主题。可以为\"block\"，\"edgeless\"，或\"classic\" theme: edgeless # 是否使弹出框固定，不随页面滚动而滚动 static: false # 弹出框在屏幕上的位置 position: bottom-left # 你网站的Cookie协议的URL policyLink: 'https://www.cookiesandyou.com/' 浏览器升级提醒 (Outdated Browser)安装指南 你可以使用浏览器升级提醒(Outdated Browser)插件来检测你的网站访客使用的老旧浏览器，并提醒他们升级浏览器。 若要启用此插件，请将主题配置中plugins &gt; outdated_browser的值设置为true。 点击此处即可预览插件开启效果。 _config.icarus.yml12plugins: outdated_browser: true 网页载入动画安装指南 Icarus默认启用网页载入动画。 若需禁止载入动画，请在你的主题配置中将plugins &gt; animejs设置为false。 _config.icarus.yml12plugins: animejs: false 另外，若需禁用网页载入进度条，请在你的主题配置中将plugins &gt; progressbar设置为false。 _config.icarus.yml12plugins: progressbar: false 文章内容有误？请点击此处提交修改。","link":"/Plugins/Other/icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-%E5%85%B6%E4%BB%96%E6%8F%92%E4%BB%B6/"},{"title":"ROM_RAM_FLASH傻傻分不清楚","text":"ROM (Read Only Memory)程序存储器是一种只能读出事先所存的数据的固态半导体存储器。ROM中所存数据稳定，一旦存储数据就再也无法将之改变或者删除，断电后所存数据也不会消失。其结构简单，因而常用于存储各种固化程序和数据。 在单片机中用来存储程序数据及常量数据或变量数据，凡是c文件及h文件中所有代码、全局变量、局部变量、‘const’限定符定义的常量数据、startup.asm文件中的代码（类似ARM中的bootloader或者X86中的BIOS，一些低端的单片机是没有这个的）通通都存储在ROM中。 为了便于使用和大批量生产，进一步发展出了可编程只读存储器（PROM）、可擦除可编程只读存储器（EPROM）。EPROM需要用紫外线长时间照射才能擦除，使用很不方便。1980s又出现了电可擦除可编程只读存储器（EEPROM），它克服了EPROM的不足，但是集成度不高、价格较贵。于是又发展出了一种新型的存储单元结构同EPROM类似的快闪存储器（FLASH MEMORY）。FLASH集成度高、功耗低、体积小，又能在线快速擦除，因而获得了快速发展。 FLASH 存储器Flash 存储器（FLASH EEPROM）又称闪存，快闪。它是EEPROM的一种。它结合了ROM和RAM的长处。不仅具备电子可擦除可编辑（EEPROM）的性能，还不会断电丢失数据同时可以快速读取数据。它于EEPROM的最大区别是，FLASH按扇区（block）操作，而EEPROM按照字节操作。FLASH的电路结构较简单，同样容量占芯片面积较小，成本自然比EEPROM低，因此适合用于做程序存储器。 RAM (Random Access Memory)随机访问存储器RAM又称随机存取存储器，存储单元的内容可按照需要随机取出或存入，且存取的速度与存储单元的位置无关。这种存储器在断电时，将丢失其存储内容，所以主要用于存储短时间使用的程序。 它主要用来存储程序中用到的变量。凡是整个程序中，所用到的需要被改写的量（包括全局变量、局部变量、堆栈段等），都存储在RAM中。 ROM, FLASH和RAM的区别对于RAM, ROM以及FLASH的区别，简单地说，在计算机中，RAM 、ROM都是数据存储器。RAM 是随机存取存储器，它的特点是易挥发性，即掉电失忆。ROM 通常指固化存储器(一次写入，反复读取)，它的特点与RAM 相反。ROM又分一次性固化、光擦除和电擦除重写两种类型。 在应用中，常规上ROM是用来存储固化程序的，RAM是用来存放数据的。由于FLASH ROM比普通的ROM读写速度快，擦写方便，一般用来存储用户程序和需要永久保存的数据。 譬如说，现在家用的电子式电度表，它的内核是一款单片机，该单片机的程序就是存放在ROM里的。电度表在工作过程中，是要运算数据的，要采集电压和电流，并根据电压和电流计算出电度来。电压和电流是一个实时的数据，用户不关心，它只是用来计算电度用，计算完后该次采集的数据就用完了，然后再采集下一次，因此这些值就没必要永久存储，就把它放在RAM里边。然而计算完的电度，是需要永久保存的，单片机会定时或者在停电的瞬间将电度数存入到FLASH里。","link":"/NXP/rom-ram-flash%E5%82%BB%E5%82%BB%E5%88%86%E4%B8%8D%E6%B8%85%E6%A5%9A/"},{"title":"RT1024 EVK 学习笔记Part2","text":"RT1024 EVK 学习笔记Part2 POWER DOMAIN 部分！ 功能模块供电BUTTON部分 包含三个按键： SW2: CPU ONOFF按键；–&gt; 连接到MCU ONOFF引脚； SW3: 系统复位按键POR_BUTTON;–&gt; 连接到MCU POR 引脚； SW4: 用户按键USER_BUTTON；–&gt; 连接到MCU的WAKEUP; 每个按键的结构相似： SPST PB（Single Pole Single Throw Push Button）单刀单掷按钮 0.1uF的去抖电容； 接地连接 按键工作原理： 正常状态下通过上拉保持高电平 按下时接地变为低电平； 电容用于消除按键抖动 USER LED LED控制电路，使用了三极管驱动方案： 供电：(注意：DCDC_3V3 来自于 5V_SYS, 通过U4，有DCDC_3V3的输出！) DCDC_3V3提供3.3V电源 R15（220Ω）作为LED**限流电阻**; LED部分： D5是一个绿色LED 阴极接三极管集电极； 三极管驱动： Q521是BC817-40LT1G NPN三极管； R1870（2.2K）和R1856（22K）构成基极偏置网络； MCU的USER_LED信号控制三极管导通； 工作原理： USER_LED低电平时，V(be) ≈0V, 三极管截止，LED熄灭； USER_LED高电平时，V(be) &gt; 0.7V, 三极管导通，LED点亮； 使用三极管可以提供更大的驱动能力 关键电源管理 SD Card Power Switch 电源路径： 输入：DCDC_3V3（3.3V） 输出：VSD_3V3（SD卡供电） 滤波： C171（1.0μF/10V）：输入滤波 C30（1.0μF/10V）：输出滤波 控制逻辑： R28（10KΩ）上拉电阻到DCDC_3V3; D7、D8二极管（RB521S30）构成AND门: 只有当SD_PWREN为高，且POR_B也为高时，U27才可以使能，有输出VSD_3V3; 即：系统复位完成后，POR_B拉高，只有系统上电后、且SD卡使能 时，U27才工作，有输出：VSD_3V3! 3V3 LDO for SNVS 这部分电路是 3.3V LDO（低压差稳压器）电源电路，用于为 SNVS（安全非易失性存储器供电域） 提供稳定的 3.3V 电压（VLDO_3V3）。 电路组成： 输入电源部分： 5V_SYS 是输入电源，提供5V电压。 C40 (10μF) 和 C41 (0.1μF)： 是输入端的去耦电容，分别用于低频和高频噪声的滤波。 C40 提供储能，减小输入电源的低频纹波。 C41 用于滤除高频噪声，保护稳压器的输入端。 LDO稳压器 (U3)： U3 (UM1750S-00) 是一颗 LDO 稳压芯片，其主要引脚功能如下： IN (1)： 输入引脚，连接 5V_SYS。 OUT (5)： 输出引脚，生成稳定的 VLDO_3V3。 GND (2)： 接地。 FB (4)： 反馈引脚，用于调节和稳定输出电压，内部参考电压为 1V。 SHDN (3)： 使能引脚，高电平使能稳压器，低电平关闭输出。 反馈电路： R32 (464kΩ) 和 R34 (200kΩ, 1%)： 组成分压网络，用于将输出电压分压后反馈到 FB 引脚。 分压电路的电压关系为： 输出滤波部分： C42 (4.7μF, 6.3V) 和 C43 (0.1μF)： C42 是主滤波电容，用于稳压器输出端的低频滤波，提供稳定的直流电压。 C43 是高频滤波电容，用于抑制高频噪声和瞬态波动，提升稳定性。 输出端： VLDO_3V3： 是稳压器的输出电压，为后续电路提供稳定的 3.3V 电源，适用于 SNVS 域或其他低功耗模块。 SNVS在上面的输出VLDO_3V3，刚好就用于SNVS，产生VDD_SNVS_3V3,最终连接到MCU的引脚VDD_SNVS_IN: NVCC_SD &lt;SD3.0&gt; 会根据 输入的 SD0_VSELECT信号，决定输出的NVCC_SD电压是1.8V或者3.3V，默认情况下是3.3V！ 核心电源域 VDDHIGH/NVCC_xxxVDDHIGH/NVCC电源管理电路： DC-DC转换器部分（U4 MP2144GJ）： 输入部分： 5V_SYS通过R38（0Ω）输入； C49(10μF)/C50(10μF)/C51(0.1μF)输入滤波； 输出部分： L2（1μH）储能电感； C52(22μF)/C53(0.1μF)输出滤波； 输出DCDC_3V3（3.3V）； 使能部分： 通过PMIC_ON_REQ信号，当它为高时，才使能U4，有输出DCDC_3V3; 同时，控制U5的复位信号为低，不复位；否则U5会复位整个电路； 反馈控制： R40（180KΩ）/R42（40.2K）分压网络；计算得到输出为3.28V; FB引脚监测输出电压； 注释显示R26/R30=4.5；(???不知道是干嘛) 复位控制电路（U5 UM605RE）： 输入信号： POR_BUTTON：通过D9二极管 WDOG_B：通过D10二极管 AND逻辑控制 当两者都为高时，才会使MR为高；只要有一个为低，都会导致MR使能； 电源监控： 监控VDD_SNVS_3V3 C60(0.1μF)去耦 控制逻辑： 使能控制： PMIC_ON_REQ信号 通过R41（10K）连接到EN引脚 PG（Power Good）： 内部上拉到VIN，即5V_SYS; DCDC_3V3_PG信号输出;(5V的PG怎么变成3V3的PG的？？搞不清楚) 辅助电源ADC供电DCDC_3V3产生VDDA_ADC_3V3，供MCU端的引脚VDDA_ADC_3P3使用！ DCDC_IN/VDD_HIGH_INDCDC_3V3产生MCU_DCDC_IN_3V3，供MCU端的引脚DCDC_IN使用！ DCDC_3V3产生VDD_HIGH_IN_3V3，供MCU端的引脚VDD_HIGH_IN使用！ 总结 SOC的输入：(VDD_SOC_IN)的来源路径： 5V_SYS -&gt; MP2144GJ(DC-DC) -&gt; DCDC_3V3/MCU_DCDC_IN_3V3 -&gt; DCDC_LP/DCDC_OUT -&gt; J4 -&gt; VDD_SOC_IN -&gt; MCU核心 VDD_SNVS_IN 5V_SYS -&gt; UM1750S-00 -&gt; VLDO_3V3 -&gt; VDD_SNVS_3V3 VDD_HIGH_IN 5V_SYS -&gt; MP2144GJ(DC-DC) -&gt; DCDC_3V3 -&gt; VDD_HIGH_IN_3V3 VDDA_ADC_3P3 5V_SYS -&gt; MP2144GJ(DC-DC) -&gt; DCDC_3V3 -&gt; VDDA_ADC_3P3 此外，先有 MCU_DCDC_IN_3V3, 然后才有 MCU_DCDC_IN。 DCDC_LP 引脚输出DCDC_OUT,供VDD_SOC_IN使用； DCDC_PWITCH引脚有一个PWITCH RC Delay电路，应该是用来保证上电时序的； PMIC_ON_REQ引脚对外输出该信号。决定了是否有DCDC_3V3的产生； POR引脚应该是低电平复位。接收输入的POR_B、RST_TGTMCU_B和U2。上电时，当电压达到阈值会释放复位，来确保上电时序。确保系统在电源稳定后才开始工作。 XTALI/XTALO连接一个外部的24MHz晶振；Y4 RTC_XTALI/RTC_XTALO连接一个32.768KHZ的晶振：Y2;","link":"/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part2/"},{"title":"RT1024 EVK 学习笔记Part3","text":"RT1024 EVK 学习笔记Part3 Page5 MCU PINOUT 部分！ 以及额外的，Page14 BOOT！ U1D SEMC 部分 SEM接口部分共有42个引脚，为GPIO_EMC_00 ~ GPIO_EMC_41。 它的功能分组如下： 引脚功能分组 数据线: SEMC_D0 ~ SEMC_D15 (16位数据总线)； 地址线: SEMC_A0 ~ SEMC_A12 (13位地址总线)； 控制信号13个: SEMC_DM0, SEMC_WE, SEMC_CAS, SEMC_RAS, SEMC_CS0, SEMC_BA0, SEMC_BA1; SEMC_CKE, SEMC_CLK, SEMC_DM1; SAI3_MCLK, ENET_MDIO, ENET_MDC; 数据选通信号DQS说明 SEMC_DQS: 数据选通信号,用于高速数据传输时的同步; 在MCU端的Pin是GPIO_EMC_28, 它默认用于SAI3_MCLK, 如果需要SEMC的DQS功能，则要断开0Ω电阻R426； SAI3_MCLK: 音频接口主时钟信号； 如果使用了SEMC_DQS, 且读写时Pin脚float，则能达到133MHz；否则，不使用SEMC_DQS, 读写速度只能达到66MHz； 控制信号详解 SEMC_DM0 / SEMC_DM1 (Data Mask): 这是数据掩码信号 分别控制低8位和高8位； SEMC_WE (Write Enable): 写使能信号 低电平有效 用于指示当前是写操作 与RAS/CAS配合使用来控制读写时序 SEMC_CAS (Column Address Strobe): 列地址选通信号 低电平有效 用于锁存列地址 SDRAM访问需要先给行地址再给列地址； SEMC_RAS (Row Address Strobe): 行地址选通信号 低电平有效 用于锁存行地址 与CAS的组合可以产生不同的SDRAM命令 SEMC_CS0 (Chip Select): 片选信号；–&gt; 因为只有一个片选信号，RT1024应该是只能外接一片SDRAM的； 低电平有效 系统可以有多个CS信号连接多个SDRAM SEMC_BA0/BA1 (Bank Address): SDRAM内部bank地址信号； 用于选择SDRAM内部的存储体 通常SDRAM有4个bank,需要2位地址 可以实现bank交错访问提高性能 U1F NVCC_SD 部分 电源设计 NVCC_SD为SD接口NVCC_SD0供电； 使用两个去耦电容: C76(4.7μF): 大电容用于稳定电源 C77(0.1μF): 小电容用于滤除高频噪声 SD卡接口信号(GPIO_SD_B0_xx组)（7个Pin：00~06） SD1_D0~D3: 4位数据线，其中，D0有上拉到NVCC_SD高电平； SD1_CMD: 命令线，上拉到NVCC_SD高电平； SD1_CLK: 时钟线； SD_CD_SW: SD卡检测信号，注意这个Pin脚是GPIO_SD_B0_06； 其他复用功能(GPIO_SD_B1_xx组)（12个Pin：00~11） CAN1_TX/RX: CAN通信接口； I2C4_SCL/SDA: I2C通信接口； SAI3相关信号: 音频接口信号： SAI3_TX_BCLK SAI3_TX_SYNC SAI3_TXD SAI3_RXD INT1/2_COMBO以及AUD_INT: 中断信号； 其中INT2_COMBO通过DNP未连接0Ω电阻R243到GPIO_SD_B1_05，它也是FlexSPI DQS线，需要floating，使QSPI Flash读写速度达到133MHz； SD_PWREN:这个也是个重要控制信号，来决定SD卡是否上电！ U1C 5V_USB_OTG 部分 MCU的USB OTG接口电路部分 电源设计 5V_USB_OTG: USB 5V供电，限流25mA，连接到USB_OTG1_VBUS引脚； VDD_USB_3V: 3.3V供电，连接到VDD_USB_CAP； 信号线 OTG1_DN / OTG1_DP: USB差分数据对 USB_OTG1_VBUS: VBUS电源检测引脚; USB_OTG1_CHD: 充电检测引脚; U1E NVCC_GPIO_3V3 部分 电源设计 DCDC_3V3转换为NVCC_GPIO_3V3供电； 采用双级去耦电容设计： 5个4.7μF大电容：处理低频噪声 5个0.1μF小电容：处理高频噪声 这种配置确保了GPIO供电的稳定性 GPIO配置 NVCC_GPIO：5个Pin给GPIO组进行独立供电； GPIO_AD_B0_xx和GPIO_AD_B1_xx：两组GPIO端口，B0组有16个Pin，B1组有10个Pin； GPIO_AD_B0_xx 组 调试接口 JTAG接口： JTAG_TMS：测试模式选择 JTAG_TCK：时钟 JTAG_TDI：测试数据输入 JTAG_TDO：测试数据输出 JTAG_nTRST：复位 JTAG_MOD 默认接地； SWD接口： SWD_CLK：时钟，复用JTAG_TCK； SWD_DIO：数据输入输出，复用JTAG_TMS; TRACE_SWO：默认DNP的，复用了GPIO_AD_B0_12; 通信接口 UART1_TXD / RXD：串口通信 ENET：以太网接口信号 4个接收/发送数据线： ENET_RXD1/ ENET_RXD0； ENET_TXD1/ ENET_TXD0； 1个时钟线：ENET_TX_REF_CLK 1个使能线：ENET_TXEN 1个复位线：ENET_RST 其他控制线： ENET_RXER ENET_CRS_DV 特殊功能 WDOG_B：看门狗复位，和JTAG_TDI复用； TRACE_SWO：跟踪调试输出 GPIO_AD_B1_xx 组 好像放的是一些外设的重要控制信号？！ ENET_INT：以太网中断信号 SD0_VSELECT：SD卡电压选择，支持1.8V/3.3V双电压模式； USER_LED USB_OTG1_PWR ： 控制外部USB设备供电 USB_OTG1_ID ： 用于确定USB角色(主机/设备) USB_OTG1_OC ： 检测USB端口是否发生过流 CAN_STBY I2C1_SCL / I2C1_SDA Page 14 BOOT 启动配置部分BOOT_CFG[0:9]： FUSE MAP配置表 FlexSPI - Serial NOR配置： HOLD TIME可选：500us/1ms/3ms/10ms FLASH类型支持多种选项： 3B/4B读取模式 HyperFlash 1V8/3V3 QSPI设备 3B读取模式–&gt; 在secondary pinmux选项上；； Micron Octal DDR MXIC Octal DDR EncryptedXIP：使能与否； SD启动配置： SD/SDXC速度模式4种选择： Normal/SDR12 High/SDR25 SDR50 SDR104 总线宽度：1-bit/4-bit 电源循环和时钟源选项 端口选择：eSDHC1/eSDHC2 快速启动选项 硬件实现 **DIP开关(SW8)**： 四个选项连接：BT_CFG[0]、BT_CFG[5]、BOOT_MODE[0]、BOOT_MODE[1]； 用于选择启动模式： Serial Download: 0001 FlexSPI Boot: 0010 SD Boot: 0110 GPIO连接： 使用GPIO_EMC_16到GPIO_EMC_27 这些引脚在启动时作为配置引脚 启动后可以作为普通GPIO使用 特殊功能 支持加密XIP（Execute In Place） 可配置快速启动模式 支持多种存储设备类型 灵活的时序和总线配置 这种设计提供了灵活的启动选项，允许系统从不同类型的存储设备启动，并且可以通过DIP开关轻松更改启动配置，方便开发和调试。","link":"/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part3/"},{"title":"RT1024 EVK 学习笔记Part1","text":"RT1024 EVK 学习笔记Part1 Main Power &amp; USB &amp; FreeLink Debugger部分详细解释！ Page3 Main Power输入可以是三种电源选项，但是输出就一定是5V_SYS， 它用来给整个MCU系统供电。以下详细的从左到右： 电源输入部分： Barrel Connector（桶型接口）J2：用于连接外部5V的电源适配器； C4 0.1uF电容：输入滤波电容，用于滤除输入电源的噪声; TP1：测试点，用于测量输入电压 MOSFET控制部分： FDMA530PZ（Q1）：功率MOSFET，用于电源开关控制； D1二极管：保护二极管，防止反向电流； R3 3.3K 电阻：限流电阻，保护MOSFET； 中间控制电路： SW1：开关； R4-R9：分压和偏置电阻网络 C5：稳定电容，用于滤波 LED指示电路： D3 LED_RED-GRN：双色LED，用于指示电源状态 Q4（BSH1115）：控制LED的MOSFET R10-R11：LED驱动电阻; 输出部分： C1-C3：输出滤波电容 J1：输出接口; C179-C180：去耦电容，用于稳定输出电压 关于J1短接选择不同的供电方式： 1-2位置：DC_5V_IN 连接到J2的直流电源输入 适用于使用外部5V电源适配器供电的场景 3-4位置：5V_USB_OTG_S 通过USB接口供电 5-6位置：P5V_SDA_S 通过OpenSDA调试器供电 适用于使用调试器进行程序下载和调试的场景 集成了调试和供电功能 那么，我们可以先看 5V_USB_OTG_S: Page6 USB 再看 P5V_SDA_S: Page13 FREELINK Page6 USBUSB OTG 部分 接口部分： 使用USB AB 5型接口，（指的是5Pin typeA/B） 包含5个引脚：VBUS（电源）、D+、D-（数据线）和GND（地）、和ID； 保护电路： TVS二极管阵列（U8 RClamp0854P）提供ESD保护; 保护USB接口免受静电和瞬态电压的损害 四个二极管保护四条信号线 EMI抑制： L3和L5（330Ω电感）用于抑制电磁干扰 L4（共模电感）用于抑制D+/D-信号线上的共模噪声； 这些元件确保信号传输的质量和稳定性 信号连接： OTG1_DN和OTG1_DP是MCU的差分数据信号； 通过0Ω电阻（R68）连接ID线和USB_OTG1_ID信号，可以方便地断开或连接信号； 5V_USB_OTG和5V_USB_OTG_S分别是USB供电的输入和输出 工作流程： 当作为Host时：提供5V电源给外部设备 当作为Device时：接收外部供电 数据信号经过EMI滤波和ESD保护后与MCU连接 作为device时，PC端供电，通过VBUS，提供给5V_USB_OTG_S，继而给整个MCU供电！ USB POWER 部分USB Power电路的工作原理如下： 核心控制芯片： U7（NX5P3090UK）是一个专用的USB电源开关/限流器 主要功能如下，其中，USB_OTG1_OC（过流检测信号），连接到FAULT引脚： 电流限制 过流保护 电压监测 故障检测 输入控制信号： EN（使能）引脚：控制电源开关的开启/关闭； FAULT（故障）引脚：指示过流或短路故障； VNT1/VNT2/VNT3：电压监测点； 工作流程： 当MCU需要提供USB主机供电时： 通过USB_OTG1_ID信号，自动检测是Device/Host，根据这个角色决定是否使能U7；工作在device模式，使能U7，对MCU供电；工作在Host模式，禁用U7； U7监控输出电流和电压； 如果发生过流，FAULT信号激活； 关键电路组件： C82/C83：输入滤波电容 C84：输出滤波电容 R67/R68：上拉电阻（100K） R69/R70：配置电阻 应用场景： MCU作为USB主机时提供受控的5V电源 保护MCU和外部设备免受电气故障损坏 其中，两个最重要的信号线： USB_OTG1_OC (Over Current): 连接到U7的FAULT引脚 当发生过流时会触发 这个信号会反馈给MCU，用于过流保护 5V_USB_OTG VBUS: 这是U7的输出端 提供受控的5V电源给USB接口 通过VBUS1/2/3引脚输出 经过C84去耦电容滤波 这两个信号构成了USB供电的核心监控和输出功能： 一个负责监控安全（OC） 一个负责实际供电（VBUS） 另外需要注意的是： Device模式（作为设备被供电）： 供电流程： 外部USB Host提供5V电源 通过USB接口进入，形成5V_USB_OTG 经过R312连接到5V_USB_OTG_S 通过J1(3-4)选择作为5V_SYS 为整个系统供电 此时U7不工作，仅作为通路； Host模式（作为主机供电）： 供电流程： 通过其他方式（DC或OpenSDA）产生5V_SYS 5V_SYS作为U7的输入； U7控制并输出5V_USB_OTG； 通过USB接口VBUS引脚对外供电5V_USB_OTG; U7提供电流限制和保护功能 关键理解点： 5V_USB_OTG和5V_USB_OTG_S的关系： 它们在电路中是相连的 但在不同模式下电流方向不同 U7的作用： 仅在Host模式时起作用 提供受控的5V输出 保护系统免受过流影响 工作模式切换： 通过ID信号识别当前模式 自动配置电源流向 U7根据模式自动使能或禁用 这种设计支持USB OTG的双向供电特性，允许设备在不同场景下灵活切换角色。看似复杂的电源路径实际上是为了实现这种灵活性。 Page13 FREELINK FreeLink部分的核心组件是LPC4322JET100，暂时先不看它，只需要知道J42跳线帽会控制FreeLink的DFU模式，进入firmware重新烧写即可！ 还有一个有意思的点，这个LPC需要外部的12MHz晶振Y5; 还有，MCU的UART1连接了电平转换芯片NTS0102，因此可以到PC的虚拟串口输出打印log。 对于Power部分来说，仍然是上一节的老朋友： U31仍然是一个NX5P3090UK: 电源路径： 输入：P5V_SDA通过U31的输入端 控制：经过U31的内部开关和保护电路 输出：通过U31的VBUS1/2/3引脚输出到P5V_SDA_S 控制机制： POWER_EN通过R216（1K）控制U31的使能 VTRG_FAULT_B通过R215（10K）提供故障监测 5V_SDA_PSW是在输出端额外引出的监测信号，可供外部使用； 那么，对于这种方式，电源路径如下： 调试器USB -&gt; VBUS -&gt; P5V_SDA -&gt; U31 -&gt; P5V_SDA_S -&gt; J1(5-6) -&gt; 5V_SYS","link":"/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part1/"},{"title":"RT1050开发--第1节 ARM Cortex-M7体系结构","text":"第一节 ARM Cortex-M7体系结构 认识ARM A系列 – 移动的王者 M系列 – 无处不在 Cortex-M7介绍 规格特点 对外接口 Cortex-M7 编程模型运行模式 所有M系列都是这两个模式：线程模式 + 处理模式（中断模式） 即：主程序都是在线程模式，中断处理函数都是处理模式，处理模式下拥有特权； 操作状态 即：一个运行，一个调试； 特权访问和非特权访问 特权访问：即可以触碰到CPU所有的资源；非特权访问有些资源碰不到！ 线程模式一般就是非特权的，处理模式都是特权的！ 系统的地址映射 0x0000_0000 ~ 0xFFFF_FFFF 一共 4GB； Code ： 即 ROM； SRAM：即数据； Peripheral：放外设，M7把代码、数据、外设 都映射到同一片地址空间； External RAM： 外部存储器！ External device：外部设备 内部私有外设总线； 外部私有外设总线；–》 M7内核的； 处理器的核心寄存器 R13栈指针一个寄存器映射两个区域：MSP 和 **PSP**； 纯裸机编程时，只有一个栈，所以只有MSP主栈指针； FreeRTOS才会用到PSP进程栈指针； 异常 ARM的异常处理流程： 1– 保存当前程序的上下文，即：xPSR、PC、LR、R0-R3,R12; 通过MSP或者PSP读取地址，把这些寄存器全都入栈，就保存了下来； 2– 把当前要返回的地址放在LR链接寄存器中； 3a– 切换模式，从线程模式切换到处理模式； 3b– 指针指向新的栈顶； 4– 找到该中断的向量地址，赋值给PC指针，执行中断处理函数；","link":"/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"title":"RT1050开发--第2节 NXP RT1050系列芯片","text":"第二节 RT1050系列芯片 MCU与MPU开发模式MPU嵌入式开发流程 MCU物联网开发流程 新的需求 iMX.RT 1050跨界处理器 降低成本 – 无需片内闪存 高性能 低中断延时 高效能 RT把DC-DC放到芯片里面，每MHz电流消耗降低了接近一半！ RT1050特色外设通用外设 低功耗外设 灵活外设 **FlexSPI**重点，覆盖了所有的SPI接口，并且速度更快，接近200M； FlexRAM：DTCM、ITCM，但是RT内核只提供了一个512K的RAM，但是它可以灵活的分配为DTCM、ITCM等； 高级外设 SEMC:安全外部存储器控制器，之前提到的SDRAM、NOR NAND都可以通过这个接口接入；","link":"/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC2%E8%8A%82-nxp-rt1050%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87/"},{"title":"RT1050开发--第3节 RT1050硬件平台","text":"第3节 RT1050硬件平台使用 RT1050 EVKB开发板介绍 EVKB硬件框图 原理图 FlexSPI： HyperFlash –高性能高速 CYPRESS S26K QSPI Flash –&gt; **用于外部扩展ROM存储器**； SDRAM： 16bit接口，内部控制器是SEMC！ 扩展RAM； SDMC： 使用SD卡存储大型文件； PCB图 开发板硬件清单 重点看一下Mass Storage，可以看到除了SD卡外，还有64M的QSPI Flash和512M的HyperFlash； 开发板供电模式 J1 放在5-6时，由OpenSDA那个USB口供电：J28； 开发板启动模式配置启动配置引脚 最常用的是：10–Internal Boot 模式！ SW7就是4个拨码开关：x-x-1-0 –&gt; Internal Boot！ 高级启动序列 即：Internal Boot的执行流程： 最上方是低功耗的WakeUp检测；如果是WakeUp模式启动，就正常Execute Image； 如果不是，就会检测Boot的启动模式；Internal Boot or 串口下载？ Internal Boot： 根据GPIO引脚的配置（高低电平），选择是从SD卡还是QSPI还是HyperFlash启动； Authenticate image； 校验通过就Execute Image； 串口下载：*暂时略过*； 外部启动模式选择（通过拨码开关） 开发板烧写/仿真接口OpenSDA CMSIS-DAP接口 使用要求","link":"/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC3%E8%8A%82-rt1050%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/"},{"title":"RT1050开发--第4节 RT1050开发环境搭建","text":"第4节 RT1050开发环境搭建 Keil5安装 安装MDK-Keil5； 安装RT1052 Keil5依赖包； 地址：https://www.keil.arm.com/packs/mimxrt1052_dfp-nxp/devices/ 仿真器驱动安装 CMSIS-DAP仿真器驱动； 串口驱动； SDK下载 下载地址：https://mcuxpresso.nxp.com/en/select SDK介绍 SDK概述 SDK源码目录 API手册外设驱动结构 原理图 数据手册 MIMXRT1050 EVKB Board Hardware User’s Guide ： https://www.nxp.com/webapp/sps/download/preDownload.jsp?render=true DataSheet: .stfduidnojun{zoom:150%;}","link":"/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC4%E8%8A%82-rt1050%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"title":"RT1050开发--第5节 RT1050 Hello World （Keil V5）","text":"第5节 RT1050 Hello World （Keil V5） HelloWorld工程介绍工程文件位置C:\\Users\\Gavin\\Documents\\RT\\Keil5\\rt1050 keil sdk &amp; doc\\SDK_2_14_0_EVKB-IMXRT1050\\boards\\evkbimxrt1050\\demo_apps\\hello_world\\ Keil工程位置 MDK工程目录结构 几种工程目标 —&gt; 我们在这里用的是flexspi_nor_debug工程，代码段放在nor flash，数据段放在TCM中！ 工程工作组 关于xip的用处： 由于RT没有内部Flash，代码都存放在外部ROM空间，那么，在系统启动时，RT是不知道外部flash的信息的，比如：代码地址，空间大小等等； 所以，需要把这些信息先存放在外部Flash中，然后RT通过SPI通信获得了这部分信息之后，才可以到外部Flash中去取指令； 打造自己的HelloWorld工程SDK工程路径 创建hello_world工程 创建01-hello_world文件夹； 复制SDK的主要文件； 根据工程包含的路径复制，得到： 打开这个新建的工程，消除找不到文件的感叹号❗ —&gt; 消除方法：通过使用文本编辑器打开该Keil工程，全文搜索并替换这几个include的相对路径！ —&gt; Reload! —&gt; 完成！ 分析Hello_world.c12345678910111213141516171819202122int main(void){ char ch; /* Init board hardware. 初始化开发板*/ BOARD_ConfigMPU(); //配置内存保护单元 BOARD_InitBootPins(); //初始化开发板IO模式 BOARD_InitBootClocks(); //初始化开发板系统时钟 BOARD_InitDebugConsole(); //初始化调试控制台 /* Just enable the trace clock, leave coresight initialization to IDE debugger */ SystemCoreClockUpdate(); CLOCK_EnableClock(kCLOCK_Trace); PRINTF(\"hello world.\\r\\n\"); while (1) { ch = GETCHAR(); PUTCHAR(ch); }} 烧写代码 Keil 快捷键 F8 实验现象","link":"/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC5%E8%8A%82-rt1050-hello-world-%EF%BC%88keil-v5%EF%BC%89/"},{"title":"RT1050开发--第6节 RT1050 Memory Mapping","text":"第6节 RT1050 Memory Mapping RT1052结构框图 Cortex-M7 存储器映射 如果给存储器再分配一个地址，就叫做存储器重映射； 在4GB的地址空间，ARM粗线条的平均分为7个块，每个块也规定了用途，大部分的款大小都是512MB以上，显然是很大的，芯片厂商在每个块的范围内设计外设时根本用不完； RT1052存储器功能划分 重点！！！ 在这上面的7个Block中，有4个非常重要。 Block0 主要用于存储**程序代码**，一般采用FLASH存储器； Block1 主要用于**运行时内存**，一般采用SRAM存储器； Block2 用来设计成片上外设，内核通过相应的地址访问片上外设； Block5 用于NVIC，系统定时器，系统功能控制块； Block0 自下往上看： ITCM：是Instruction Tightly-Coupled Memory的缩写，指的是**指令紧耦合内存**。 所谓紧耦合，指的是该内存与内核紧密连接，有很高的访问速度，而“指令”，表示该内存用于缓存指令； 对于我们希望有极高执行速度的代码，可以要求内核上电后把相应的代码从外部的Flash加载至ITCM，那么在运行时，代码的执行速度就不会因为外部的Flash访问速度而存在瓶颈。 ROCMP：**这是一小段ROM空间，用于存储芯片启动时的加载代码，即Bootloader，Bootloader负载把指令从外部存储器加载到ITCM**； FlexSPI：和SEMC一起是RT1052中可用于控制外部并行和串行NorFlash的两个外设，此处把它们映射到这个代码空间，是歪了支持XIP功能（即指令直接在NorFlash中运行，不需要加载到内部的ITCM）。 SEMC：智能外部存储器控制器； Block1 DTCM：数据紧耦合内存，和ITCM类似，有着极高的访问速度，*不过它是专门用来存储程序数据的，即带啊吗中变量的存储位置*； OCRAM：是 On-chip RAM 的缩写。即片上内存，可以完全把它理解为传统MCU内部的SRAM，它没有像ITCM和DTCM的专用限制，**可以用于存储指令和数据**（通用目的）。 注意！在RT1052中，TCM只有512KB，不是分别ITCM DTCM OCRAM都有，而是它们三个共有512KB！ 通过FUSE，有16种FlexRAM的配置！这个和后续的分散加载文件息息相关！ 具体来说，ITCM DTCM OCRAM三种存储器**共享内部FlexRAM的空间，而这个内部的FlexRAM空间在RT1052中是512KB**； 默认是第一种配置，256-128-128； Block2 Block2 用于设计片内的外设，在RT1052中，它的外设使用4条总线与内核进行连接，AIPS 是 ARM IP Bus 的缩写，**它一边与 AHB 总线连接，另一边与片上的各种外设连接，AIPS1~4 即连接了各种各样的外设，此处每条总线划分的地址范围是1MB，内核根据地址可以访问相应总线下的外设，达到控制目的**。 Block5 谁影响了代码的运行速度？ 订正： I-Cache/D-Cache RT1052没有内置的Flash，那么如果像原来一样，在MCU的Flash中运行，就会受限于NorFlash的总线访问速度，无法发挥CPU速度的优势。那么，通过分散加载文件，到Cache，TCM中运行，就是一个可行的解决方案了。","link":"/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC6%E8%8A%82-rt1050-memory-mapping/"},{"title":"RT1050开发--第7节 RT1050 硬件启动模式","text":"第7节 RT1050 硬件启动模式详解 硬件启动配置外部设备设备配置 开发板配置选项 启动配置选项电路 启动配置引脚 启动模式选择 启动模式选择可以有：从Fuses、从串口下载、从内部； 串行Flash配置选项 这两位控制支持的Flash Type； 即SW7的前两位确定Flash的规格，后两位确定启动的方式！ Nor Flash 启动流程 .uchhxihmowwp{zoom:150%;} BootRom里面的程序： 配置 FlexSPI 的Pin复用功能，配置时钟频率30MHz，进行基础的读取操作； FlexSPI最高300MHz，这里不知道外部Flash是啥情况，配置为低速时钟用来读NorFlash的头上的配置信息； 获取到外部Flash的配置参数； 读取了外部Flash的配置参数之后，RT用来配置它的外设 FlexSPI ； 它是根据读取的外部Flash的配置参数，来配置FlexSPI； 设置boot device 参数 Image 地址， memory范围； 即：**真正的代码段的地址和长度**； 判断Image是否直接在Flash的片上进行取址： 如果XIP，则从FlexSPI1的地址空间中执行Image； 如果非XIP，则拷贝到OCRAM中，再从OCRAM中运行Image； Flash的配置参数.hfxjsxcewctj{zoom:200%;} 512字节的串口Nor Flash配置字段： memCfg：外部时序，时钟等； pageSize：页大小； sectorSize：块大小； xxxClkFreq: 串口的时钟频率； 工程代码： Image的关键信息 Image vector table（IVT）：声明image的具体位置，即代码在 nor flash 的具体位置是多少； Boot data：image位置和大小； Device configuration data （DCD）： User code and data： IVT + Boot data IVT 需要放在外部Flash的固定偏移地址，供ROM读取以便让系统知道用户Image的第一条可执行指令放在哪里，以及Boot Data和DCD的存放位置； BootData保存了完整的Image首地址和整个Image所占大小； 程序代码： DCD DCD包含了一些配置命令以便在跳到用户程序入口之前，供ROM调用配置内部外设以更好的匹配外部IC，一般如果系统外挂了SDRAM的情况下需要配置好DCD； 程序代码：","link":"/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/"},{"title":"RT1060--串口空闲中断&amp;EDMA接收不定长数据","text":"串口空闲中断 &amp; EDMA 接收不定长数据 客户有接收不定长数据的需求，但是如果采用协议适配的方法会非常繁琐。使用UART的IDLE中断+DMA的方式，即可高效的解决这一问题！ 另外，如果通过协议先接收单独的单字节，串口进中断接收在数据量大的时候效率会低很多 以RT1060EVK为例来进行这一操作！ 代码部分1234567891011121314151617181920让我仔细分析一下这个main函数的执行流程和中断调用关系...首先看到几个关键的中断和回调:1. DEMO_LPUART_IRQHandler - UART的中断处理函数2. LPUART_UserCallback - DMA传输完成的回调函数中断触发的场景:1. IDLE线检测 - 接收到一帧数据后的空闲状态2. TC(传输完成)中断 - 发送完成后触发3. DMA传输完成中断 - 通过callback通知数据流转过程:1. 初始状态是接收模式2. 数据到来 -&gt; DMA自动接收到buffer3. 检测到空闲 -&gt; IDLE中断4. 处理数据 -&gt; 准备发送5. DMA发送 -&gt; 发送完成触发TC中断6. TC中断中切换回接收模式这里面有很多细节需要梳理,让我详细分析每个阶段的处理... 让我详细解释main函数的逻辑和中断调用关系: 初始化配置:12345678910// 配置UART中断LPUART_EnableInterrupts(DEMO_LPUART, kLPUART_IdleLineInterruptEnable| // 空闲线检测中断 kLPUART_RxOverrunInterruptEnable| // 接收溢出中断 kLPUART_NoiseErrorInterruptEnable| // 噪声错误中断 kLPUART_FramingErrorInterruptEnable| // 帧错误中断 kLPUART_ParityErrorInterruptEnable); // 奇偶校验错误中断// 初始时禁用TC中断LPUART_DisableInterrupts(DEMO_LPUART, kLPUART_TransmissionCompleteInterruptEnable); 中断和DMA的调用流程:接收数据流程: DMA持续接收数据到g_rxBuffer 当检测到空闲线(一段时间没有新数据)时,触发IDLE中断； 在IDLE中断处理函数中:123456789101112131415161718void DEMO_LPUART_IRQHandler(void){ if ((kLPUART_IdleLineFlag)&amp;stat) { // 1. 获取已接收的数据长度 LPUART_TransferGetReceiveCountEDMA(...); // 2. 复制数据到发送缓冲区 memcpy(g_txBuffer, g_rxBuffer, rx_count); // 3. 设置发送标志 reciveFrame = true; // 4. 重新启动接收 LPUART_TransferAbortReceiveEDMA(...); LPUART_ReceiveEDMA(...); }} 发送数据流程: main循环检测到reciveFrame为true时启动发送 DMA开始发送数据 发送完成后触发DMA完成中断,调用LPUART_UserCallback 在callback中使能TC中断:12345678void LPUART_UserCallback(...){ if (kStatus_LPUART_TxIdle == status) { // 使能TC中断 LPUART_EnableInterrupts(DEMO_LPUART, kLPUART_TransmissionCompleteInterruptEnable); }} TC中断触发后,在中断处理函数中:123456789101112if((kLPUART_TransmissionCompleteFlag)&amp;stat){ // 1. 禁用TC中断 LPUART_DisableInterrupts(DEMO_LPUART, kLPUART_TransmissionCompleteInterruptEnable); // 2. 切换到接收模式 Set_RS485_Receive(); // 3. 重新启动接收 LPUART_TransferAbortReceiveEDMA(...); LPUART_ReceiveEDMA(...);} 主循环逻辑:123456789101112131415161718while(1){ if(reciveFrame) // 检查是否收到完整数据帧 { // 1. 准备发送数据 sendXfer.data = g_txBuffer; sendXfer.dataSize = send_size; // 2. 切换到发送模式 Set_RS485_Transimit(); // 3. 启动DMA发送 LPUART_SendEDMA(DEMO_LPUART, &amp;g_lpuartEdmaHandle, &amp;sendXfer); // 4. 清除标志 reciveFrame = false; }} 关键点说明 DMA用于实际的数据传输,不占用CPU IDLE中断用于检测一帧数据的接收完成 TC中断用于确保最后一个字节完全发送出去 使用回调和中断机制实现自动的收发切换 主循环只负责检测标志并启动新的发送 这种设计实现了高效的非阻塞式数据收发,同时正确处理了RS485半双工通信的方向切换时序。 备注：详细的回调/中断实现的自动收发切换1234567891011121314flowchart TD A[初始状态: 接收模式] --&gt;|DMA接收数据| B[接收数据] B --&gt;|检测到IDLE| C[IDLE中断处理] C --&gt;|1. 获取接收数据长度&lt;br&gt;2. 复制数据到TX buffer&lt;br&gt;3. 设置reciveFrame标志| D[主循环] D --&gt;|检测到reciveFrame| E[开始发送] E --&gt;|1. 切换RS485方向&lt;br&gt;2. 启动DMA发送| F[DMA发送数据] F --&gt;|DMA发送完成| G[DMA完成回调&lt;br&gt;LPUART_UserCallback] G --&gt;|使能TC中断| H[等待最后一个字节发送] H --&gt;|TC中断触发| I[TC中断处理] I --&gt;|1. 禁用TC中断&lt;br&gt;2. 切换RS485方向&lt;br&gt;3. 重启DMA接收| A 让我详细解释每个阶段的切换过程： 接收阶段: 123// 初始配置为接收模式Set_RS485_Receive(); // GPIO设为低电平LPUART_ReceiveEDMA(...); // 启动DMA接收 接收完成检测: 12345678// IDLE中断处理函数中if ((kLPUART_IdleLineFlag)&amp;stat){ // 获取接收到的数据 LPUART_TransferGetReceiveCountEDMA(...); memcpy(g_txBuffer, g_rxBuffer, rx_count); reciveFrame = true; // 设置标志通知主循环} 切换到发送模式: 1234567// 主循环中if(reciveFrame){ Set_RS485_Transimit(); // GPIO设为高电平 LPUART_SendEDMA(...); // 启动DMA发送 reciveFrame = false;} 发送完成处理: 12345678910111213141516171819// DMA发送完成回调void LPUART_UserCallback(...){ if (kStatus_LPUART_TxIdle == status) { // 使能TC中断，等待最后一个字节发送完成 LPUART_EnableInterrupts(DEMO_LPUART, kLPUART_TransmissionCompleteInterruptEnable); }}// TC中断处理if((kLPUART_TransmissionCompleteFlag)&amp;stat){ LPUART_DisableInterrupts(DEMO_LPUART, kLPUART_TransmissionCompleteInterruptEnable); Set_RS485_Receive(); // 切换回接收模式 // 重新启动接收 LPUART_TransferAbortReceiveEDMA(...); LPUART_ReceiveEDMA(...);} 关键设计考虑： 为什么需要TC中断？ DMA完成不代表最后一个字节已经完全发送出去 TC中断确保最后一个字节完全发送后才切换方向 避免方向切换过早导致数据截断 方向切换时序: 发送前：先切换方向，再开始发送 发送后：等待TC中断确认完全发送后，再切换回接收 自动化处理: 使用中断和回调机制，无需主循环干预 主循环只负责启动新的发送 其他切换过程由中断自动完成 这种设计保证了RS485半双工通信的可靠性，同时通过DMA和中断机制提高了效率。","link":"/NXP/RT1060/rt1060-%E4%B8%B2%E5%8F%A3%E7%A9%BA%E9%97%B2%E4%B8%AD%E6%96%AD-edma%E6%8E%A5%E6%94%B6%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%95%B0%E6%8D%AE/"},{"title":"RT1060--串口edma详解(SDK)","text":"串口edma详解 这次我们来一起看一下，基于 NXP MIMXRT1060 开发板的串口通信示例工程，学习如何使用 EDMA(增强型直接内存访问)来实现高效的串口数据传输。 主要特点： 使用 LPUART (低功耗串口)进行通信 利用 EDMA 实现数据传输，减少 CPU 干预 实现了一个回显功能 - 将接收到的数据发送回去 关键数据流 接收流程： 串口输入 -&gt; LPUART接收寄存器 -&gt; EDMA传输 -&gt; 接收缓冲区(g_rxBuffer) 发送流程： 发送缓冲区(g_txBuffer) -&gt; EDMA传输 -&gt; LPUART发送寄存器 -&gt; 串口输出 lpuart_edma_transfer.c 工作流程 系统初始化： 配置 LPUART（波特率115200，使能收发） 配置 DMAMUX（设置 DMA 通道映射） 初始化 EDMA（并创建传输句柄） 主循环逻辑： 123456789101112131415161718192021222324while (1){ /* If RX is idle and g_rxBuffer is empty, start to read data to g_rxBuffer. */ if ((!rxOnGoing) &amp;&amp; rxBufferEmpty) { rxOnGoing = true; LPUART_ReceiveEDMA(DEMO_LPUART, &amp;g_lpuartEdmaHandle, &amp;receiveXfer); } /* If TX is idle and g_txBuffer is full, start to send data. */ if ((!txOnGoing) &amp;&amp; txBufferFull) { txOnGoing = true; LPUART_SendEDMA(DEMO_LPUART, &amp;g_lpuartEdmaHandle, &amp;sendXfer); } /* If g_txBuffer is empty and g_rxBuffer is full, copy g_rxBuffer to g_txBuffer. */ if ((!rxBufferEmpty) &amp;&amp; (!txBufferFull)) { memcpy(g_txBuffer, g_rxBuffer, ECHO_BUFFER_LENGTH); rxBufferEmpty = true; txBufferFull = true; }} 检查接收缓冲区状态，空闲则启动新的接收 检查发送缓冲区状态，满则启动新的发送 在接收完成且发送空闲时，将数据从接收缓冲区复制到发送缓冲区 状态管理： 使用回调函数处理传输完成事件 通过状态标志(rxBufferEmpty, txBufferFull等)协调收发过程 仔细分析callback机制 首先看到几个关键的回调函数: LPUART_UserCallback - 这是用户层的回调函数,在main中注册 LPUART_SendEDMACallback - EDMA发送完成的回调 LPUART_ReceiveEDMACallback - EDMA接收完成的回调 LPUART_TransferEdmaHandleIRQ - LPUART的EDMA中断处理函数 从代码中可以看到调用链路: 在main中通过LPUART_TransferCreateHandleEDMA注册了用户回调: 123/* Create LPUART DMA handle. */LPUART_TransferCreateHandleEDMA(DEMO_LPUART, &amp;g_lpuartEdmaHandle, LPUART_UserCallback, NULL, &amp;g_lpuartTxEdmaHandle, &amp;g_lpuartRxEdmaHandle); 当EDMA传输完成时,会触发中断,调用LPUART_TransferEdmaHandleIRQ(); 12345678/* Save the handle in global variables to support the double weak mechanism. */s_lpuartHandle[instance] = handle;/* Set LPUART_TransferEdmaHandleIRQ as DMA IRQ handler */s_lpuartIsr[instance] = LPUART_TransferEdmaHandleIRQ;/* Disable all LPUART internal interrupts */LPUART_DisableInterrupts(base, (uint32_t)kLPUART_AllInterruptEnable);/* Enable interrupt in NVIC. */(void)EnableIRQ(s_lpuartIRQ[instance]); 在EDMA的回调中会更新状态标志并调用用户回调: 123LPUART_SendEDMACallbackLPUART_ReceiveEDMACallback --&gt; LPUART_UserCallback 以下是LPUART EDMA传输的回调流程图: 12345678910graph TD A[EDMA传输开始] --&gt; B[EDMA传输完成中断] B --&gt; C[LPUART_TransferEdmaHandleIRQ] C --&gt; D{传输类型?} D --&gt;|发送完成| E[LPUART_SendEDMACallback] D --&gt;|接收完成| F[LPUART_ReceiveEDMACallback] E --&gt; G[LPUART_UserCallback] F --&gt; G G --&gt;|TX完成| H[设置txBufferFull=false&lt;br&gt;txOnGoing=false] G --&gt;|RX完成| I[设置rxBufferEmpty=false&lt;br&gt;rxOnGoing=false] 所以整个调用链是: EDMA完成传输 触发LPUART传输完成中断 调用LPUART_TransferEdmaHandleIRQ LPUART_TransferEdmaHandleIRQ调用用户回调 用户回调更新状态标志 这个机制实现了: 硬件中断与软件处理的解耦 灵活的状态管理 异步操作的完成通知 总结 初始化流程: main函数中创建EDMA handle 注册LPUART_UserCallback作为用户回调 配置EDMA通道和中断 发送流程: LPUART_SendEDMA触发发送 EDMA完成后触发中断 通过回调链更新状态标志 接收流程: LPUART_ReceiveEDMA启动接收 EDMA完成后触发中断 通过回调链更新状态标志 状态管理: txOnGoing/rxOnGoing表示传输进行状态 txBufferFull/rxBufferEmpty表示缓冲区状态 这些标志在回调中更新,在主循环中使用 这种回调机制实现了: 异步处理EDMA传输 状态管理的解耦 用户代码与底层驱动的分离","link":"/NXP/RT1060/rt1060-%E4%B8%B2%E5%8F%A3edma%E8%AF%A6%E8%A7%A3-sdk/"},{"title":"RT1060--串口中断传输详解(SDK)","text":"串口中断传输详解(SDK) 1. evkmimxrt1060_lpuart_interrupt 使用 NXP 的 fsl_lpuart.h 库，通过中断方式实现 LPUART 的数据接收和回显。 它使用了一个ring buffer来暂存接收到的数据，然后在主循环中将缓冲区的数据发送出去。 代码解释 宏定义： DEMO_LPUART: 定义使用的 LPUART 外设为 LPUART1。 DEMO_LPUART_CLK_FREQ: 定义 LPUART 的时钟频率。 DEMO_LPUART_IRQn: 定义 LPUART 的中断号。 DEMO_LPUART_IRQHandler: 定义 LPUART 的中断处理函数名。 DEMO_RING_BUFFER_SIZE: 定义环形缓冲区的大小为 16 字节。 全局变量： g_tipString: 提示字符串，程序启动时发送到串口。 demoRingBuffer: 环形缓冲区，用于存储接收到的数据。 txIndex: 发送索引，指向下一个要发送的数据在环形缓冲区中的位置。 rxIndex: 接收索引，指向下一个要写入接收数据的环形缓冲区位置。 DEMO_LPUART_IRQHandler() 函数： LPUART 中断处理函数： 如果Rx Data 寄存器满，则： 读取receiver register数据： (LPUART_ReadByte())。 读完之后检查环形缓冲区是否已满，如果未满，则将接收到的数据写入环形缓冲区，并更新 rxIndex。 main() 函数： 初始化开发板和 LPUART。 发送提示字符串。 使能 LPUART 的接收满中断 (kLPUART_RxDataRegFullInterruptEnable)。 使能 LPUART 中断 (EnableIRQ(DEMO_LPUART_IRQn))。 进入主循环： 检查 LPUART 发送寄存器是否为空 (kLPUART_TxDataRegEmptyFlag)。 检查环形缓冲区是否非空。 如果发送寄存器为空且缓冲区非空，则从环形缓冲区读取数据 (demoRingBuffer[txIndex])，并通过 LPUART_WriteByte() 发送出去，并更新 txIndex。 数据/中断/callback调用流程图 详细流程解释： 中断处理： 读取接收到的数据并存入环形缓冲区 demoRingBuffer。 更新接收索引 rxIndex。 主循环处理： 主循环不断检查 LPUART 发送寄存器是否为空以及环形缓冲区是否非空。 如果条件满足，则从环形缓冲区读取数据，并通过 LPUART_WriteByte() 发送出去。 更新发送索引 txIndex。 数据发送： LPUART 硬件将数据发送到串口接收端。 关键点 环形缓冲区： 用于在中断处理函数和主循环之间传递数据，避免数据丢失。 中断驱动： 使用中断来处理接收事件，提高了 CPU 效率。 非阻塞发送： 主循环中轮询检查发送寄存器是否为空和ring buffer非空，用于读取数据并发送，更新txIndex; 2. evkmimxrt1060_lpuart_interrupt_transfer 使用 LPUART 进行回显。 程序通过 LPUART 接收用户输入的 8 个字符，然后将这 8 个字符回显给用户终端。 代码解释代码结构： 宏定义：定义了一些宏和变量，例如使用的 LPUART 实例 (DEMO_LPUART)、时钟频率 (DEMO_LPUART_CLK_FREQ)、回显缓冲区长度 (ECHO_BUFFER_LENGTH) 。 callback声明：声明了一个 LPUART 用户回调函数 LPUART_UserCallback。 变量：定义了一些全局变量，例如用于存储句柄 (g_lpuartHandle)、提示信息字符串 (g_tipString)、发送缓冲区 (g_txBuffer)、接收缓冲区 (g_rxBuffer) 等，还有一些标志位用于指示缓冲区状态和传输状态： 1234volatile bool rxBufferEmpty = true;volatile bool txBufferFull = false;volatile bool txOnGoing = false;volatile bool rxOnGoing = false; **LPUART 用户回调函数 (LPUART_UserCallback)**：该函数会在 LPUART 传输完成 (发送或接收) 时被调用。它更新发送和接收缓冲区的相关标志位 (txBufferFull、txOnGoing、rxBufferEmpty、rxOnGoing)。 1234567891011121314151617/* LPUART user callback */void LPUART_UserCallback(LPUART_Type *base, lpuart_handle_t *handle, status_t status, void *userData){ userData = userData; if (kStatus_LPUART_TxIdle == status) // 实际上就是发送完成！ { txBufferFull = false; txOnGoing = false; } if (kStatus_LPUART_RxIdle == status) // 实际上对应接收完成！ { rxBufferEmpty = false; rxOnGoing = false; }} 主函数 (main) 初始化时钟、引脚复用等。 配置 LPUART：设置波特率、启用发送和接收功能等。 创建 LPUART 传输句柄。 LPUART_TransferCreateHandle(DEMO_LPUART, &amp;g_lpuartHandle, LPUART_UserCallback, NULL); 发送提示信息字符串。 LPUART_TransferSendNonBlocking(DEMO_LPUART, &amp;g_lpuartHandle, &amp;xfer); 进入循环，实现回显功能： 如果接收空闲且接收缓冲区为空，则启动接收数据到接收缓冲区。 LPUART_TransferReceiveNonBlocking(DEMO_LPUART, &amp;g_lpuartHandle, &amp;receiveXfer, NULL); 如果发送空闲且发送缓冲区满，则启动发送数据。 LPUART_TransferSendNonBlocking(DEMO_LPUART, &amp;g_lpuartHandle, &amp;sendXfer); 如果接收非空且发送不满，则将接收缓冲区内容复制到发送缓冲区，并更新缓冲区标志位。 123memcpy(g_txBuffer, g_rxBuffer, ECHO_BUFFER_LENGTH);rxBufferEmpty = true;txBufferFull = true; 流程图： 数据流： 初始化阶段： 配置 LPUART。 发送提示信息： 将提示信息字符串拷贝到发送缓冲区。 启动发送。 回显循环： 接收数据： 如果接收空闲且接收缓冲区为空，则启动接收数据。 接收完成触发回调函数，更新接收缓冲区标志位。 发送数据： 如果发送空闲且发送缓冲区满，则启动发送数据。 发送完成触发回调函数，更新发送缓冲区标志位。 复制数据： 如果接收非空且发送不满，则将接收缓冲区内容复制到发送缓冲区。 更新接收和发送缓冲区标志位。 中断和回调流程： 当数据接收完成或发送完成后，会产生中断。 中断服务程序会将控制权转移到 LPUART 驱动程序。 驱动程序会调用用户回调函数 LPUART_UserCallback。 回调函数中，根据传输完成类型 (发送/接收) 更新相关的缓冲区标志位。 注意： 该代码使用非阻塞式传输，即发送或接收启动后，程序不会等待传输完成，而是继续执行其他操作。 回调函数中只更新了标志位，并没有直接操作数据缓冲区。数据处理是在主循环中进行的。 代码关键点 非阻塞传输： 使用了 LPUART_TransferSendNonBlocking 和 LPUART_TransferReceiveNonBlocking 函数，这意味着发送和接收操作会在后台进行，不会阻塞主循环。 回调函数： LPUART_UserCallback 函数用于处理传输完成事件。在这个函数中，主要任务是更新标志位，例如 txOnGoing、txBufferFull、rxOnGoing 和 rxBufferEmpty。 缓冲区管理： 使用了 g_txBuffer 和 g_rxBuffer 作为发送和接收缓冲区，并通过 memcpy 函数在两个缓冲区之间复制数据。 主循环逻辑： 主循环负责启动发送和接收操作，并在缓冲区之间复制数据。 12345678910111213141516171819202122232425262728graph TD subgraph 初始化 A[初始化 LPUART] --&gt; B{发送提示信息} B --&gt; C[启动发送&lt;br&gt;LPUART_TransferSendNonBlocking] C --&gt; D{等待发送完成&lt;br&gt; txOnGoing } end D --&gt; E[回显循环] subgraph 接收 E --&gt; F{接收空闲 &amp; 接收缓冲区为空&lt;br&gt; !rxOnGoing &amp;&amp; rxBufferEmpty } F -- 是 --&gt; G[启动接收&lt;br&gt;LPUART_TransferReceiveNonBlocking] G --&gt; H[LPUART 硬件接收数据&lt;br&gt;RxDataRegFullFlag 置位] H --&gt; I[产生中断信号] I --&gt; J[NVIC 处理中断&lt;br&gt;调用中断服务例程&lt;br&gt;LPUART_TransferHandleIRQ] J --&gt; K[中断服务例程&lt;br&gt;调用 LPUART_UserCallback&lt;br&gt;kStatus_LPUART_RxIdle&lt;br&gt;rxBufferEmpty = false&lt;br&gt;rxOnGoing = false] end subgraph 发送 E --&gt; L{发送空闲 &amp; 发送缓冲区满&lt;br&gt; !txOnGoing &amp;&amp; txBufferFull } L -- 是 --&gt; M[启动发送&lt;br&gt;LPUART_TransferSendNonBlocking] M --&gt; N[LPUART 硬件发送数据] N --&gt; O[发送完成&lt;br&gt;产生中断信号] O --&gt; P[NVIC 处理中断&lt;br&gt;调用中断服务例程&lt;br&gt;LPUART_TransferHandleIRQ] P --&gt; Q[中断服务例程&lt;br&gt;调用 LPUART_UserCallback&lt;br&gt;kStatus_LPUART_TxIdle&lt;br&gt;txBufferFull = false&lt;br&gt;txOnGoing = false] end E --&gt; R{接收缓冲区非空 &amp; 发送缓冲区未满&lt;br&gt; !rxBufferEmpty &amp;&amp; !txBufferFull} R -- 是 --&gt; S[数据复制&lt;br&gt;memcpy&lt;br&gt;rxBufferEmpty = true&lt;br&gt;txBufferFull = true] K --&gt; E Q --&gt; E S --&gt; E 代码逻辑解释： 初始化： 程序首先初始化 LPUART 外设，然后发送一个提示信息。 回显循环： 程序进入一个无限循环，不断检查以下条件： 接收： 如果当前没有正在接收数据 (!rxOnGoing) 并且接收缓冲区为空 (rxBufferEmpty)，则启动一次非阻塞的接收操作 (LPUART_TransferReceiveNonBlocking)。 当 LPUART 硬件接收到数据后，RxDataRegFullFlag 标志位会被置位，触发中断。 NVIC 接收到中断请求后，会调用中断服务例程。在中断服务例程中，会调用用户定义的回调函数 LPUART_UserCallback。 回调函数根据 kStatus_LPUART_RxIdle 状态将 rxBufferEmpty 设置为 false，将 rxOnGoing 设置为 false，表明接收已完成。 发送： 如果当前没有正在发送数据 (!txOnGoing) 并且发送缓冲区已满 (txBufferFull)，则启动一次非阻塞的发送操作 (LPUART_TransferSendNonBlocking)。 LPUART 硬件发送完数据后，会产生中断。 NVIC 处理中断，并调用回调函数 LPUART_UserCallback。 回调函数根据 kStatus_LPUART_TxIdle 状态将 txBufferFull 设置为 false，将 txOnGoing 设置为 false，表明发送已完成。 数据复制：如果接收缓冲区非空 (!rxBufferEmpty) 并且发送缓冲区未满 (!txBufferFull)，则使用 memcpy 函数将接收缓冲区的数据复制到发送缓冲区，并将 rxBufferEmpty 设置为 true，txBufferFull 设置为 true，为下一次接收和发送做准备。 关于中断和回调LPUART_UserCallback 是一个用户自定义的回调函数，它会在 LPUART 驱动程序中的中断处理函数 LPUART_TransferHandleIRQ 中，当特定的传输事件发生后被调用。具体来说，以下几种情况下会调用 LPUART_UserCallback： 接收完成： 当使用 LPUART_TransferReceiveNonBlocking 函数启动非阻塞接收，并且所有请求的数据都已接收完毕时，LPUART_TransferHandleIRQ 函数会在处理接收数据就绪中断时调用 LPUART_UserCallback，并传递状态 kStatus_LPUART_RxIdle。 发送完成： 当使用 LPUART_TransferSendNonBlocking 函数启动非阻塞发送，并且所有数据都已发送完毕时，LPUART_TransferHandleIRQ 函数会在处理发送完成中断时调用 LPUART_UserCallback，并传递状态 kStatus_LPUART_TxIdle。 接收硬件溢出： 当 LPUART 硬件发生接收溢出错误时，LPUART_TransferHandleIRQ 函数会在处理接收溢出中断时调用 LPUART_UserCallback，并传递状态 kStatus_LPUART_RxHardwareOverrun。这个状态表示有数据在接收之前就被覆盖了，导致数据丢失。 完整的接收流程和发送流程接收流程： 应用程序调用 LPUART_TransferReceiveNonBlocking 函数启动非阻塞接收。 LPUART_TransferReceiveNonBlocking 函数配置 LPUART 硬件，使能接收中断，并将接收请求的信息保存在 lpuart_handle_t 结构体中。 LPUART 硬件接收到数据后，触发中断。 CPU 响应中断，执行中断服务例程 LPUART_TransferHandleIRQ。 LPUART_TransferHandleIRQ 函数检查中断状态，如果是接收数据就绪中断，则调用 LPUART_TransferHandleReceiveDataFull 函数。 LPUART_TransferHandleReceiveDataFull函数将数据从LPUART接收FIFO读取到handle指定的缓冲区。 LPUART_TransferHandleReceiveDataFull函数检查是否所有请求的数据都已接收完毕，如果是，则在LPUART_TransferHandleIRQ中调用handle-&gt;callback，即 LPUART_UserCallback，并传递 kStatus_LPUART_RxIdle 状态。 发送流程： 应用程序调用 LPUART_TransferSendNonBlocking 函数启动非阻塞发送。 LPUART_TransferSendNonBlocking 函数配置 LPUART 硬件，使能发送中断，并将发送请求的信息保存在 lpuart_handle_t 结构体中。 当发送数据寄存器为空时，LPUART 硬件触发中断。 CPU 响应中断，执行中断服务例程 LPUART_TransferHandleIRQ。 LPUART_TransferHandleIRQ 函数检查中断状态，如果是发送数据寄存器空中断，则调用 LPUART_TransferHandleSendDataEmpty 函数。 LPUART_TransferHandleSendDataEmpty函数将数据从handle指定的缓冲区写入LPUART发送FIFO。 LPUART_TransferHandleSendDataEmpty函数检查是否所有数据都已发送完毕。如果是，则当发送完成后，在LPUART_TransferHandleIRQ中调用 handle-&gt;callback，即 LPUART_UserCallback，并传递 kStatus_LPUART_TxIdle 状态。 总结： LPUART_UserCallback 是一个在中断上下文中被调用的回调函数。它允许用户在 LPUART 传输完成后执行自定义的操作，例如： 设置标志位，通知应用程序传输已完成。 启动下一次传输。 处理接收到的数据。 进行错误处理。 通过使用回调函数，可以实现事件驱动的编程模型，提高程序的效率和响应性。用户不需要在主循环中轮询 LPUART 的状态，而是通过回调函数在传输完成后得到通知。 因此，LPUART_UserCallback 的调用时机取决于 LPUART 的传输状态和中断事件，主要发生在接收完成、发送完成和接收溢出等情况下。它在整个 LPUART 驱动程序中起到了连接驱动程序和用户应用程序的重要作用。","link":"/NXP/RT1060/rt1060-%E4%B8%B2%E5%8F%A3%E4%B8%AD%E6%96%AD%E4%BC%A0%E8%BE%93%E8%AF%A6%E8%A7%A3-sdk/"},{"title":"STL之vector","text":"STL之vector 向量vector是一个多功能的、能够操作多种数据结构和算法的模板类和函数库。 vector之所以被认为是一个容器，是因为它能够像容器一样存放各种类型的对象，简单地说，vector是一个能够存放任意类型的动态数组，能够增加和压缩数据。 向量可将元素存储在连续的内存位置中，并在运行时根据需要分配内存。 vector和array的区别数组array遵循静态方法，这意味着在运行时不能更改其大小，而vector实现动态数组意味着在添加元素时会自动调整其大小。 vector基础使用123456789101112131415161718#include &lt;iostream&gt;#include &lt;vector&gt;// 创建vector// vector&lt;object_type&gt; v1;using namespace std;int main(){ vector&lt;string&gt; v1; v1.push_back(\"C++ STL\"); v1.push_back(\"VECTOR\"); for (vector&lt;string&gt;::iterator itr = v1.begin(); itr != v1.end(); ++itr) { cout &lt;&lt; *itr &lt;&lt; endl; } return 0;} vector的常用成员函数 at(idx) : 传回索引idx所指向的数据，如果idx越界，抛出out_of_range; back() : 返回最后一个元素，不检查这个数据是否存在； front() : 返回第一个元素，不检查这个数据是否存在； swap() : 交换两个vector； push_back() : 在vector的末尾追加一个元素； pop_back() : 在vector中删除最后一个元素； empty() : 判断vector是否为空，为空则返回true； insert() : 在指定位置插入新元素； erase() : 删除指定的元素？？？ resize() : 修改vector的大小； clear() : 从vector中删除所有元素； size() : 返回vector的元素个数； capacity() : 返回vector在不重新分配内存的情况下，当前最多可以容纳的元素个数； assige() : 将新值分配给vector； operator=() : 将新值分配给vector容器； operator : 访问指定的元素； end() : 返回最末尾元素的迭代器； emplace() : 在位置pos之前，插入一个新的元素； emplace_back() : 在末尾插入一个元素； rend() : 指向vector的第一个元素之前的元素； rbegin() : 指向vector的最后一个元素； begin() : 返回第一个元素的迭代器； max_size() : 返回vector所能容纳的元素的最大数量（上限值）； cend() : 指向vector中的last-last-element; cbegin() : 指向vector的第一个元素； crbegin() : 指向vector的最后一个字符； crend() : 指向vector第一个元素之前的元素；？？？ data() : 将vector的数据写入array； shrink_to_fit() : 减小vector的容量，使它等于vector的大小； val = v1.at(idx)返回索引位置的值，和v1[idx]一样; 栗子： 12345678910111213#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(){ vector&lt;int&gt; v1{1, 2, 3, 4}; for (int i = 0; i &lt; v1.size(); i++) { cout &lt;&lt; v1.at(i) &lt;&lt; endl; } return 0;} val = v1.back()返回最后一个元素，不管存在不存在，v1.end()考虑下差别； v1.back()返回最后一个元素； v1.front()返回第一个元素； 栗子： 1234567891011121314151617#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(){ vector&lt;string&gt; v1{ \"begin\", \"middle\", \"end\", }; cout &lt;&lt; v1.back() &lt;&lt; endl; cout &lt;&lt; v1.front() &lt;&lt; endl; return 0;}// 发现一个问题：string居然区分单引号双引号，必须双引号才可以！ v1.swap(v2)交换两个vector中的元素； 如果两个vector的size不一样，会自动扩容，因为vector的长度可变。 栗子： 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(){ vector&lt;int&gt; v1 = {1, 2, 3, 4, 5}; vector&lt;int&gt; v2 = {6, 7, 8, 9, 10, 11}; cout &lt;&lt; \"在交换之前，v1的元素是 :\"; for (int i = 0; i &lt; v1.size(); i++) cout &lt;&lt; v1[i] &lt;&lt; \" \"; cout &lt;&lt; '\\n'; cout &lt;&lt; \"在交换之前，v2的元素是 :\"; for (int i = 0; i &lt; v2.size(); i++) cout &lt;&lt; v2[i] &lt;&lt; \" \"; cout &lt;&lt; '\\n'; v1.swap(v2); cout &lt;&lt; \"交换后，v1的元素为 :\"; for (int i = 0; i &lt; v1.size(); i++) cout &lt;&lt; v1[i] &lt;&lt; \" \"; cout &lt;&lt; '\\n'; cout &lt;&lt; \"交换后，v2的元素为 :\"; for (int i = 0; i &lt; v2.size(); i++) cout &lt;&lt; v2[i] &lt;&lt; \" \"; return 0;}","link":"/C/STL/stl%E4%B9%8Bvector/"},{"title":"STL开篇","text":"STL开篇STL 实际上，是一套封装好的C++模板类。提供通用的模板类和函数，用来高性能的实现常用的算法和数据结构，比如：向量vector、链表、队列、栈。 STL 做到了数据结构和算法的分离，比如：vector的底层是顺序表（数组），list的底层为双向链表，deque的底层是循环队列，set的底层是红黑树，hash_set的底层是哈希表。 C++ STL 的核心包括三个组件： 容器（Containers）:容器用来管理某同一类对象的集合。C++的各种容器类型，比如：deque、list、vector、map等。 算法（Algorithms）：算法作用于容器。提供执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作； 迭代器（iterators）：迭代器用于遍历对象集合的元素，这些集合可能是容器，也可能是容器的子集。 一个简单的vector示例vecotr和数组非常相似，唯一不同的是，vector在需要扩展大小的时候，会自动处理它的存储需求！ 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(){ vector&lt;int&gt; vec; int i; cout &lt;&lt; \"vec的原始大小： \" &lt;&lt; vec.size() &lt;&lt; endl; for (i = 0; i &lt; 6; i++) { vec.push_back(i + 1); } cout &lt;&lt; \"vec扩展后大小： \" &lt;&lt; vec.size() &lt;&lt; endl; for (i = 0; i &lt; 6; i++) { cout &lt;&lt; \"vec[\" &lt;&lt; i &lt;&lt; \"] 的值是：\" &lt;&lt; vec[i] &lt;&lt; endl; } // 使用迭代器iterator访问值 vector&lt;int&gt;::iterator v = vec.begin(); while (v != vec.end()) { cout &lt;&lt; \"迭代器*v的值：\" &lt;&lt; *v &lt;&lt; endl; v++; } cout &lt;&lt; *vec.begin() &lt;&lt; endl; return 0;} vector的常用函数： push_back(): 向vector的末尾插入值，如有必要，会扩展向量的大小； size(): 显示向量的大小； begin(): 返回一个指向向量开头的迭代器； end(): 返回一个指向向量结尾的迭代器 vector::iterator v = vec.begin();","link":"/C/STL/stl%E5%BC%80%E7%AF%87/"},{"title":"Icarus用户指南 - 站内搜索插件","text":"本文介绍Icarus 5支持的站内搜索插件的安装配置。 本文同时提供以下语言的翻译：English。 下面的站内搜索插件由ppoffice/hexo-component-inferno提供，完整的支持插件列表和配置详情以其为准。 .content ol:not([type]) { list-style-type: simp-chinese-informal; } Algolia 安装指南 在线预览 在Hexo站点的根目录安装hexo-algolia插件。 注册并登录Algolia。 首次登录控制面板(Dashboard)时点击页面上的“创建索引”(Create Index)按钮。 然后，输入”索引名称“(Index name)并点击“创建”(Create)完成索引创建。 下一步，点击右侧导航栏上的”API密钥“(API Keys)，复制页面上的“应用ID”(Application ID)和“仅限搜索的API Key” (Search-Only API Key)。 打开Hexo站点根目录下的站点配置文件_config.yml，填入上面复制的信息到hexo-algolia插件的配置中。 例如，下面的Algolia索引信息： Algolia索引信息123Algolia索引名称: My-Hexo-SiteApplication ID: ABCDEFGHIJKLSearch-Only API Key: 7b08fca7d42412cee901a25643124221 对应的站点配置为： _config.yml1234algolia: applicationID: My-Hexo-Site indexName: ABCDEFGHIJKL apiKey: 7b08fca7d42412cee901a25643124221 回到Algolia控制面板的”API密钥“(API Keys)页面并切换到“所有API Keys”(All API Keys)标签页。 点击“新建API Key”(New API Key)按钮。 在弹出的“创建API Key”(Create API Key)对话框中，在”索引“(Indices)处选择你在上一步中创建的“索引”(Indices)。 然后，“ACL”项中添加addObject，deleteObject，listIndexes， deleteIndex。 点击“创建”(Create)完成密钥的创建。 复制刚刚创建的API Key，例如727fbd8c998fe419318fa350db6793ca。 打开一个Windows命令行(CMD)或Linux/macOS终端并切换当前目录到你的Hexo站点的根目录。 设置环境变量HEXO_ALGOLIA_INDEXING_KEY为上一步中创建的API Key。 hexo-algolia插件上传网站索引时会用到这个变量。 Windows下： Windows命令行(CMD)12C:\\Users\\you&gt; cd path/to/your/hexo/siteC:\\Users\\you&gt; set HEXO_ALGOLIA_INDEXING_KEY=727fbd8c998fe419318fa350db6793ca Linux/macOS下： Linux/macOS终端12$ cd path/to/your/hexo/site$ export HEXO_ALGOLIA_INDEXING_KEY=\"727fbd8c998fe419318fa350db6793ca\" 然后，运行下面的命令来清理站点并上传网站索引到Algolia： Windows命令行(CMD)或Linux/macOS终端12$ hexo clean$ hexo algolia 最后，在主题配置中设置搜索引擎为Algolia： _config.icarus.yml12search: type: algolia 百度搜索安装指南 打开主题配置文件并设置搜索为百度搜索： _config.icarus.yml12search: type: baidu 谷歌自定义搜索 安装指南 在线预览 登录你的谷歌账户并访问Google CSE来创建自定义搜索。 在“需要搜索的站点”(Sites to Search)中填入你的Hexo站点域名。 在“语言”(Language)选择框中选择正确的语言。 然后填写自定义“搜索引擎名称”(Name of the search engine)。 点击“创建”(Create)按钮完成引擎的创建。 然后，点击页面上的“添加到你的站点”(Add it to your site)右侧的“获取代码”(Get code)按钮。 从HTML代码中复制cx的值填入到对应主题配置项中。 例如，下面的HTML代码： Google CSE HTML代码12&lt;script async src=\"https://cse.google.com/cse.js?cx=012345601234560123456:abcdefghijklmn\"&gt;&lt;/script&gt;&lt;div class=\"gcse-search\"&gt;&lt;/div&gt; 对应下面的主题配置： _config.icarus.yml123search: type: google_cse cx: 012345601234560123456:abcdefghijklmn Insight安装指南 Insight为本站默认的站内搜索引擎。 你可以通过下面的主题配置来启用它： _config.icarus.yml123search: type: insight include_pages: true # 可选项。设置为false时从搜索结果中排除所有page 文章内容有误？请点击此处提交修改。","link":"/Plugins/Search/icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E6%8F%92%E4%BB%B6/"},{"title":"Icarus用户指南 - 分享按钮","text":"本文介绍Icarus 5支持的分享按钮的安装配置。 本文同时提供以下语言的翻译：English。 下面的分享按钮由ppoffice/hexo-component-inferno提供，完整的支持按钮列表和配置详情以其为准。 .content ol:not([type]) { list-style-type: simp-chinese-informal; } AddThis 此分享按钮可能会被部分广告拦截浏览器扩展拦截，请酌情使用。 AddThis分享按钮服务已下线，建议使用其他分享按钮服务作为替代。 安装指南 在线预览 注册AddThis。 在提交注册表单后的“选择工具”(Select a Tool)页面选择“分享按钮”(Share Buttons)。 在“选择工具类型”(Select a Tool Type)界面选择样式和按钮，点击“继续”(Continue)。 在下一页面中进一步自定义分享按钮，完成时点击“激活工具”(Activate Tool)按钮。 在”获取代码“(Get The Code)页面找到HTML代码，复制src属性值中的URL地址并填入分享按钮配置中。 例如，下面AddThis代码中的URL： AddThis代码12&lt;!-- Go to www.addthis.com/dashboard to customize your tools --&gt;&lt;script type=\"text/javascript\" src=\"//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-xxxxxxxxxxxxx\"&gt;&lt;/script&gt; 对应如下的主题配置： _config.icarus.yml123share: type: addthis install_url: //s7.addthis.com/js/300/addthis_widget.js#pubid=ra-xxxxxxxxxxxxx AddToAny 安装指南 在线预览 你可以启用AddToAny而无需注册用户。 仅需将下面的代码放到你的主题配置中： _config.icarus.yml12share: type: addtoany 如果你想自定义分享按钮，请采用如下步骤： 访问AddToAny官网并点击“获取分享按钮”(Get the Share Button)。 然后，选择“任意网站”(Any Website)并完成按钮的配置。 完成后点击“获取按钮代码”(Get Button Code)。 由于分享按钮是由ppoffice/hexo-component-inferno 提供，你需要将AddToAny的布局文件src/view/share/addtoany.jsx从这个仓库中复制到&lt;icarus_directory&gt;/layout/share/addtoany.jsx。 然后，替换addtoany.jsx中AddToAny代码并修正文件头部的包引用。 例如，假设下面的代码是你从上一步获得的代码： AddToAny代码 &gt;folded123456789&lt;!-- AddToAny BEGIN --&gt;&lt;div class=\"a2a_kit a2a_kit_size_32 a2a_default_style\"&gt;&lt;a class=\"a2a_dd\" href=\"https://www.addtoany.com/share\"&gt;&lt;/a&gt;&lt;a class=\"a2a_button_facebook\"&gt;&lt;/a&gt;&lt;a class=\"a2a_button_twitter\"&gt;&lt;/a&gt;&lt;a class=\"a2a_button_email\"&gt;&lt;/a&gt;&lt;/div&gt;&lt;script async src=\"https://static.addtoany.com/menu/page.js\"&gt;&lt;/script&gt;&lt;!-- AddToAny END --&gt; 那么你需要对addtoany.jsx做出如下修改： &lt;icarus_directory&gt;/layout/share/addtoany.jsx &gt;folded123456789101112131415161718192021222324const { Component, Fragment } = require('inferno');- const { cacheComponent } = require('../../util/cache');+ const { cacheComponent } = require('hexo-component-inferno/lib/util/cache');...中间省略部分代码...class AddToAny extends Component { render() { return &lt;Fragment&gt;- &lt;div class=\"a2a_kit a2a_kit_size_32 a2a_default_style\"&gt;- &lt;a class=\"a2a_dd\" href=\"https://www.addtoany.com/share\"&gt;&lt;/a&gt;- &lt;a class=\"a2a_button_facebook\"&gt;&lt;/a&gt;- &lt;a class=\"a2a_button_twitter\"&gt;&lt;/a&gt;- &lt;a class=\"a2a_button_telegram\"&gt;&lt;/a&gt;- &lt;a class=\"a2a_button_whatsapp\"&gt;&lt;/a&gt;- &lt;a class=\"a2a_button_reddit\"&gt;&lt;/a&gt;- &lt;/div&gt;+ 刚刚获取的AddToAny HTML代码替换到这里 &lt;script src=\"https://static.addtoany.com/menu/page.js\" defer={true}&gt;&lt;/script&gt; &lt;/Fragment&gt;; }}...下面省略部分代码... 百度分享 此分享按钮可能会被部分广告拦截浏览器扩展拦截，请酌情使用。 百度分享按钮服务似乎已下线，建议使用其他分享按钮服务作为替代。 安装指南 你可以启用百度分享按钮而无需注册用户。 直接将下面的代码添加到你的主题配置中： _config.icarus.yml12share: type: bdshare Share.js Share.js服务已停止维护，建议使用其他分享按钮服务作为替代。 安装指南 在线预览 你可以启用Share.js分享按钮而无需用户注册。 直接将下面代码添加到主题配置中： _config.icarus.yml12share: type: sharejs (可选)请参照AddToAny部分的个性化步骤与share.js主页 来了解更多关于自定义分享按钮的信息。 ShareThis 安装指南 在线预览 访问ShareThis并点击页面上的“从分享按钮开始”(Start with Share Buttons)按钮。 在“选择分享按钮类型”(Choose type of sharing button)页面选择你需要的按钮类型。 不要启用”GDPR规范工具“，否则可能会导致一些问题。 你也可以点击“自定义你的分享按钮”(Customize your share buttons)链接来进行按钮的进一步配置。 完成后点击“下一步”(Next)。 在”选择你的CMS平台“(Choose your CMS platform)页面选择”HTML“并点击”下一步“(Next)。 在“注册并获取代码”(Register and get the code!)页面输入邮箱和密码完成ShareThis的注册。 最后，从HTML代码段中复制src中的URL地址到分享按钮配置中。 例如，下面的ShareThis代码： AddThis代码1&lt;script type=\"text/javascript\" src=\"https://platform-api.sharethis.com/js/sharethis.js#property=xxxxxxxxxxxxx&amp;product=inline-share-buttons\" async=\"async\"&gt;&lt;/script&gt; 对应下面的主题配置： _config.icarus.yml123share: type: sharethis install_url: https://platform-api.sharethis.com/js/sharethis.js#property=xxxxxxxxxxxxx&amp;product=inline-share-buttons 文章内容有误？请点击此处提交修改。","link":"/Plugins/Share/icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-%E5%88%86%E4%BA%AB%E6%8C%89%E9%92%AE/"},{"title":"Thread协议基础","text":"General Thread introduction1.1 家用无线网络的要求✔低功耗 ✔弹性（网状） ✔基于IP ✔开放协议 ✔安全和用户友好 ✔快速上市 ✔现有无线电芯片 关于弹性组网： Resilient (mesh) No single point of failure 无单点故障 Self-healing 自我修复 Interference robustness 干扰鲁棒性 Self-extending 自我扩展 Reliable enough for critical infrastructure 足够可靠，适用于关键基础设施 1.2 What is THREAD ？ 为家庭及其连接产品提供安全的无线网状网络 基于久经考验的现有技术构建 在现有 802.15.4 芯片上运行 使用 6LoWPAN 和 IPv6 寻址 UDP Transport 新的强制性安全体系结构 添加/删除产品简单且安全 可扩展到每个网络 250 多个产品 设计用于超低功耗操作 适用于关键基础设施 1.3 THREAD target applocationsThread专为家庭中的各种产品而设计 Appliances Access control Climate control Energy management Lighting Safety Security Thread networking architecture2.1 网络拓扑Many Border Router + One Thread Leader + Up to 31 Thread Active Router + Up to 512 per Active Router End Device = Thousands of Devices Per Network (16K) 可路由设备： Active Router : 当网络的连接性相对有限时，REED 请求领导者使其成为活动路由器。 例如：当现有活动路由器的总数小于 &lt; 16 Router Eligible End Device (REED) : 在最初通过现有的Active Routers加入网络后，或在网络有足够的连接性时，立即加入网络。 Leader : 如果它是网络分区中的初始设备，或者当当前的领导者不可用时; The Border Router : Usually is a subset of Router Eligible Device Has at least one more different interface than IEEE 802.15.4 (e.g.: Wi-Fi, Ethernet, USB) Facilitates IP packet forwarding to and from the Thread network to home LAN or upstream IP infrastructure Can be a specialized networking device: wireless access point home gateway Or can be embedded in a consumer product: thermostat appliance 2.2 flexible network Devices join as Router Eligible End Devices or End Devices; REED 可以成为一个Router，如果Leader确定需要更好的覆盖范围； 所有Router通过Trickle机制和MLE向所有其他路由器保持状态； 所有Router通过Trickle机制和MLE维持Border Router的状态； Sleeping End Devices route through parent Router Router Eligible Devices can also maintain state Leader used to make decisions within network； 2.3 No single point of failure 无单点故障 不需要识别网络中的专门设备； Leader作出决定，但一旦失败，另一个Router将成为Leader 网络将在需要时增加Active Routers以改善连接性。 2.4 Low-Power End Devices 睡眠设备轮询父母的信息（或远程设备，如果应用程序已配置） 睡眠设备不需要与父母设备check in，从而实现低功耗操作 父母为睡眠设备保留信息 睡眠设备在失去连接时自动切换parent Thread IP addressing architecture3.1 IP地址分配 IP Addresses are assigned at the border between the IP layer and each specific Media Interface below the IP stack（IP地址是在IP层和IP堆栈下面的每个特定媒体接口之间的边界上分配的） Multiple IP address can be assigned to the same Media Interface（多个IP地址可以分配给同一个媒体接口） The same address can be assigned to the multiple Media Interfaces on the same device or on different devices（同一个地址可以分配给同一个设备上的多个媒体接口，也可以分配给不同设备上的多个媒体接口。） 3.2 IPV6地址符号基础 An IPv6 address has 16 bytes (128 bits), represented as eight 2-byte groups: 2001:3344:5566:7788:99AA:BBCC:DDEE:0000 All 0000 groups can be represented as a single 0 每个group开头的0可以省略 所有0组的最长连续集合可表示为2个冒号: 2001:0044:0000:0000:0000:BBCC:00EE:0000 is equivalent to 2001:44::BBCC:EE:0 Addresses 分为 Network Prefix and Network Address 网络前缀和网络地址: Representing the length of the network prefix can be done with a /prefixlen notation 2001:3344:5566:7788:99AA:BBCC:DDEE:FF00/64 3.3 IPV6 ADDRESS CLASSES Unicast –Identifies a single Media Interface on a single network host(识别单一网络主机上的单一媒体接口): Network Prefix: 64 bits Network Address = Interface Identifier (IID): 64 bits Multicast–Identifies all network hosts which have assigned a multicast group to one or more Media Interfaces(识别已将multicast group分配给一个或多个媒体接口的所有network hosts) Multicast Prefix: 8 bits all 1s (multicast address format FF::) Flags: 4 bits Scope: 4 bits Multicast Group: 112 bits Anycast–Identifies a unicast-like address assigned to multiple interfaces where the final destination of packets can be any of the nodes using the address(标识分配给多个接口的类似单播的地址，其中数据包的最终目的地可以是使用该地址的任何节点) 3.4 HOW MANY ADDRESSES DOES A THREAD DEVICE GET?Once joined to a network, a Thread device will get: At least 3 Unicast IPv6 addresses to the Thread Interface: Link local address (LL64): Mesh local address (ML16, RLOC): Mesh local address (ML64, ML-EID): Two All Thread Nodes multicast addresses: Link local all Thread Nodes(Multicast): Realm local all Thread Nodes(Multicast): Optional will also get: Unique local address (ULA): Global unique address (GUA): 3.5 THREAD SCOPES SCOPES在使用和转发地址的数据包时指定网络的边界; Link Local single-hop within radio range Mesh Local multi-hop within the PAN Unique Local multi-hop within the PAN and inter-PAN for the same network Global internet addressable UNICAST LINK LOCAL ADDRESS LL64 允许在IEEE802.15.4无线电范围内的直接邻居之间进行通信，换句话说，就是那些相距一跳的链接。 LL64接口标识符被设置为MAC扩展地址（$thr get randomaddr），universal/local bit被颠倒。 UNICAST MESH LOCAL ADDRESS ML16 到达 Thread 网络中的任何设备，供 Thread 堆栈内部使用。 RLOC 嵌入了Router ID（分配了leader）和Child ID（分配了路由器） 每当 Thread Network 分区拓扑发生变化时，ML16 都会发生变化 UNICAST MESH LOCAL ADDRESS 到达 Thread 网络中的任何节点 强烈推荐application使用 Mesh Local Endpoint Identifier (ML-EID)由 Thread Stack 随机生成，并在重启后保持不变 MulticastLink local all Thread nodes 执行Multicast而不重试数据包，消息包将只被IEEE 802.15.4无线电范围内的邻居接收。 Realm local all Thread nodes 数据包可以到达网络的每个节点，只要节点距离请求者最多 2 个“跳” 每次到达路由器时，数据包都会被转发 3 次。","link":"/IoT%E5%8D%8F%E8%AE%AE/Thread/thread%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/"},{"title":"UART_Polling模式代码","text":"主函数 usart_polling.c 12345678910111213141516171819202122232425262728293031323334353637383940414243int main(void){ uint8_t ch; usart_config_t config; // 配置波特率、帧格式、上升下降沿、奇偶校验、停止位等 /* Security code to allow debug access */ SYSCON-&gt;CODESECURITYPROT = 0x87654320; /* attach clock for USART(debug console) */ CLOCK_AttachClk(BOARD_DEBUG_UART_CLK_ATTACH); /* reset FLEXCOMM for USART */ RESET_PeripheralReset(kFC0_RST_SHIFT_RSTn); BOARD_BootClockRUN(); BOARD_InitDebugConsole(); BOARD_InitPins(); /* * config.baudRate_Bps = 115200U; * config.parityMode = kUSART_ParityDisabled; * config.stopBitCount = kUSART_OneStopBit; * config.loopback = false; * config.enableTx = false; * config.enableRx = false; */ USART_GetDefaultConfig(&amp;config); // 使用默认配置，传入config的引用 config.baudRate_Bps = BOARD_DEBUG_UART_BAUDRATE; // 客制化usart配置 config.enableTx = true; config.enableRx = true; USART_Init(DEMO_USART, &amp;config, DEMO_USART_CLK_FREQ); // 使用config和外部时钟初始化USART实例，其中外部时钟只在设置波特率时使用 USART_WriteBlocking(DEMO_USART, txbuff, sizeof(txbuff) - 1); // 将数组中的值写入 while (1) { PRINTF(\"READ:\\n\\r\"); USART_ReadBlocking(DEMO_USART, &amp;ch, 1); // 数据逐个从FIFORD读入ch，这里只读入一位 PRINTF(\"\\n\\rWRITE:\\n\\r\"); USART_WriteBlocking(DEMO_USART, &amp;ch, 1); // 数据逐个从ch写入FIFOWR，这里只读入一位，等待TX进入IDLE模式结束 PRINTF(\"\\n\\r\"); }} 只接收一个char实验结果： 接收字符串原始代码修改为接收一个定长5的array，代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243int main(void){ uint8_t array[6]; usart_config_t config; /* Security code to allow debug access */ SYSCON-&gt;CODESECURITYPROT = 0x87654320; /* attach clock for USART(debug console) */ CLOCK_AttachClk(BOARD_DEBUG_UART_CLK_ATTACH); /* reset FLEXCOMM for USART */ RESET_PeripheralReset(kFC0_RST_SHIFT_RSTn); BOARD_BootClockRUN(); BOARD_InitDebugConsole(); BOARD_InitPins(); /* * config.baudRate_Bps = 115200U; * config.parityMode = kUSART_ParityDisabled; * config.stopBitCount = kUSART_OneStopBit; * config.loopback = false; * config.enableTx = false; * config.enableRx = false; */ USART_GetDefaultConfig(&amp;config); config.baudRate_Bps = BOARD_DEBUG_UART_BAUDRATE; config.enableTx = true; config.enableRx = true; USART_Init(DEMO_USART, &amp;config, DEMO_USART_CLK_FREQ); USART_WriteBlocking(DEMO_USART, txbuff, sizeof(txbuff) - 1); while (1) { PRINTF(\"READ:\\n\\r\"); USART_ReadBlocking(DEMO_USART, &amp;array, sizeof(array) - 1); PRINTF(\"\\n\\rWRITE:\\n\\r\"); USART_WriteBlocking(DEMO_USART, &amp;array, sizeof(array) - 1); PRINTF(\"\\n\\r\"); }} 实验结果：","link":"/%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE/UART/uart-polling%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81/"},{"title":"UART总结","text":"总线协议 – UART一、 UART简介 UART: Universal Asynchronous Receiver Transmitter（通用异步收发器）， 通用的串行、异步通信总线，它有两条数据线，实现全双工发送和接收。 1.1 通信基础串行、并行： 并行通信：总线在传递数据的时候，可以一次性收发多个位的数据。并行虽然快，但是要考虑多个线的资源占用，以及多条线互相干扰的问题； 串行通信：每一位数据逐次传递；（IIC\\SPI都是串行通信） 单工、双工： 单工通信：只能是单向的，发送器给接收器发送数据，而不能反过来； 双工通信：可以是A到B，也可以是B到A； 半双工：不能同时发生；只有一根线，发送时就不能接收； 全双工：可以同时发送和接收，有两根线； 波特率： 波特率：描述UART通信速度，单位bps，(bit per second)，每秒传送的bit的数量； 每秒的波特数，波特等于单个信号包含的码元数量 比特率：是指每秒传送的比特(bit)数。单位为 bps(Bit Per Second)，比特率越高，每秒传送数据就越多。 波特率：表示每秒钟传送码元符号的个数，是衡量数据传送速率的指标。 在信息传输通道中，携带数据信息的信号单元叫码元，每秒钟通过信道传输的码元数称为码元传输速率，简称波特率。波特率是传输通道频宽的指标。 比特率=波特率x单个调制状态对应的二进制位数 两相调制(单个调制状态对应1个二进制位)的比特率等于波特率;四相调制(单个调制状态对应2个二进制位)的比特率为波特率的两倍;八相调制(单个调制状态对应3个二进制位)的比特率为波特率的三倍;依次类推。 1.2 UART帧格式 起始位：1bit的0，标志发送开始；因为空闲时为1，所以开始为0； 数据位： 5-8bit，先发低位，后发高位； 校验位：可有可无；奇偶校验，是校验奇数还是偶数个1； 停止位：高电平1； 空闲位： 注意： UART空闲的时候，用高电平表示； 串口协议从低位先发，最后发高位； 串口每次都只发一个byte，下一个byte又重新开始起始位，是因为它是异步的，发送方和接收方的时钟不是同一个，防止由于时钟不同步导致误差累积； IIC和SPI都是同步通信，可以发多个字节； 1.3 Tx &amp; Rx 串口的信号一般较弱，通信距离短，容易被干扰，所以增加了一块专有芯片用来增加抗干扰能力，使发送距离更远；(TTL信号转为232信号) 发送STEPs： 待发送数据放入FIFO 增加了UART协议的各种头，比如起始和校验，然后拷贝放入shifter； shifter每个bit依次移位到引脚来发送，先发低位，后发高位； 即发送时： FIFO –&gt; shifter –&gt; TxD; 接收时顺序相反，RxD –&gt; shifter –&gt; FIFO; 1.4 UART工作模式CPU会通过总线，和接收和发送的BUFFer相连，用来读写数据，另外，也和控制单元相连，对控制单元的设置进行修改； look-back: 回环模式look-back是在内部将Tx和Rx短接，一般用于测试； 三种常见的工作模式： polling 轮询 CPU不断地对FIFO进行访问，查询需要的数据有没有发过来； CPU的状态： 工作 –&gt; 轮询 –&gt; 工作 –&gt; 轮询 … 直到查找到需要的数据； 费时费力，消耗资源 interrupt 中断 CPU和FIFO约定，CPU不主动去查询，当FIFO收到数据要发送过来的时候，给CPU发送中断信号，CPU中断当前工作，接收FIFO的数据； 比polling模式省资源； DMA 直接存储器访问 CPU收到FIFO的数据，最终也是要放入某一块内存中去使用的； DMA模式跳过CPU，当FIFO数据过来时，直接放入需要的内存中； 二、 polling模式实验（以qn9090为例）2.1 主函数 usart_polling.c 12345678910111213141516171819202122232425262728293031323334353637383940414243int main(void){ uint8_t ch; usart_config_t config; // 配置波特率、帧格式、上升下降沿、奇偶校验、停止位等 /* Security code to allow debug access */ SYSCON-&gt;CODESECURITYPROT = 0x87654320; /* attach clock for USART(debug console) */ CLOCK_AttachClk(BOARD_DEBUG_UART_CLK_ATTACH); /* reset FLEXCOMM for USART */ RESET_PeripheralReset(kFC0_RST_SHIFT_RSTn); BOARD_BootClockRUN(); BOARD_InitDebugConsole(); BOARD_InitPins(); /* * config.baudRate_Bps = 115200U; * config.parityMode = kUSART_ParityDisabled; * config.stopBitCount = kUSART_OneStopBit; * config.loopback = false; * config.enableTx = false; * config.enableRx = false; */ USART_GetDefaultConfig(&amp;config); // 使用默认配置，传入config的引用 config.baudRate_Bps = BOARD_DEBUG_UART_BAUDRATE; // 客制化usart配置 config.enableTx = true; config.enableRx = true; USART_Init(DEMO_USART, &amp;config, DEMO_USART_CLK_FREQ); // 使用config和外部时钟初始化USART实例，其中外部时钟只在设置波特率时使用 USART_WriteBlocking(DEMO_USART, txbuff, sizeof(txbuff) - 1); // 将数组中的值写入 while (1) { PRINTF(\"READ:\\n\\r\"); USART_ReadBlocking(DEMO_USART, &amp;ch, 1); // 数据逐个从FIFORD读入ch，这里只读入一位 PRINTF(\"\\n\\rWRITE:\\n\\r\"); USART_WriteBlocking(DEMO_USART, &amp;ch, 1); // 数据逐个从ch写入FIFOWR，这里只读入一位，等待TX进入IDLE模式结束 PRINTF(\"\\n\\r\"); }} 2.2 只接收一个char实验结果： 接收字符串原始代码修改为接收一个定长5的array，代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243int main(void){ uint8_t array[6]; usart_config_t config; /* Security code to allow debug access */ SYSCON-&gt;CODESECURITYPROT = 0x87654320; /* attach clock for USART(debug console) */ CLOCK_AttachClk(BOARD_DEBUG_UART_CLK_ATTACH); /* reset FLEXCOMM for USART */ RESET_PeripheralReset(kFC0_RST_SHIFT_RSTn); BOARD_BootClockRUN(); BOARD_InitDebugConsole(); BOARD_InitPins(); /* * config.baudRate_Bps = 115200U; * config.parityMode = kUSART_ParityDisabled; * config.stopBitCount = kUSART_OneStopBit; * config.loopback = false; * config.enableTx = false; * config.enableRx = false; */ USART_GetDefaultConfig(&amp;config); config.baudRate_Bps = BOARD_DEBUG_UART_BAUDRATE; config.enableTx = true; config.enableRx = true; USART_Init(DEMO_USART, &amp;config, DEMO_USART_CLK_FREQ); USART_WriteBlocking(DEMO_USART, txbuff, sizeof(txbuff) - 1); while (1) { PRINTF(\"READ:\\n\\r\"); USART_ReadBlocking(DEMO_USART, &amp;array, sizeof(array) - 1); PRINTF(\"\\n\\rWRITE:\\n\\r\"); USART_WriteBlocking(DEMO_USART, &amp;array, sizeof(array) - 1); PRINTF(\"\\n\\r\"); }} 实验结果： 三、补充3.1 SDK中典型使用在NXP的QN9090的SDK中，提供了丰富的示例： polling method 收发 interrupt method 收发 ringbuffer接收数据 DMA method 收发 文档 ： MCUXpresso SDK API Reference Manual.pdf 3.2 串口的工作原理一个byte的数据，如何转为串口输出的bit？ 通过移位寄存器原理实现 移位寄存器原理： 初始状态： A3A2A1A0＝ 1011 然后Q3的输出，是在每个时钟节拍，按照这个先后顺序，把A3A2A1A0串行的输出出去。(小端) 其实利用的就是D触发器的特性。 如果我们使用8位的移位寄存器，就可以利用8个clk的时间，发一组8bit的数据通过一根导线传输出去。","link":"/%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE/UART/uart%E6%80%BB%E7%BB%93/"},{"title":"升级指南","text":"本文同时提供以下语言的翻译： English. 从5.x升级至6.x 将Node.js升级到14.0或者更新的版本。 下载源代码或者从NPM安装Icarus 6.x。 你可以在Icarus快速上手中找到安装指导。 如果你打算通过修改源代码的方式自定义主题，你必须从源代码安装主题。 运行hexo clean来清理缓存并让Icarus为你升级主题配置文件。 阅读更新说明和最新文档来了解更多新功能的信息。 从4.x升级至5.x 将Node.js升级到12.4.0或者更新的版本。 下载源代码或者从NPM安装Icarus 5.x。 你可以在Icarus快速上手中找到安装指导。 如果你打算通过修改源代码的方式自定义主题，你必须从源代码安装主题。 运行hexo clean来清理缓存并让Icarus为你升级主题配置文件。 阅读更新说明和最新文档来了解更多新功能的信息。 从3.x升级至4.x 将Node.js升级到10.13.0或者更新的版本。 下载源代码或者从NPM安装Icarus 4.x。 你可以在Icarus快速上手中找到安装指导。 如果你打算通过修改源代码的方式自定义主题，你必须从源代码安装主题。 运行hexo clean来清理缓存。 按照Icarus的提示安装缺失的依赖软件包： 命令行123456$ hexo clean...ERROR Please install the missing dependencies your Hexo site root directory:ERROR npm install --save hexo@^5.0.2 hexo-component-inferno@^0.8.2 hexo-log@^2.0.0 hexo-util@^2.2.0ERROR or:ERROR yarn add hexo@^5.0.2 hexo-component-inferno@^0.8.2 hexo-log@^2.0.0 hexo-util@^2.2.0 再次运行hexo clean来让Icarus为你升级主题配置文件。 Icarus会备份并删除themes/icarus/_config.yml文件，然后创建_config.icarus.yml作为新的主题配置文件。 你可以参考_config.icarus.yml.example来了解示例配置. 命令行123456789$ hexo clean...WARN Your theme configuration is outdated (3.0.0 &lt; 4.0.0).INFO To skip the configuration upgrade, use \"--icarus-dont-upgrade-config\".INFO Backing up theme configuration files...INFO themes/icarus/_config.yml =&gt; themes/icarus/_config.yml.dc00f8b8f8bc03ede351d711e958dc4bINFO Upgrading theme configurations...INFO Theme configurations are written to /tmp/_config.icarus.yml.INFO Example configurations is at /tmp/_config.icarus.yml.example. Icarus现在将文章的缩略图和封面图区别对待。 对于有缩略图的所有文章/页面，将其front-matter中的thumbnail:更改为cover:。 post.md12345 title: Icarus快速上手 date: 2020-04-01- thumbnail: /gallery/covers/vector_landscape_1.svg+ cover: /gallery/covers/vector_landscape_1.svg--- 你仍可以在front-matter中设置thumbnail来在文章归档页面以及最新文章挂件中显示小一点的缩略图。 阅读更新说明和最新文档来了解更多新功能的信息.","link":"/uncategorized/%E5%8D%87%E7%BA%A7%E6%8C%87%E5%8D%97/"},{"title":"Vim使用","text":"Vim使用本周学习了小彭老师的vim教程，很受启发，学习记录在这。 先放链接： 【Vim插件整合包】C++/Python自动补全，模糊查找文件，编译CMake工程等 F4 == :wa 保存文件 F5 cmake多文件运行 F7 单文件运行 F8 打开一个外部shell F8 执行完命令之后，按Ctrl+D退出shell，回到文件中 F9 打开nerdtree ctrl + T 打开/关闭终端 ctrl + \\ ctrl + n 终端进入普通模式，可选中 ctrl + w + “” 在终端中粘贴；如果来自别的寄存器a，则ctrl + w + “a 可视模式按y复制，按p粘贴，按u撤销，按ctrl+r恢复撤销，按x删除单个字符，按dw删除单词，按dd删除行 Z == ZZ 保存并退出 Q 直接退出所有窗口 F10 快速修改error ctrl + ww 切换窗口 ctrl + wk 或者 wj 上下切换窗口 :split 和 :vsplit 分割窗口 普通模式 gq 快速修复 普通模式 gf 格式化代码 gd 跳转到定义 gD 跳转到声明 gr 跳转到引用 gy 跳转到类型定义 gI 跳转到函数实现 gn 重命名当前光标下的变量名 g + tab 查找命令表 gci 批量注释和反注释 K 查看当前光标下的symbol的文档 ctrl + i 或者 ctrl + o 光标跳转到上一次、下一次的位置 然后，不同的窗口之间切换，F2 F3 :Git blame 显示每一行的提交信息 空格 + g 打开所有当前git仓库中的文件 空格 + s 相当于git status 空格 + h 显示最近打开过的文件 空格 + b 显示目前已经打开的所有文件 空格 + l 搜索已打开文件中的内容 空格 + o 只在当前文件中搜索 空格 + r 在目前没打开的文件中搜索name % 跳转到匹配的括号 一些可以修改的运行tasks配置： 位置： ~/.vim/tasks.ini","link":"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/vim/vim%E4%BD%BF%E7%94%A8/"},{"title":"Icarus用户指南 - 网站分析插件","text":"本文介绍Icarus 5支持的网站统计与分析插件的安装配置。 本文同时提供以下语言的翻译：English。 下面的网站统计与分析插件由ppoffice/hexo-component-inferno提供，完整的支持插件列表和配置详情以其为准。 本文中涉及的所有插件均可能被部分广告拦截浏览器扩展拦截，请酌情使用。 百度统计安装指南 登录百度统计。 在“管理 &gt; 网站列表”页面上点击“新增网站”按钮并填写“网站域名”，“网站首页”等站点信息。 点击“确定”完成站点创建。 在下一页面上找到hm.baidu.com/hm.js?后的ID并填写到主题配置的plugins &gt; baidu_analytics &gt; tracking_id值中。 例如，如下的统计代码： 百度统计代码123456789&lt;script&gt;var _hmt = _hmt || [];(function() {var hm = document.createElement(\"script\");hm.src = \"https://hm.baidu.com/hm.js?3f06f2b732a5b1034c989f74e28d0eea\";var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s);})();&lt;/script&gt; 对应的主题配置为： _config.icarus.yml123plugins: baidu_analytics: tracking_id: 3f06f2b732a5b1034c989f74e28d0eea Bing Webmaster Tools安装指南 登录Bing - Webmaster Tools. 然后，选择“手动添加网站”(Add your site manually)并输入你网站的URL。 点击“添加”(Add)继续。 在“添加并验证网站”(Add &amp; verify site)面板，选择“HTML Meta 标记”(HTML Meta Tag)方法。 复制HTML meta标签中content属性的值到主题配置中的plugins &gt; bing_webmaster &gt; tracking_id下。 _config.icarus.yml123plugins: bing_webmaster: tracking_id: ABCDEFABCDEFABCDEFABCDEFABCDEFABCDEF 不蒜子网页计数器安装指南 将plugins &gt; busuanzi设置为true来开启不蒜子访客计数器并在网页尾部和每篇博文的头部展示访问次数。 _config.icarus.yml12plugins: busuanzi: true CNZZ统计安装指南 登录友盟+。 在友盟+工作台首页点击“创建新应用” &gt; “Web应用”。 然后输入“网站名称”，“网站域名”，“网站首页”等站点信息信息。 完成后点击“确认添加站点”。 在获取统计代码界面找到“文字样式”一栏下的HTML代码。 分别将其中id与web_id的值复制到主题配置的plugins &gt; cnzz &gt; id和web_id中。 例如，如下的统计安装代码： CNZZ统计代码1&lt;script type=\"text/javascript\" src=\"https://s9.cnzz.com/z_stat.php?id=123456789000&amp;web_id=123456789000\"&gt;&lt;/script&gt; 对应的主题配置为： _config.icarus.yml1234plugins: cnzz: id: 123456789000 web_id: 123456789000 Google Analytics安装指南 登录Google Analytics并点击左侧的”管理“(Admin)进入管理界面。 在管理界面上点击”创建资产“(Create Property)按钮，选择“测量的应用类型”(What do you want to measure?)为Web。 然后点击”继续“(Continue)按钮。 然后，填写“网站名称”(Website Name)，“URL地址”(Website URL)，“行业分类”(Industry Category)，以及“报告时区” (Reporting Time Zone)等信息。 点击”创建“(Create)按钮完成资产创建。 在”追踪代码“(Tracking Code)界面上找到”Tracking ID”的值，例如”UA-12345678-0”. 将其填写到主题配置的plugins &gt; google_analytics &gt; tracking_id即可开启Google Analytics插件。 _config.icarus.yml123plugins: google_analytics: tracking_id: UA-12345678-0 Hotjar安装指南 登录Hotjar，点击页面左上角的➕(加号) &gt; ”添加新站点“(Add new site)链接。 填写”网站地址“(WEBSITE)，”站点类型“(SITE TYPE)，和”站点所有者“(SITE OWNER)，然后点击”添加站点“(Add Site)按钮。 在重定向到的”站点&amp;组织“(Sites &amp; Organizations)页面找到新建的站点。 点击右侧的”追踪代码“(Tracking Code)按钮。 复制弹出对话框中”Site ID”的值(如”1234567”)到主题配置的plugins &gt; hotjar &gt; site_id来启用Hotjar插件。 _config.icarus.yml123plugins: hotjar: site_id: 1234567 Statcounter安装指南 登录Statcounter。 点击“项目”(Projects)页面上的“添加新项目”(Add New Project)。 在“添加页面”(Add Project)页面上填写网站网址和项目标题。 如有需要，调整其他的项目设置。 然后，点击“添加项目”(Add Project)按钮。 点击“完成平台检查”(Platform Check Complete)页面上的“继续默认安装”(Continue to Default Installation)按钮。 最终，在“在你的网站上插入代码”(Insert the Code on Your Website)页面，分别复制HTML代码片段中sc_project和sc_security变量的值 到主题配置中的plugins &gt; statcounter &gt; project和plugins &gt; statcounter &gt; security中。 例如，下面的Statcounter代码： Statcounter code12345678910&lt;script type=\"text/javascript\"&gt;var sc_project=12345678; var sc_invisible=1; var sc_security=\"abcdef12\"; var sc_https=1; &lt;/script&gt;&lt;script type=\"text/javascript\"src=\"https://www.statcounter.com/counter/counter.js\"async&gt;&lt;/script&gt;... 对应的主题配置为： _config.icarus.yml1234plugins: statcounter: project: 12345678 security: abcdef12 Twitter转化跟踪安装指南 按照如何设置转化跟踪启用Twitter转化追踪的通用网站标签(Universal website tag)。 在你的转化追踪代码中找到init (Pixel ID)。复制它的值到主题配置中的plugins &gt; twitter_conversion_tracking &gt; pixel_id。 例如，如下的Twitter追踪转化代码： Twitter追踪转化代码1234567891011&lt;!-- Twitter universal website tag code --&gt;&lt;script&gt;!function(e,n,u,a){e.twq||(a=e.twq=function(){a.exe?a.exe.apply(a,arguments):a.queue.push(arguments);},a.version='1',a.queue=[],t=n.createElement(u),t.async=!0,t.src='//static.ads-twitter.com/uwt.js',s=n.getElementsByTagName(u)[0],s.parentNode.insertBefore(t,s))}(window,document,'script');// Insert Twitter Pixel ID and Standard Event data belowtwq('init','abcdef');twq('track','PageView');&lt;/script&gt;&lt;!-- End Twitter universal website tag code --&gt; 对应的主题配置为： _config.icarus.yml123plugins: twitter_conversion_tracking: pixel_id: abcdef 文章内容有误？请点击此处提交修改。","link":"/Plugins/Analytics/icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-%E7%BD%91%E7%AB%99%E5%88%86%E6%9E%90%E6%8F%92%E4%BB%B6/"},{"title":"Icarus用户指南 - 挂件","text":"本文介绍Icarus 5支持的页面挂件的安装配置。 若要同时展示多个挂件，只需在主题配置的widgets数组中添加多个挂件配置。 它们会按照定义的顺序出现。 每个挂件必须包含type(挂件类型)与position(挂件展示位置)设置项。 示例如下： _config.icarus.yml123456789widgets: - type: ... # 挂件1 position: left ... - type: ... # 挂件2 position: right ... 本文同时提供以下语言的翻译：English。 下面的挂件由ppoffice/hexo-component-inferno提供，完整的支持挂件列表和配置详情以其为准。 作者资料卡你可以启用作者资料卡挂件来展示文章作者/网站站长的信息。 资料卡的配置如下所示： _config.icarus.yml123456789101112131415161718192021222324widgets: - position: right type: profile # 作者名称 author: hulatocat # 作者头衔 author_title: A GitHub Octocat # 作者所在地/公司 location: GitHub Inc. # 头像图片地址 avatar: https://octodex.github.com/images/hula_loop_octodex03.gif # 是否显示圆形头像 avatar_rounded: false # Gravatar邮箱(如不设置`avatar`项) gravatar: # 关注按钮链接地址 follow_link: 'https://octodex.github.com/hulatocat' # 社交媒体链接 social_links: Github: icon: fab fa-github url: 'https://github.com/' Icarus: 'https://github.com/ppoffice/hexo-theme-icarus' 需要注意的是： 如果你希望使用Gravatar而不是avatar配置项作为头像图片，请在gravatar项填入 你的Gravatar邮箱地址并在avatar一项中留空； social_links可以采用如下两种格式： 图标形式： social_links123&lt;链接名称&gt;: icon: &lt;FontAwesome5_图标的_HTML_class名称&gt; url: &lt;链接的URL地址&gt; 文字形式： social_links1&lt;链接名称&gt;: &lt;链接的URL地址&gt; 文章目录若要展示文章目录，请在主题配置中添加如下挂件配置： _config.icarus.yml123456widgets: - type: toc position: left # 是否显示目录项目的序号 index: true 然后，在需要开启目录的文章头部加入toc: true： Post.md1234title: 一篇有目录的文章toc: true---文章内容... 友站链接你可以使用友站链接挂件来展示外部网站的列表。 示例配置如下所示： _config.icarus.yml12345678widgets: - position: left type: links # 友站名称与链接 links: Hexo: 'https://hexo.io' Bulma: 'https://bulma.io' 最新文章使用如下挂件配置来开启最新文章挂件： _config.icarus.yml1234widgets: - position: right type: recent_posts 文章归档使用如下挂件配置来开启文章归档挂件： _config.icarus.yml1234widgets: - position: right type: archives 文章分类使用如下挂件配置来开启文章分类挂件： _config.icarus.yml1234widgets: - position: right type: categories 文章标签使用如下挂件配置来开启文章标签挂件： _config.icarus.yml1234567widgets: - position: right type: tags order_by: name # 可选项。按名称(name)或长度(length)来排序。加上`-`前缀来倒序排列。 amount: 20 # 可选项。最多显示的标签数量。留空以显示所有标签。 show_count: true # 可选项。是否显示标签名称右侧的文章数量。 Google Feedburner Google即将关闭Feedburner的邮件订阅功能。 你可以切换到follow.it挂件或者其他邮件订阅服务。 按照如下步骤即可启用Google Feedburner插件： 首先，使用诸如hexo-generator-feed此类的Hexo插件生成 你的Hexo网站的RSS源。 然后登录Google Feedburner，在输入框内输入你的RSS地址并点击“下一步”(Next) 来添加你的RSS源。 然后，在下一页中填写“源标题”。 点击“下一步”(Next)来继续自定义你的源，或者点击“直接跳到源管理”(Skip directly to feed management)来完成配置。 完成添加源后，点击网页顶部的”我的源“(My Feeds)链接。 点击“我的源”(My Feeds)页面上新添加的源。 切换到”宣传“(Publicize)标签页并点击页面左侧的”邮件订阅“(Email Subscription)链接。 点击“激活”(Activate)按钮来开启“邮件订阅”(Email Subscription)功能。 在”邮件订阅“(Email Subscription)页面上从HTML代码中找到如下信息： Google Feedburner URL1https://feedburner.google.com/fb/a/mailverify?uri=****** 复制uri=后的ID(如feedforall/ABCD)到挂件配置的feedburner_id设置中： _config.icarus.yml1234567widgets: - position: left type: subscribe_email # (可选) 描述文字 description: 邮件订阅，更新早知道 feedburner_id: feedforall/ABCD Google AdSense在Google AdSense上新建广告。 然后，复制广告HTML代码中的data-ad-client和data-ad-slot值分别填入到挂件配置的client_id和slot_id项中。 示例如下： _config.icarus.yml123456widgets: - position: left type: adsense client_id: ca-pub-xxxxxxxx slot_id: xxxxxxx follow.it按照如下步骤即可启用follow.it邮件订阅插件： 首先，使用诸如hexo-generator-feed此类的Hexo插件生成 你的Hexo网站的RSS源。 访问follow.it并在“向你的站点添加关注功能”(Add the follow feature to your site)下方的 输入框中填写RSS源的文件地址，例如http://example.com/atom.xml。 然后，点击“下一步”(Next)。 点击“定义关注表单设计”(Define the follow form’s design)页面上的“继续”(Continue)按钮。 搜索action=并复制action=后双引号中的链接。 把你复制的action链接粘贴到挂件配置中的action_url设置项。 在那之后，点击“完成”(Done)。 _config.icarus.yml1234567widgets: - position: left type: followit description: action_url: https://api.follow.it/****** verification_code: '' 点击“继续”(Continue)按钮或者“跳过此步”(Skip this)链接来跳过“选择你想要的关注按钮”(Pick the Follow icons you want)和 ”显示弹窗来最大化交流“(Show a pop-up for maximum conversion)页面。 在”连接你的源到follow.it账户“(Connect your feed to a follow.it account)页面上，在输入框中填入你将要用来注册follow.it账户 和管理订阅者的邮箱地址。 然后，点击”开始“(Start)。 你会收到一封来自follow.it的邮件。 在那封邮件中搜索&lt;meta name=\"follow_it-verification-code\" content=\"******\"/&gt;并复制content=后双引号中的content的值。 将你复制的值粘贴到挂件设置中的verification_code设置项。 _config.icarus.yml1234567widgets: - position: left type: followit description: action_url: https://api.follow.it/****** verification_code: ****** 生成你的站点并将其上传到你的服务器。 回到follow.it并用你的邮箱地址注册一个账户。 回到你收到的第一封邮件并点击”点击这里来认领“(Click here to claim it)链接来认领你的订阅源。 文章内容有误？请点击此处提交修改。","link":"/Widgets/icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-%E6%8C%82%E4%BB%B6/"},{"title":"ZigBeePRO-Fundamentals_Training","text":"1_ZigBeePRO-Fundamentals_Training0 Agend Zigbee Basics Zigbee Architecture ZigBee PRO Networks ZigBee Profiles, Devices and Clusters Network Commissioning Network Security Features 低功耗：将传输范围限制在0-10m line-of-sight. ZigBee 通常用于需要较长电池寿命和安全网络的低数据速率应用。 ZigBee 的定义速率为 250 Kbit/s，最适合来自传感器或输入设备的间歇性数据传输intermittent data transmissions 10 kbps to 115 kbps data throughput 10 to 75 m coverage range Up to 100 collocated networks Up to 2 years of battery life on standard alkaline batteries 1. Basic1.1 ZigBee的理想应用 点对点cable replacement（例如，无线鼠标、遥控器、玩具） 安全系统（例如，火灾和入侵者） 环境控制（例如，供暖和空调） 医院病人监控 照明控制 家庭自动化（例如，家庭娱乐、门、大门、窗帘和百叶窗） 自动抄表 (AMR) 工业自动化（例如，工厂监控） 2. Architecture2.1 适用于 ZigBee 堆栈的 OSI 模型 2.2 软件架构 3. ZigBee Pro Networks3.1 网络节点 Coordinator ： 每个网络都必须有一个Co-ordinator； 开启整个网络； 允许子节点通过它加入网络； 能作为父节点，允许有children Coordinator； Router ： 网络可以有多个router； router有路由能力； 允许其他节点通过它加入网络； 能作为parent，也能作为child； End Device ： 网络可以有很多终端设备； 只有收发数据的能力； 不能做parents，不能有child； 3.2 Network Identity PAN ID 16位的值，叫做PAN ID （Personal Area Network Identifier). 网络运行时，由Cooridnator随机选择； 新安装的网络生成的PAN ID可能与同一radio channel同一neighborhood的已有的网络存在冲突； Extended PAN ID： 64位的值，叫做EPID； 3.2 Network Addressing IEEE (MAC) 地址： 这是一个 64 位地址，由 IEEE 分配，唯一标识设备 在 ZigBee 网络中，有时称为“extended”地址。 网络地址： 此16位地址标识网络中的节点 有时称为“short”地址。 当节点首次加入网络时，由父节点动态分配为随机 16 位值。 协调器始终拥有网络地址 0x0000 3.3 NerghborTables 路由节点（Router 或 Coordinator）保存有关其相邻节点的信息，该信息存储在 Neighbor 表中，其中包含节点的直接子节点的条目. 3.4 网络创建的过程 初始化IEEE 802.15.4 stack 创建PAN Coordinator 设置网络的PAN ID 设置PAN Coordinator的short地址； 选择radio frequency channel start网络 加入其他设备 开始传输数据 3.5 Descriptors Node Descriptor 类型（End Device, Router or Coordinator) 使用的频段（868 MHz、902 MHz 或 2400 MHHz） Node Power Descriptor Power mode Available power sources Simple Descriptor The endpoint on which the application communicates Lists of input and output clusters 4. ZIGBEE PROFILES, DEVICES AND CLUSTER4.1 ZigBee Endpoints 一个设备可以运行多个应用程序或同一应用程序的多个实例 endpoint是为应用程序实例提供通信端口的软件实体 endpoint number用于在向node发送消息时标识目标应用程序 256 个endpoints，编号0 到 255： 0 保留给 ZDO（ZigBee Device Objects 1 到 240 可用于应用程序实例 241 到 254 保留，242 保留给 ZigBee Green Power 255 用于广播到所有应用程序实例 4.2 Application Profiles 应用程序配置文件定义了一组设备，这些设备可以一起用于实现特定市场领域的应用程序——例如： 照明系统的开/关 switch、调光开关和占用传感器用于光照系统； ZigBee 联盟定义了许多“公共”配置文件-例如： 智能能源 家庭自动化 公共配置文件确保来自不同制造商的 ZigBee 设备的互操作性 -例如： 允许一个供应商的开关与另一个供应商的灯具（包含负载控制器）一起工作 可互操作的产品必须经过测试和认证，以符合相关的 ZigBee 应用规范 4.3 Device Types ZigBee 配置文件（例如家庭自动化）包含许多设备类型 设备类型是： 对应于功能设备的软件实体（例如可调光） 在节点上作为具有相应端点的应用程序实施 设备类型由许多功能“集群”支持： 一些集群是强制性的（例如基本集群），一些是可选的 一些集群是特定于配置文件的 一些集群由配置文件共享并来自 ZigBee Cluster Library (ZCL) 在设备结构中启用了所需的集群 可以在同一节点上实现多个设备类型（或同一设备类型的多个实例） 4.4 Clusters and Attributes 集群是最小的功能构建块，对应于特定功能（例如开/关、可调光、恒温器 集群包含属性和用于与它们交互的命令 属性是保存的数据实体（例如温度）在设备上并且可以在设备之间进行通信 例如，恒温器集群包含与以下相关的属性： 当前温度 最低温度 最高温度 ZigBee 联盟已经定义了标准集群： 在 ZigBee Cluster Library(ZCL)中收集的一组常见集群 作为公共应用程序配置文件一部分的特定集群，例如智能能源 一个集群有两种形式——客户端和服务端——存在于两个通信设备上 4.5 Cluster Servers and Clients一个集群有两种形式，服务器和客户端： Cluster Server：用于存储属性并接收命令来操作它们 Cluster Client：用于通过发送命令来操作相应集群server中的属性（通常是“写”命令设置属性值，“读”命令获取属性值） 5. NETWORK COMMISSIONING5.1 Service Discovery 服务发现 允许加入设备找到与之操作的兼容节点（例如，调光开关可能需要找到可调光） 有关节点的信息保存在节点的“descriptors”中 根据兼容的集群进行匹配 集群信息是保存在节点上的简单描述符中 加入节点broadcast一个匹配描述符请求（Match Descriptor Request），列出感兴趣的集群 具有相关集群的节点单播unicast一个Match Descriptor Response，包含地址和端点信息 加入节点可能会收到多个响应 加入节点上的应用程序，必须确定它将与哪个响应节点一起工作 5.2 Direct Addressing, Grouping and Binding 直接寻址、分组和绑定节点可以通过直接寻址、分组或绑定与compatible node进行通信： Direct Addressing 涉及使用其地址向各个节点发送消息。 Grouping 涉及创建具有关联 16 位组地址的一组节点： Group Table保存在每个远程（目标）节点 此表包含节点所属组的组的地址 组的消息发送到相应的组地址 当一个group的消息已经receive，仅当组地址在表中时才接受此消息 Binding 涉及创建一组预定义的链接或与远程节点的绑定： 将本地端点（应用程序）与远程节点上的端点（应用程序）绑定 包含这些链路的绑定表保存在本地（源）节点上 来自本地端点的所有后续通信都自动发送到绑定的远程端点 可以本地或远程创建绑定 5.3 Sending Data Packets by Direct Addressing 通过直接寻址发送数据包 5.4 Sending Data Packets by Group Addressing 通过组寻址发送数据包要在group中包括node，必须使用“Add Group”命令将group address添加到node上的“Group Table”中。 5.5 Local and Remote BindingLocal BindingLocal device writes details of bound endpoint into its Binding Table. Remote Binding(Watch, Trap)Local device requests remote devices to write its details into their Binding Tables. 5.6 Sending Data Packets to Bound Endpoints 5.6 Attribute Reporting 一个节点可能需要向另一个节点发送regular/periodic报告。比如，一个开/关灯将其状态报告给Control Bridge（用于物联网） 属性报告涉及从集群服务器主动向客户端发送属性值（而不是客户端轮询polling服务器）： 减少网络流量 允许休眠服务器报告唤醒时的属性值 “属性报告”可以通过以下方式发出： 通过用户应用程序中的函数调用（在服务器设备上） 由 ZCL 自动发出 自动属性报告涉及两种机制： 报告由属性值变化触发 定期为属性发布报告 这些机制可以同时运行 必须首先使用Configure Reporting命令配置属性报告。 6. NETWORK SECURITY6.1 Security Schemes 安全方案安全措施由信任中心管理： Trust Center Policy 信任中心策略 White Listing白名单：仅允许预定义的“友好”节点加入网络 Security Key Distribution安全密钥分发：生成和传输用于加密的密钥 Encryption Schemes加密方案 高度安全的基于 AES 的加密系统 128 位加密密钥 可应用于两个级别： Network Level网络级别：相同的“网络密钥”用于所有网络通信 Application Level应用级别（可选）：每对应用程序之间的唯一“Link key” 6.2 Network Key Provisioning 下图说明了从Trust Centre到joining node的Network Key的提供。 该过程假定预配置的Link Key（全局或唯一）可用。 使用唯一link key，Trust Centre检查其是否具有与joining node的 MAC 地址相对应的密钥。 6.3 Application-level Security 可以为一对节点设置 允许两个节点之间的专用通信，使用application link key进行加密/解密 link key是唯一的，一对节点独占的 link key由信任中心颁发： 来自 TC 的一个请求节点链接密钥 TC 将密钥发送到两个节点 密钥的传输使用Network Key和TC和target node中间的link key加密（如果适用的话） 6.4 Data Encryption/Decryption in Stack 7. ZIGBEE CERTIFICATIONZigbee 3.0 完整的 loT solution — 从mesh network到允许智能对象协同工作的通用语言。 Zigbee增加了用户和开发人员的选择和灵活性;并让人们相信产品和服务将协同工作。 Zigbee服务于智能家居和商业建筑市场。","link":"/IoT%E5%8D%8F%E8%AE%AE/ZigBee/zigbeepro-fundamentals-training/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/uncategorized/hello-world/"},{"title":"kw38点灯大师","text":"KW38点灯大师 frdmkw38_gpio_led_output 工程 KW38点灯大师哈哈哈. 主函数1234567891011121314151617181920212223242526int main(void){ /* Define the init structure for the output LED pin*/ gpio_pin_config_t led_config = { kGPIO_DigitalOutput, 0, }; /* Board pin, clock, debug console init */ BOARD_InitPins(); BOARD_BootClockRUN(); BOARD_InitDebugConsole(); /* Print a note to terminal. */ PRINTF(\"\\r\\n GPIO Driver example\\r\\n\"); PRINTF(\"\\r\\n The LED is blinking.\\r\\n\"); /* Init output LED GPIO. */ GPIO_PinInit(BOARD_LED_GPIO, BOARD_LED_GPIO_PIN, &amp;led_config); while (1) { delay(); GPIO_PortToggle(BOARD_LED_GPIO, 1u &lt;&lt; BOARD_LED_GPIO_PIN); }} 这段代码是一个GPIO驱动的示例代码，它使用了MCUXpresso SDK提供的GPIO驱动库来控制开发板上的LED灯。 在这个示例中，我们使用了GPIO_PinInit()函数来初始化LED灯的GPIO引脚，然后在一个while循环中不断地切换LED灯的状态，从而实现LED灯的闪烁效果。 具体来说，我们使用了GPIO_PortToggle()函数来切换LED灯的状态，使用了delay()函数来控制LED灯的闪烁频率。 led_config 结构体定义了一个gpio_pin_config_t类型的变量led_config，它是一个结构体类型，用于配置GPIO引脚的属性。具体来说，它包含两个成员变量， 第一个成员变量是GPIO的工作模式，这里我们使用了kGPIO_DigitalOutput模式，表示这个GPIO引脚是一个数字输出引脚； 第二个成员变量是GPIO的初始电平，这里我们使用了0，表示初始电平为低电平。 这个led_config变量会在GPIO_PinInit函数中被使用，用于初始化LED灯的GPIO引脚。 GPIO_PinInit 函数12// 初始化GPIO引脚GPIO_PinInit(BOARD_LED_GPIO, BOARD_LED_GPIO_PIN, &amp;led_config); 三个参数： BOARD_LED_GPIO ： 第一个参数是GPIO的端口号 BOARD_LED_GPIO_PIN ： 第二个参数是GPIO的引脚号 &amp;led_config ： 第三个参数是一个指向gpio_pin_config_t类型的指针，用于配置GPIO引脚的属性 这个函数会根据传入的参数来初始化GPIO引脚，从而使得LED灯能够正常工作。 这里根据宏定义，使用的是红灯，查找board.h可以知道： 12345678#ifndef BOARD_LED_RED_GPIO#define BOARD_LED_RED_GPIO GPIOC#endif#define BOARD_LED_RED_GPIO_PORT PORTC#ifndef BOARD_LED_RED_GPIO_PIN#define BOARD_LED_RED_GPIO_PIN 1U#endif// 红灯是GPIOC Pin1 绿灯是GPIOA Pin16 蓝灯是GPIOB Pin2 GPIO_PinInit()函数初始化了一个由板子使用的GPIO引脚。它接受参数： GPIO外设基址指针(GPIOA、GPIOB、GPIOC等)、 GPIO端口引脚号和 GPIO引脚配置指针。 该函数根据配置将引脚设置为输入或输出引脚。 该函数首先检查配置指针是否不为空。然后它将标志设置为1。 如果引脚方向设置为数字输入，则函数在端口数据方向寄存器(PDDR)中清除引脚号处的位。（按位与上0） 如果引脚方向设置为数字输出，则函数使用GPIO_PinWrite()函数将输出逻辑值写入引脚，并在PDDR中设置引脚号处的位(按位或上1)。 GPIO_PinWrite()函数关于 GPIO_PinWrite()函数： 用于设置GPIO的输出电平。函数的输入参数：包括GPIO的基地址、GPIO的引脚号以及输出电平。 函数的实现是通过设置GPIO的寄存器来实现的。 如果输出电平为0，则通过PCOR寄存器清除对应引脚的输出电平；如果输出电平为1，则通过PSOR寄存器设置对应引脚的输出电平。 GPIO_PortToggle() 函数用来控制GPIO口输出，它的作用是将指定的GPIO口的指定引脚的电平翻转。在这个例子中，它被用来控制开发板上的LED灯的闪烁。 GPIO_PortToggle()函数的第一个参数是GPIO端口号，第二个参数是要翻转的引脚号。 在这个例子中，BOARD_LED_GPIO和BOARD_LED_GPIO_PIN分别定义了LED灯的GPIO端口号和引脚号。GPIO_PortToggle(BOARD_LED_GPIO, 1u &lt;&lt; BOARD_LED_GPIO_PIN)的作用是将LED灯的电平翻转。 其中1u &lt;&lt; BOARD_LED_GPIO_PIN是将1左移BOARD_LED_GPIO_PIN位，得到一个只有BOARD_LED_GPIO_PIN位为1的数，这个数表示要翻转的引脚。GPIO_PortToggle()函数会将这个数对应的引脚的电平翻转。 base-&gt;PTOR = mask;通过配置PTOR寄存器设置引脚电平翻转。 宏定义和原型函数1234567891011121314151617181920212223242526#define BOARD_LED_GPIO BOARD_LED_RED_GPIO#define BOARD_LED_GPIO_PIN BOARD_LED_RED_GPIO_PIN/******************************************************************************* * Prototypes ******************************************************************************//*! * @brief delay a while. */void delay(void);/******************************************************************************* * Variables ******************************************************************************//******************************************************************************* * Code ******************************************************************************/void delay(void){ volatile uint32_t i = 0; for (i = 0; i &lt; 800000; ++i) { __asm(\"NOP\"); /* delay */ }} delay函数delay函数中的for循环执行了800000次，每次循环都执行了一个空指令__asm(\"NOP\")，这个指令的作用是延迟一段时间。 具体来说，这个循环的执行时间取决于CPU的主频和循环次数，假设CPU主频为100MHz，那么这个循环的执行时间大约为8ms。因此，delay函数的作用是延迟一段时间，用于控制LED灯的闪烁频率。 其他mtb.c 这个文件是MTB初始化文件。MTB是Micro Trace Buffer的缩写，是一种用于调试的技术。 MTB可以记录程序的执行过程，包括程序计数器的值、寄存器的值、函数调用和返回等信息。这个文件中的代码用于初始化MTB缓冲区。 如果定义了__MTB_DISABLE，则不会创建MTB缓冲区。 如果没有定义__MTB_BUFFER_SIZE，则会提供一个小的默认缓冲区。 如果定义了__MTB_RAM_BANK，则会将MTB缓冲区放置在指定的RAM bank中。 如果没有定义__MTB_RAM_BANK，则会将MTB缓冲区放置在默认的RAM bank中。 如果__MTB_BUFFER_SIZE大于0，则会引入cr_mtb_buffer.h头文件，并将MTB缓冲区放置在RAM bank中。 semihost_hardfault.c 这个文件是提供硬故障处理程序的，以允许半主机代码在调试器未连接时不挂起应用程序。 在应用程序中包含半主机操作（例如printf调用）的应用程序的一个问题是，当调试器未连接时，代码将无法正确执行。通常，这将显示为应用程序似乎只是挂起。这可能包括从复位运行应用程序或启动板子（已经在FLASH中存在应用程序），以及在调试会话终止后应用程序无法继续执行。 总结点灯的流程 BOARD_InitPins(); 里面有Port的时钟使能，CLOCK_EnableClock(kCLOCK_PortA); 引脚复用 PORT_SetPinMux(BOARD_INITPINS_myGreen_PORT, BOARD_INITPINS_myGreen_PIN, kPORT_MuxAsGpio); BOARD_BootClockRUN(); 板子时钟RUN模式使能 BOARD_InitDebugConsole(); 板子console debug初始化 GPIO_PinInit(BOARD_LED_GPIO0, BOARD_LED_GPIO_PIN0, &amp;led_config); GPIO引脚初始化； GPIO_PortToggle(BOARD_LED_GPIO0, 1u &lt;&lt; BOARD_LED_GPIO_PIN0); GPIO端口高低电平切换","link":"/NXP/KW38/kw38%E7%82%B9%E7%81%AF%E5%A4%A7%E5%B8%88/"},{"title":"kw38点灯大师2_GPIO中断","text":"kw38点灯大师2_GPIO中断 frdmkw38_gpio_led_output 工程 frdmkw38_gpio_input_interrupt 工程 主函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273int main(void){ /* Define the init structure for the output LED pin*/ gpio_pin_config_t led_config = { kGPIO_DigitalOutput, 0, }; /* Define the init structure for the input switch pin */ gpio_pin_config_t sw_config = { kGPIO_DigitalInput, 0, }; /* Board pin, clock, debug console init */ BOARD_InitPins(); BOARD_BootClockRUN(); BOARD_InitDebugConsole(); /* Print a note to terminal. */ PRINTF(\"\\r\\n GPIO Driver example\\r\\n\"); PRINTF(\"\\r\\n The LED is blinking.\\r\\n\"); PRINTF(\"\\r\\n 按压开关 %s 来开关和切换LED.\\r\\n\", BOARD_SW_NAME);/* Init input switch GPIO. */#if (defined(FSL_FEATURE_PORT_HAS_NO_INTERRUPT) &amp;&amp; FSL_FEATURE_PORT_HAS_NO_INTERRUPT) GPIO_SetPinInterruptConfig(BOARD_SW2_GPIO, BOARD_SW2_GPIO_PIN, kGPIO_InterruptFallingEdge);#else PORT_SetPinInterruptConfig(BOARD_SW2_PORT, BOARD_SW2_GPIO_PIN, kPORT_InterruptFallingEdge);#endif EnableIRQ(BOARD_SW2_IRQ); GPIO_PinInit(BOARD_SW2_GPIO, BOARD_SW2_GPIO_PIN, &amp;sw_config); /* Init output LED GPIO. */ GPIO_PinInit(BOARD_LED_GPIO0, BOARD_LED_GPIO_PIN0, &amp;led_config); GPIO_PinInit(BOARD_LED_GPIO1, BOARD_LED_GPIO_PIN1, &amp;led_config); GPIO_PinInit(BOARD_LED_GPIO2, BOARD_LED_GPIO_PIN2, &amp;led_config); uint32_t temp = 0; while (1) { if (g_ButtonPress) { temp ++; PRINTF(\" %s is pressed, it is time: %d \\r\\n\", BOARD_SW_NAME, temp); switch(temp%3) { case 0: PRINTF(\" case 0, BLUE LED ON\"); LED_RED_OFF(); LED_GREEN_OFF(); LED_BLUE_ON(); break; case 1: PRINTF(\" case 1, GREEN LED ON\"); LED_RED_OFF(); LED_GREEN_ON(); LED_BLUE_OFF(); break; case 2: PRINTF(\" case 2, RED LED ON\"); LED_RED_ON(); LED_GREEN_OFF(); LED_BLUE_OFF(); break; }// /* Toggle LED. */// GPIO_PortToggle(BOARD_LED_GPIO, 1U &lt;&lt; BOARD_LED_GPIO_PIN);// /* Reset state of button. */ g_ButtonPress = false; } }} 中断处理函数123456789101112void BOARD_SW2_IRQ_HANDLER(){ /* Clear external interrupt flag. */ GPIO_PortClearInterruptFlags(BOARD_SW2_GPIO, 1U &lt;&lt; BOARD_SW2_GPIO_PIN); /* Change state of button. */ g_ButtonPress = true;/* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping exception return operation might vector to incorrect interrupt */#if defined __CORTEX_M &amp;&amp; (__CORTEX_M == 4U) __DSB();#endif} 预定义12345678910#define BOARD_LED_GPIO0 BOARD_LED_RED_GPIO#define BOARD_LED_GPIO_PIN0 BOARD_LED_RED_GPIO_PIN#define BOARD_LED_GPIO1 BOARD_LED_GREEN_GPIO#define BOARD_LED_GPIO_PIN1 BOARD_LED_GREEN_GPIO_PIN#define BOARD_LED_GPIO2 BOARD_LED_BLUE_GPIO#define BOARD_LED_GPIO_PIN2 BOARD_LED_BLUE_GPIO_PIN#define BOARD_SW_NAME BOARD_SW2_NAME 总结GPIO中断的流程 变量flag volatile bool g_ButtonPress = false; 指示是否按下开关 中断处理函数 void BOARD_SW2_IRQ_HANDLER() 先清空外部中断，GPIO_PortClearInterruptFlags(BOARD_SW2_GPIO, 1U &lt;&lt; BOARD_SW2_GPIO_PIN); 再对flag置一，表示中断已经发生； 之后，它会进入到main的while循环里面的if(g_ButtonPress); main函数里面初始化板子之后，要初始化SW的GPIO； 中断config设置 GPIO_SetPinInterruptConfig(BOARD_SW2_GPIO, BOARD_SW2_GPIO_PIN, kGPIO_InterruptFallingEdge);; GPIO_PinInit GPIO_PinInit(BOARD_SW2_GPIO, BOARD_SW2_GPIO_PIN, &amp;sw_config); 然后 EnableIRQ(BOARD_SW2_IRQ);","link":"/NXP/KW38/GPIO%E4%B8%AD%E6%96%AD/kw38%E7%82%B9%E7%81%AF%E5%A4%A7%E5%B8%882-gpio%E4%B8%AD%E6%96%AD/"},{"title":"pyTorch学习","text":"一、 MLP 模型的实现 数据 sigmoid.csv, 前几列是特征值，最后一列是lable； 通过建立自己的数据集跑出结果； A B…H I -0.882353 … 0 -0.882353 … 1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import torch import numpy as npfrom torch.utils.data import Datasetfrom torch.utils.data import DataLoader### 自己实现Dataset类去加载本地的CSV数据 ###### 需要三个函数： init get_item lenclass MyDataset(Dataset): def __init__(self, filepath): xy = np.loadtxt(filepath, delimiter=\",\", dtype=np.float32) self.len = xy.shape[0] # 行数 self.x_data = torch.from_numpy(xy[:, :-1]) #所有的行，不包括最后一列的其他列 self.y_data = torch.from_numpy(xy[:, [-1]]) #所有的行，最后一列 def __getitem__(self, index): return self.x_data[index], self.y_data[index] def __len__(self): return self.lendataset = MyDataset('./sigmoid.csv')train_loader = DataLoader(dataset=dataset, batch_size=32, shuffle=True)class Model(torch.nn.Module): def __init__(self): super(Model, self).__init__() self.linear1 = torch.nn.Linear(8, 6) self.linear2 = torch.nn.Linear(6, 4) self.linear3 = torch.nn.Linear(4, 1) self.sigmoid = torch.nn.Sigmoid() def forward(self, x): x = self.sigmoid(self.linear1(x)) x = self.sigmoid(self.linear2(x)) x = self.sigmoid(self.linear3(x)) return xmodel = Model()### 建立 损失函数 和 优化器criterion = torch.nn.BCELoss(reduction='mean')optimizer = torch.optim.SGD(model.parameters(), lr=0.01)for epoch in range(100): for i, data in enumerate(train_loader): inputs, labels = data y_pred = model(inputs) loss = criterion(y_pred, labels) print(epoch, i, loss.item()) optimizer.zero_grad() loss.bachward() 二、CNN模型 mnist数据集，只有20个，用来举例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139import osimport pandas as pdimport numpy as npfrom PIL import Imageimport torchfrom torch.utils.data import Datasetfrom torchvision import transformsimport torch.nn as nnclass MnistDataset(Dataset): def __init__(self, image_path, image_label, transform=None): super(MnistDataset, self).__init__() self.image_path = image_path # 初始化图像路径列表 self.image_label = image_label # 初始化图像标签列表 self.transform = transform # 初始化数据增强方法 def __getitem__(self, index): \"\"\" 获取对应index的图像，并视情况进行数据增强 \"\"\" image = Image.open(self.image_path[index]) image = np.array(image) label = int(self.image_label[index]) if self.transform is not None: image = self.transform(image) return image, torch.tensor(label) def __len__(self): return len(self.image_path)def get_path_label(img_root, label_file_path): \"\"\" 获取数字图像的路径和标签并返回对应列表 @para: img_root: 保存图像的根目录 @para:label_file_path: 保存图像标签数据的文件路径 .csv 或 .txt 分隔符为',' @return: 图像的路径列表和对应标签列表 \"\"\" data = pd.read_csv(label_file_path, names=[\"img\", \"label\"]) data[\"img\"] = data[\"img\"].apply(lambda x: img_root + x) return data[\"img\"].tolist(), data[\"label\"].tolist()# 获取训练集路径列表和标签列表dir_path = os.path.dirname(__file__)train_data_root = dir_path + \"/mnist_data/train/\"train_label = dir_path + \"/mnist_data/train.txt\"train_img_list, train_label_list = get_path_label(train_data_root, train_label)# 训练集datasettrain_dataset = MnistDataset( train_img_list, train_label_list, transform=transforms.Compose([transforms.ToTensor()]),)# 获取测试集路径列表和标签列表test_data_root = dir_path + \"/mnist_data/test/\"test_label = dir_path + \"/mnist_data/test.txt\"test_img_list, test_label_list = get_path_label(test_data_root, test_label)# 测试集sdatasettest_dataset = MnistDataset( test_img_list, test_label_list, transform=transforms.Compose([transforms.ToTensor()]),)num_epochs = 5num_classes = 10batch_size = 10learning_rate = 0.001train_loader = torch.utils.data.DataLoader( dataset=train_dataset, batch_size=batch_size, shuffle=True)test_loader = torch.utils.data.DataLoader( dataset=test_dataset, batch_size=batch_size, shuffle=False)class ConvNet(nn.Module): def __init__(self, num_classes=10): super(ConvNet, self).__init__() ## 池化+batchnorm+relu激活+池化 self.layer1 = nn.Sequential( nn.Conv2d(1, 16, kernel_size=5, stride=1, padding=2), nn.BatchNorm2d(16), nn.ReLU(), nn.MaxPool2d(kernel_size=2, stride=2), ) self.layer2 = nn.Sequential( nn.Conv2d(16, 32, kernel_size=5, stride=1, padding=2), nn.BatchNorm2d(32), nn.ReLU(), nn.MaxPool2d(kernel_size=2, stride=2), ) self.fc = nn.Linear(7 * 7 * 32, num_classes) ## 全链接 def forward(self, x): out = self.layer1(x) out = self.layer2(out) out = out.reshape(out.size(0), -1) out = self.fc(out) return outmodel = ConvNet(num_classes)# Loss and optimizercriterion = nn.CrossEntropyLoss()optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)# Train the modeltotal_step = len(train_loader)for epoch in range(num_epochs): for i, (images, labels) in enumerate(train_loader): images = images labels = labels # Forward pass outputs = model(images) loss = criterion(outputs, labels) # Backward and optimize optimizer.zero_grad() loss.backward() optimizer.step() # if (i + 1) % 2 == 0: print( \"Epoch [{}/{}], Step [{}/{}], Loss: {:.4f}\".format( epoch + 1, num_epochs, i + 1, total_step, loss.item() ) ) 三、 RNN","link":"/NLP/PyTorch/pytorch%E5%AD%A6%E4%B9%A0/"},{"title":"代码解读之GPIO_Adapter","text":"读fsl_adapter_gpio.c 和 .h 代码1. fsl_adapter_gpio.c这个代码是一个包含头文件并定义与MCU中的GPIO（通用输入/输出）功能相关的一些宏的 C 源文件。它是为 NXP 公司制造的特定MCU编写的。 该文件包含以下头文件： fsl_device_registers.h：包含设备特定的寄存器定义。 fsl_gpio.h：提供用于GPIO操作的API函数。 fsl_port.h：提供用于PORT（端口控制和中断）操作的API函数。 fsl_adapter_gpio.h：提供用于GPIO操作的适配器功能。 该文件还定义了一个组件ID，tools使用它。 该代码定义了两个宏： HAL_GPIO_CLZ(x)：计算32位数字x中前导零的数量，该数量用于确定GPIO引脚的bit位置。此宏的实现取决于用于编译代码的工具链。 HAL_GPIO_BSR(x)：根据GPIO引脚掩码的值计算GPIO引脚的bit位置。此宏使用 HAL_GPIO_CLZ(x) 宏计算掩码中前导零的数量，然后从31中减去结果（因为GPIO引脚编号是从LSB到MSB进行计数）。 1.1 结构体hal_gpio_pin_t 和 hal_gpio_state_t这些结构体定义了单片机中GPIO引脚的引脚配置和状态。 hal_gpio_pin_t结构体用于配置GPIO引脚的属性，具有以下字段： port：一个整数值（0-7），指定引脚的PORT编号。 reserved：值为0的位域，用于填充。 pin：一个整数值（0-31），指定指定PORT内的引脚编号。 direction：一个整数值（0或1），指定引脚的方向（输入或输出）。 trigger：一个整数值（0-7），指定在引脚上启用中断时的触发条件。 reserved2：值为0的位域，用于填充。 hal_gpio_state_t结构体用于存储GPIO引脚的状态，具有以下字段： next：指向链表中下一个元素的指针。 callback：指向回调函数的函数指针，当引脚上的中断被触发时将执行该函数。 callbackParam：指向将传递给回调函数的数据的指针。 direction：一个整数值（0或1），指定引脚的方向（输入或输出）。 level：一个整数值（0或1），指定引脚的当前逻辑电平。 port：一个整数值（0-7），指定引脚的PORT编号。 pin：一个整数值（0-31），指定指定PORT内的引脚编号。 trigger：一个整数值（0-7），指定在引脚上启用中断时的触发条件。 1.2 静态变量 static GPIO_Type *const s_GpioPort[] 和 static hal_gpio_state_t *s_GpioHead;这个部分定义了函数的原型，这些函数将在源文件中使用，但在这种情况下没有原型。 该部分还定义了一些静态变量： s_GpioPort：指向GPIO_Type结构体指针的数组。每个指针对应微控制器中的一个GPIO端口。 s_GpioHead：指向hal_gpio_state_t结构体链表的头部的指针。此链表用于跟踪MCU中所有GPIO引脚的状态。 1.3 函数 static void HAL_GpioInterruptHandle(uint8_t port)这段代码片段是一个GPIO（通用输入/输出）驱动程序的C实现。代码定义了两个数据结构，hal_gpio_pin_t和hal_gpio_state_t，它们分别包含有关引脚配置和状态的信息。代码还定义了几个函数来处理中断和添加/删除GPIO状态节点的链接列表。 HAL_GpioInterruptHandle函数：==通过迭代GPIO状态节点的链表并检查指定port上的任何pin是否触发了中断来处理GPIO中断。如果引脚发生中断，则该函数执行与该引脚相关联的回调函数==。 HAL_GpioConflictSearch函数：搜索GPIO状态节点的链表，**以检查引脚是否与已注册的引脚冲突**。仅当定义了HAL_GPIO_CONFLICT_CHECK_ENABLE宏并将其设置为大于零的值时，才使用此函数。 HAL_GpioAddItem函数：将新的GPIO状态节点添加到链接列表中。该函数首先检查新节点是否与已注册的引脚发生冲突，然后再将其添加到列表中。 HAL_GpioRemoveItem函数：从链接列表中删除GPIO状态节点。该函数通过遍历列表以查找指定的节点并将其删除。 总的来说，这段代码片段提供了GPIO驱动程序的基本实现，可用于配置和控制微控制器上的GPIO引脚。 这是HAL_GpioInterruptHandle函数的函数实现，该函数==负责处理GPIO中断==。 该函数接受一个参数port，该参数是发生中断的端口号。该函数首先遍历GPIO引脚状态结构的链表，以找到与端口号相对应的结构。如果找不到一个合适的结构，则函数将简单地返回。 接下来，该函数使用GPIO_GpioGetInterruptFlags或GPIO_PortGetInterruptFlags函数**检索在指定端口上发生的引脚中断的集合，具体取决于芯片是否具有每个引脚的个别GPIO中断标志。然后，该函数清除引发中断的引脚的中断标志**。 然后，该函数再次遍历GPIO引脚状态结构的链表，这次检查每个结构以查看它是否对应于触发中断的引脚之一。如果找到匹配项，则函数调用与引脚关联的回调函数来处理中断。 最后，该函数通过清除刚刚处理的引脚的中断标志来更新触发中断的引脚中断集。如果没有更多的中断需要处理，该函数将返回。 1.4 函数 static hal_gpio_status_t HAL_GpioConflictSearch(hal_gpio_state_t *head, uint8_t port, uint8_t pin)这段代码定义了一个函数HAL_GpioConflictSearch，它通过遍历hal_gpio_state_t结构体的链表来**查找指定的端口和引脚与链表中现有的端口和引脚是否有冲突**。 该函数需要链表的头部（head）、端口号（port）和引脚号（pin）作为输入。 然后，它使用while循环遍历链表，检查是否有hal_gpio_state_t结构体的端口和引脚与输入的相同。 如果找到匹配的hal_gpio_state_t结构体，则该函数返回kStatus_HAL_GpioPinConflict，表示存在冲突。如果没有找到匹配的结构体，则函数返回kStatus_HAL_GpioSuccess，表示不存在冲突。 当预处理宏HAL_GPIO_CONFLICT_CHECK_ENABLE被定义且其值大于零时，才会编译此函数。 预处理指令，用于检查宏HAL_GPIO_CONFLICT_CHECK_ENABLE是否被定义，并且其值大于0。 如果该宏被定义并且其值大于0，那么#if和#endif语句中的代码将会被编译，否则将被跳过。 1.5 函数 static hal_gpio_status_t HAL_GpioAddItem(hal_gpio_state_t **head, hal_gpio_state_t *node)这个函数**将一个新的 GPIO 引脚添加到 GPIO 引脚的链表中**。它把链表头的指针和要添加的新 GPIO 引脚的指针作为输入参数。 该函数首先禁用全局中断，然后检查链表是否为空。 如果它是空的，新的 GPIO 引脚将添加为链表的第一个元素。 否则，函数通过搜索链表来检查新的 GPIO 引脚是否与任何现有 GPIO 引脚冲突。 如果找到冲突，函数会重新启用全局中断并返回指示 GPIO 引脚冲突的错误状态。 如果没有发现冲突，则在链接列表的末尾添加新的 GPIO 引脚，并返回成功状态。 最后，在返回之前，该函数启用全局中断。 1.6 函数 static hal_gpio_status_t HAL_GpioRemoveItem(hal_gpio_state_t **head, hal_gpio_state_t *node)此函数从 GPIO 引脚的链表中移除一个节点。它以列表的头**head和要移除的节点 *node作为输入，二者都是指向 hal_gpio_state_t 结构的指针。 该函数通过使用 DisableGlobalIRQ() 函数禁用中断并将 PRIMASK 寄存器的值存储在 regPrimask 中来启动。然后它使用 while 循环遍历列表，查找要删除的节点。一旦找到，它会更新指针以从列表中删除节点。如果要移除的节点是列表的头，则会更新 *head。 最后，该函数使用 EnableGlobalIRQ(regPrimask) 启用中断，并返回 kStatus_HAL_GpioSuccess。 1.7 GPIOX_INT1_IRQHandler() 和 GPIOX_INT0_IRQHandler()这些是设备上每个GPIO端口的中断处理程序函数。 它们是为了没有专门为每个GPIO端口提供中断处理程序的平台而实现的，这由 FSL_FEATURE_PORT_HAS_NO_INTERRUPT 宏指示。 对于每个GPIO端口，定义了两个中断处理程序，GPIOX_INT0_IRQHandler()和GPIOX_INT1_IRQHandler()。 GPIOX_INT0_IRQHandler()函数是端口的实际中断处理程序，并调用HAL_GpioInterruptHandle()函数来处理中断。 GPIOX_INT1_IRQHandler()函数是中断优先级配置的占位符，它只调用GPIOX_INT0_IRQHandler()函数。 SDK_ISR_EXIT_BARRIER宏用于在退出中断处理程序之前添加障碍，以确保在从中断返回之前完成所有存储器访问。 1.8 PORTX_IRQHandler()这是一系列针对 GPIO 端口的中断处理函数。 根据所使用的特定微控制器，这些功能将以前缀 GPIO 或 PORT 命名。 如果微控制器具有 GPIO 的“无中断”FSL_FEATURE_PORT_HAS_NO_INTERRUPT功能，则中断处理程序将使用 GPIO 前缀并具有类似 GPIOA_INT0_IRQHandler() 的名称。否则，中断处理程序将使用 PORT 前缀并具有类似于 PORTA_IRQHandler() 的名称。 每个中断处理函数负责处理特定 GPIO 端口的中断。例如，GPIOA_INT0_IRQHandler() 处理端口 A、引脚 0 的中断。 在每个中断处理函数中，HAL_GpioInterruptHandle() 以端口号作为参数被调用。此函数负责查找触发中断的引脚并调用任何已注册的回调。 **==SDK_ISR_EXIT_BARRIER 宏用于标记中断处理函数的结束。这是一种防止编译器在从中断返回后生成代码的方法，这可能会导致系统堆栈或中断处理出现问题==**。 1.9 函数 void HAL_GpioPreInit(void)函数 HAL_GpioPreInit() 将全局指针 s_GpioHead 初始化为 NULL，用作包含每个已配置 GPIO 引脚的 GPIO 状态信息的链表的头部。 此函数通常在 GPIO 驱动程序初始化期间调用，**在添加或配置任何 GPIO 引脚之前**。 1.10 函数 hal_gpio_status_t HAL_GpioInit(hal_gpio_handle_t gpioHandle, hal_gpio_pin_config_t *pinConfig)**这是用提供的配置，初始化GPIO引脚的功能实现**。 该函数使用gpioHandle参数表示GPIO引脚的句柄和使用pinConfig参数表示引脚的配置的指针。 该函数首先断言gpioHandle和pinConfig参数不为null，并且gpioHandle参数的大小至少与hal_gpio_state_t结构的大小一样。然后将gpioHandle参数转换为指向hal_gpio_state_t结构的指针gpioState，该结构包含有关GPIO引脚状态的信息。 如果启用冲突检查HAL_GPIO_CONFLICT_CHECK_ENABLE，则该函数搜索GPIO引脚的链表，以确保指定端口和引脚没有冲突。如果发现冲突，则该函数返回kStatus_HAL_GpioPinConflict。 然后，该函数使用HAL_GpioAddItem函数将GPIO引脚添加到GPIO引脚的链表中，并使用GPIO_PinInit函数设置GPIO方向和其他配置选项。 最后，如果初始化成功，该函数返回kStatus_HAL_GpioSuccess。 1.11 函数 hal_gpio_status_t HAL_GpioDeinit(hal_gpio_handle_t gpioHandle)此函数负责**==取消初始化 GPIO 引脚==**。 它接收 GPIO 引脚的句柄，该句柄是在使用 HAL_GpioInit 函数初始化引脚时获得的。 首先，该函数使用断言检查输入 gpioHandle 是否不为 NULL。 接下来，它使用 gpioHandle 获取指向 GPIO 状态结构的指针。 然后，如果 GPIO 引脚配置为输入引脚，则该函数通过使用 kHAL_GpioInterruptDisable 参数调用 HAL_GpioSetTriggerMode 来**==禁用其中断触发模式==**。 最后，函数使用HAL_GpioRemoveItem函数从链表s_GpioHead中移除GPIO管脚状态，返回kStatus_HAL_GpioSuccess表示操作成功。 1.12 函数 hal_gpio_status_t HAL_GpioGetInput(hal_gpio_handle_t gpioHandle, uint8_t *pinState)**==此函数获取配置为输入的 GPIO 引脚的当前状态==**。 它需要一个 GPIO 引脚的句柄（表示为 hal_gpio_handle_t 类型）和一个指向变量的指针来存储引脚状态。 在函数内部，它首先断言 gpioHandle 和 pinState 参数不为 NULL。**==然后它将 gpioHandle 转换为 hal_gpio_state_t 类型并使用 GPIO_PinRead 函数读取引脚状态。 GPIO_PinRead函数返回一个uint32_t类型，转换为uint8_t类型存储在pinState变量中。==**最后函数返回kStatus_HAL_GpioSuccess表示操作成功。 1.13 函数 hal_gpio_status_t HAL_GpioSetOutput(hal_gpio_handle_t gpioHandle, uint8_t pinState)**此函数设置 GPIO 引脚的输出状态**。 它将要配置的 GPIO 引脚的句柄和指定要设置的输出状态（高电平或低电平）的值作为输入。 该函数首先检查 GPIO 句柄是否为 NULL。然后它将句柄转换为 hal_gpio_state_t 指针并使用它来获取 GPIO 端口和引脚号。 最后，它使用 GPIO_PinWrite 函数设置 GPIO 引脚的输出状态，**该函数将 GPIO 端口、引脚号和输出值作为输入**。 该函数返回一个状态代码以指示操作是否成功。 1.14 函数 hal_gpio_status_t HAL_GpioInstallCallback(hal_gpio_handle_t gpioHandle， hal_gpio_callback_t callback, void *callbackParam)**==此函数将回调函数及其关联参数安装到给定句柄指定的 GPIO 引脚==**。 该函数接受三个参数： gpioHandle：将要安装其回调函数的 GPIO 引脚的句柄。 callback：指向将要安装的回调函数的函数指针。 callbackParam：指向将要传递给回调函数的参数的空指针。 该函数首先断言 gpioHandle 不为 NULL。然后它将句柄转换为 hal_gpio_state_t 指针，**并将 hal_gpio_state_t 结构的 callbackParam 和 callback 字段分别设置为 callbackParam 和 callback 的值。** 最后，该函数返回 kStatus_HAL_GpioSuccess。 安装回调函数后，当在 GPIO 引脚上触发中断时，GPIO 驱动程序可以调用它。 GPIO 驱动在回调函数被调用时会将 callbackParam 参数传给回调函数。 应用程序可以使用此参数将上下文信息传递给回调函数。 1.15 函数 hal_gpio_status_t HAL_GpioGetTriggerMode(hal_gpio_handle_t gpioHandle, hal_gpio_interrupt_trigger_t *gpioTrigger)**==该函数用于获取某个GPIO引脚的中断触发方式==**。 该函数有两个参数：gpioHandle 和 gpioTrigger。 gpioHandle是GPIO引脚的句柄，用于标识GPIO引脚。 gpioTrigger 是一个指向 hal_gpio_interrupt_trigger_t 类型变量的指针，将用于返回 GPIO 引脚的中断触发模式。 该函数首先检查 gpioHandle 参数是否有效。然后它将 gpioHandle 参数转换为指向 hal_gpio_state_t 结构的指针，该结构是 GPIO 驱动程序的内部状态结构。 **==然后该函数检查 GPIO 引脚是否配置为输入引脚，如果不是，则返回错误==**。 最后，**==该函数从 hal_gpio_state_t 结构中获取 GPIO 引脚的中断触发模式，并将其存储在 gpioTrigger 参数中==**。 如果函数成功完成，它会返回 kStatus_HAL_GpioSuccess。 1.16 函数 hal_gpio_status_t HAL_GpioSetTriggerMode(hal_gpio_handle_t gpioHandle, hal_gpio_interrupt_trigger_t gpioTrigger)此函数设置 GPIO 引脚的中断触发模式。 它接受 GPIO 引脚的句柄，以及所需的中断触发模式。 该函数首先检查引脚的方向是否未设置为输出，**因为中断触发只能用于输入引脚**。 然后它将给定的触发模式映射到硬件平台的相应中断配置值。**它设置 GPIO 引脚的触发模式，并在 NVIC（嵌套向量中断控制器）中启用相应的中断**，优先级为 HAL_GPIO_ISR_PRIORITY（可能在代码库的其他地方定义）。 最后，它返回一个状态代码，指示操作是成功还是遇到错误。 1.17 函数 hal_gpio_status_t HAL_GpioWakeUpSetting(hal_gpio_handle_t gpioHandle, uint8_t enable)==该函数是 GPIO 驱动程序的一部分，用于启用/禁用 GPIO 引脚的唤醒功能。== 当设备处于低功耗模式时，如果特定 GPIO 引脚上的唤醒功能已启用，则它可以被该引脚上的信号唤醒。 该函数有两个参数，一个 GPIO 句柄和一个启用标志。 GPIO 句柄用于标识要配置的特定 GPIO 引脚，而启用标志用于指定是启用还是禁用唤醒功能。 该函数首先断言 GPIO 句柄不为 NULL。 **然后检查GPIO引脚方向是否输出。如果输出方向，则返回错误**。 然后它检查启用标志是否为 0，这意味着禁用唤醒功能。如果启用标志为 0，则返回错误。否则，它返回成功。 总的来说，该函数用于配置GPIO引脚的唤醒功能，确保输入参数有效。 1.18 函数 hal_gpio_status_t HAL_GpioEnterLowpower(hal_gpio_handle_t gpioHandle)HAL_GpioEnterLowpower 的实现似乎是一个placeholder占位符函数，它返回kStatus_HAL_GpioSuccess而不执行任何实际操作。 ==此函数很可能旨在由 HAL 库的用户实现，以提供特定于其应用程序的低功耗功能。== 1.19 函数 hal_gpio_status_t HAL_GpioExitLowpower(hal_gpio_handle_t gpioHandle)**==此函数负责在退出低功耗模式后将 GPIO 引脚恢复为之前的配置==**。 它以一个 GPIO 句柄作为输入并返回一个状态代码，指示操作是否成功。 该函数首先断言 GPIO 句柄有效。 然后它从句柄中检索 GPIO 状态，并使用引脚方向（输入或输出）和默认值 0 初始化一个新的 GPIO 引脚配置对象。 如果之前将引脚配置为输出，则新配置对象中的引脚方向将设置为输出。 然后，该函数使用 GPIO_PinInit 函数使用新配置初始化 GPIO 引脚。 如果该引脚之前被配置为输入，则该函数调用 HAL_GpioSetTriggerMode 函数来**恢复进入低功耗模式之前设置的中断触发模式**。 最后，函数返回一个状态码，表示操作成功。 2. fsl_adapter_gpio.h2.1. 引言这是用于 GPIO（通用输入/输出）接口的 HAL（硬件抽象层）头文件的开头。它从许可证和标题保护开始。 header包括 fsl_common.h，它是在不同 SDK（软件开发工具包）组件之间共享的通用实用函数、结构和宏的集合。 此外，如果定义了 SDK_OS_FREE_RTOS，它会包含 FreeRTOS.h，这是 FreeRTOS 操作系统的头文件。 header guard 定义为 HAL_GPIO_H 以防止多次包含同一头文件。 头文件为 GPIO 适配器提供定义和结构，它是位于供应商 (NXP) 提供的低级 GPIO 驱动程序之上的抽象层。 该文件提供了以下定义： GPIO适配器版本 GPIO 冲突检查使能 GPIO适配器句柄大小 GPIO句柄定义宏 GPIO 适配器 ISR 优先级 GPIO 句柄类型 (hal_gpio_handle_t) GPIO回调函数类型(hal_gpio_callback_t) GPIO 中断触发类型 (hal_gpio_interrupt_trigger_t) GPIO 状态代码 (hal_gpio_status_t) GPIO 方向类型 (hal_gpio_direction_t) GPIO 引脚配置结构 (hal_gpio_pin_config_t) 这个头文件定义了 GPIO 适配器，它是一个抽象 GPIO 接口的硬件特定细节的驱动程序。驱动程序提供 API 来配置和控制设备的 GPIO 引脚，例如**设置引脚的方向、读取或写入其值以及在引脚上启用中断**。 该文件以一些标准 C 语言定义开头，包括 GPIO 适配器句柄、回调函数、中断触发器、状态和方向的类型定义。这些类型在整个 GPIO 适配器驱动程序 API 中使用，以提供清晰一致的接口。 该文件还定义了一些宏，包括 GPIO 适配器驱动程序的版本号、GPIO 适配器句柄的大小以及启用或禁用 GPIO 冲突检查的标志。 最后，该文件包括 fsl_common.h 头文件，它提供了在 Freescale/NXP SDK 软件中使用的通用宏和定义，以及 FreeRTOS.h 头文件，它为正在使用的 FreeRTOS 操作系统提供 API。 这是 GPIO（通用输入/输出）适配器的头文件，用于配置和控制MCU上的 GPIO 引脚。 该文件定义了几种类型，包括 hal_gpio_handle_t、hal_gpio_callback_t、hal_gpio_interrupt_trigger_t、hal_gpio_status_t、hal_gpio_direction_t 和 hal_gpio_pin_config_t。 hal_gpio_handle_t是指向GPIO适配器句柄的指针， hal_gpio_callback_t是用于回调的函数指针， hal_gpio_interrupt_trigger_t定义了中断触发器， hal_gpio_status_t定义了GPIO适配器的状态， hal_gpio_direction_t定义了GPIO引脚的方向， hal_gpio_pin_config_t是一个保存配置的结构GPIO 引脚的设置。 头文件还包含宏，例如 FSL_GPIO_ADAPTER_VERSION 指示驱动程序的版本，HAL_GPIO_CONFLICT_CHECK_ENABLE 启用/禁用 GPIO 冲突检查，以及 HAL_GPIO_HANDLE_SIZE 定义 GPIO 适配器句柄的大小。 此外，头文件定义了一个宏 GPIO_HANDLE_DEFINE 来定义一个 4 字节对齐的 GPIO 句柄 和一个宏 HAL_GPIO_ISR_PRIORITY 来定义 GPIO ISR（中断服务程序）的优先级。 2.2 预先初始化引脚 void HAL_GpioPreInit(void)此函数初始化位于内存的 .bss 部分中的静态变量。这通常由 IDE 自动完成，但如果在自动清理 .bss 部分之前使用 GPIO 适配器，则可以使用此功能。 用户通常不需要调用此 API。代码注释中提供了一个示例来演示如何使用它。 首先，调用 HAL_GpioPreInit() 函数， 然后使用 GPIO_HANDLE_DEFINE 宏定义 GPIO 句柄。 然后，使用所需的 GPIO 引脚配置定义并初始化 hal_gpio_pin_config_t 结构。 最后，调用 HAL_GpioInit() 函数以使用先前定义的 GPIO 句柄以指定配置初始化 GPIO 引脚。 12345678HAL_GpioPreInit();GPIO_HANDLE_DEFINE(g_GpioHandle);hal_gpio_pin_config_t config; config.direction = kHAL_GpioDirectionOut; config.port = 0; config.pin = 0; config.level = 0;HAL_GpioInit((hal_gpio_handle_t)g_GpioHandle, &amp;config); 2.3 初始化 hal_gpio_status_t HAL_GpioInit(hal_gpio_handle_t gpioHandle, hal_gpio_pin_config_t *pinConfig);这是 GPIO（通用输入/输出）模块中的一个函数，它使用**==用户定义的设置初始化 GPIO 实例==**。该函数有两个参数： gpioHandle：指向调用者分配的大小为HAL_GPIO_HANDLE_SIZE的内存空间的指针。句柄应该是 4 字节对齐的。用户可以通过两种方式定义句柄： 使用 GPIO_HANDLE_DEFINE(gpioHandle) 或 uint32_t gpioHandle[((HAL_GPIO_HANDLE_SIZE + sizeof(uint32_t) - 1U) / sizeof(uint32_t))] pinConfig：指向 hal_gpio_pin_config_t 类型的用户定义配置结构的指针，**该结构保存 GPIO 的配置。该结构有四个字段**： direction：GPIO的方向，输出可以设置为kHAL_GpioDirectionOut，输入可以设置为kHAL_GpioDirectionIn。 port：GPIO 端口号。 pin：GPIO 引脚号。 level：**GPIO的初始值，可设置为0或1**。 该函数返回以下状态代码之一： kStatus_HAL_GpioError：初始化 GPIO 时发生错误。 kStatus_HAL_GpioPinConflict：pinConfig 传递的pin 和port 对已经初始化，所以conflict。 kStatus_HAL_GpioSuccess：GPIO 初始化成功。 1234567GPIO_HANDLE_DEFINE(g_GpioHandle);hal_gpio_pin_config_t config;config.direction = kHAL_GpioDirectionOut;config.port = 0;config.pin = 0;config.level = 0;HAL_GpioInit((hal_gpio_handle_t)g_GpioHandle, &amp;config); 2.4 取消初始化 HAL_GpioDeinit(hal_gpio_handle_t gpioHandle)HAL_GpioDeinit 函数用于取消初始化 GPIO 实例。**==它禁用触发模式==**。 1hal_gpio_status_t HAL_GpioDeinit(hal_gpio_handle_t gpioHandle); gpioHandle：GPIO句柄指针。句柄应该是 4 字节对齐的，因为某些设备不支持未对齐的访问。 如果 GPIO 去初始化成功，该函数返回 kStatus_HAL_GpioSuccess。 2.5 获取输入引脚状态 HAL_GpioGetInput()此函数用于获取输入 GPIO 引脚的当前状态。通过 pinState 指针参数读取并返回引脚状态。 这是一个示例用法： 1234GPIO_HANDLE_DEFINE(g_GpioHandle);uint8_t pinState;HAL_GpioInit((hal_gpio_handle_t)g_GpioHandle, &amp;config);HAL_GpioGetInput((hal_gpio_handle_t)g_GpioHandle, &amp;pinState); ==在此示例中，已使用 HAL_GpioInit() 初始化 GPIO 引脚，然后使用 HAL_GpioGetInput() 读取引脚的当前状态。引脚的当前状态通过 pinState 指针参数返回。== 2.6 设置输出电平HAL_GpioSetOutput这是 HAL_GpioSetOutput 函数的函数定义。此函数**==将 GPIO 引脚的电压电平设置为指定值==**。下面简单解释一下参数和返回值： gpioHandle：这是一个指向GPIO句柄对象的指针，表示设备上的一个特定的GPIO引脚。句柄应该是 4 字节对齐的，以确保正确的内存访问。 pinState：这是一个 8 位无符号整数，表示 GPIO 引脚的所需电压电平。值为 0 表示低电压电平，而值为 1 表示高电压电平。 返回值：该函数返回一个hal_gpio_status_t类型的值，代表操作成功或失败。如果操作成功，函数返回 kStatus_HAL_GpioSuccess。 2.7 获取Pin中断触发模式 HAL_GpioGetTriggerMode函数 HAL_GpioGetTriggerMode **==获取引脚中断触发模式==**。 触发模式由枚举类型hal_gpio_interrupt_trigger_t表示，可以是以下值之一: kHAL_GpioInterruptTriggerLowLevel：低电平触发中断 kHAL_GpioInterruptTriggerHighLevel：高电平触发中断 kHAL_GpioInterruptTriggerRisingEdge：上升沿触发中断 kHAL_GpioInterruptTriggerFallingEdge：下降沿触发中断 kHAL_GpioInterruptTriggerEitherEdge：在任一边沿触发中断 **==如果引脚配置为输出，函数返回 kStatus_HAL_GpioError==**。 该函数有两个参数： gpioHandle：GPIO句柄指针。 gpioTrigger：保存管脚触发模式值的指针。 该函数返回以下状态代码之一： kStatus_HAL_GpioSuccess：引脚触发模式已成功检索。 kStatus_HAL_GpioError：引脚配置为输出。 2.8 设置触发模式 HAL_GpioSetTriggerModeHAL_Gpio* 函数是硬件抽象层 (HAL) 库的一部分，用于与微控制器上的 GPIO（通用输入/输出）引脚进行交互。 GPIO 引脚可用于多种用途，例如控制 LED 或读取按钮按下情况。 HAL_GpioPreInit() 函数用于初始化位于 .bss 部分的静态变量。该变量将用于存储 GPIO 引脚的配置信息。通常不需要此功能，仅在某些情况下使用，例如在 .bss 部分被 IDE 自动清理之前使用 GPIO 适配器时。 HAL_GpioInit() 函数使用 GPIO 句柄和用户配置结构初始化 GPIO 实例。用户可以配置配置结构来设置引脚方向（输入或输出）、端口号、引脚号和初始引脚电平。 gpioHandle参数是一个指向调用者分配的内存空间的指针，用于存储GPIO实例的信息。 HAL_GpioDeinit() 函数通过禁用触发模式来取消初始化 GPIO 实例。当不再需要 GPIO 引脚时，应调用此函数。 HAL_GpioGetInput() 函数获取输入 GPIO 引脚的电压电平。电压电平在 pinState 参数中返回。 HAL_GpioSetOutput() 函数设置输出 GPIO 引脚的电压电平。所需的电压电平在 pinState 参数中传递。 HAL_GpioGetTriggerMode() 函数获取 GPIO 引脚的中断触发模式。触发模式决定了是什么导致在引脚上产生中断，例如上升沿或下降沿。触发模式在 gpioTrigger 参数中返回。 HAL_GpioSetTriggerMode() 函数设置 GPIO 引脚的中断触发模式。所需的触发模式在 gpioTrigger 参数中传递。 2.9 HAL_GpioInstallCallback()该函数用于**为GPIO模块安装一个回调函数及其对应的参数**。 当引脚状态中断发生时，驱动会通过调用已安装的回调函数通知上层。 GPIO管脚状态可以通过回调函数内部调用函数HAL_GpioGetInput()获取。 该函数采用三个参数： gpioHandle：GPIO句柄指针。 callback：要安装的回调函数。 callbackParam：回调函数的参数。 该函数返回一个状态代码，指示回调是否已成功安装。如果成功，返回值为 kStatus_HAL_GpioSuccess。 2.10 HAL_GpioWakeUpSetting()HAL_GpioWakeUpSetting 函数**==启用或禁用 GPIO 唤醒功能==**。 此功能允许系统**通过 GPIO 引脚状态的变化从低功耗模式唤醒**。 该函数采用 gpioHandle 参数，该参数是指向 GPIO 句柄的指针。句柄应该是 4 字节对齐的，因为某些设备不支持未对齐的访问。 enable 参数是一个布尔值，指示是启用还是禁用唤醒功能。值 1 启用该功能，而值 0 禁用它。 该函数返回一个 hal_gpio_status_t 状态码，其中 kStatus_HAL_GpioSuccess 表示成功，kStatus_HAL_GpioError 表示发生错误。 2.11 HAL_GpioEnterLowpower()根据提供的函数定义，函数 HAL_GpioEnterLowpower() 用于准备进入低功耗。但是，函数定义中并未指定为低功耗准备所采取的确切步骤。该**==函数很可能会执行必要的步骤将 GPIO 模块置于低功耗状态==**，例如禁用未使用的引脚或将时钟频率设置为较低的值。 在定义此函数的 HAL 库的文档或源代码中可能会提供更多信息。 2.12 HAL_GpioExitLowpower()这两个函数 HAL_GpioEnterLowpower 和 HAL_GpioExitLowpower 似乎是用于管理低功耗的更大系统的一部分。 GPIO 模块用于控制系统的唤醒行为，这些函数可能分别用于准备 GPIO 模块进入低功耗模式和从低功耗模式恢复。 HAL_GpioEnterLowpower 可以执行诸如禁用 GPIO 中断、将 GPIO 引脚设置为低功耗状态或降低 GPIO 模块的时钟频率以节省电量等操作。 HAL_GpioExitLowpower 可能会执行 HAL_GpioEnterLowpower 的反向操作，例如恢复 GPIO 中断，将 GPIO 引脚恢复到之前的状态，或者提高 GPIO 模块的时钟频率以恢复正常操作。 总体而言，这些功能似乎是用于管理功耗和唤醒行为的更大系统的一部分，而不是独立的 GPIO 功能。","link":"/NXP/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8Bgpio-adapter/"},{"title":"kw38_helloworld","text":"kw38_helloworld1234567891011121314151617int main(void){ char ch; /* Init board hardware. */ BOARD_InitPins(); BOARD_BootClockRUN(); BOARD_InitDebugConsole(); PRINTF(\"hello world.\\r\\n\"); while (1) { ch = GETCHAR(); PUTCHAR(ch); }} main功能这段代码是一个简单的hello world程序，它的作用是在终端输出”hello world.”，并且可以接收终端输入的字符并将其输出。 在main函数中，首先调用了BOARD_InitPins()函数来初始化板子的引脚，然后调用了BOARD_BootClockRUN()函数来初始化时钟，最后调用了BOARD_InitDebugConsole()函数来初始化调试控制台。 接下来，使用PRINTF函数在终端输出”hello world.”，然后进入一个死循环，不断地接收终端输入的字符并将其输出，直到程序结束。 其中，GETCHAR函数用于接收终端输入的字符，PUTCHAR函数用于将字符输出到终端。 main的函数调用这段代码调用了三个函数，分别是BOARD_InitPins()、BOARD_BootClockRUN()和BOARD_InitDebugConsole()。 BOARD_InitPins()函数用于初始化板子的引脚， BOARD_BootClockRUN()函数用于初始化时钟， BOARD_InitDebugConsole()函数用于初始化调试控制台。 在这个程序中，这三个函数的作用是为了确保程序能够正常运行，因为程序需要使用板子的引脚、时钟和调试控制台。 main的包含头文件这段代码include了以下几个文件： fsl_device_registers.h：包含了芯片的寄存器定义，用于访问芯片的寄存器。 fsl_debug_console.h：包含了调试控制台的相关函数，用于在终端输出和输入字符。 board.h：包含了板子的相关函数和宏定义，用于初始化板子的引脚和时钟。 pin_mux.h：包含了引脚的配置信息，用于初始化板子的引脚。 stdbool.h：包含了bool类型的定义，用于定义布尔类型的变量。 clock_config.h：包含了时钟的配置信息，用于初始化时钟。 其中，fsl_device_registers.h、fsl_debug_console.h、board.h和pin_mux.h是MCUXpresso SDK提供的库文件，而stdbool.h和clock_config.h是标准C库文件。这些文件的作用是为了确保程序能够正常运行，因为程序需要使用芯片的寄存器、调试控制台、板子的引脚和时钟。 pin_mux.h这是一个头文件，用于使用 MCUXpresso 配置工具为微控制器配置引脚复用和电气特性。 它提供了一个函数来初始化微控制器使用的引脚，可以在启动期间调用。 该文件定义了用于配置引脚电气特性的宏常量 SOPT5_LPUART0ODE_0b0、SOPT5_LPUART0RXSRC_0b0 和 SOPT5_LPUART0TXSRC_0b00。 头文件由包含保护 (#ifndef _PIN_MUX_H_) 保护，确保它在编译单元中仅包含一次。 123#define SOPT5_LPUART0ODE_0b0 0x00u /*LPUART0开漏禁用*/#define SOPT5_LPUART0RXSRC_0b0 0x00u /*LPUART0接收数据源选择：LPUART_RX pin */#define SOPT5_LPUART0TXSRC_0b00 0x00u /*LPUART0发送数据源选择：LPUART_TX pin */ 声明了两个函数： void BOARD_InitPins(void); 配置引脚routing和可选引脚电气特性 void BOARD_InitBootPins(void); 初始化启动引脚； pin_mux.cvoid BOARD_IninPins(void)这段代码是来自项目中的“pin_mux.c”文件，该文件包含了MKW38A512微控制器的引脚配置函数。 所选代码块是函数“BOARD_InitPins()”，它配置了LPUART0外设的引脚路由和电气特性。 具体来说，它将 使能PortC的时钟； 42号和43号引脚的引脚复用设置为LPUART0_RX和LPUART0_TX。 将LPUART0传输数据源设置为LPUART0_TX引脚，将LPUART0接收数据源设置为LPUART_RX引脚，并在LPUART0上禁用了开漏特性。 该函数由“BOARD_InitBootPins()”调用，在引导过程中调用以初始化引脚。 clock_config.cvoid BOARD_BootClockRUN(void)这段代码是MKW38A512芯片的时钟配置代码，主要包括两个函数：BOARD_BootClockRUN和BOARD_BootClockVLPR。 这两个函数分别用于配置系统在RUN模式和VLPR模式下的时钟。在这两个函数中，主要使用了MCUXpresso Config Tools提供的时钟驱动函数来配置系统时钟。具体来说，这两个函数的主要步骤如下： BOARD_RfOscInit函数：初始化射频晶振，用于提供系统时钟的参考时钟。 CLOCK_SetSimSafeDivs函数：设置系统时钟分频器的初始值，以确保在时钟模式切换时，核心时钟、总线时钟、flexbus时钟和flash时钟都在允许的范围内。 BOARD_InitOsc0函数：初始化MCG OSC，用于提供系统时钟的参考时钟。 CLOCK_BootToFeeMode函数：将MCG模式设置为FEE模式，即FLL Engaged External模式，此时FLL时钟和外部参考时钟都被使能。 CLOCK_SetInternalRefClkConfig函数：配置内部参考时钟MCGIRCLK。 CLOCK_SetSimConfig函数：设置SIM模块的时钟配置。 SystemCoreClock变量：设置当前系统核心时钟的频率。 其中，BOARD_BootClockRUN函数用于配置系统在RUN模式下的时钟，而BOARD_BootClockVLPR函数用于配置系统在VLPR模式下的时钟。 在这两个函数中，主要的区别在于MCG模式的设置不同，以及时钟分频器的设置不同。 在RUN模式下，MCG模式被设置为FEE模式，时钟分频器的初始值为1，2，2，5， 而在VLPR模式下，MCG模式被设置为BLPI模式，时钟分频器的初始值为1，5，1， board.cvoid BOARD_InitDebugConsole(void)这段代码是初始化调试控制台的函数。在这个函数中，首先设置了LPUART0的时钟源为OSCERCLK，然后初始化了调试控制台。 调试控制台的初始化使用了MCUXpresso SDK提供的DbgConsole_Init函数，该函数需要传入调试控制台的实例、波特率、类型和时钟源频率等参数。在这个函数中，调试控制台的实例为BOARD_DEBUG_UART_INSTANCE，波特率为BOARD_DEBUG_UART_BAUDRATE，类型为BOARD_DEBUG_UART_TYPE，时钟源频率为uartClkSrcFreq。 fsl_debug_console.cint DbgConsole_Printf(const char *formatString, …)12345678910111213141516171819/* See fsl_debug_console.h for documentation of this function. */int DbgConsole_Printf(const char *formatString, ...){ va_list ap; int logLength = 0, dbgResult = 0; char printBuf[DEBUG_CONSOLE_PRINTF_MAX_LOG_LEN] = {'\\0'}; if (NULL != g_serialHandle) { va_start(ap, formatString); /* format print log first */ logLength = StrFormatPrintf(formatString, ap, printBuf, DbgConsole_PrintCallback); /* print log */ dbgResult = DbgConsole_SendDataReliable((uint8_t *)printBuf, (size_t)logLength); va_end(ap); } return dbgResult;} 这段代码是fsl_debug_console.c文件的一部分。该文件包含了调试控制台模块的实现。调试控制台模块提供了一组函数来初始化、去初始化、打印和从调试控制台读取数据。 所选代码是DbgConsole_Printf函数的实现。该函数用于将格式化数据打印到调试控制台。 该函数接受一个格式字符串和一个可变数量的参数。格式字符串指定输出字符串的格式，参数是要格式化和打印的值。 该函数首先使用StrFormatPrintf函数格式化输出字符串。该函数将格式字符串、可变参数和回调函数作为输入。回调函数用于输出格式化数据。在这种情况下，回调函数是DbgConsole_PrintCallback。 格式化输出字符串后，该函数使用DbgConsole_SendDataReliable函数将数据发送到调试控制台。该函数可靠地发送数据，这意味着它将重试发送数据，直到成功发送为止。 后缀代码包含了DbgConsole_Putchar和DbgConsole_Scanf函数的实现。DbgConsole_Putchar函数用于将单个字符打印到调试控制台。该函数只需调用DbgConsole_SendDataReliable函数并传递要打印的字符即可。 DbgConsole_Scanf函数用于从调试控制台读取格式化数据。该函数接受一个格式字符串和一个可变数量的参数。格式字符串指定输入数据的格式，参数是指向存储输入数据的变量的指针。 该函数首先使用DbgConsole_ReadLine函数读取一行输入。然后使用StrFormatScanf函数格式化输入数据，并将格式化数据存储在由参数指向的变量中。 总的来说，这些函数提供了一种方便的方式来与调试控制台交互，并打印和读取格式化数据。 关于引脚的四种输出情况上拉 (Pull-up) 和下拉 (Pull-down) 是指在数字电路中使用电阻将输入或输出引脚连接到电源或地，以确保在没有输入信号的情况下，引脚保持在一个已知状态。具体来说，上拉是指将引脚连接到电源（通常是高电平），下拉是指将引脚连接到地（通常是低电平）。在某些情况下，还可以使用弱上拉或弱下拉，即使用较大阻值的电阻。 开漏 (Open-Drain) 和推挽 (Push-Pull) 是指输出引脚的驱动方式。开漏输出只能将引脚拉到低电平，而不能将其拉到高电平，而推挽输出可以将引脚驱动到高电平或低电平。在使用开漏输出时，还需要在输出引脚和电源之间连接一个上拉电阻，以确保输出引脚能够被拉到高电平。 开漏输出通常用于需要将多个设备连接到同一个总线上的情况，而推挽输出则更适用于需要直接驱动其他器件的情况。","link":"/NXP/KW38/kw38-helloworld/"},{"title":"代码解读之fsl_gpio","text":"读fsl_gpio.c 和 fsl_gpio.h 代码 使用kw38的win mcuxpresso版本 SDK_2_6_615_FRDM-KW38_mcuxpresso_win fsl_gpio.h 123#ifndef _FSL_GPIO_H_#define _FSL_GPIO_H_#include \"fsl_common.h\" 结构体Part1 gpio_pin_direction_t 和 gpio_checker_attribute_t12345678typedef enum _gpio_pin_direction{ kGPIO_DigitalInput = 0U, /*!&lt; Set current pin as digital input*/ kGPIO_DigitalOutput = 1U, /*!&lt; Set current pin as digital output*/} gpio_pin_direction_t;typedef enum _gpio_checker_attribute{}gpio_checker_attribute_t; gpio_pin_direction_t 确定Pin引脚方向，输入为0，输出为1。 GPIO 检查器属性用于某些具有 GPIO 属性检查器功能的 NXP 微控制器。此功能用于安全目的，根据访问属性检查是否允许访问 GPIO 引脚。 gpio_checker_attribute_t 枚举定义了可以检查的可能属性。这些属性指定不同权限级别（用户非安全、用户安全和特权安全）的读取和写入权限。 另外还有一个属性值kGPIO_IgnoreAttributeCheck，表示忽略属性检查。 GPIO 检查器属性与 GPIO_CheckAttribute() 函数结合使用，以根据操作的属性检查是否允许 GPIO 引脚上的特定操作。 Part2 gpio_pin_config_t 和 gpio_interrupt_config_t12345678typedef struct _gpio_pin_config{ gpio_pin_direction_t pinDirection; uint8_t outputLogic; /*!&lt; Set a default output logic, which has no use in input */} gpio_pin_config_t;typedef enum _gpio_interrupt_config{} gpio_interrupt_config_t; 这是一个 C 语言代码片段，它定义了两个数据结构和一个枚举类型，用于在微控制器上配置通用输入/输出 (GPIO) 引脚。 gpio_pin_config_t 定义了 GPIO 引脚的配置参数，包括它的方向（输入或输出）和它的默认输出逻辑（如果它是一个输出引脚）。 第二个数据结构 gpio_interrupt_config_t 是有条件地定义的，具体取决于微控制器是否支持其 GPIO 引脚上的中断。如果是，则此结构定义中断生成条件的配置参数。 枚举类型 gpio_interrupt_config_t 定义了中断生成条件的可能值，例如在上升沿、下降沿、任一边沿或逻辑电平为高或低时启用中断。 函数接口GPIO配置Part1 GPIO_PinInit()这是名为 GPIO_PinInit() 的函数的代码片段，它是用于处理微控制器上的通用输入/输出 (GPIO) 引脚的更大驱动程序的一部分。该驱动程序提供一组函数来配置、读取和写入 GPIO 引脚。 函数 GPIO_PinInit() 初始化板使用的 GPIO 引脚。它采用三个参数： GPIO 外设的基地址 GPIO peripheral base pointer (GPIOA, GPIOB, GPIOC, and so on.) GPIO 端口的引脚号 GPIO port pin number 以及指向定义 GPIO 引脚配置的 gpio_pin_config_t 结构的指针 GPIO pin configuration pointer gpio_pin_config_t 结构包含两个字段： pinDirection：GPIO引脚的方向，可以设置为kGPIO_DigitalInput或kGPIO_DigitalOutput。 outputLogic：GPIO引脚的输出逻辑电平，仅在引脚配置为数字输出时适用。它可以设置为 0 或 1。 函数 GPIO_PinInit() 使用 gpio_pin_config_t 结构中定义的配置初始化 GPIO 引脚。 GPIO输入操作Part2 静态函数 GPIO_PinWrite()这是名为 GPIO_PinWrite() 的函数的代码片段。 函数GPIO_PinWrite()将一个GPIO引脚的输出电平设置为逻辑1或逻辑0。它需要三个参数： GPIO外设的基址、 GPIO端口的引脚号、 GPIO引脚的输出电平. 输出参数可以设置为 0 或 1 以指定 GPIO 引脚的输出逻辑电平。如果输出为 0，则相应的引脚输出设置为逻辑低电平，否则，如果输出为 1，则相应的引脚输出设置为逻辑高电平。 函数 GPIO_PinWrite() 使用按位操作来设置 GPIO 引脚的输出电平。如果输出参数为0，则使用左移操作清除GPIO端口输出清除寄存器（GPIOx_PCOR）中的相应位。否则，如果输出参数为 1，则使用左移操作设置 GPIO 端口输出设置寄存器 (GPIOx_PSOR) 中的相应位。 此代码是用 C 编程语言编写的，并假定微控制器具有 GPIO 寄存器的特定实现，例如分别用于清除和设置 GPIO 输出引脚的 PCOR 和 PSOR 寄存器。 Part3 静态函数 GPIO_PortSet()这是名为 GPIO_PortSet() 的函数的代码片段. 函数 GPIO_PortSet() 将多个 GPIO 引脚的输出电平设置为逻辑 1。它有两个参数： GPIO 外设的基址, base GPIO peripheral base pointer (GPIOA, GPIOB, GPIOC, and so on.) 指定要设置哪些 GPIO 引脚的掩码。GPIO pin number macro 掩码参数是一个位掩码，指示要设置的引脚。掩码参数的每一位对应一个特定的 GPIO 引脚。如果某位设置为 1，则相应的 GPIO 引脚输出设置为逻辑高电平。 函数 GPIO_PortSet() 通过使用按位或运算写入 GPIO 端口输出设置寄存器 (GPIOx_PSOR)，将指定 GPIO 引脚的输出电平设置为逻辑 1。在执行按位或操作之前，将掩码参数的值左移以与 GPIO 端口输出设置寄存器的位位置对齐。 此代码是用 C 编程语言编写的，并假定微控制器具有 GPIO 寄存器的特定实现，例如用于设置 GPIO 输出引脚的 PSOR 寄存器。 Part4 静态函数 GPIO_PortClear()这是名为 GPIO_PortClear() 的函数的代码片段. 函数 GPIO_PortClear() 将多个 GPIO 引脚的输出电平设置为逻辑 0。它有两个参数： GPIO 外设的基址 和指定要清除哪些 GPIO 引脚的掩码。 掩码参数是一个位掩码，指示要清除哪些引脚。掩码参数的每一位对应一个特定的 GPIO 引脚。如果某位设置为0，则相应的 GPIO 引脚输出设置为逻辑低电平。 函数 GPIO_PortClear() 通过使用按位或运算写入 GPIO 端口输出清除寄存器 (GPIOx_PCOR)，将指定 GPIO 引脚的输出电平设置为逻辑 0。在执行按位或操作之前，将掩码参数的值左移以与 GPIO 端口输出清除寄存器的位位置对齐。 此代码是用 C 编程语言编写的，并假定微控制器具有 GPIO 寄存器的特定实现，例如用于清除 GPIO 输出引脚的 PCOR 寄存器。 Part5 静态函数 GPIO_PortToggle()这是名为 GPIO_PortToggle() 的函数的代码片段。 函数 GPIO_PortToggle() 反转多个 GPIO 引脚的当前输出逻辑。它有两个参数： GPIO 外设的基地址 和一个掩码，它指定要切换的 GPIO 引脚。 掩码参数是一个位掩码，指示要切换的引脚。掩码参数的每一位对应一个特定的 GPIO 引脚。如果某位设置为 1，则相应的 GPIO 引脚输出逻辑反转，即如果设置为逻辑 1，则变为逻辑 0，反之亦然。 函数 GPIO_PortToggle() 通过使用按位或运算写入 GPIO 端口输出切换寄存器 (GPIOx_PTOR) 来反转指定 GPIO 引脚的输出逻辑。在执行按位或操作之前，掩码参数的值左移以与 GPIO 端口输出切换寄存器的位位置对齐。 此代码是用 C 编程语言编写的，并假定微控制器具有 GPIO 寄存器的特定实现，例如用于切换 GPIO 输出引脚的 PTOR 寄存器。 GPIO输入操作Part6 静态函数 GPIO_PinRead()这是一个名为 GPIO_PinRead() 的函数的代码片段。 函数 GPIO_PinRead() 读取单个 GPIO 引脚的当前输入值。它需要两个参数：GPIO外设的基地址和要读取的GPIO引脚的引脚号。 函数 GPIO_PinRead() 通过使用移位和与操作从 GPIO 端口输入数据寄存器 (GPIOx_PDIR) 读取来读取指定 GPIO 引脚的输入值。按位移位操作将 GPIO 端口输入数据寄存器的值右对齐，以与指定 GPIO 引脚的位位置对齐。 AND 运算会屏蔽除对应于指定 GPIO 引脚的位之外的所有位。 该函数将指定 GPIO 引脚的输入值作为single-bit值（0 或 1）返回。 此代码是用 C 编程语言编写的，并假定微控制器具有 GPIO 寄存器的特定实现，例如用于读取 GPIO 输入引脚的 PDIR 寄存器。 GPIO中断GPIO_PortGetInterruptFlags() 和 GPIO_PortClearInterruptFlags()此代码提供了一个 API，用于配置和处理 GPIO 引脚上的中断。 前两个函数 GPIO_PortGetInterruptFlags() 和 GPIO_PortClearInterruptFlags() 分别用于读取和清除 GPIO 端口中多个引脚的中断状态标志。 base参数是指GPIO peripheral的基地址，mask参数是用来指定要对哪个GPIO引脚进行读或清除操作。 此语句似乎描述了与数字系统中的 DMA 请求或电平敏感中断相关联的标志的行为。 如果某个引脚被配置为生成 DMA 请求，则当请求的 DMA 传输完成时，相应的标志将自动清除。这意味着该标志指示 DMA 传输的状态，并在传输完成时重置。 另一方面，如果引脚未配置为生成 DMA 请求，则相应的标志将保持设置状态，直到将逻辑 1 写入该标志。这意味着该标志可用于指示与 DMA 无关的事件的发生，例如中断或数据传输。 最后，如果引脚被配置为电平敏感中断并且中断信号保持有效，则标志立即再次设置。此行为允许系统响应连续信号，例如按钮按下或传感器读数，而不会错过任何事件。 GPIO_SetPinInterruptConfig() 和 GPIO_GetPinsDMARequestFlags() GPIO_SetMultipleInterruptPinsConfig()其余函数是有条件的，取决于 GPIO 端口是否支持中断。如果支持中断，则 GPIO_SetPinInterruptConfig() 函数用于设置单个引脚的中断配置。 pin 参数指定 GPIO 引脚号，而 config 参数用于指定中断配置。 GPIO_SetPinInterruptConfig() 函数用于读取多个引脚的 DMA 请求标志。 GPIO_SetMultipleInterruptPinsConfig() 函数用于同时设置多个引脚的中断配置。 mask 参数用于指定要为其设置中断配置的 GPIO 引脚，而 config 参数指定中断配置。 中断配置选项包括设置中断/DMA 请求、触发中断/DMA 请求的边沿类型、触发中断的逻辑电平以及输出触发模式。 GPIO_CheckAttributeBytes()此代码片段定义了一个名为 GPIO_CheckAttributeBytes() 的函数。该函数有两个参数：一个指向 GPIO 外设（基）的指针和一个名为 attribute 的 gpio_checker_attribute_t 参数。 该函数检查 GPIO 模块是否具有设备特定数量的数据端口，以及它是否支持属性检查器。如果满足这些条件，该函数将继续检查成功访问指定 GPIO 引脚（掩码）的 GPIO 编程模型所需的字节级属性。 属性参数是一个枚举，表示 GACR 中 4 个数据字节的属性控制值。字节级属性是使用小端数据约定定义的。 fgpio_driver 快速GPIOFGPIO_PortInit() 此代码片段介绍了 FGPIO 功能，该功能仅在某些 Kinetis MCU 上受支持。 FGPIO 寄存器是 IOPORT 接口的别名，通过 IOPORT 接口的访问与任何指令获取并行发生，并在一个周期内完成。此内存映射称为 FGPIO。 然后代码定义了一个名为 FGPIO_PortInit() 的函数，该函数将指向 FGPIO 外设（基）的指针作为其参数。此函数通过关闭其时钟来初始化 FGPIO 外设。 FGPIO_Type 可能是表示 FGPIO 外设的结构的类型定义。特定的 FGPIO 外设用后缀（FGPIOA、FGPIOB、FGPIOC 等）表示，并且可能具有不同的配置和引脚映射。 还有一个条件预处理器指令，用于检查 FSL_FEATURE_SOC_FGPIO_COUNT 功能是否已定义和支持。如果不支持，则不会编译指令中的代码。 同样，还有另一个条件预处理器指令检查 FSL_FEATURE_PCC_HAS_FGPIO_CLOCK_GATE_CONTROL 功能是否已定义和支持。如果不支持，则不会编译指令中的代码。 总的来说，这段代码设置了 FGPIO 功能并提供了一个函数来初始化 FGPIO 外设。但是，如果没有关于如何使用此代码以及 FGPIO_Type 结构是什么样子的更多上下文，则很难提供更详细的分析。 fsl_gpio.c12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061static PORT_Type *const s_portBases[] = PORT_BASE_PTRS;static GPIO_Type *const s_gpioBases[] = GPIO_BASE_PTRS;static uint32_t GPIO_GetInstance(GPIO_Type *base){ uint32_t instance; /* Find the instance index from base address mappings. */ for (instance = 0; instance &lt; ARRAY_SIZE(s_gpioBases); instance++) { if (s_gpioBases[instance] == base) { break; } } assert(instance &lt; ARRAY_SIZE(s_gpioBases)); return instance;}void GPIO_PinInit(GPIO_Type *base, uint32_t pin, const gpio_pin_config_t *config){ assert(NULL != config); uint32_t u32flag = 1; if (config-&gt;pinDirection == kGPIO_DigitalInput) { base-&gt;PDDR &amp;= ~(u32flag &lt;&lt; pin); } else { GPIO_PinWrite(base, pin, config-&gt;outputLogic); base-&gt;PDDR |= (u32flag &lt;&lt; pin); }}uint32_t GPIO_PortGetInterruptFlags(GPIO_Type *base){ uint8_t instance; PORT_Type *portBase; instance = (uint8_t)GPIO_GetInstance(base); portBase = s_portBases[instance]; return portBase-&gt;ISFR;}void GPIO_PortClearInterruptFlags(GPIO_Type *base, uint32_t mask){ uint8_t instance; PORT_Type *portBase; instance = (uint8_t)GPIO_GetInstance(base); portBase = s_portBases[instance]; portBase-&gt;ISFR = mask;}void GPIO_CheckAttributeBytes(GPIO_Type *base, gpio_checker_attribute_t attribute){ base-&gt;GACR = ((uint32_t)attribute &lt;&lt; GPIO_GACR_ACB0_SHIFT) | ((uint32_t)attribute &lt;&lt; GPIO_GACR_ACB1_SHIFT) | ((uint32_t)attribute &lt;&lt; GPIO_GACR_ACB2_SHIFT) | ((uint32_t)attribute &lt;&lt; GPIO_GACR_ACB3_SHIFT);}","link":"/NXP/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8Bfsl-gpio/"},{"title":"基础准备1_Numpy","text":"0. Numpy的随机数 12345678910111213141516171819\"\"\"随机数numpy.random.rand() 产生一个[0,1)之间的随机数, 包含0不包含1numpy.random.randn() 产生一个标准正态分布的随机数 np.random.randn(2,4)np.random.normal(loc=0.0, scale=1.0, size=None) 参数loc决定均值，参数scale决定标准差，参数size决定数量numpy.random.randint(low, high=None, size=None, dtype='l') 产生一个或多个随机整数，范围区间为[low, high) np.random.randint(-5,5,size=(2,2))numpy.random.random_sample(size=None)numpy.random.random(size=None)numpy.random.ranf(size=None)numpy.random.sample(size=None) 都是产生[0,1)之间的随机数np.random.choice(5,size=(3,2)) 产生一个或多个随机整数，范围区间为[0,5) np.random.choice([1,2,3,4,5],size=(3,2))demo_list = ['lenovo', 'sansumg','moto','xiaomi', 'iphone']np.random.choice(demo_list,size=(3,3), p=[0.1,0.6,0.1,0.1,0.1]) 注意p的长度必须和demo_list的长度一致,且p的和为1numpy.random.seed() 设置随机数种子\"\"\" 1. Numpy的数组1","link":"/NLP/Python/%E5%9F%BA%E7%A1%80%E5%87%86%E5%A4%871-numpy/"},{"title":"嵌入式common","text":"startup.c是做什么的？startup.c通常是指嵌入式系统中的启动代码，它的主要作用是初始化系统并启动应用程序。 在启动过程中，会进行一些初始化操作，如设置堆栈、复制数据段、清零BSS段、设置中断向量表等。此外，startup.c还会加载应用程序，将控制转移到应用程序的入口处，开始执行应用程序的功能。 因此，startup.c非常重要，涉及到整个系统的启动和运行。不同的嵌入式平台和芯片厂商会有不同的startup.c代码，但它们的基本逻辑和流程是类似的。 启动文件为什么会比main先启动？这个问题总结起来就是CPU启动时根据外部boot引脚状态从(起始地址+0x4)地址加载数据，赋值给PC(执行程序寄存器，r15)，而编译器将startup.s文件中的ResetHander函数的地址编译到(起始地址+0x4)内部，所以startup.s被先调用。 详细的解释需要参考Cortex-M系列的知识，下面来详细说明。首先参考STM32F1x的手册2.4启动配置这句话 那么就可以理解从0x04地址执行代码，这是由芯片设计时规定的，至于如何实现就是集成电路相关的知识了，这里不在说明，那么就是第二个问题，ResetHander如何被编译到0x04偏移地址的，这就涉及中断向量表的知识，下面来自于&lt;Cortex-M3权威指南&gt;关于异常的说明章节。 从上面可以看出，在0x04偏移地址中定位的就是复位向量，而在代码startup.s中，就可以看到 12345__Vectors DCD __initial_sp ; Top of Stack DCD Reset_Handler ; Reset Handler DCD NMI_Handler ; NMI Handler ...__Vectors_End 也就是说由内核特性和STM芯片的定义，上电时的入口地址一定是Reset_Handler，而Reset_Handler就放置在在启动文件startup.s中，这就是启动文件startup.s比main先调用的总的原因. 简略回答： startup比main更先调用，确实和编译器设置有关，但更多的是程序本来如此。 详细回答：背景知识程序的生成步骤一般分成四步 preprocess(.c) -&gt; compile(.S) -&gt; assemble (.o) -&gt; link，具体可阅读 The Four Stages of Compiling a C Program 。 Linker Script的基本知识： Simple Linker Script Example具体例子下面的截图是Atmel SAMD10D14AM的souce code，第一张是 Linker Script (samd10d14am_flash.ld)，第二张是 Startup file (startup_samd10.c)。接下来解释highlight部分的含义。 Linker Script Vector Table Vectors就是所谓Exception Table。对于ARM处理器Cortex M系列，Table的第一条是Stack Pointer的地址，第二条就是最重要的ISR for reset的地址。 左边的Linker Script指定把 section(“.vector”) 放在生成程序的.text代码段，一般也就是flash的起始地址。从keyword MEMORY的定义来看，flash rom的起始地址是0x00000000，大小是0x00000800 (16K)，刚好符合官方文档的描述 https://web.eecs.umich.edu/~prabal/teaching/resources/eecs373/ARM_Cortex_AppNote179.pdf 1.1 Nested Vectored Interrupt Controller (NVIC)The initial stack pointer and the address of the reset handler must be located at 0x0 and 0x4 respectively. These values are then loaded into the appropriate CPU registers at reset. Reset_Handler()这个ISR就是CPU power on或者reset后的第一个routine，里面会先做一些简单初始化，比如Intialize the C libray（这样我们才能在后头的代码里直接用strcpy()等常见函数），最后跳往我们最熟悉的main()。 其余的ISR都是optional，可以留白，会自动被Dummy_Handler填充，因为keyword weak。结论启动文件startup比main()先启动，是因为程序的启动顺序就是这样的，**CPU power on / reset -&gt; Reset_Handler() -&gt; main()**。 BSS段是做什么的？BSS段（Block Started by Symbol）是指程序中未被初始化的全局变量和静态变量所占用的一段内存空间。在程序加载运行时，操作系统会自动分配一块内存空间用于存放BSS段。 BSS段中的变量被默认初始化为0，因此，在程序编写中不需要为它们显式地赋初值。BSS段对于节省内存空间和程序运行效率都有很大的帮助。这是因为，程序中的未初始化变量会在BSS段中被统一地设置为0，而不需要在程序中存储这些变量的具体值。这样，在程序执行过程中，BSS段所占空间可以被多次重用并动态分配，从而使得程序的内存利用率更高。 RAM中的各个段RAM内存RAM内存包括： 代码段（text） 数据段(data) bss段 堆栈段（head stack） 编译器编译结果分析 编译结果有代码段（text）、数据段(data)、bss段。 代码段（.text）是可执行指令的集合； 数据段 (.data) 表示已经初始化不为0的存放在静态区的数据（全局 or 静态）。 .bss段 表示未初始化的或为0的存放在静态区的数据（全局 or 静态）。 从可执行程序的角度来说，如果一个数据未被初始化，就不需要为其分配空间，所以.data 和.bss 的区别就是： .bss 并不占用可执行文件的大小，仅仅记录需要用多少空间来存储这些未初始化的数据，而不分配实际空间。 所以代码段（text）、数据段(data)这两者相加共同构成可执行文件的大小，dec也就是文件大小(hex也是文件大小，只不过是16进制表示的)。 堆栈堆 heap堆保存函数内部动态分配（malloc 或 new）的内存，是另外一种用来保存程序信息的数据结构。 堆是先进先出（FIFO）数据结构。堆的地址空间是向上增加，即当堆上保存的数据越多，堆的地址越高。动态内存分配。 注意：堆内存需要程序员手动管理内存，通常适用于较大的内存分配，如频繁的分配较小的内存，容易导致内存碎片化。 栈 stack栈保存函数的局部变量（不包括 static 修饰的变量），参数以及返回值。是一种后进先出（LIFO）的数据结构。 在调用函数或过程后，系统会清除栈上保存的局部变量、函数调用信息及其他信息。 栈的另外一个重要特征是，它的地址空间 向下减少，即当栈上保存的数据越多，栈的地址越低。静态内存分配。 注意：由于栈的空间通常比较小，一般 linux 程序只有几 M，故局部变量，函数入参应该避免出现超大栈内存使用，比如超大结构体，数组等，避免出现 stack overflow。 总结 段名 存储属性 内存分配 代码段.text 存放可执行程序的指令，存储态和运行态都有 静态 数据段.data 存放已初始化（非零初始化的全局变量和静态局部变量）的数据，存储态和运行态都有 静态 bss段.bss 存放未初始化（未初始化或者0初始化的全局变量和静态局部变量）的数据，存储态和运行态都有 静态 堆heap 动态分配内存，需要通过malloc手动申请，free手动释放，适合大块内存。容易造成内存泄漏和内存碎片。运行态才有 动态 栈stack 存放函数局部变量和参数以及返回值，函数返回后，由操作系统立即回收。栈空间不大，使用不当容易栈溢出。运行态才有 静态 例子1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std; int a = 0;//初始化的全局变量:保存在数据段char *p1;//未初始化的全局变量:保存在BSS段 int main(){ int b;//未初始化的局部变量:保存在栈上 char s[] = \"abc\"; /* \"abc\"为字符串常量保存在常量区；数组保存在栈上， 并将常量区的\"abc\\0\"复制到该数组中。这个数组可以随意修改而不会有任何隐患， 而\"123\"这个字符串依然会保留在静态区中。 */ char *p2;//p2保存在栈上 char *p3 = \"123456\";//p3保存在栈上，\"123456\\0\"保存在data区的read-only部分 //注意：如果令p3[1] = 9; 则程序崩溃，指针可以访问但不允许改变常量区的内容 /* 声明了一个指针p3并指向\"123456\\0\"在静态区中的地址，事实上，p3应该声明为 char const *，以免可以通过p3[i]='\\n'这一类的语法去修改这个字符串的内容。如果这样做了，在支持“常量区”的系统中可能会导致异常，在“合并相同字符串”的编译方法下会导致其它地方的字符串常量古怪地发生变化。 */ static int c = 0;//初始化的静态局部变量:保存在数据区（数据段） p1 = (char *)malloc(sizeof(char) * 10);//分配的10字节区域保存在堆上 p2 = (char *)malloc(sizeof(char) * 20);//分配的20字节区域保存在堆上 strcpy(p1, \"123456\"); //\"123456\\0\"放在常量区，编译器可能会将它与p3所指向\"123456\"优化成一个地方 return 0;}","link":"/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80/%E5%B5%8C%E5%85%A5%E5%BC%8Fcommon/"},{"title":"嵌入式系统1--简介","text":"嵌入式系统1–简介 实时操作系统是不是RTOS，由任务调度策略决定： Windows等OS不是实时操作系统，因为，CPU为任务分配时间片，到了时间不管有没有执行完都换下一个任务，所有任务都有机会运行到，是时间线轮转策略； RTOS有uCosⅡ、VxWorks等，CPU对多个任务分配优先级，执行完一个才执行下一个，是基于优先级的调度策略； 硬件最小系统 处理器 51 arm powerpc MIPS 电源电路 复位电路 时钟电路 存储电路 RAM：掉电丢失 SRAM DRAM：需要周期性刷新，不然不断电也丢数据 ROM：只读，不能写，掉电不丢失 PROM：只能写一次 EPROM：可擦除，所以可写入多次，写入前必须擦除，擦除需要紫外线； EEPROM：先擦后写，电可擦除，容量小，2k左右 FLASH:多次写入，先擦后写 NORFlash NANDFlash EMMC 嵌入式软件开发模式 开发主机（Host） — 也叫上位机 代码编写、编译 目标板（Target） — 也叫下位机 代码运行 连接介质","link":"/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F1-%E7%AE%80%E4%BB%8B/"},{"title":"嵌入式系统2--开发板介绍","text":"嵌入式系统2–开发板介绍T-PAD开发板简介核心板+底板： 核心板： DDRAM: 1G EMMC: 掉电不丢失，相当于硬盘，8G 接线方式：","link":"/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F2-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BB%8B%E7%BB%8D/"},{"title":"总线协议之 -- UART","text":"总线协议之 – UARTUART简介 UART: Universal Asynchronous Receiver Transmitter（通用异步收发器）， 通用的串行、异步通信总线，它有两条数据线，实现全双工发送和接收。 通信基础串行、并行： 并行通信：总线在传递数据的时候，可以一次性收发多个位的数据。并行虽然快，但是要考虑多个线的资源占用，以及多条线互相干扰的问题； 串行通信：每一位数据逐次传递；（IIC\\SPI都是串行通信） 单工、双工： 单工通信：只能是单向的，发送器给接收器发送数据，而不能反过来； 双工通信：可以是A到B，也可以是B到A； 半双工：不能同时发生；只有一根线，发送时就不能接收； 全双工：可以同时发送和接收，有两根线； 波特率： 波特率：描述UART通信速度，单位bps，(bit per second)，每秒传送的bit的数量； 每秒的波特数，波特等于单个信号包含的码元数量 比特率：是指每秒传送的比特(bit)数。单位为 bps(Bit Per Second)，比特率越高，每秒传送数据就越多。 波特率：表示每秒钟传送码元符号的个数，是衡量数据传送速率的指标。 在信息传输通道中，携带数据信息的信号单元叫码元，每秒钟通过信道传输的码元数称为码元传输速率，简称波特率。波特率是传输通道频宽的指标。 比特率=波特率x单个调制状态对应的二进制位数 两相调制(单个调制状态对应1个二进制位)的比特率等于波特率;四相调制(单个调制状态对应2个二进制位)的比特率为波特率的两倍;八相调制(单个调制状态对应3个二进制位)的比特率为波特率的三倍;依次类推。 UART帧格式 起始位：1bit的0，标志发送开始；因为空闲时为1，所以开始为0； 数据位： 5-8bit，先发低位，后发高位； 校验位：可有可无；奇偶校验，是校验奇数还是偶数个1； 停止位：高电平1； 空闲位： 注意： UART空闲的时候，用高电平表示； 串口协议从低位先发，最后发高位； 串口每次都只发一个byte，下一个byte又重新开始起始位，是因为它是异步的，发送方和接收方的时钟不是同一个，防止由于时钟不同步导致误差累积； IIC和SPI都是同步通信，可以发多个字节； Exynos4412下的UART控制器 串口的信号一般较弱，通信距离短，容易被干扰，所以增加了一块专有芯片用来增加抗干扰能力，使发送距离更远；(TTL信号转为232信号) STEPs： 待发送数据放入FIFO 增加了UART协议的各种头，比如起始和校验，然后拷贝放入shifter； shifter每个bit依次移位到引脚来发送，先发低位，后发高位； 接收时顺序相反，RxD –&gt; shifter –&gt; FIFO; UART控制器的总体框图 CPU会通过总线，和接收和发送的BUFFer相连，用来读写数据，另外，也和控制单元相连，对控制单元的设置进行修改； UART寄存器详解 补充一个细节，回环模式look-back是在内部将Tx和Rx短接，一般用于测试； 三种工作模式： polling 轮询 CPU不断地对FIFO进行访问，查询需要的数据有没有发过来； CPU的状态： 工作 –&gt; 轮询 –&gt; 工作 –&gt; 轮询 … 直到查找到需要的数据； 费时费力，消耗资源 interrupt 中断 CPU和FIFO约定，CPU不主动去查询，当FIFO收到数据要发送过来的时候，给CPU发送中断信号，CPU中断当前工作，接收FIFO的数据； 比polling模式省资源； DMA 直接存储器访问 CPU收到FIFO的数据，最终也是要放入某一块内存中去使用的； DMA模式跳过CPU，当FIFO数据过来时，直接放入需要的内存中； UART编程之前，设置需要的寄存器，以及顺序： UART编程STEP 1： 串口初始化 STEP 2： main函数 STEP 3： 收发函数封装 发送数据： 接收数据： STEP 4： 优化 电脑 – &gt; 开发板， 然后开发板收到数据+1，再返回给电脑； 输入输出重定向 这种通过判断发送寄存器是不是空，来把数据放入UART的寄存器中，就是相当于printf重定向到UART串口，而其他操作系统中，是重定向到显卡或者磁盘； 尝试写一个发送字符串的函数：","link":"/%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE/UART/%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE%E4%B9%8B-uart/"},{"title":"数字设计流程","text":"数字设计流程 先放地址，来源于B站比特大陆相关的学习资料。 链接 一、 项目立项1.1 项目解读市场、研发、架构、编译器 等相关人员，进行市场需求和竞品分析，初步决定芯片功能、面积、功耗等相关指标。 1.2 技术调研软件建模、硬件预实现、方案可行性分析等，生成一个市场需求报告。 1.3 开发计划制定有几个方面会影响到芯片开发的时间线： 购买IP，比如PCI接口、DDR等，IP供应商也要时间准备进行定制化开发； 代工厂排期； 预留研发调试时间； 二、 研发阶段2.1 技术研讨方案制定划分芯片的子系统和模块、软硬件工作的划分和规划、各个子系统也要有性能指标定义等。 2.2 详细设计 算法和硬件架构、硬件电路设计、功能验证都属于前端设计部分； 逻辑综合、静态时序分析、一致性验证算是中端； 布局布线等等都属于后端； 下面，对这些步骤进行详细介绍： 2.2.1 算法和硬件架构设计 输入： 功能需求 输出： 软件参考模型 过程： 架构人员使用Matlab、C++、System C、 System Verilog 等语言工具，完成芯片中数字部分的高层次算法或架构的分析和建模，为硬件提供正确的软件功能模型，更为重要的是，通过大量的高层次仿真和调试，为RTL实现提供总体性的设计指导。越是复杂的数字电路，这部分算法模型仿真越重要。 2.2.2 硬件电路设计 输入： 从架构拿到的软件参考模型 输出： RTL代码、详细的设计文档、逻辑综合报告、语法检查报告 spyglass: 时序校验、语法校验等 Design Compiler： 预综合，观察时序面积功耗等是否达到要求； 2.2.3 功能验证 输入： 设计规格、设计代码、软件模型； 输出： 代码覆盖率和功能覆盖率报告； 2.2.4 逻辑综合 输入： RTL代码、工艺库、约束； 输出： 网表、标准延迟文件SDF、工程文件(.ddc)、各类报告； 2.2.5 静态时序分析 中端人员使用静态时序分析工具 Prime Time，从静态分析角度，保证设计中所有的路径，满足内部时序单元对建立时间和保持时间的要求。 即无论起点是什么，信号都可以被及时的传递到该路径的终点，并且在电路正常工作所需的时间段内保持恒定； 2.2.6 一致性验证 输入： RTL代码、网表、约束； 输出： match（两张图的节点是否一致）和verify（计算得到的两张图的功能是否一致）的报告； 过程： RTL和网表都可以抽象成两幅图，由节点和边组成，中端人员使用Formality、Conformal工具进行一致性验证，采用类似于直接比较两幅图是否一致的方法，来确定网表是否正确。 2.2.7 布局布线 布图规划（floor plan）： 后端人员使用IC complier、 Encounter等工具进行布局前的规划，目标是优化芯片的面积，时序收敛，稳定，方便走线。是整个后端最重要的一步，也是弹性最大的一步。因为没有标准的最佳方案，但又有很多细节需要考虑。 布局： 布局就是摆放标准单元，I/o pad（用于胡须连接芯片引脚），宏单元来实现电路逻辑。布局目标：利用率越高越好，总线越短越好，时序越快越好。但是利用率高布线就困难，总线就长，时序就慢，因此要做个平衡取舍。 时钟树综合（clock tree synthesis）： 简单说就是时钟的布线，因为时钟信号在数字电路的全局指挥最用，它的分布应该是对称式连接到各个寄存器单元的，从而时钟从一个时钟源到各个寄存器时，时钟延迟差异最小。这也是为什么时钟信号需要单独布线的原因。 布线： 在满足工艺规则和布线层数限制、线宽、线间距限制和各线网可靠绝缘的电性能约束条件下，根据电路的连接关系，将各单元和I/O pad用互连线连接起来。 2.2.8 生成版图并验证 寄生参数提取： 由于导线本身存在电阻，相邻导线之间的互感，耦合电容在芯片内部会产生信号噪声，串扰和反射。这些效应会产生信号完整性的问题，导致信号电压波动和变化，如果严重就会导致信号失真错误。提取寄生参数进行再次分析验证，分析信号完整性是非常重要的。 生成版图并验证： 对完成布线的物理版图进行功能和时序上的验证，大概包括以下方面： LVS（layout vs schematic）、 DRC（Design Rule Checking）、 ERC（Electrical Rule Checking）","link":"/%E6%95%B0%E5%AD%97IC/%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B/"},{"title":"数组01二分查找","text":"数组01–二分查找1. 数组的基本理论 数组下标从0开始； 数组内存空间连续； 导致数组增加和删除元素需要移动其他元素，开销很大！ vector 和 array 的区别： vector 的底层是用array实现的，所以，vector是容器，而不是数组！ 数组的元素是不能删除的，只能覆盖！ 二维数组的内存地址一般是连续的，可能不同，C++是连续的； 测试二维数组的内存地址空间是否连续： 123456789101112131415# include &lt;iostream&gt;using namespace std;void test_arr() { int array[2][3] = { {0, 1, 2}, {3, 4, 5} }; cout &lt;&lt; &amp;array[0][0] &lt;&lt; \" \" &lt;&lt; &amp;array[0][1] &lt;&lt; \" \" &lt;&lt; &amp;array[0][2] &lt;&lt; endl; cout &lt;&lt; &amp;array[1][0] &lt;&lt; \" \" &lt;&lt; &amp;array[1][1] &lt;&lt; \" \" &lt;&lt; &amp;array[1][2] &lt;&lt; endl;}int main() { test_arr();} 2. 二分查找704 Binary Search Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1. You must write an algorithm with O(log n) runtime complexity. Example 1: 123Input: nums = [-1,0,3,5,9,12], target = 9Output: 4Explanation: 9 exists in nums and its index is 4 Example 2: 123Input: nums = [-1,0,3,5,9,12], target = 2Output: -1Explanation: 2 does not exist in nums so return -1 Constraints: 12341 &lt;= nums.length &lt;= 104-104 &lt; nums[i], target &lt; 104All the integers in nums are unique.nums is sorted in ascending order. 经典二分查找的模板： 12345678910111213141516171819class Solution {public: int search(vector&lt;int&gt;&amp; nums, int target) { int left = 0; int right = nums.size() - 1; //定义target在左闭右闭空间[left, right] while(left &lt;= right){ // 因为left==right时，闭区间依然有效 int middle = left + ((right - left) / 2); // 防止溢出 if (nums[middle] &gt; target) { right = middle - 1; }else if (nums[middle] &lt; target) { left = middle + 1; } else { return middle; } } return -1; }}; C语言写法： 1234567891011121314int search(int* nums, int numsSize, int target){ int left = 0, right = numsSize -1; while(left &lt;= right) { int middle = (left + right)/2; if (target &lt; nums[middle]) { right = middle - 1; } else if (target &gt; nums[middle]) { left = middle + 1; } else { return middle; } } return -1;} 二分查找的第二种方法 第一种写法是左闭右闭区间，这里考虑改成左闭右开区间[left, right) 这样，判断的边界条件就发生了变化； 如下两点： while (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的 if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle] 总结 二分查找最重要的地方，是搞清3点! 根本点： 使用闭区间还是开区间； while中的条件在该区间下是否存在； 闭区间的right是middle-1，开区间的right是middle；但是left都是middle+1；因为开区间的时候，middle为right就刚好是取不到的情况！ 其他相关题目 35 34 69 367","link":"/Leetcode/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%8401%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"title":"数组02移除元素","text":"数组02–移除元素题干1234567Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed.Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.Return k after placing the final result in the first k slots of nums.Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory. Example 1: 1234Input: nums = [3,2,2,3], val = 3Output: 2, nums = [2,2,_,_]Explanation: Your function should return k = 2, with the first two elements of nums being 2.It does not matter what you leave beyond the returned k (hence they are underscores). 暴力解法123456789101112131415161718192021// 暴力解法：两个循环，一个for遍历数组，一个for更新数组// 时间 O(n^2)// 空间 O(1)class Solution {public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int size = nums.size(); for (int i = 0; i &lt; size; i++) { if (nums[i] == val){ for(int j = i + 1; j &lt; size; j++){ nums[j-1] = nums[j]; } i --;//因为i后面的都前移一位，所以i也要前移一位， //i++回来，再从这个位置计算，因为新的i位置可能还是那个val，要重新判断 size --; } } return size; }}; 双指针法 双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。 双指针法（快慢指针法）： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。 定义快慢指针: 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组 慢指针：指向更新新数组下标的位置 很多同学这道题目做的很懵，就是不理解 快慢指针究竟都是什么含义，所以一定要明确含义，后面的思路就更容易理解了。 1234567891011121314151617// 快慢指针法// 时间O(n)// 空间O(1)class Solution {public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int slowIndex = 0; for(int fastIndex = 0; fastIndex &lt; nums.size(); fastIndex++){ if(val != nums[fastIndex]){ nums[slowIndex] = nums[fastIndex]; slowIndex++; } } return slowIndex; }}; 其他相关题目 26.删除排序数组中的重复项 283.移动零 844.比较含退格的字符串 977.有序数组的平方","link":"/Leetcode/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%8402%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"},{"title":"数组03有序数组的平方","text":"数组03–有序数组的平方977. Squares of a Sorted Array 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100] 示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121] 暴力解法 直接每个数求平方，然后排序 12345678910class Solution {public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) { for (int i = 0; i &lt; nums.size(); i++){ nums[i] *= nums[i]; } sort(nums.begin(), nums.end()); //快速排序 return nums; }}; 时间复杂度：**O(n + nlogn)**， 可以说是O(nlogn)的时间复杂度，但为了和下面双指针法算法时间复杂度有鲜明对比，我记为 O(n + nlog n)； 空间复杂度： ？？快排的空间复杂度是多少？ 双指针法数组其实是有序的， 只不过负数平方之后可能成为最大数了。 那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。 此时可以考虑双指针法了，i指向起始位置，j指向终止位置。 定义一个新数组result，和nums数组一样的大小，让k指向result数组终止位置。 如果 nums[i] * nums[i] &lt; nums[j] * nums[j] 那么result[k–] = nums[j] * nums[j]; 如果 nums[i] * nums[i] &gt;= nums[j] * nums[j] 那么result[k–] = nums[i] * nums[i]; 相当于通过双指针，把nums中的元素一个个拉进来result中； 123456789101112131415161718192021class Solution {public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) { int k = nums.size() - 1; vector&lt;int&gt; result(nums.size(), 0); for(int i = 0, j = nums.size()-1; i&lt;=j; ) { // 注意这里i&lt;=j，因为最后i=j的时候还有一个元素没有放进去result if(nums[i]*nums[i] &lt; nums[j]*nums[j]) { result[k] = nums[j]*nums[j]; k--; j--; } else { result[k] = nums[i] * nums[i]; k--; i++; } } return result; }}; 时间复杂度： O(n); 空间复杂度： ？？？","link":"/Leetcode/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%8403%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/"},{"title":"数组04长度最小的子数组","text":"数组04–长度最小的子数组209. Minimum Size Subarray Sum描述 给定一个含有 n 个正整数的数组nums和一个正整数 target ， 找出该数组中满足其sum ≥ target 的长度最小的连续子数组，并返回其长度。 如果不存在符合条件的子数组，返回 0。 示例： 输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 思路滑动窗口！ 暴力解法 两个for循环，不断寻找符合条件的子序列， 时间复杂度是O(n^2); 1234567891011121314151617181920class Solution {public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) { int result = INT32_MAX; int sum = 0; int subLength = 0; for(int i = 0; i &lt; nums.size(); i++){ // 子序列起点为i sum = 0; for(int j = i; j &lt; nums.size(); j++){ sum += nums[j]; if(sum &gt;= target){ subLength = j - i + 1; result = result &lt; subLength ? result : subLength; //长度最小的子数组 break; // 找到一个子数组之后就break } } } return result == INT32_MAX ? 0 : result; }}; 滑动窗口接下来就开始介绍数组操作中另一个重要的方法：滑动窗口。 所谓滑动窗口，就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果。 在暴力解法中，是一个for循环滑动窗口的起始位置，一个for循环为滑动窗口的终止位置，用两个for循环完成了一个不断搜索区间的过程。 滑动窗口如何用一个for循环来完成这个操作。 注意： 只用一个for循环，那么这个循环的索引，一定是表示滑动窗口的终止位置。 那么问题来了， 滑动窗口的起始位置如何移动呢？ 滑动窗口的思路需要解决几个问题： 窗口内是什么？ 如何移动窗口的起始位置？ 如何移动窗口的结束位置？ 窗口就是满足其和 ≥ target 的长度最小的连续子数组。 窗口的起始位置如何移动：如果当前窗口的值大于target了，窗口就要向前移动了（也就是该缩小了）。 窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。 可以发现滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)!! 为什么时间复杂度是O(n)? 不要以为for里放一个while就以为是O(n^2)啊， 主要是看每一个元素被操作的次数， 每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是 2 × n 也就是O(n)。 1234567891011121314151617181920class Solution {public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) { int result = INT32_MAX; int sum = 0; int i = 0; int subLength = 0; for(int j = 0; j &lt; nums.size(); j++){ sum += nums[j]; // while循环每次更新起始位置i，并比较子序列是否符合条件 while(sum &gt;= target){ subLength = j - i + 1; result = result &lt; subLength ? result : subLength; sum -= nums[i]; i++; } } return result == INT32_MAX ? 0 : result; }}; 相关题目 904 76","link":"/Leetcode/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%8404%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"},{"title":"数组05螺旋矩阵Ⅱ","text":"数组05–螺旋矩阵Ⅱ59. Spiral Matrix II描述 给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。 示例: 输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ] 思路本题并不涉及到什么算法，就是模拟过程，考察对代码的掌控能力。如何画出这个螺旋排列的正方形矩阵呢？ 很多同学刚开始做这种题目的时候，上来就是一波判断猛如虎。 结果运行的时候各种问题，然后开始各种修修补补，最后发现改了这里那里有问题，改了那里这里又跑不起来了。 求解本题依然是要坚持循环不变量原则。 模拟顺时针画矩阵的过程: 填充上行，从左到右； 右列，从上到下； 下行，从右到左； 左列，从下到上； 要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开右闭的原则，这样这一圈才能按照统一的规则画下来。 Solution12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution {public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) { vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n, 0)); //使用vector定义一个二维数组 int startx = 0, starty = 0; //循环一个圈的起始位置 int loop = n / 2; // 循环几个圈， int mid = n / 2; //矩阵中间的位置，比如，n=3时，中心点为(1,1) int count = 1; // 用来给矩阵中每一个格子赋值 int offset = 1; // 控制每一条边遍历的长度，每次循环右边界收缩一位 int i, j; while (loop --) { i = startx; j = starty; // 四个for循环模拟四条边转圈 for (j = starty; j &lt; n - offset; j++) { res[startx][j] = count++; } for (i = startx; i &lt; n - offset; i++) { res[i][j] = count++; } for (; j &gt; starty; j--) { res[i][j] = count++; } for (; i &gt; startx; i--) { res[i][j] = count++; } // 第二圈开始的时候，起始位置各自加一 startx++; starty++; offset += 1; } // 当n为奇数时，需要单独给最后中心值赋值 if(n % 2) { res[mid][mid] = count; } return res; }}; 相关题目 54.螺旋矩阵 剑指Offer 29.顺时针打印矩阵","link":"/Leetcode/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%8405%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%E2%85%B1/"},{"title":"数组06--总结","text":"数组06–总结数组的理论基础 数组是存放在内存连续空间上的相同类型的数据的集合； 两个注意点： 下标从0开始； 内存地址连续； So： 正是因为内存地址连续，所以在删除和增加元素的时候，就必须移动其他元素，导致时间开销大！ 在C++中，要注意vector和array的区别，vector的底层实现是array，严格来讲vector是容器，不是数组。 数组的元素是不能删的，只能覆盖。 数组经典题目 大概四种，对应之前例题 二分法 暴力解法：时间复杂度O(n); 二分法：时间复杂度O(logn); 循环不变量原则 : 只有在循环中坚持对区间的定义，才能清楚的把握循环中的各种细节。 双指针法双指针法（快慢指针法） ： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。 暴力解法 : 时间复杂度：O(n^2) 双指针 : 时间复杂度：O(n) 数组中的元素为什么不能删除，主要是因为以下两点： 数组在内存中是连续的地址空间，不能释放单一元素，如果要释放，就是全释放（程序运行结束，回收内存栈空间）。 C++中vector和array的区别一定要弄清楚，vector的底层实现是array，封装后使用更友好。 双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组和链表操作的面试题，都使用双指针法。 滑动窗口 暴力解法 : 时间复杂度：O(n^2) 滑动窗口 : 时间复杂度：O(n) 主要要理解滑动窗口如何移动 窗口起始位置，达到动态更新窗口大小的条件，从而得出长度最小的符合条件的长度。 滑动窗口的精妙之处在于 : 根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。 如果没有接触过这一类的方法，很难想到类似的解题思路，滑动窗口方法还是很巧妙的。 模拟行为模拟类的题目在数组中很常见，不涉及到什么算法，就是单纯的模拟，考察对代码的掌控能力。 在这道题目中，我们再一次介绍到了循环不变量原则，其实这也是写程序中的重要原则。 相信大家有遇到过这种情况： 感觉题目的边界调节超多，一波接着一波的判断，找边界，拆了东墙补西墙，好不容易运行通过了，代码写的十分冗余，毫无章法，其实真正解决题目的代码都是简洁的，或者有原则性的，大家可以在这道题目中体会到这一点。 总结","link":"/Leetcode/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%8406-%E6%80%BB%E7%BB%93/"},{"title":"考研英语100句Day10","text":"考研英语100句–Day10Sentence 46While the researchers assumed that the well-structured daily plans would be most effective when it came to the execution of tasks, they were wrong: the detailed daily plans demotivated students. 尽管研究人员认为，在执行任务时，详尽的每日目标是最为高效的，但他们错了，详细的每日计划使学生失去了动力。 单词 assume well-structured execution demotivate 词组 sb assumed that .. the execution of tasks when it came to .. the detailed daily plans Sentence 47While fossil fuels—coal, oil, gas—still generate roughly 85 percent of the world’s energy supply, it’s clearer than ever that the future belongs to renewable sources such as wind and solar. 虽然化石燃料——煤、石油、天然气——仍然占据世界能源供应的85%左右，但比以往任何时候都更明显的是，未来属于风能和太阳能等可再生能源。 单词 fossil coal, oil, gas—still generate roughly 词组 fossil fuels energy supply it’s clear than the future belongs to .. renewable sources Sentence 48Only if the jobless arrive at the jobcentre with a CV, register for online job search, and start looking for work will they be eligible for benefit—and then they should report weekly rather than fortnightly. 只有当失业者带着简历来到就业服务中心，注册在线求职，并开始寻找工作，他们才有资格获得补助金，然后他们应该每周而不是每两周汇报一次求职情况。 单词 jobcentre the jobless register eligible fortnightly 词组 register for online job search start looking for work be eligible for benefit Sentence 49It is not that pink is intrinsically bad, but it is such a tiny slice of the rainbow and, though it may celebrate girlhood in one way, it also repeatedly and firmly fuses girls’ identity to appearance. 究其本质，粉红色本身并没有什么不好，它只不过是彩虹上微小的一抹。虽然从某种程度上来说它歌颂了少女时代，但它也反复且坚定地把女孩的个性和外表融合起来。 单词 intrinsically celebrate firmly fuse identity appearance 词组 such a tiny slice of the rainbow in one way fuse girls’ identity to appearance Sentence 50Here, Darwinism seems to offer justification, for if all humans share common origins, it seems reasonable to suppose that cultural diversity could also be traced to more constrained beginnings. 在此，达尔文学说似乎给出了合理化的解释，这是因为如果整个人类有相同的起源，那么我们就有理由认为，文化多样性同样也可以追溯到更为有限的开端。 单词 justification 解释；理由 reasonable diversity constrained 词组 it seems to offer justification share common origins suppose that .. cultural diversity be traced to more constrained beginnings","link":"/%E8%8B%B1%E8%AF%AD/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD100%E5%8F%A5day10/"},{"title":"考研英语100句Day1","text":"考研英语100句–Day1Sentence 01 We become defensive when criticised, and apply negative stereotypes to others to boost our own esteem. 一旦受到批评，我们就会为自己辩护，并将他人定格为消极的老套形象，以此增强自己的 自尊心。 单词 defensive criticised negative stereotypes boost esteem 词组 when criticised apply sth to sb boost our esteem Sentence 02Devoted concertgoers who reply that recordings are no substitute for live performance are missing the point. 那些忠诚的音乐会听众回应说现场演出绝非是唱片所能替代的，可这些听众没有领会到问题 的关键点。 单词 devoted concertgoers recordings substitute live performance 词组 recordings are no substitute for live performance miss the point Sentence 03Ants keep predatory insects away from where their aphids feed; Gmail keeps the spammers out of our inboxes. 蚂蚁让食肉昆虫远离蚜虫进食的地方；谷歌邮箱让滥发垃圾邮件的人远离我们的收件箱。 单词 predatory insect aphid spammer 词组 keep sb away from sb Sentence 04At the same time, people continue to treat fire as an event that needs to be wholly controlled and unleashed only out of necessity. 与此同时，人们继续把用火视为一种需要全面控制的事件，只有在必要之时才放出来使用。 单词 wholly unleash 词组 continue to do sth needs to be wholly controlled needs to be unleashed only out of necessity treat fire as an event .. Sentence 05As boards scrutinize succession plans in response to shareholder pressure, executives who don’t get the nod also may wish to move on. 在董事会迫于股东的压力严格审查继任计划的时候，那些没被选中的高管们也可能想离开。 单词 boards scrutinize succession plans shareholder executive 词组 in response to sth get the nod wish to do move on","link":"/%E8%8B%B1%E8%AF%AD/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD100%E5%8F%A5day1/"},{"title":"考研英语100句Day11","text":"考研英语100句–Day11Sentence 51If you are working on a word processor, you can take advantage of its capacity to make additions and deletions as well as move entire paragraphs by making just a few simple keyboard commands. 尽如果你正借助文字处理软件进行工作，只需通过几个简单的键盘指令，你就可以利用它来进行删减、增加或移动整段文字。 单词 processor 词组 take advantage of its capacity to .. move entire paragraphs make commands Sentence 52This success, coupled with later research showing that memory itself is not genetically determined, led Ericsson to conclude that the act of memorizing is more of a cognitive exercise than an intuitive one. 这次的成功，加上后来表明记忆本身不由基因决定的研究，让埃里克森得出结论：记忆行为与其说是一种直觉性的活动，不如说是一种认知性的活动。 单词 genetically cognitive intuitive 词组 coupled with showing that genetically determined lead sb to conclude that .. the act of memorizing sth is more of a cognitive exercise than an intuitive one Sentence 53That’s because Congress has always envisioned joint federal-state immigration enforcement and explicitly encourages state officers to share information and cooperate with federal colleagues. 那是因为美国国会一直希望联邦政府能与州政府联合执行移民法案，并明确鼓励州政府官员与联邦政府的同事加强合作、信息共享。 单词 Congress federal-state immigration enforcement explicitly encourage colleague cooperate 词组 has always envisioned joint sb sth explicitly encourages sb to do cooperate with sb. Sentence 54Ministers should also look at creating greater certainty in the rental environment, which would have a significant impact on the ability of registered providers to fund new developments from revenues. 部长们也应该考虑提高房屋租赁市场的稳定性，这对注册供应商从收入中拨出资金来进行新的开发会产生重大的影响。 单词 Minister certainty rental revenue fund n.基金、钱 v.投资 词组 should look at doing 应该考虑做某事 create greater certainty in the rental environment have a significant impact on .. Sentence 55Such hijacked media are the opposite of earned media: an asset or campaign becomes hostage to consumers, other stakeholders, or activists who make negative allegations about a brand or product. 这种被操纵的媒体和赚钱的媒体完全不同：一项资产或一场活动受那些对某个品牌或产品有不满说法的消费者、其他利益相关者或积极分子所左右。 单词 hijacked asset campaign hostage stakeholder brand allegation 词组 hijacked media sth is the opposite of sth who make negative allegations about a brand or product make negative allegations about sth becomes hostage to sb 受某人左右","link":"/%E8%8B%B1%E8%AF%AD/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD100%E5%8F%A5day11/"},{"title":"考研英语100句Day12","text":"考研英语100句–Day12Sentence 56The policy follows similar efforts from other journals, after widespread concern that basic mistakes in data analysis are contributing to the irreproducibility of many published research findings. 这项政策效仿了与其他杂志类似的尝试，此前人们普遍担忧数据分析中的基本错误正导致许多已发表的研究结果无法被再现。 单词 policy widespread irreproducibility 词组 follows similar efforts from other journals widespread concern that .. sth are contributing to .. the irreproducibility of published research findings Sentence 57They should exhibit strong interest and respect for whatever currently interests their fledgling adult （as naive or ill conceived as it may seem） while becoming a partner in exploring options for the future. 对当前让这些羽翼未丰的成年人感兴趣的任何事物（也许看上去很幼稚或欠考虑周全），父母都应该表现出强烈的兴趣和尊重，同时要成为他们的伙伴，与他们一起探索未来的选择。 单词 exhibit fledgling conceived 词组 exhibit strong interest and respect become a partner in doing sth explore options for the future 探索未来的选择 as naive or ill conceived as it may seem ill conceived Sentence 58In other words, at a time when the working class has turned the country on its political head, frustrated that the opportunity that once defined America is vanishing, one obvious solution is staring us in the face. 换句话说，在工人阶级彻底改变这个国家的政治格局，对曾经使美国之所以成为美国的机会正在消失而感到沮丧的时候，一个显而易见的解决方案就摆在我们面前。 单词 frustrated opportunity vanish 词组 In other words at a time when .. the working class 工人阶级 turned the country on its political head one obvious solution is staring us in the face Sentence 59Brain researchers have discovered that when we consciously develop new habits, we create parallel synaptic paths, and even entirely new brain cells, that can jump our trains of thought onto new, innovative tracks. 大脑研究人员发现，当我们有意识地培养新习惯的时候，大脑会创建出平行的突触路径，甚至是全新的脑细胞，这样可以使我们的思路跳转到全新的、创造性的轨道中。 单词 consciously certainty parallel synaptic innovative 词组 discovered that .. develop new habits synaptic paths jump our trains of thought onto new, innovative tracks trains of thought innovative track Sentence 60This type of integrity requires well-enforced laws in government transparency, such as records of official meetings, rules on lobbying, and information about each elected leader’s source of wealth. 这种廉政要求在政府透明度方面有严格执行的法律，如官方会议记录、游说规则以及每位当选领导人的财富来源的信息。 单词 integrity transparency lobbying 词组 well-enforced law official meetings rules on .. source of wealth","link":"/%E8%8B%B1%E8%AF%AD/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD100%E5%8F%A5day12/"},{"title":"考研英语100句Day13","text":"考研英语100句–Day13Sentence 61In the past couple of weeks a quarrel has illustrated the value to advertisers of such fine-grained information: Should advertisers assume that people are happy to be tracked and sent behavioural ads? 在过去几周里，一场争论已经阐明了这种精确的信息对于广告商的价值：广告商是否可以认为用户愿意被追踪其在网络上的行为并接收基于他们在网络上的行为而制定的广告？ 单词 quarrel illustrate fine-grained assume behavioural 词组 the value to advertisers of such fine-grained information sb is happy to be tracked behavioural ads Sentence 62Last year, the Transportation Security Administration （ TSA ） found in a secret check that undercover investigators were able to sneak weapons—both fake and real—past airport security nearly every time they tried. 去年，美国运输安全管理局，在一次秘密检查中发现，便衣调查员几乎每次尝试私携武器——无论是伪造的武器还是真的武器——都能顺利通过机场安检。 单词 transportation security administration secret undercover investigator sneak weapon 词组 the Transportation Security Administration in a secret check nearly every time they tried Sentence 63California has asked the justices to refrain from a sweeping ruling, particularly one that upsets the old assumptions that authorities may search through the possessions of suspects at the time of their arrest. 加利福尼亚州已经要求法官们避免做出一刀切的裁决，尤其是不能做出那种颠覆了当局在逮捕嫌疑人时可以搜查其财产这些存在已久的假定的裁决。 单词 justice refrain 避免 particularly upset assumption authority possession suspect arrest 词组 ask sb to do sth refrain from refrain from a sweeping ruling search through at the time of their arrest Sentence 64Priestly explains how the deep blue color of the assistant’s sweater descended over the years from fashion shows to department stores and to the bargain bin in which the poor girl doubtless found her garment. 普里斯特利解释了这位助理身上这件针织衫所采用的深蓝色这些年来是如何从时装秀没落到百货商店，最后沦落到商品打折处理区的，而这位可怜的女孩无疑是在那里淘到了这件衣服。 单词 explain assistant sweater descend bargain doubtless garment 词组 over the years the bargain bin Sentence 65If the district is essentially giving a pass to students who do not do their homework because of complicated family lives, it is going riskily close to the implication that standards need to be lowered for poor children. 如果该学区让那些因为家庭环境复杂而不做家庭作业的学生通过考试的话，那么这就危险地近乎于暗示着，对于贫穷的孩子，学业标准需要降低。 单词 district essentially 实质上 complicated implication 暗示 standard 词组 give a pass to sb because of complicated family lives it is going riskily close to sth","link":"/%E8%8B%B1%E8%AF%AD/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD100%E5%8F%A5day13/"},{"title":"考研英语100句Day14","text":"考研英语100句–Day14Sentence 66The findings of a research institution have consistently shown that workers in all countries can be trained on the job to achieve radically higher productivity and, as a result, radically higher standards of living. 一所研究机构的研究结果一致表明，所有国家的工人都可以通过在岗培训，从根本上提高生产率，从而从根本上提高生活水平。 单词 institution consistently achieve radically productivity 词组 achieve radically higher productivity as a result higher standards of living Sentence 67Their analysis ruled out the possibility that it was firms’ political influence, rather than their CSR stand, that accounted for the leniency: Companies that contributed more to political campaigns did not receive lower fines. 他们的分析排除了这样的可能性，即：是公司的政治影响力，而非他们的企业社会责任立场让公司获得了宽大处理，因为那些支持政治运动更多的公司并没有被处以更少的罚金。 单词 analysis firm political leniency campaign 词组 rule out 排除 political influence that accounted for the leniency accounte for 解释 receive lower fines contribute more to political campaign Sentence 68The potential evolution of today’s technology, and its social consequences, is dazzlingly complicated, and it’s perhaps best left to science fiction writers and futurologists to explore the many possibilities we can envisage. 当今科技的潜在发展及其社会影响惊人地复杂，或许我们最好把诸多可能留给科幻作家和未来学家去探索。 单词 potential evolution technology consequence dazzlingly 眼花缭乱地 complicated 复杂的 explore envisage 词组 social consequences be left to sb science fiction writers explore the many possibilities we can envisage Sentence 69The company, a major energy supplier in New England, provoked justified outrage in Vermont last week when it announced it was reneging on a longstanding commitment to abide by the strict nuclear regulations. 当上周新英格兰地区的主要能源供应商宣布它将放弃遵守严格的核安全条例这一长期承诺时，该公司在佛蒙特州激起了民众无可厚非的愤怒。 单词 provoke 激怒、挑衅 justified 正当的 outrage 愤怒 announce renege 背叛 longstanding 长期坚持的 commitment 承诺 abide 遵守 regulation 规章、法规 词组 a major energy supplier be reneging on sth a longstanding commitment Sentence 70Of all the changes that have taken place in English-language newspapers during the past quarter-century, perhaps the most far-reaching has been the inexorable decline in the scope and seriousness of their arts coverage. 在过去的25年英文报纸所发生的变化中，影响最深远的可能是其艺术方面的报道在范围和严肃程度上都不可阻挡地下降了。 单词 quarter-century far-reaching inexorable 坚决的、不可阻挡的 decline scope seriousness coverage 词组 take place in English-language newspapers during the past quarter-century the most far-reaching 影响最深远的 inexorable decline in ..","link":"/%E8%8B%B1%E8%AF%AD/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD100%E5%8F%A5day14/"},{"title":"考研英语100句Day15","text":"考研英语100句–Day15Sentence 71Infants are wired to look at parents’ faces to try to understand their world, and if those faces are blank and unresponsive — as they often are when absorbed in a device — it can be extremely disconcerting for the children. 婴幼儿天生会观察父母的表情，试图理解他们的世界，如果父母的脸上毫无表情和反应——沉浸于电子设备时经常如此——这会让孩子们极其不安。 单词 infant unresponsive absorbed extremely disconcerting 词组 are wired to do .. 天生就会做.. try to understand their world when absorbed in a device be extremely disconcerting for sb. Sentence 72Scientists have found that although we are prone to snap overreactions, if we take a moment and think about how we are likely to react, we can reduce or even eliminate the negative effects of our quick, hard-wired responses. 科学家们已经发现：虽然我们易于快速做出过度反应，但是如果我们花点时间考虑一下我们可能会做何反应，就可以减少，甚至是消除我们快速、本能的反应所带来的消极影响。 单词 prone 易于的，俯卧的，有倾向的.. snap 折断，快照，突然的 overreaction 过度反应 reduce eliminate 消除 词组 have found that .. be prone to do sth.. 易于，有倾向于做某事 be prone to snap overreactions take a moment and think about how .. how we are likely to react be likely to do .. reduce the negative effects of our hard-wired responses hard-wired responses Sentence 73Further arrangements — and there may be many — between the NHS and DeepMind will be carefully scrutinised to ensure that all necessary permissions have been asked of patients and all unnecessary data has been cleaned. 英国国民医疗服务体系（NHS）和DeepMind之间的进一步的协议——也许还有很多协议——将受到仔细审查，以确保从病人那里获得了所有必要的许可，以及所有不必要的数据都已被清除。 单词 arrangement scrutinize 审查 ensure permission 词组 further arrangements be carefully scrutinised to ensure that necessary permission Sentence 74Studies of both animals and humans have shown that sex hormones somehow affect the stress response, causing females under stress to produce more of the trigger chemicals than do males under the same conditions. 对动物和人类的研究表明：性激素会以某种方式影响应激反应，使处于压力下的雌性比处于相同条件下的雄性产生更多的能触发不良反应的化学物质。 单词 hormone somehow affect chemical 词组 sex hormones affect the stress response under stress causing females under stress to produce more of the trigger chemicals under the same conditions trigger chemical Sentence 75“Carry a book with you at all times” can actually work too – providing you dip in often enough, so that reading becomes the default state from which you temporarily surface to take care of business, before dropping back down. 如果你能经常翻阅的话，“随时携带一本书”这种方式也能奏效，从而让阅读成为你的常态，你可以在需要处理事务的时候从书中暂时抽离出来，之后再重新开始阅读。 单词 actually temporarily dip 浸入，深入 词组 Carry a book with you at all times dip in often enough default state drop back down","link":"/%E8%8B%B1%E8%AF%AD/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD100%E5%8F%A5day15/"},{"title":"考研英语100句Day16","text":"考研英语100句–Day16Sentence 76Today, widespread social pressure to immediately go to college in conjunction with increasingly high expectations in a fast-moving world often causes students to completely overlook the possibility of taking a gap year. 如今，高中毕业后即刻升入大学这一普遍的社会压力，加之快速发展的世界对学生寄予越来越高的期望，这常常导致学生完全忽略了选择间隔年这一可能。 单词 widespread immediately expectation conjunction overlook 词组 widespread social pressure go to college increasingly high expectations in a fast-moving world in conjunction with the possibility of taking a gap year cause sb. to do sth. Sentence 77It could be that we are evolving two communities of social scientists: one that is discipline-oriented and publishing in highly specialized journals, and one that is problem-oriented and publishing elsewhere, such as policy briefs. 这可能是因为我们发展出了两类社会科学家群体：一类是学科导向型并在高度专业的期刊上发表文章，另一类是问题导向型并在如政策简报等其他地方发表文章。 单词 evolve community discipline-oriented problem-oriented brief 词组 two communities of social scientists publish in highly specialized journals Sentence 78Steelworkers, airline employees, and now those in the auto industry are joining millions of families who must worry about interest rates, stock market fluctuation, and the harsh reality that they may outlive their retirement money. 炼钢工人、航空公司职员，以及现在那些在汽车行业的员工都正在加入那些不得不担心利率股市波动和退休金不够用这一残酷现实的数百万家庭的行列。 单词 steelworkers worry about interest rate 利率 fluctuation harsh outlive 词组 the harsh reality retirement money Sentence 79After all, four decades of evidence has now shown that corporations in Europe as well as the US are evading the meritocratic hiring and promotion of women to top position — no matter how much “soft pressure” is put upon them. 毕竟四十年的事实现已表明，不管被施加多大的“软压力”，欧洲和美国的企业一直在回避英才管理制度，限制女性晋升到高层。 单词 decade corporation evade meritocratic promotion 词组 after all four decades of evidence has now shown that .. no matter how .. as well as the meritocratic hiring Sentence 80His analysis should therefore end any self-contentedness among those who may believe that the global position of English is so stable that the young generation of the United Kingdom do not need additional language capabilities. 有些人可能认为英语的全球地位如此稳定以至于英国的年轻一代不需要获得额外的语言能力；他的分析应该会结束那些人的自满情绪。 单词 self-contentedness 自满 stable generation additional capability 词组 end any self-contentedness among those who .. the global position of English the young generation of the United Kingdom additional language capabilities","link":"/%E8%8B%B1%E8%AF%AD/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD100%E5%8F%A5day16/"},{"title":"考研英语100句Day17","text":"考研英语100句–Day17Sentence 81The Internet — and pressure from funding agencies, who are questioning why commercial publishers are making money from government-funded research by restricting access to it — is making access to scientific results a reality. 提供资金的机构施加压力，质疑为什么商业出版商可以通过限制人们查看政府资助的研究结果而从中牟利，来自这方面的压力和互联网正在使阅读科研结果成为现实。 单词 agency commercial restrict 限制 词组 funding agencies commercial publisher make money from government-funded research by restricting access to it make access to sth a reality make sth a reality Sentence 82There is pressure for change from within the profession, but opponents of change among the regulators insist that keeping outsiders out of a law firm isolates lawyers from the pressure to make money rather than serve clients ethically. 在行业内部存在着改革的压力，但是监管部门中反对变革的人坚称，将外部人士排除在律师事务所之外，可以让律师远离赚钱的压力，从而遵守职业道德为委托人服务。 单词 opponent regulator 调整者，规定者 insist 坚持 ethically 道德上 词组 within the profession keep outsiders out of a law firm isolate lawyers from the pressure to make money rather than serve clients Sentence 83The force of geographic conditions peculiar to America, the interplay of the varied national groups upon one another, and the sheer difficulty of maintaining old-world ways in a raw, new continent caused significant changes. 美国特有的地理条件的影响，不同民族之间的相互作用，以及在这片原始新大陆上维持旧有方式的困难，这些因素引起了重大的变化。 单词 force geographic peculiar 特别的，奇异的 interplay sheer continent significant 词组 peculiar to the varied national groups Sentence 84Yet, when one looks at the photographs of the garden created by the homeless, it strikes one that, for all their diversity of styles, these gardens speak of various other fundamental urges, beyond that of decoration and creative expression. 然而，当人们看到那些无家可归者所创建的花园的照片时，受到了深深的震撼：尽管这些花园风格多样，但它们除了表现出创作者的装饰和创造力表达的需求之外，还表现出各种其他根本的需求。 单词 photograph strike diversity fundamental urge decoration 装饰 词组 it strikes one that the diversity of styles creative expression Sentence 85Under the plan, for example, the agency said it would not prosecute landowner or businesses that unintentionally kill, harm, or disturb the bird, as long as they had signed a range-wide management plan to restore prairie chicken habitat. 例如，根据此项计划，只要他们签署了一项大范围的管理计划来恢复小草原松鸡的栖息地，该管理局称其不会起诉那些无意杀死、伤害或干扰小草原松鸡的土地所有者或企业。 单词 prosecute landowner unintentionally disturb restore prairie habitat 词组 under the plan as long as sign a range-wide management plan","link":"/%E8%8B%B1%E8%AF%AD/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD100%E5%8F%A5day17/"},{"title":"考研英语100句Day18","text":"考研英语100句–Day18Sentence 86In his article “How Intelligent Is Intelligence Testing?”, Sternberg notes that traditional tests best assess analytical and verbal skills but fail to measure creativity and practical knowledge, components also critical to problem solving and life success. 在斯腾伯格的文章《智力测试有多明智？》中，他指出传统的测试能最大程度地评估分析能力和语言表达能力，但不能衡量创造力和实践知识，这些部分对于解决问题和获得人生成功也极其重要。 单词 intelligent traditional critical component 词组 he notes that .. analytical and verbal skills measure creativity and practical knowledge critical to problem solving and life success Sentence 87At a time when Thomas Piketty and other economists are warning of rising inequality and the increasing power of inherited wealth, it is bizarre that wealthy aristocratic families should still be the symbolic heart of modern democratic states. 在托马斯·皮凯蒂和其他经济学家提醒民众警惕不断加剧的不平等现象和不断增加的继承财富的权力时，这些富有的贵族家庭仍然是现代民主国家的象征性核心，这是很奇怪的。 单词 economist inherit 继承 bizarre 奇怪的 aristocratic 贵族的 democratic 民主的 词组 at a time when .. warn of sth rising inequality the increasing power of inherited wealth Sentence 88Calls to disassemble all telescopes on Mauna Kea or to ban future development there ignore the reality that astronomy and Hawaiian culture both seek to answer big questions about who we are, where we come from and where we are going. 拆除莫纳克亚山上所有的望远镜或禁止未来在那里新建望远镜的呼声忽略了这样一个事实，即天文学和夏威夷文化都在寻求关于“我们是谁”“我们来自哪里”“我们要去何处”这些重大问题的答案。 单词 disassemble telescope astronomy 天文学 词组 ignore the reality that .. seek to answer big questions about .. Sentence 89Humans are unique in their capacity to not only make tools but then turn around and use them to create superfluous material goods—paintings, sculpture and architecture— and superfluous experiences—music, literature, religion and philosophy. 人类的独特之处在于，他们不仅有能力制造工具，而且还能反过来使用工具来创作额外的有形物品——绘画、雕塑和建筑——和额外的精神体验——音乐、文学、宗教和哲学。 单词 superfluous 额外的 material sculpture architecture experience literature religion philosophy 词组 are unique in their capacity to .. turn around Sentence 90As a discovery claim works its way through the community, the interaction and confrontation between shared and competing beliefs about the science and the technology involved transforms an individual’s discovery claim into the community’s credible discovery. 当一个发现声明逐步通过科学界的审查时，与该科技相容和矛盾的观点就会相互作用和对抗，这样就会把个人的发现声明转变为科学界的可靠发现。 单词 discovery claim community interaction confrontation individual credible 词组 transforms sth. into sth.","link":"/%E8%8B%B1%E8%AF%AD/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD100%E5%8F%A5day18/"},{"title":"考研英语100句Day19","text":"考研英语100句–Day19Sentence 91But in her new book Join the Club, Tina Rosenberg contends that peer pressure can also be a positive force through what she calls the social cure, in which organizations and officials use the power of group dynamics to help individuals improve their lives and possibly the world. 但是，蒂娜·罗森堡在她的新书《加入俱乐部》中主张，同辈压力也可以通过她所说的“社会治疗”转化成一种积极的力量。在社会治疗的过程中，各机构及官员可以利用群体动力来帮助个人改善生活，甚至可能改善整个世界。 单词 contend cure 词组 peer pressure a positive force the social cure help individuals improve their lives Sentence 92Fundamentally, the USPS is in a historic squeeze between technological change that has permanently decreased demand for its bread-and-butter product, first-class mail, and a regulatory structure that denies management the flexibility to adjust its operations to the new reality. 从根本上说，美国邮政署（USPS）正处于一个历史性的困境之中，一方面是技术变革永久性地降低了对其主要产品——普通邮件的需求，另一方面是监管结构拒绝让管理部门灵活调整其业务以适应新形势。 单词 fundamentally historic squeeze permanently decrease demand deny flexibility operations 经营，手术，操作，执行 词组 in a historic squeeze permanently decreased demand for sth. its bread-and-butter product adjust its operations to the new reality Sentence 93Unhappy parents rarely are provoked to wonder if they shouldn’t have had kids, but unhappy childless folks are bothered with the message that children are the single most important thing in the world: obviously their misery must be a direct result of the gaping baby-size holes in their lives. 几乎没有事情会促使不幸福的父母去琢磨自己是否不该养孩子，但是不幸福的且没有孩子的人们却总是被“孩子是世上唯一最重要的东西”这一信息所困扰：显然他们的不幸肯定是他们一生中没有孩子的缺憾造成的。 单词 rarely provoke 诱导，挑衅，煽动 folks 人们 obviously misery 词组 be provoked to wonder if they should .. be bothered with sth .. must be a direct result of sth. Sentence 94To encourage innovation and competition, the report calls for increased investment in research, the crafting of coherent curricula that improve students’ ability to solve problems and communicate effectively in the 21st century, increased funding for teachers and the encouragement of scholars to bring their learning to bear on the great challenges of the day. 为了鼓励创新和竞争，报告呼吁增加对此项研究的投资，呼吁精心设计系统连贯的课程以提高学生在21世纪解决问题和有效沟通的能力，呼吁增加教师的经费，并鼓励学者应用他们的学识来应对当今巨大的挑战。 单词 encourage innovation competition investment craft 制定 coherent 配套的，连贯的 curricula 课程表，课程 词组 calls for sth .. 呼吁 increased investment in research increased funding for teachers improve students’ ability to solve problems communicate effectively bring their learning to bear on the great challenges of the day Sentence 95Moreover, average overall margins are higher in wholesale than in retail; wholesale demand from the food service sector is growing quickly as more Europeans eat out more often; and changes in the competitive dynamics of this fragmented industry are at last making it feasible for wholesalers to consolidate. 此外，批发业的平均总利润高于零售业；随着越来越多的欧洲人更加频繁地外出就餐，餐饮服务业的批发需求也迅速增长；这一零散产业竞争力量的变化最终会使批发商们的联合成为可能。 单词 moreover overall margin wholesale retail sector 行业 competitive fragmented feasible 可行的 consolidate 整顿，整并 词组 average overall margins this fragmented industry","link":"/%E8%8B%B1%E8%AF%AD/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD100%E5%8F%A5day19/"},{"title":"考研英语100句Day2","text":"考研英语100句–Day2Sentence 06Everyone needs to find their extra – their unique value contribution that makes them stand out in whatever is their field of employment. 人人都需要找到自己的额外价值——让自己在任何所在职业领域中都脱颖而出的独特价值 贡献。 单词 extra unique value contribution stand out 词组 their field of employment make sb stand out Sentence 07It is also the reason why when we try to describe music with words, all we can do is articulate our reactions to it, and not grasp music itself. 这也是为什么当我们试图用语言来描述音乐时，我们所能做的只能是说清楚对音乐的感受， 而不能理解音乐本身。 单词 articulate reactions grasp 词组 It is also the reason why try to describe music with words articulate our reactions to it grasp music itself Sentence 08Scientists jumped to the rescue with some distinctly shaky evidence to the effect that insects would eat us up if birds failed to control them. 科学家们立即拿出某些明显站不住脚的证据前来“救驾”，其大意是说如果鸟儿不能控制这 些昆虫的数量的话，昆虫就会吃光一切。 单词 scientists distinctly shaky evidence rescue 词组 jump to the rescue some distinctly shaky evidence eat us up failed to control sth Sentence 09A moralist, satirist, and social reformer, Dickens crafted complex plots and striking characters that capture the panorama of English society. 作为一位道德家、讽刺作家和社会改革家，狄更斯精心设计了复杂的情节和引人注目的人物， 捕捉了英国社会的全貌。 单词 moralist satirist social reformer complex plots striking characters capture panorama 词组 capture the panorama of English society Sentence 10Half a century of town and country planning has enabled it to retain an enviable rural coherence, while still permitting low-density urban living. 半个世纪的城乡规划使其（英国）得以保留令人羡慕的乡村和谐，同时仍允许低密度的城镇 生活。 单词 century retain enviable rural coherence permitting low-density 词组 low-density urban living has enabled it to retain an enviable rural coherence","link":"/%E8%8B%B1%E8%AF%AD/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD100%E5%8F%A5day2/"},{"title":"考研英语100句Day20","text":"考研英语100句–Day20Sentence 96Just as bosses and boards have finally sorted out their worst accounting and compliance troubles, and improved their feeble corporation governance, a new problem threatens to earn them — especially in America — the sort of nasty headlines that inevitably lead to heads rolling in the executive suite: data insecurity. 就在老板和董事会终于处理好其最严重的财务和规章问题，改善了公司薄弱的管理之后，又一个新问题正威胁着他们——尤其是在美国——这个问题就是数据不安全性，这会让他们出现在令人不快的新闻头条中，将不可避免地使高层们受到严惩。 单词 feeble corporation governance threaten insecurity nasty headline inevitably executive 行政的，执行官 词组 sort out accounting and compliance troubles a new problem threatens to earn them the sort of nasty headlines Sentence 97The article is actually quite optimistic, as it outlines a potential solution to this problem, suggesting that an approach（which involves a one-hour, next-to-no-cost program） can close 63 percent of the achievement gap（measured by such factors as grades） between first-generation and other students. 这篇文章实际上相当乐观，因为它针对这个问题简要描述了一种可能的解决方案，表示有一种方式（一个耗时一小时、几乎零成本的项目）能够缩小第一代大学生和其他学生之间63%的成绩差距（以分数等指标衡量）。 单词 optimistic 乐观的 outline potential achievement involve factor 词组 a potential solution to this problem Sentence 98Precisely because readers from different historical periods, places and social experiences produce different but overlapping readings of the same words on the page — including for texts that engage with fundamental human concerns—debates about texts can play an important role in social discussion of beliefs and values. 正因为来自不同历史时期、不同地域和有着不同社会经历的读者会对页面上那些相同的文字产生不同但有重叠的解读——包括对涉及人类所关注的基本问题的文本解读，关于文本解读的争议才能在信仰和价值观的社会讨论中发挥重要作用。 单词 precisely 正确地，清晰地 historical period overlapping engage debate discussion 词组 different historical periods they produce different but overlapping readings of the same words on the page texts that engage with fundamental human concerns play an important role in .. debates about texts can play an important role in social discussion of beliefs and values. Sentence 99At Tulane University’s Tear Analysis Laboratory, Dr.Peter Kastl and his colleagues report that they can use tears to detect drug abuse and exposure to medication, to determine whether a contact lens fits properly or why it may be uncomfortable, to study the causes of “dry eye” syndrome and the effects of eye surgery, and perhaps even to measure exposure to environmental pollutants. 在杜兰大学的眼泪分析实验室，彼得·卡斯尔博士和他的同事报告称，他们可以用眼泪来检测出滥用毒品及使用药物的情况，确认隐形眼镜戴起来是否合适或者是戴着不舒适的原因，还能用来探究“干眼”综合征产生的原因和眼部手术的效果，也许甚至还能用来测量与环境污染物接触的情况。 单词 Laboratory colleague detect exposure abuse contact 接触 syndrome surgery pollutant 污染物 词组 report that .. detect drug abuse detect exposure to medication a contact lens 隐形眼镜 sth. fit properly study the causes of .. 探究..的原因 environmental pollutants Sentence 100Young people who are still getting started in life were more likely than older adults to prioritize personal fulfillment in their work, to believe they will advance their careers most by regularly changing jobs, to favor communities with more public services and a faster pace of life, to agree that couples should be financially secure before getting married or having children, and to maintain that children are best served by two parents working outside the home, the survey found. 该调查发现，比起老年人，那些仍然处在生活起跑线的年轻人会更优先考虑他们在工作中的个人成就，更加认同通过定期换工作来推进个人职业生涯，更喜欢拥有较多公共服务的社区和节奏更快的生活，更坚信夫妻在结婚或者抚育孩子之前应该有经济上的保障，更主张父母双方都在外工作才能给孩子提供最好的生活。 单词 prioritize 给..优先权 fulfillment 成就，满足感，实现 advance pace 步伐 secure maintain survey 词组 be likely to do .. personal fulfillment be financially secure get married","link":"/%E8%8B%B1%E8%AF%AD/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD100%E5%8F%A5day20/"},{"title":"考研英语100句Day3","text":"考研英语100句–Day3Sentence 11Integrity had collapsed, she argued, because of a collective acceptance that the only “sorting mechanism” in society should be profit and the market. 她认为，诚信已瓦解，因为我们集体接受的观念是，社会中唯一的“分选机制”应该是利润和市场。 单词 argue integrity collapse a collective acceptance profit mechanism 词组 because of a collective acceptance that .. Sentence 12We need them to imagine the United States as a place where they can be productive for a while without committing themselves to staying forever. 我们需要他们把美国想象为这样一个地方，在这里他们可以在一段时间内创造价值，而无需承诺永久居留于此。 单词 productive commit 词组 imagine the United States as a place where .. need sb to do sth be productive for a while without committing themselves to staying forever Sentence 13The issue of voluntary part-time relates to Obamacare because one of the main purposes was to allow people to get insurance outside of employment. 自愿兼职工作这一问题与奥巴马医改计划相关联，因为该计划的主要目的之一就是让人们不就业也能得到医疗保险。 单词 issue voluntary insurance purpose 词组 one of the main purposes is to do .. allow people to do .. get insurance outside of employment Sentence 14Firms are now studying how genes interact, looking for correlations that might be used to determine the causes of disease or predict a drug’s efficacy. 一些公司正在研究基因是如何相互作用的，寻找可能用来确定病因或者预测药物疗效的相关性。 单词 firm correlation determine cause disease predict efficacy 词组 how genes interact Sentence 15Dead markets partly reflect the paralysis of banks which will not sell assets for fear of booking losses, yet are reluctant to buy all those supposed bargains. 毫无活力的市场一定程度上反映了银行系统的瘫痪，由于担心账面损失，银行不会出售资产，但也不愿意收购那些所谓的廉价资产。 单词 reflect paralysis asset supposed bargain reluctant 词组 dead market for fear of booking losses supposed bargain","link":"/%E8%8B%B1%E8%AF%AD/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD100%E5%8F%A5day3/"},{"title":"考研英语100句Day4","text":"考研英语100句–Day4Sentence 16He adds humbly that perhaps he was “superior to the common run of men in noticing things which easily escape attention, and in observing them carefully”. 他谦虚地补充道，或许他“优于常人的地方在于能够注意到容易被忽视的东西，并对这些东西进行仔细观察”。 单词 humbly perhaps superior escape observing 词组 the common run of men in noticing things easily escape attention Sentence 17Many leading American universities want their undergraduates to have a grounding in the basic canon of ideas that every educated person should possess. 许多顶尖的美国大学都希望他们的本科生接受对一些基本的、富含思想的经典作品的基础教学，这些思想是每个受教育人士都应该有的。 单词 undergraduate possess canon 词组 every educated person the basic canon of ideas have a grounding in … Sentence 18Buying gifts or giving to charity is often more pleasurable than purchasing things for oneself, and luxuries are most enjoyable when they are consumed sparingly. 买礼物或给慈善机构捐款往往会比给自己买东西更让人开心，有节制地消费奢侈品才会给人以最大的愉悦。 单词 charity pleasurable purchase luxuries sparingly consume 词组 when they are consumed sparingly Sentence 19These benefactors have succeeded in their chosen fields, they say, and they want to use their wealth to draw attention to those who have succeeded in science. 他们说，这些捐助者在各自所选择的领域都很成功，而且他们想用自己的财富让人们注意到那些在科学领域有所成就的人。 单词 benefactor 词组 have succeeded in their chosen fields draw attention to Sentence 20Perhaps faintly, they hint that people should look to intangible qualities like character and intellect rather than dieting their way to size zero or wasp-waist physiques. 这些禁令或许还隐约地暗示，人们应该注重如个性和才智等无形的品质，而不是通过节食来达到“零号身材”或“蜂腰体型”。 单词 faintly hint intangible qualities physiques wasp-waist 词组 should look to sth. diet their way to size zero or wasp-waist physiques","link":"/%E8%8B%B1%E8%AF%AD/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD100%E5%8F%A5day4/"},{"title":"考研英语100句Day5","text":"考研英语100句–Day5Sentence 21The Navy Department moved into the east wing in 1879, where elaborate wall and ceiling stenciling and marquetry floors decorated the office of the Secretary. 海军部门于 1879 年搬进了东翼，在那里，精心制作的墙壁、天花板上的镂花涂装和镶嵌工艺地板装饰着部长办公室。 单词 nacy department elaborate stenciling marquetry decorate Secretary 词组 NONE Sentence 22The researchers mapped not only the city’s vast and ornate ceremonial areas, but also hundreds of simpler apartment complexes where common people lived. 研究人员不仅绘制了这座城市广阔且装饰华丽的庆典区，还绘制了数百个普通民众居住的简单公寓建筑群。 单词 researcher vast ornate ceremonial apartment complexe 词组 map out Sentence 23It may be said that the measure of the worth of any social institution is its effect in enlarging and improving experience, but this effect is not a part of its original motive. 可以说，衡量任何社会制度价值的标准是其在扩大和改进经验上的成效，但这种成效并不是其最初动机的一部分。 单词 measure institution effect enlarge improve motive 词组 the measure of the worth of any social institution its effect in doing … original motive Sentence 24Our mental health doesn’t really go anywhere; like the sun behind a cloud, it can be temporarily hidden from view, but it is fully capable of being restored in an instant. 我们的心理健康并不是真的消失不见了；就像云朵背后的太阳，它也许暂时被遮挡，但是它完全可以在瞬间重焕光芒。 单词 mental go anywhere temporarily 词组 be hidden from view be fully capable of doing … in an instant be restored Sentence 25No boy who went to a grammar school could be ignorant that the drama was a form of literature which gave glory to Greece and Rome and might yet bring honor to England. 每个进入文法学校学习的学生都知道，戏剧是一种文学形式，这种文学形式赋予希腊和罗马以荣光，并且可能也会为英国带来荣耀。 单词 ignorant glory literature honor 词组 be ignorant that a form of literature give glory to .. bring honor to","link":"/%E8%8B%B1%E8%AF%AD/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD100%E5%8F%A5day5/"},{"title":"考研英语100句Day6","text":"考研英语100句–Day6Sentence 26The most loyal customers would still get the product they favor, the idea goes, and they’d feel like they were helping sustain the quality of something they believe in. 这个想法是这样：那些最忠诚的顾客依旧会购买他们喜欢的产品，他们会觉得这是在帮助维护他们所信任的产品的品质。 单词 loyal favor sustain 词组 sustain the quality of something they believe in Sentence 27But policymakers who refocus efforts on improving well-being rather than simply worrying about GDP figures could avoid the forecasted doom and may even see progress. 但是那些重新致力于改善福祉，而不仅仅是担心国内生产总值数据的决策者们，就能够避免可预见的厄运，甚至可能看到进步。 单词 policymakers refocus improve well-being figure avoid forecasted doom progress 词组 refocus efforts on rather than worry about avoid the forecasted doom Sentence 28Indeed, there is something a little absurd in the state getting involved in the planning of such a fundamentally “grassroots” concept as community sports associations. 确实，让国家参与像社区体育协会这样从根本上带有“草根阶层”意味的规划是有些荒唐的。 单词 Indeed absurd involve fundamentally concept community association 词组 a little absurd doing get involved in .. Sentence 29While few craftsmen or farmers, let alone dependents and servants, left literary compositions to be analyzed, it is obvious that their views were less fully intellectualized. 尽管很少有工匠或农场主能留下可供分析的文学作品，更不用说他们的随从和佣人了，但很明显他们的观点并不十分理性。 单词 craftsman servant literary composition analyze intellectualized 词组 let alone it is obvious that left literary compositions to be analyzed less fully intellectualized Sentence 30While comment and reaction from lawyers may enhance stories, it is preferable for journalists to rely on their own notions of significance and make their own judgments. 尽管来自律师们的评论和反馈可能会提高新闻报道的质量，但新闻记者最好还是依靠自己对事件重要性的认识而做出自己的判断。 单词 reaction enhance preferable journalist significance notion 词组 rely on their own notions of significance make their own judgments","link":"/%E8%8B%B1%E8%AF%AD/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD100%E5%8F%A5day6/"},{"title":"考研英语100句Day7","text":"考研英语100句–Day7Sentence 31Social media allows users to experience news events more intimately and immediately while also permitting them to re-share news as a projection of their values and interests. 社交媒体允许用户更密切、更迅速地体验新闻事件，同时也允许他们将新闻作为自己价值观和兴趣的投射而重新分享。 单词 experience intimately immediately permitte projection 词组 re-share sth as .. a projection of sth. Sentence 32According to research from Princeton University, people assess your competence, trustworthiness, and likeability in just a tenth of a second, solely based on the way you look. 根据普林斯顿大学的研究，人们会在仅仅十分之一秒的时间内，仅根据你的外表去评判你的能力、可信度及你受人喜欢的程度。 单词 assess competence trustworthiness likeability solely 词组 according to a tenth of a second based on the way you look Sentence 33Some attributed virtually every important cultural achievement to the inventions of a few, especially gifted people that, according to diffusionists, then spread to other cultures. 有些人认为，几乎每一项重要的文化成就都是由少数特别有天赋的民族所发明创造的，根据传播论者的看法，这些发明后来传播到了其他的文化中。 单词 invention virtually 几乎 cultural achievement diffusionist spread 词组 attributed sth to sb/sth 归因于 gifted people Sentence 34The upside is the possibilities contained in knowing that everything is up to us; where before we were experts in the array of limitations, now we become authorities of what is possible. 积极的一面是，既然万事都取决于我们，那么就有无限可能。以前，我们能够熟练应对种种局限；现在，我们把握着未来的可能。 单词 upside possibility authority 词组 be expert in .. become authorities of what is possible Sentence 35If people in the network just two degrees removed from the initial influential prove resistant, for example, the cascade of change won’t propagate very far or affect many people. 例如，如果网络中与最初的影响者只有两度之差的人被证明是有抵抗力的，那么这一连串的变化不会传播得很远，也不会影响很多人。 单词 cascade propagate 传播 resistant 词组 the cascade of change prove resistant two degrees removed from","link":"/%E8%8B%B1%E8%AF%AD/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD100%E5%8F%A5day7/"},{"title":"考研英语100句Day8","text":"考研英语100句–Day8Sentence 36In a workplace that’s fundamentally indifferent to your life and its meaning, office speak can help you figure out how you relate to your work—and how your work defines who you are. 在一个根本不关心你的生活及其意义的职场中，办公室用语能帮助你理清自己和工作的关系，以及工作对你的身份的定义。 单词 fundamentally 词组 is indifferent to your life and its meaning figure out how you relate to your work Sentence 37Conversations are links, which means when you have a conversation with a new person a link gets formed and every conversation you have after that moment will strengthen the link. 交谈是一种联系，这意味着当你和一个刚认识的人交谈时，一种联系就形成了，而在那之后的每一次交谈都会强化这一联系。 单词 strengthen 词组 which means .. have a conversation with a new person a link gets formed strengthen the link Sentence 38Researchers measured people’s cortisol, which is a stress marker, while they were at work and while they were at home and found it higher at what is supposed to be a place of refuge. 研究人员测量了人们在工作和在家时的皮质醇，它是一种压力标志，并发现在家这个理应是庇护所的地方，人们的皮质醇水平更高。 单词 measure cortisol refuge 词组 a stress marker what is supposed to be a place of refuge Sentence 39While Washington and Jefferson privately expressed distaste for slavery, they also understood that it was part of the political and economic bedrock of the country they helped to create. 尽管华盛顿和杰斐逊私下都表达过对奴隶制的不满，但是他们也明白，奴隶制是他们帮助创建的这个国家的政治和经济基础的一部分。 单词 privately express distaste slavery political economic bedrock 基石 词组 it is part of the political bedrock privately expressed distaste for .. Sentence 40When younger kids learn computer science, they learn that it’s not just a confusing, endless string of letters and numbers—but a tool to build apps, or create artwork, or test hypotheses. 当小孩子们学习计算机科学的时候，他们会发现它并不仅仅是一串令人困惑的、无穷无尽的字母和数字——它还是一种工具，这种工具能编写应用程序、创作艺术作品或测试假设。 单词 confusing hypotheses 词组 a tool to build apps test hypotheses","link":"/%E8%8B%B1%E8%AF%AD/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD100%E5%8F%A5day8/"},{"title":"考研英语100句Day9","text":"考研英语100句–Day9Sentence 41The Industrial Revolution didn’t go so well for Luddites whose jobs were displaced by mechanized looms, but it eventually raised living standards and created more jobs than it destroyed. 尽管工业革命在工作被机械化织布机取代的卢德派分子中进展并不顺利，但它最终提高了生活水平，并创造了比被它摧毁的工作岗位更多的就业机会。 单词 mechanized 词组 the Industrial Revolution go well for .. be displaced by .. living standards Sentence 42That ruling produced an explosion in business-method patent filings, initially by emerging internet companies trying to stake out exclusive rights to specific types of online transactions. 那项裁决使得商业方法专利申请文件数量激增，起初只是一些新兴的网络公司试图抢占对某些特定类型的在线交易方法的独家专有权。 单词 explosion ruling patent transaction exclusive 词组 produce an explosion in .. patent filings emerging companies stake out exclusive rights specific types of online transactions Sentence 43Even though there is plenty of evidence that the quality of the teachers is the most important variable, teachers’ unions have fought against getting rid of bad ones and promoting good ones. 虽然有充分的证据表明，教师素质是最重要的可变因素，但是教师工会却反对开除差教师、提拔好教师。 单词 evidence quality promote 词组 there is plenty of evidence that .. the quality of the teachers the most important variable get rid of .. 开除 fight against Sentence 44Yet most ancestry testing only considers a single lineage, either the Y chromosome inherited through men in a father’s line or mitochondrial DNA, which is passed down only from mothers. 然而，大多数血统检测只考虑单一的血统，要么只考虑来自父亲的男性遗传的Y 染色体，要么只考虑从母亲那里遗传的线粒体DNA。 单词 ancestry lineage chromosome inherit mitochondrial 词组 ancestry testing pass down Sentence 45Moreover, even though humans have been upright for millions of years, our feet and back continue to struggle with bipedal posture and cannot easily withstand repeated strain imposed by oversize limbs. 此外，尽管人类直立行走已达数百万年之久，但是我们的双脚和背部仍然在与两足行走的姿势作斗争，并且很难承受过长的四肢施加的持续压力。 单词 Moreover struggle posture strain withstand limbs 词组 even though continue to struggle with imposed by","link":"/%E8%8B%B1%E8%AF%AD/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD100%E5%8F%A5day9/"},{"title":"芯片验证漫游指南0","text":"本书从结构上分为四个部分，分别是： 验证的通识部分（第1章至第6章）： 具备不同经验的读者都可以从中获取验证世界的全貌。 第1章是对芯片验证的总览； 第2章从各个维度来介绍验证的策略； 第3章描述目前所有的验证方法； 第4章则从验证计划入手介绍如何量化验证； 第5章从验证管理的角度来论述其各个要素； 而第6章则作为进入下一部分（SystemVerilog语言）的准备来介绍验证环境的结构和组件。 SystemVerilog语言部分（第7章至第9章）： 该部分不同于以往的语言类学习书籍，它的重点不在于提供完整的语法要点，而是结合贯穿于本书的设计MCDF来展开实践，带领读者思考如何利用SV的主要特性去构建一个完整的验证环境。因此，该部分是从 验证环境基础要素学习（第7章）到 基本组件的实现（第8章），再到最后的 环境集成（第9章）。 这一部分对于缺少SV语言基础的读者会有帮助，同时建议参考对照SV语言的标准手册一同学习。对于具备SV经验的读者，阅读这一部分也会帮助其梳理以往容易出错的知识点。 UVM验证方法学部分（第10章至第14章）：通过SV语言部分的学习，读者可以利用MCDF的 SV 轻量级环境来理解验证环境的共性，包括环境的组织、构建、通信和运行。当进入到UVM部分时，建议读者逐章阅读，以此达到循序渐进的效果。 第10章带领读者游览UVM世界，了解其重要的各个特性； 第11章则仿照SV的学习步骤，给读者介绍UVM的各个组件和环境构成； 第12章是UVM的TLM通信部分； 第13章是UVM的运行部分，即介绍序列的各种用法； 第14章是平行于UVM结构的部分但又不可或缺，即寄存器模型部分。 从SV部分过渡到UVM部分的读者会在这部分的各章节中有似曾相似识的感觉，因为UVM的主要特性和结构已经在SV部分中有类似的实现，这种连续性有助于将SV与UVM进行特性对比和学习。 高级应用部分（第15章至第18章）： 该部分结合了实际项目和验证潮流，对中高级验证工程师有启示作用。我也希望读者可以从这些部分了解到，语言和方法学是验证的技能基础，但要解决项目的实际需求、提高整体的验证效率和一致性、实现跨平台、跨研发部分的验证平台，还需要做出更多的定制化解决方案。而对于目前还没有令人满意的解决方案的验证难题，我们还需要时间去构想推动新的验证方法和工具。 第15章给出了如何实现验证平台自动化和测试标准化的方案，适用于大中型公司的验证效率提升； 第16章着眼于目前在标准制定过程中的便携激励标准，介绍了已有的便携激励工具和跨平台的验证结构； 第17章针对SV与UVM同其他语言的接口给予实践指导； 第18章则将一些分散的高级话题给出行业的解决方案。读者可以将这一部分作为工作的指导手册，在将来遇到相关问题时参考。 尽管试图给出动态验证的全貌，但我也不得不遗憾地指出，几个重要内容暂未在本书首版中囊括，包括：从验证计划到功能覆盖率的量化手段和标准，功能覆盖率驱动的智能化收敛验证，断言的应用场景和复用实践，验证IP的开发模式和推广等，未尽的地方只能寄希望于在下一版中补缺，而在那时，验证世界风起云涌，又将出现什么新的技术还未尽可知，且让我们拭目以待吧。","link":"/IC%E9%AA%8C%E8%AF%81/%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%97/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%970/"},{"title":"芯片验证漫游指南1芯片验证全视","text":"1 功能验证简介 如果你在设计一款处理器，你需要考虑将其拆分成为运算器（算术逻辑运算单元，ALU,Arithmetic Logic Unit）、高速缓冲存储器（Cache）和连接它们的总线（Bus）；如果你在设计一款系统集成芯片（SoC、System-on-Chip），那么它可能包括的子系统包括处理器、片上网络（NoC,Network-on-Chip）、存储器、I/O 控制器（例如 USB,PCIe）等。你会发现，随着系统集成度的提高，系统自身的复杂性增加，而且结合实际工程项目来看，系统复杂度的提高对于功能验证的要求是首当其冲的。由于功能验证在芯片全流程中占据关键位置，验证工程师需要充分理解系统验证的全过程，这个过程就是功能验证的生命周期。功能验证在项目的延续中（目前芯片迭代周期越来越短的一个重要原因，就是依靠剪裁以前项目来做快速的芯片设计）得到不断的提升，而这要求验证工程师考虑如何完善验证流程和环境。在本书一开始，路桑将带领读者从芯片开发流程进入，检视芯片验证在整个项目中的作用（见图1.1）。 一般而言，新的芯片项目首先从市场人员与客户沟通开始。市场人员收集客户对芯片的要求（主要包括功能、尺寸、功耗、性能），这些指标被记录在设计结构和产品文档中。随后，客户关心的系统层面功能被系统设计人员按照功能进一步划分为各个独立的子系统。这些子系统如果本身过于庞大，则被划分为功能模块，直到被划分出来的尺寸可以被小的设计团队进行硬件实现。硬件设计人员按照芯片的功能模块划分成不同的小组，同时系统设计人员的数目随系统复杂度的升高而增加。在硬件设计过程中，硬件设计工程师将具体的功能描述文本通过逻辑翻译成为硬件描述语言（HDL,Hardware DescriptionLanguage模型），目前广泛使用的HDL语言VHDL和Verilog均被各大EDA（Electronic Design Automation）公司的软件支持。由于SystemVerilog囊括了Verilog语法和更多高级设计属性，其也被用做一种设计语言。 当细分的模块初步完成RTL级（寄存器级别，Register Transistor Level）的设计之后，验证人员要做几项工作来检查设计： 设计文件是否正确地按照功能描述文档实施了？ 硬件设计人员是否有遗漏掉的边界情况（corner case）？ 硬件设计是否足够稳定以处理一些错误情况（error response）？ 在实际项目中，硬件设计人员和功能验证人员的合作是紧密的，具体表现在： 系统设计团队将功能需求（抽象指标）翻译为功能描述（自然语言）之后，硬件设计团队和功能验证团队要围绕功能描述文档分别展开各自的工作。 在设计团队初步实现设计以后，验证团队要搭建验证环境展开各功能点的验证。 当验证环境测试出的结果与预期不符合时，需根据情况区别对待。如果设计与功能描述存在明显不符，验证人员应报告出设计缺陷，同时设计人员应修复设计，这样从验证到设计再转回到验证即完成一个缺陷检测和修正周期；当结果和预期有模糊边界时（例如时序 问题、状态机跳转问题），验证人员和设计人员对功能描述的理解可能存在分歧，此时他们应做初步讨论，确定哪一方的理解有偏差。当讨论未决时，双方应找系统设计人员进行“裁决”，以明确设计思想，统一对功能的理解。 因此，硬件设计的完成度和缺陷率在设计人员和验证人员的迭代周期中不断得到完善，最终可以达到目标。关于功能验证目标的定义，我们会在1.4节详细讲述。芯片硬件和软件的开发集成过程在图1.2中给出。 功能验证完成后，后端人员（backend）将 RTL 文件综合生成门级网表（gate netlist），同时进行布局布线，最终使物理电路可以在设定的时钟频率上工作。在后端的各种流程中，与验证人员联系紧密的当属标准延时格式（SDF,Standard Delay Format）文件，该文件包含门级网表中各个门单元之间的延时信息，它们被用来准确描述物理电路的时序和检查要求。对于功能验证流程，我们所说的仿真可以 根据项目的实施流程将其划分为前端仿真和后端仿真： 前端仿真指的是进行 RTL 仿真，在这种仿真中是没有真实延时情况的。对于一个寄存器（register），它的输出端（Q port）相对时钟输入端（Clk port）的延时为零延时（delta delay）。 后端仿真指的是进行门级（gate level）仿真。在实际项目中，由于后端SDF文件本身需要不断迭代（直至满足时钟频率要求），我们进一步将门级仿真划分为零延时（zero delay）仿真、单位延时（unit delay）仿真和SDF仿真。 零延时仿真只有门级网表参与仿真，没有SDF文件来具体反向标注（back annotation）门级延时情况，所以门之间的延时仍然为零延时。这时门级零延时仿真与 RTL 仿真的区别仅在于前者是后者的逻辑映射，从寄存器级别到门级的逻辑转译，这一步是由后端的综合工具（synthesis tooling）完成的。 单位延时仿真类似于零延时仿真，也没有 SDF 输入，而是将各个单元门之间的路径延时和门内的延时都以单位延时计算，以此模拟时序的叠加，但并不准确，依然无法反映实际物理时序。此仿真同零延时仿真一样，只可用作逻辑实现检查，无法检查物理时序。 后端产生出SDF文件时，我们将门级网表反向标注上SDF文件中包含的时序信息，最终进行真实延时电路的仿真。 从验证完整性而言，前端仿真和后端仿真均需要在项目中实施，但它们侧重的目标有所不同。前端仿真是为了检测出功能逻辑的缺陷，而后端仿真是为了检测出门级电路由延迟导致采样失败所产生的功能缺陷。 因此，验证人员不能将前端仿真的功能缺陷检测任务下移到后端仿真阶段。就效率而言，前端仿真要显著高于后端仿真。同时，后端仿真之所以不能忽略，是因为它可以协助后端人员测试出实际生成电路中是否存在时序不满足的问题。 完成后端仿真以后，我们将后端生成的标准格式文件最终交付给芯片生产商进行流片（tape out）。从上面的描述来看，这是一颗完整的芯片从定义、分块、设计、验证和后端的硅前（pre-silicon）流程。 同时，芯片在流片以后所面临的硅后流程（post-silicon）也是一个完整的周期，包括组件测试、驱动、系统固件和应用软件编写，等等。由于功能验证处在硅前流程中，我们在这里主要阐述该流程， 同时将一些相对独立的部分略去（这并不代表它们不重要），例如，可测试性设计（DFT,Design For Test）。设计和验证团队协同工作示意于图1.3中。 2 验证的处境2.1 验证语言的发展简单而言，验证的目标就是在一定的时间内尽可能多地测试硬件设计，发现设计缺陷并报告出来。同时，验证本身也是一项棘手的挑战，这一点可以从语言发展和各种快速发展的EDA工具上得到佐证。 我们从VHDL的语言发展线路来看，它的标准IEEE Std 1076-1987逐步经历了1076-1993,1076-2002再到1076-2008，这中间的年份从1987年逐步发展到2008年，可是我们真正在使用的设计标准是哪一部分呢？可能超过90%以上的设计都基于1076-1987和1076-1993，这是将近20年之前的标准，可是设计人员用它来描述电路已经足够了。因为设计面临的问题不是语言自身的局限，更多的是设计人员的经验和思想。 同样，我们看看Verilog语言的发展从IEEE Std 1364-1995到1364-2001再到1364-2005。目前我们所使用的Verilog代码也基本是在遵循1364-2001的标准，EDA工具商也主要在支持这一年份标准。 再来看看目前的主流验证语言SystemVerilog的发展情况，如果不考虑它之前在Accellera坐板凳的日子，它正式被认定位IEEE Std 1800-2005是从2005年才开始的！可我们看看它在这10年中便经历了1800-2009和1800-2012，更重要的是，它的每一次更新都得到了工具商的及时支持。为什么呢？因为实际验证的需要，绝对需要。 2.2 验证面临的挑战随着芯片自身复杂度的日渐提高，以及一直存在的项目进度压力，如何实现验证的完整性和高效性成一个大家都关注的话题。概括来讲，验证目前面临的两大挑战是： 如何穷尽所有可能的情况给设计产生激励。 如何在各种可能的激励情况下判断出不符合硬件描述的行为并报告出来。 我们先看看第一个挑战——如何穷尽所有可能的情况。在这里以手机屏幕显示为例，假设手机屏幕分辨率是1920×1080，像素点的色彩值是232，同时，每个像素点之间的状态是独立的，那么屏幕可能分布的状态应该是：232×（1920×1080）=8 906 044 184 985 600 如果再考虑到像素点色彩值的变化，那么在连续两个时钟下，像素点可能发生的状态跳转空间是：232×（1920×1080）×232×（1920×1080）=7.9×1031 这仅仅是屏幕色彩的一个基本功能，而可以预见到的状态空间数目足以让人抓狂。所以，面对这样的挑战，我们需要作出一些平衡，这种平衡来自于状态空间本身的庞大和项目实施中的进度压力。如何划分出有效的测试空间、如何给出随机约束激励是验证人员需要具备的职业素质。 接下来我们看看第二个挑战，如何在各种可能的激励下判断出硬件设计的缺陷。首先把常见的硬件设计划分为如表1.1所示的几类，同时再看看针对不同设计的激励输入类型和结果判断的方法。 从表1.1可以发现，不同类型的设计需要产生的激励类型和结果比对方法是不一样的。针对不同类型、不同复杂度、不同集成度的设计，应采用不同的验证方法。从验证工具的分类看，可以将其分为仿真验证和形式验证；从复杂度出发，可以划分为黑盒验证、白盒验证以及灰盒验证。关于验证的方式以及合适的运用场景，我们也会在第2章里面展开详细讨论。 3 验证能力的5个维度列出验证人员需要具备的5个能力维度： 完备性 复用性 高效性 高产出 代码性能 3.1 完备性完备性要求验证的充分。然而，充分一词对于验证而言边界是模糊的，很难量化到什么时候才可以达到完成验证的标准。所以，作为一名验证经理，需要引入各种数据来综合量化出验证的进度，其中包括验证功能点的覆盖率、代码覆盖率、是否经过效能验证流程（power aware verification）、是否经过跨时钟域（clock domain crossing）检查等。 通过数据量化，验证人员和验证经理更有信心来宣布在某一个项目节点中，设计已经得到“充分”的验证。当然，对于功能覆盖率部分，如何将功能描述文档充分理解，进而列出要测试的功能点并尽可能地细分出来，这需要系统人员、设计人员和验证人员的共同努力。同时，将抽象的验证计划转换到功能覆盖率要求验证人员具备这样的能力。 3.2 复用性从项目的实际运用角度看，复用性和完备性是同等重要的。没有人愿意在下一个项目中将以前的验证环境做较大的更新，因为这意味着额外的资源消耗，包括时间、人力和项目进度的考虑。 在硬件设计角度而言，通过标准总线协议，可以最大限度地在模块之间实现相对独立和快速集成。对于目前项目周期不断缩短的现状来看，一方面是市场的瞬息万变导致的，一方面也是由于SoC自身趋向于软件的周期迭代方式而形成的。对于一个系列芯片而言，后续芯片的性能提高、功耗优化都是建立在前一代的基础上的。而这些不断的提高和优化具体到每一个硬件子系统而言，可能就是它们的存储大小、时钟快慢、动态电源开关、总线宽度、缓存深度来综合决定的，并且下一代硬件设计自身一般不会有第一代芯片的艰难历程（否则也就称不上是系列芯片了）。 那么从硬件设计的角度看，这些更新如果不在逻辑上面有大的变动，那么带来的工作量是可以估计的。而从验证角度看，我们很自然地希望验证的工作量不要太大——可事实并不一定是这样的。首先从芯片项目的人员安排看，验证人员相比于设计人员流动性更高。那么当一个验证人员在尝试维护和修改上一个项目的验证代码时，就要看他的“运气”，而他的运气与上一个验证人员的代码风格有直接关系。因此，如何标准化验证环境和测试规范，成为验证复用性的一个重要考量。同时，验证人员在处理一些总线协议时要有意识引入参数来为日后的复用做好准备。不断融合的验证方法学走到今天，UVM（Universal Verification Methodology）之所以划分出不同的功能组件，实现小的颗粒度，提供快速插拔式的环境集成能力，也是从复用性考虑的。 3.3 高效性高效性指的是用尽可能少的工作量完成验证工作。在保证验证完备性的考虑下，实际上复用性和高效性会有存在冲突的可能。例如，验证人员会考虑如何“短平快”地在一个紧张周期内完成验证工作，但他可能不会采用UVM等方法学框架，也有可能不会考虑将参数引入到验证环境中。因为这些“额外”的因素虽然对复用性有帮助，但与高效性冲突（费时）。所以，验证人员需要针对不同的情况在维度之间做好平衡，至少需要保持一种意识，那就是工程学的执行阶段本身就是一种平衡。对于验证人员来讲，他需要做出的判断就是在每一个项目的验证任务中做好取舍，给出合适的验证考量综合维度。对于同一项验证任务而言，采取不同的验证策略有不同的验证效果。例如，一开始考虑采用随机约束的验证方法，那么单单就约束而言，它的约束一开始是比较窄合适，还是一开始比较宽合适？ 这里我们给出图1.5来说明高效性在一项验证任务的不同周期需要有相应的变化。在开始阶段，考虑到设计不够完备且尚未经历过验证，我们将其称为基本功能验证阶段。这个阶段，我们将随机约束域降低到基本范围，尽可能少地触碰到边界情况，把重点放到如何先将各项基本功能都验证到。第二个阶段是在已经完成基本功能验证以后开始的完备功能验证阶段，这时可以逐渐放开随机约束域，而开放的域范围需要验证人员考虑到各种合理的情形再做限定。到了功能覆盖率一般上升到80%附近时，就处于最后的爬坡阶段。这时，再沿用之前广泛的约束域就会产生很多无效的随机种子，这些“无效”的随机种子对于剩下的验证覆盖率几乎没有什么帮助。这时，验证人员需要通过理解设计本身和随机约束两方面来考虑具体贡献覆盖率的测试序列，再进一步缩窄随机约束域，偏置（biasing）产生一些激励。对于最后这一阶段，一种极端的情况就是将随机约束域缩到尽可能地窄，甚至和定向测试（directed test）没有什么区别。 3.4 高产出高产出指的是在一定的时间，能够调试、报告、帮助修正出多少设计缺陷，以及如何建立完整的验证环境。多年来，数字设计（RTL级别）的基础并没有发生太多变化，同时EDA厂商提供的自动化工具又进一步提高了设计的可靠性。但这一情况却并不适用于数字验证，因为EDA工具目前仍然只能作为辅助手段（例如提供更多的调试功能和接口），却不能帮助自动化建立复杂的验证环境。这也就不难解释2017年IC行业功能验证领域的调查数据显示，当前在设计和验证领域面临着最大的挑战之一就是为快速的芯片产品迭代和员工数量增长之间找到一个平衡点，实现单位产出的提高。 3.5 代码性能代码性能似乎也跟高效性、高产出有冲突的地方。因为验证代码的整洁性、复用性甚至一点点的美感都与验证完备性没有直接联系。这也包括你的验证经理可能有好长时间都不会注意到你写的验证代码，除非有一天你验证的那个设计出了一个缺陷，而且是一个显而易见的缺陷却没有被发现，才会引起验证经理的注意并专门来回顾可能是一团糟的代码结构。每一位验证人员需要记住一句台词“出来混，迟早是要还的”。不管是别人的验证代码中存在着没有注释、没有缩进、超长函数等不良问题，还是你因为项目紧张，在快速搭建验证环境和编写测试用例时没有考虑到“后来阅读者”和“你后来阅读”而偷的各种懒。相信我，时间会让你为此买单的。所以，作为一名验证人员，请你在写每一行代码时把它当做你日后行业名声的荣誉墙。尽管你迫于项目的压力需要快速建立环境疲于完成验证计划，但等到你闲时会去改善那些代码吗？不要再相信这些鬼话了，现在就去做吧！ 从上面的5个维度来看，做一名合格的验证人员实属不易，更不要说考虑到每一项验证任务量体裁衣制定出合适的5个维度指数。虽然项目执行没有尽善尽美，但针对验证人员自身，如果可以意识到这5个维度的存在，并且能够在实际工作中综合考量它们，那你就是有意识地在培养自己成为一名优秀的验证师了。 4 验证的任务和目标验证师的工作就是完成分配给他的任务，这个任务可能是模块级（module level）、子系统级（subsystem level）或者系统级（chip level）的。准确来讲，验证的目标就是“按时保质低耗完成”目标硬件设计的验证工作，这句话实际也包含了要完成验证目标需要考虑到的三个方面。 按时保质低耗 按时 验证师需要按照项目预先的进度来考虑验证的节点（milestone），在项目开始时就将节点记挂在心上。之前提到的验证师的5个能力维度，在面对项目进度时，也需要考虑哪个维度为主、哪个维度为辅。例如，硬件设计的验证计划、验证环境的复杂度和复用性、大概需要用多少测试用例来尽快达到验证工作量的80%，这些都是要与项目进度一同考虑的。要知道“一个都不能少”在芯片流程中的重要性，没有一款芯片可以因为其中一个模块的验证延迟而有信心去流片。所以，整支验证队伍自上到下，覆盖到各个模块的验证师都应该有这种意识：即，无论何时，时间总是第一位的，时间就意味着客户的耐心和市场的窗口。 保质 保质指的是尽可能少地将缺陷暴露在流片以后，至少要尽可能少地暴露在客户和市场面前。因为从成本的角度看，缺陷暴露在不同的阶段造成的损失有指数级的差别。如果芯片交付给客户以后才被反馈出一些大的缺陷，那么芯片设计方就会背负很大的压力，除了要同客户一起进行高密度的对话、联调外，整个产品链都要为这个缺陷付出更大的人力、物力成本；如果芯片是在客户方通过测试却被市场发现自身性能不如预期的话，那么会对芯片设计公司和客户双方都造成消极的影响，无论是在市场反馈还是用户对品牌的认知度上，都是如此。 低耗 低消耗有两方面，用更短的时间、更少的人力来完成芯片设计任务，这是一笔前期看得见的可以预期控制的成本；同时，也有一些成本是突发的，其中一个就是缺陷的暴露问题。从图1.6可以看出，暴露在不同研发阶段的缺陷对芯片项目造成的额外成本是随着项目进程指数级递增。 硅前验证中RTL验证发现的缺陷带来的影响要明显小于Gate验证中带来的影响。因为RTL阶段发现的缺陷，只需要修改RTL代码，而Gate验证发现的缺陷除了需要同时做RTL修改和网表修改，更是要后端一系列流程的反复。如果在硅后测试中发现了缺陷，就需要考虑这个缺陷是不是致命的。所谓致命的，就是它无法使用一些重要功能，甚至本身会导致一些重要功能的失效和错误行为，且没有办法通过软件层面来做修复。这样的致命性缺陷就意味着芯片要做第二次流片，要针对致命缺陷做出修复、功能验证、后端流程，这样的过程通常耗时三个月以上。如果一个致命缺陷等到被交付给客户以后才发现，那么造成的损失则是双方的。对于客户来讲，他们需要为这个致命缺陷吞下产品延迟上市的苦酒；而对于芯片公司来讲，恐怕这可能是双方最后一次合作了。 芯片研发与客户反馈 进一步来看，如果我们将硅前流程、硅后流程同客户反馈联系在一起（见图1.7），就能对芯片流程有一个更清晰的认识。从图1.7可以发现，芯片在出片以后被检测出的严重缺陷会直接导致芯片的二次流片，这对成本控制而言是一种额外的损失，同时将时间和人力资源消耗在本可以避免的二次流片上。所以，功能验证是唯一可以用低成本在硅前流程将上述目标“按时、保质、低耗”达成的方法。也正因如此，对于功能验证而言，验证经理通过量化的方式来衡量验证产出的进度。用来衡量的两个标准，一个是时间，一个是发现的缺陷数量。 缺陷增长曲线 通过缺陷数量在时间线上的记录，我们可以绘制出缺陷数量的增长曲线，如图1.8所示。 一般来讲，缺陷数量的增长曲线是逐渐逼近趋于缓慢的。功能验证需要保证的是将缺陷数量的增值（至少是致命缺陷数量）保证在硅前阶段，不应该让其发生在硅后测试阶段。针对缺陷的类型，我们一般遵循先易后难的验证方法，这表现在两个方面： 我们给出的激励向量应该是先易后难，先从简单的激励向量测试设计的基本功能，这一点我们在1.3节提到随机约束域的宽窄设定和验证阶段之间的关系。当验证将基本功能测试完毕后，我们再朝着更复杂的情景着手去测试其他功能。 我们查找出的缺陷也应该是先基本后高级。这么做有两方面的好处，当开始的激励向量是基本形态的时，有助于设计本身在缺陷报告反馈中逐步稳定，同时留出一定的时间用来帮助设计师和验证师针对设计细节交换意见，在硬件描述上面统一理解。 这种缓冲会使得在其后的复杂测试中，设计师和验证师双方就复杂情形中的硬件输出结果快速达成一致，因为之前已经就功能描述达成一致了。对于验证师而言，这么做也符合验证的曲线，也就是前期的缺陷曲线斜率较高，是因为设计本身容易被发现一些基本设计问题；随着验证周期的进展，缺陷曲线率慢慢减小，说明设计自身的稳定和功能完备情况趋于最终的设计目标。 对于验证经理，如果有追踪缺陷率曲线的习惯，那么一般建议检查两个地方： 缺陷率曲线是否在收敛，或者斜率是否在变小，这一定程度上可以说明验证的状态是否在收敛和趋于完备。 需要注意验证过程中发现的缺陷种类，应从基本缺陷再到高级缺陷。假如到了后期，尽管缺陷率收敛，却发现了基本缺陷，这时应对整个验证质量打一个问号。 有必要的话，同验证师一起回顾验证计划、验证环境和测试序列。因为越到后期越不应该发现基本类型的缺陷，否则验证经理无法对于整个验证任务的完成有足够的信心。 5 验证的周期5.1 验证周期中的检查点功能验证有着一整套完备的流程，从硬件系统定义贯穿到硅后测试部分。一般来讲，验证团队会基于时间差同时进行多个项目，多个项目之间自然也存在着借鉴、更新的关系，所以验证的环境和复用性也是在不断提高的。每一个项目在进行瀑布模式开发时，验证团队也 会在细分的流程中完成任务，同时在展开下一项任务之前进行一些重要检查点（checkpoint）的回顾工作。验证人员不断地在新项目中完善验证环境，验证的周期因而也是不断往复、螺旋上升的过程。 图1.9将功能验证的各个关键节点罗列并使之成为一个周期。验证周期的起始点从创建验证计划开始，验证计划需要参照系统工程师给出的功能详述文档。接着验证人员开发验证环境，在创建验证环境的过程中，验证人员一般会邀请设计人员和系统人员一同回顾验证计划，确保验证计划没有明显的遗漏，所以验证计划的回顾是第一个检查点。 验证环境准备完毕且有一些可供测试的激励时，验证人员会比对设计的输出结果。如果发现有比对错误，验证人员首先要自己去调试环境，定位到硬件HDL文件存在缺陷的大致位置。如果验证人员有充分的经验，他还可以进一步给设计人员修改代码的建议。硬件设计经过一定数量的激励测试，验证人员就可以准备回归（regression）测试了。回归测试就是将已有的所有测试序列都执行一次。一般来讲，随机序列的回归测试覆盖率贡献要大于直接序列的回归测试，不过这种优势会随着验证率曲线的增长而变得不那么明显，具体的原因就是随机激励无法给出定向激励来填补剩余的验证空间，而定向测试则可以被有经验的验证人员运用，用来验证边界情况。在完成回归测试之前，我们需要进行第二个检查点——验证代码检查，这一检查点的作用是通过回顾验证代码从而发现可能遗漏的测试激励、不恰当的随机约束、代码结构的缺陷等。 完成回归测试后进行第三个重要的检查点——流片前验证完备性检查。一般这项检查是验证经理最后签字的。验证经理根据一份检查清单来将验证进度做量化的综合评定，最后判读是否完成验证的任务。当然，这一过程并非只有在流片前才会评估，而是发生在这一期间内若干阶段，包括模块验证阶段、子系统验证阶段、芯片系统验证阶段和最后的网表验证阶段。每一个阶段验证经理都有相应的通过标准和检查清单，判定模块、子系统和最终的芯片系统是否达到验证的目标。 即使在最终流片以后，验证团队也需要和硅后系统测试团队完成对接。这是由于，硅后系统测试阶段才是真正能够判定小到每一个功能模块大到整个芯片系统的各项功能能否正常工作的标准。通常，系统测试团队参考功能验证团队的验证计划，从底部测试每个模块的功能，逐步向上层走，最终测试整个芯片的联合功能。在系统测试环节中，如果发生了功能测试失败，系统测试人员与验证人员协作，最终定位到是硬件自身缺陷还是测试中的环境配置，或者是寄存器设置问题。如果最终测试发现了硬件缺陷，那么硬件团队和软件团队也会一起评估该缺陷是否是不可修复的。针对硅后测试发现缺陷的情况，一般首先考虑是否有软件修复的可能，接下来才考虑硬件上有无变通的办法。当两方面都无法解决时，我们只能宣告，一个无法硅后修复的缺陷在测试阶段发现了。当然，更糟糕的情况是，这个缺陷竟然是一个致命缺陷。 经过系统测试后，验证团队最终被硅后测试发现的缺陷展开逃逸分析，来检讨为什么漏洞会在硅后测试环节中被发现（而不是在硅前验证环节）。 可能引起漏洞在硅前验证阶段逃逸的情况包括： 验证计划制定不充分，没有完全覆盖功能验证点。 激励序列生成不完全，没有覆盖全部的有效激励场景。 验证环境不完备，例如比较器（checker/scoreboard）没有足够完善去比对输出结果。 展开逃逸分析之后，要进行验证周期的最后一项检查——吸取教训。吸取教训是一种被动的方式，我们在完成的项目中犯了一些错误，如果不想被同一块石头绊倒两次（没有人会愿意吧），就需要吸取教训。这种被动的方式和主动提高验证效率没有冲突，恰恰是在我们没有考虑到的地方吸取教训，在我们考虑到的地方主动完善，使之成为一种内外结合提高验证质量的方式。 关于吸取教训，在这里我们给出一些建议： 请在整个验证周期内保持收集与验证完善相关信息，比如，突发状况以及如何克服，陷阱从哪里来，有哪些遗憾，等等。之所以这么做，是因为我们通常在项目结束以后会懈怠下来，我们的记忆无法保存事发当时的一些细节，也容易忘掉当时一些心理上的痛苦。所以 就像做一份验证记录一样，保持着这样一份完整记录，将来我们可以从中很快地回溯起来我们一路是如何走过的。 除了一些个别情况，验证缺陷的暴露与整个模块验证团队都有关系。因为可能我们一起制定的验证计划不够充分，一起回顾测试序列的时候也不够仔细……要思考团队整体的疏忽在什么地方。每个人都需要考虑到自己在验证周期的不同阶段应该充分履行的责任是什 么。 尽量从一些教训中量化今后可以加强的地方。比如，如果功能覆盖率和代码覆盖率的指标是硬性的，那么验证人员就不应该妥协，应想办法达到这个标准；又比如，一些跨时钟域的问题没有被发现或者在网表仿真时才被发现，以后就应该将跨时钟域检查、同步单元检 查作为标准在验证过程中执行下去。 5.2 功能详述对于一个芯片，大到芯片自身，小到可以细分的模块，都需要系统工程师给出功能详述文档。这里以较小颗粒度的模块功能文档为例，看看一个基本大小的模块如何依靠功能文档来实现硬件设计和功能验证。 一份功能文档，通常包含如下几方面的信息： 接口信息。是不是标准接口、是标准接口的哪一个版本。如果接口是标准接口，那么功能详述中不需要详尽列出接口的时序信息、命令、数据传输等，而只需给出基本的时钟、复位、接口信号名。对于标准接口，设计人员和验证人员可以下载标准接口文档来更详尽地了解接口信息。如果接口是公司内部定义的接口，则需要参照内部定义的接口文档；如果是自定义接口，由于这种接口没有被规范化，功能文档中应尽可能周全地描述需要给出的信息，以方便日后设计人员和验证人员双方参考。 结构信息。结构信息将模块进一步细分为各个功能组件，以及包含组件之间的逻辑关系。各功能组件对设计人员而言可以匹配出对应的 RTL 文件，其后可以自底向上进行集成；对于验证人员而言，为了尽可能与设计保持同步，验证环境的开发可以同设计组件同步展 开。从设计组件A和验证环境VA，再到组件B和验证环境VB，再到组件C和验证环境VC，最后集成出模块M（A+B+C）和验证环境V（VA+VB+VC），就可以完成模块M的集成验证了。 交互信息。由于模块稍后会被集成到更高一级的子系统当中，所以功能详述文档中包含模块 M 同外界模块交互的示意图。必要时，这些交互信号之间也会给出准确的时序信息，确保集成后两个模块之间的交互按照预期定义的时序发生。比如一对握手（handshake）信号，需要指明输入信号的频率、是否需要考虑同步、是电平信号还是脉冲信号、大致维持几个时钟周期，相应的输出信号也要有类似的考量，以满足输出信号接收方的要求。 功能详述文档是硬件设计和功能验证的基础部分，也是共同参考依照的标准。设计人员通过自己的理解将其实现成 RTL 文件，而验证人员也按照自己的理解为设计构建出验证环境。尽管看起来验证人员重复了一次功能上的理解，但正也是因为这样，确保了功能描述文件 可以被设计和验证双方理解一致。验证人员自己设计的参考模型（reference model）才也会按照功能详述文档做出正确的行为和数据输出。参考模型对应硬件设计，通过结果比对检查是否有不符合预期结果的情况。这种方式可以让功能文档变得易读清晰，降低设计人员误解功能描述和实现错误硬件的可能性。 5.3 制定验证计划验证计划是为了完成验证目标的，因此它本身要回答两个问题——验证对象是谁、如何验证。制定验证计划的主体在不同公司可能不同，例如，公司A是由系统人员制定验证计划的，而公司B是由验证人员制定验证计划的。不过可以肯定的一点是，最后回顾验证计划 时，会将系统人员、设计人员和验证人员组织到一起来回顾，检查可能存在的验证漏洞。验证计划也存在颗粒度，与模块大小、处在系统的层次相关。 这里我们仍然以模块M为例，考虑验证计划中的检查事项： 验证方法：是采用直接验证、随机约束验证、形式验证还是其他的方式。 验证工具：选择需要的验证工具来支持验证方法。 验证完备标准：量化出一些参数以衡量验证任务是否完成。 验证资源：包括人力、时间、硬件、软件等所有与项目预算有关的内容。 验证的功能点：需要给出验证的功能点以及在什么层次去验证它，更具体的包括生成何种激励、检查设计的何种状态和数据输出。 5.4 开发验证环境验证环境的开发是验证人员花费时间较多的部分。验证人员从搭建环境开始，实现激励产生器（stimulus generator）、参考模型（reference model）和数据比较器（data comparator）。 验证环境的运行需要软件工具的支持，目前的主流仿真工具均可以对仿真验证提供广泛支持。当然，制定验证计划时需要考虑采取何种验证方法，之后才开发验证环境。不同的验证方法决定不同验证环境的结构和所用的软件。伴随着设计缺陷的发现和修正，验证环境也需要保持更新，最终同硬件设计一样趋于稳定，进入验证的下一个阶段。 5.5 调试环境和HDL文件验证人员在调试方面的时间投入最多。环境的建立在验证早期投入较多，设计的功能调试却是一步步向前推进的。验证刚开始时，验证人员调试的对象主要集中在环境的协调整合上；环境稳定后，验证人员递交测试，进行仿真验证。针对每一个功能点的验证均需要给出一个或者多个激励向量，在激励给入后，将参考模型和实际输出进行比较，发现比较错误时需要进一步定位问题的源头： 环境是否有瑕疵； 测试序列是否合理； 参考模型是否遵循功能详述文档； 硬件设计本身是否存在功能缺陷。 定位问题时，一般建议验证人员： 先从环境着手，试图去稳定环境部分，因为这一部分是我们可以控制的。 让环境趋于稳定后，我们再去定位问题是否来源于硬件设计。判定设计存在缺陷时，验证人员需要了解设计、定位到缺陷的位置，提交给设计人员并得到反馈。 设计缺陷被修复后，应重复递交同一个测试用例，用例中产生的测试向量也不应该改变。如果使用的是随机约束方式，应记住上一次仿真出错的时间位置和随机种子（random seed），在后面重新递交时采用同一个随机种子以产生同样的测试向量，确保外部激励的场景是一致的。这种方式背后的逻辑是，在调试过程中应尽量减少变量的数量，理想情况下只有一个变量。对于上面的场景，这个变量就是设计缺陷在修复前和修复后的功能表现。 至于如何设定随机种子，在仿真器的用户使用文档中可以找到相应的使用方法和仿真选项。 5.6 回归测试回归测试指的是验证硬件在某个缺陷修复或添加了某项新功能后，仍然可以通过以前的所有测试用例（test case）和可能添加的新的测试用例。可能存在的环境变化包括硬件设计自身的改进、缺陷修复、功能添加和验证环境的更新。在每次的回归测试中都可能发现新的缺陷、添加新的测试用例或者更新验证环境。 每次回归测试都会帮助完成两个目标： 确保这次改动没有引入新的缺陷，并修复了之前的漏洞，或者按照预定目标实现了新的功能。 随机验证在每次递交时默认的随机种子不同，这对重复递交一套回归测试表也是有意义的。伴随着功能覆盖率，可以通过往复的回归测试和补充的定向测试来将逐步提高验证完备性。 当代的回归测试逐步趋向自动化，需要一种合适的回归测试工具协助完成回归测试表的提交、分配到不同的服务器上面以计算量来换取时间的缩短、自动识别仿真的结果、到最后给出验证报告。 这种回归测试工具，可以从 EDA 公司的工具表中找到商业化的产品，同时大中型公司也有适合自己团队工作流程和需求的定制工具。回归测试是实现验证完备性的一项重要手段，因为只有通过将大量测试用例并行提交到服务器群，才可能完成覆盖率的快速上升，满足项目进度的要求。 5.7 芯片生产经历过回归测试阶段（RTL 回归和门级网表回归），意味着芯片的逻辑和物理数据都经过各项检查了。在将芯片最后送交给半导体生产商（fabrication facility）之前，项目经理与设计经理、验证经理、后端经理一起回顾整个检查表（checklist），确保所有的标准都已经通过。芯片的数据提交给生产商后，最终制造出来，我们称之为流片（tape-out）。 值得注意的是，此时功能验证的流程并没有全部走完，仍然需要提交回归测试，通过保持不停的随机测试，在新的状态空间上测试，可能发现新的问题。如果在递交给厂商生产以后发现新的缺陷，要像硅后测试发现的缺陷一样对待。通过分析这些缺陷，考虑是否有软件补救办法，或者提交设计修改意见，在下一次流片前准备好设计方案和验证方案，将其计划到下一次验证周期内。 5.8 硅后系统测试芯片返回后，系统测试人员依照系统集成的顺序从底层模块开始测试。测试前，需将芯片同测试开发板结合起来，或将芯片植入到待开发的系统上。随后硅前人员（设计人员、验证人员、系统人员）和硅后人员（测试人员）保持频繁的沟通，一旦测试出了问题，第一时间判断是测试的方法不恰当还是硬件自身的问题。之所以要求硅前人员参与，是因为我们不期望硅后测试出现太多的问题，尤其是致命的缺陷。当一个硬件缺陷被发现之后，硅前人员需要讨论这个缺陷的严重性，从软件层面上讨论可行的补救办法，再从硬件层面看是否有其他办法使能这项功能，或者不使这项缺陷扩大影响面导致重要功能失败。如果最终无法避免这个缺陷，且该缺陷严重影响系统功能，就需要在下个芯片设计周期内去修改和验证这项功能。 5.9 逃逸分析有时，我们难以避免个别的验证漏洞一直被忽视，导致它们可以从硅前验证阶段“逃走”，到硅后测试才被发现。遇到这样的情况，硬件设计人员和验证人员都要与测试人员沟通，尝试在硅前的仿真环境中重现遇到的测试失败场景。如果可以复现，设计人员和验证人员要再次思考这个漏洞逃脱的原因；如果无法复现，则仍旧无法保证硬件做出的更改可以在下次流片后修复这次测试的问题。这种硅后测试失败要求硅前验证重现的难度，相较于在交给客户之后遇到的应用失败场景还是容易很多的。因为一旦从硬件级别向上堆叠经过驱动层、固件层再到客户的应用层，更加难以在硅前验证环境中重现客户应用失败的场景。作为验证人员，如果你有幸遇到过这样的场景重现和失效点定位的问题，那么想必你会深深记住它的。当逃逸分析完成以后，这一过程会对下一个芯片周期中，设计人员如何规避设计陷阱、验证人员如何完善验证方案、产生尽可能多的有效测试序列都是很有意义的。在整个芯片过程中都贯穿着“吸取教训”四个字，因为要完成芯片从硅前到硅后的过程本身就很漫长（相比软件的迭代开发而言）。要积累尽可能多的经验，芯片工程师应该在每一个关键节点养成总结的习惯，并在下一个阶段有意识地去完善，保持一种不断成长的态度。 6 作者结束语 在刚进入职场时，我每天都在公司工作到很晚，倒不是工作太多、效率不高导致的，而是给自己设定了目标，需要在更短的时间熟悉公司的流程。我翻阅了公司内部和外部的很多文档，一天从早到晚除了睡觉以外，手边都放着各种文档。如果将这些文档分类，那么一部分是技术文档，我大致用了三年的时间掌握了主流验证技术；而另外一部分是验证流程的相关文档，这部分文档是常读常新的，我总可以在不懂时翻阅文档，或者请教更有经验的同事。有句话说，“自己知道得越多，知道自己不知道的也就越多”。在IC验证这条道路上我们面对的不仅仅是更新很快的验证知识，也包括一些“常识”。所谓常识，就同前辈教的道理一样，往往在遇到挫折时才想得起来，对此我也深有体会。之所以将这一章作为本书的开头，就是为了让读者能够清楚：在通往专业化的验证道路上，需要经历不少的磨炼。接下来，我们将从验证通识的各个方面分别展开论述。当然，你也可以跳过验证通识的内容部分，转而阅读SystemVerilog和UVM的知识。但请不要忘记一点，验证通识对于你提升自己的专业化素质会有很大的帮助。","link":"/IC%E9%AA%8C%E8%AF%81/%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%97/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%971%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E5%85%A8%E8%A7%86/"},{"title":"芯片验证漫游指南2验证的策略","text":"1. 设计的流程我们在第1章给出了芯片产品开发的流程图，在描述中我们将开发流程分为两条主线： 芯片功能的细分； 不同人员的任务分配。 也就是说，不同人员需要在硅前不同阶段实现和测试芯片的模块功能。如果我们从另外一个角度看，芯片的开发即是将抽象级别逐次降低的过程，从一开始的抽象自然语言描述到硬件HDL语言描述再到最后的门级网表。在我们介绍过RTL设计和门级网表后，这里需要引入一个更高抽象级的描述方式TLM（事务级模型，Transaction Level Model）。TLM一般在早期用于模拟硬件的行为，侧重于它的功能描述，而不在于严格的时序。同时各个 TLM 模型也会被集成为一个系统，用来评估系统的整体性能和模块之间的交互。 TLM模型在早期的设计和验证中，如果足够准确的话，可以替代验证人员的参考模型，一方面为硬件设计提供了可以参考的设计（来源于系统描述），一方面也加速了验证（无须再构建参考模型，而且TLM模型足够准确反映硬件描述）。 1.1 TLM模型的需求和ESL开发早期的芯片开发模式是遵循从系统结构设计到芯片设计制造，再到上层软件开发的。随着产品开发的进展，需要让系统人员、硬件人员和软件人员保持充沛的工作量，同时对于一个芯片项目而言，我们也希望硬件人员和软件人员可以尽可能地同时进行开发。这听起来怎么可能？毕竟芯片还没有制造出来，没有开发板怎么去构建软件呢？ 在这里，系统结构人员会在早期构建一个高抽象级的系统，该系统具备相应的基本功能，且各模块的接口保持数据交互。通过将功能描述变成可运行的系统，让硬件人员和软件人员在早期利用该系统进行硬件参照和软件开发。这种可以为复杂系统建立模型、让多个流程分支可以并行开发的方式称为ESL（电子系统级，electronic systemlevel）开发。 1.2 传统的系统设计流程传统的系统设计流程如图2.1所示，是瀑布形式（waterfall）开发的，这种顺序开发的方式存在明显的边界： 时间边界：不同的开发子过程之间顺序执行，几乎没有交叠的空间来缩短整体的项目交付时间。 组织边界：开发小组之间的交流发生在上一个过程结束、下一个过程开始时，这引入了额外的沟通成本; 1.3 ESL系统设计流程图2.2为ESL系统设计流程。为了模糊或者融合这种边界，ESL开发流程通过建立虚拟原型（virtual prototype），又称TLM模型，使参与到系统开发的各小组做并行开发。之所以有这种魔力，是因为 TLM 模型不再是一种无法被硬件开发和软件开发利用的抽象描述，而是一种更早期开发的软件模型。在ESL开发的协助下，其余的开发流程可以更早地与系统设计一块进行开发，从整体上看，这种方式有助于缩短芯片开发的时间。除此之外，ESL在前期产品定义的阶段有相对可量化的模型，有助于早期评估产品的功能、性能是否满足客户要求，也能减轻一些低配置性能的风险以及降低过多设计的成本。 这是为什么呢？原因有以下几点： 在早期定义产品时，市场部门将产品功能和性能要求从客户那里收集回来，交由系统结构人员来定义芯片结构。这中间存在一些问题，例如，系统结构人员无法深入到局部功能，更无从列举出所有的用例来判断功能是否满足需求，而在性能测试方面也只能通过一些表 格化数据做出静态估算。这时，TLM 模型可以帮助在系统级别完成模型搭建和系统集成，甚至测算系统的性能。这样，系统结构人员有更多的信心给出合理的结构配置。 正由于可以在芯片结构的定义阶段快速做出性能评估，系统结构人员才可以及时地做出资源调整来满足用户的需求。否则，尽管芯片可能是低缺陷率的，但如果它的执行速度不够快、功耗过高，那么仍然无法满足客户的要求。 过度设计的结构就像给一只袜子缀上水钻一样没有必要。客户给的报价摆在那里，你的设计过度，不但意味着成本的增长，也意味着更高的复杂度和风险。 ESL和TLM对系统模型的要求使得需要有一门语言具备这些特性： 纵深多个抽象级别来进行模型描述； 标准开放； 高效的仿真性能和调试接口； 被主流仿真工具支持； 本身包含TLM事务级传输的接口。 这样的语言就是接下来要介绍的SystemC。SystemC是可以满足TLM模型开发的一种语言。严格来讲，它本身不是一种语言，而是建立在C++之上的一种类库（class library）。SystemC语言可以用来描述系统级别的硬件行为，而这一点恰是其他语言无法满足的。2006年，SystemC被IEEE收入IEEE 1666标准，它本身也易于学习，具有C++/Java基础和硬件设计概念的人使用起来都不需要太多的学习成本。 1.4 语言的抽象级比较不同的硬件领域使用到的建模语言都有它们各自适合的抽象级，图2.3指出了各个语言擅长的抽象级领域。从左至右，VHDL和Verilog主要用做RTL仿真和数字电路的综合，也用来在早期搭建一些验证平台。SystemVerilog/Vera/e是用来做功能验证语言的，其中包括了它们的随机约束重要特性，同时可以发现，SystemVerilog 本身可以用来描述硬件做 RTL仿真和门级综合。在此之上，SystemC 更偏向于系统层，它在结构层面上可以做更高抽象级的描述，虽然本身无法描述电路的综合网表，但它能够作为虚拟平台为上层软件开发做准备。MATLAB在信号处理上面被用来作为描述和算法验证。 1.5 传统的系统集成视角前面已经提到，传统的瀑布开发模型（见图2.4）无法让硬件人员和软件人员在系统结构定义早期参与其中。硬件的设计和验证人员需等待系统定义完成之后，才能将功能描述文档分别翻译出来，建立可综合模型和参考模型。软件人员只有在硬件流片以后才真正开始进行软件开发，尽管目前的FPGA有着比硬件更快的仿真优势，但无论从时间还是从速度来看，它仍然不是理想的软件开发平台。虽然FPGA等硬件加速工具对硅后系统测试有积极意义，但因介入较晚，加上基于速度层面的考量，其对软件系统层开发的贡献依然存在局限性。 1.6 ESL系统集成视角新型的ESL系统开发方式（见图2.5）在系统定义阶段建立TLM模型。这一模型的建立对系统人员、硬件设计人员、验证人员和软件开发人员有显著帮助： 系统人员在TLM模型集成系统上更易评估系统性能。 硬件设计人员同时利用功能描述文档和TLM模型，更准确地翻译为可综合的RTL设计。 验证人员可以直接将TLM模型作为参考模型集成到验证环境中，省去额外开发参考模型的时间。 软件开发人员可以在TLM集成后的虚拟系统上进行软件开发，在芯片真正出片后，则只需做一些基于实际硬件的软件移植；这可以把软件开发的起点大大提前。 TLM 建模有很多优点。然而，在真正考虑施行 ESL 系统集成流程时，需要考虑一些实际的问题： TLM建模对系统人员有更高的技能要求。不但要求他们掌握SystemC开发，同时要求有硬件描述的基础。他们的工作量同时包括功能描述文档和 TLM 模型，且TLM需要准确翻译功能描述文档，确保一致性。从传统流程迈向 ESL 流程，可能需要做一些妥协，引入专门的虚拟建模（virtual prototyping）团队协助系统人员翻译功能描述文档。他们的共同产出最终作为一致的参考标准。 尽管已经有了可以被综合的 SystemC 的子集和代码规范，但这种方式目前仍未得到业界的广泛应用。在某个硬件模块没有就位或者需要加快仿真速度时，可以临时用TLM模型替换原先的硬件设计。前提是，系统的仿真行为保持不变，且TLM模型接口上的时序满足HDL仿真的要求。 当 TLM 模型被验证环境复用时，要求 TLM 与验证环境之间保持标准接口（TLM interface），以便于TLM模型的插拔。 软件开发需在完整的系统层面进行，因此当TLM协助软件开发时，TLM子模块要被尽早地集成到一起，作为整体系统为软件开发所用。TLM 模型需要具备标准接口，以便更快地实现系统集成。 目前常见的设计流程仍然是瀑布开发方式或类 ESL 开发方式。类 ESL 开发指的是开发流程并没有完全遵循上述流程，而是在一些地方引入TLM建模。在图2.6中，由于系统人员的技能限制，项目开发需要额外引入虚拟建模团队。虚拟建模团队服务的主要对象是软件开发一方，他们与硬件设计、验证团队的沟通会较少。这种类ESL的开发可能有多种组合，但需要警惕的是，在方便软件开发早期进入项目时，TLM模型应该与系统定义保持绝对的一致性，从而为硬件和软件方提供模型和代码参考。 从图2.6来看，这种类ESL的方式是存在风险的，因为虚拟建模团队从系统定义到TLM模型的过程存在二次翻译。如果翻译不准确、存在疏漏，可以想象，基于 TLM 模型的软件开发不会那么容易被移植到真正的硬件系统上，因为硬件本身也是二次翻译的。所以，理想的合作边界应该如图2.7所示，虚拟建模首先和系统定义保持原义的一致性，硬件和软件则可以将TLM模型视为功能描述的一致性翻译，然后各自在TLM模型上进行开发。 2. 验证的层次从系统定义阶段开始，我们将芯片系统划分为子系统，进而将每个子系统划分为不同的功能模块，直到划分为复杂度合适的模块。到设计阶段，按照自底向上的方式开始做硬件设计和集成。从定义阶段到设计阶段，再到后端部分，整个硅前的流程都是将芯片按照层次划分的，一般称为芯片系统级（chip level /system level）、子系统级（sub-system level）和模块级（module level /unit level）。 这种层次划分的方式对于芯片开发有哪些好处呢？ 便于拆解功能模块，实现人员的并行工作协同。这一点是从项目执行效率出发的。 对于系统定义而言，这是从主要的功能、性能要求量化为系统不同模块定义的方法。 从设计和验证角度出发，合适的复杂度模块有助于估计工作量和人员分配。设计最终是通过模块化来集成的，而验证环境在模块化后可方便地在更高层的环境中复用。 对于后端，在进行了合理的区域划分后，模块和芯片系统可以并行进行后续的物理设计流程。设计模块在每个阶段进行相关的设计检查，集成后的芯片系统最终进行设计检查并通过流片要求。 如果我们是在为一款手机设计通信芯片，如图2.8显示，一开始的系统定义阶段可能要规划出这么多的功能模块，还需考虑模块的性能因素。每一款芯片都包括多个子系统，每个子系统包含多个功能模块。从图1.3中的这款手机通信芯片结构来看，它包括的子系统有： 处理器子系统； 协处理器子系统； 本地存储子系统； 外部存储控制器系统； 数据接口系统； 系统模块外设； 多媒体子系统； 调制解调子系统。 核心模块调制解调子系统中的2G/3G/4G 由于自身的复杂性提高，可以进一步作为独立的系统来对待，进而细分下去。至于如何划分层次，我们一般从如下几个角度考虑： 系统的复杂性：如果系统相对独立，自身就有作为子系统的条件；如果本身仍过于复杂，则可以进一步细分。 芯片集成的便利性：对于顶层芯片集成而言，一个合适的子系统应与外界有清晰的功能边界，如系统信号边界、标准总线边界、与其他子系统交互的边界，同时这些信号边界也尽可能保持稳定和精简。这是从顶层集成的工作量和后端布局布线的角度出发的。 验证的阶段：验证人员需要清楚，哪些功能点在模块级验证、哪些在子系统级验证和芯片系统级验证、是否有必要在不同级别重复验证、各个层次是否会保证验证完备性。 后端的流程：如果一个子系统占芯片整体面积的10%以上，那么后端就有理由考虑将其单独综合，因为合理的划分子系统且并行综合有助于后期整个芯片综合的收敛。 接下来主要从验证的角度来考虑，如何选择合适的验证层次和对应的验证环境： 模块级（block level /unit level）； 子系统级（sub-system level）； 芯片系统级（chip level）； 硅后系统级（post-silicon system level） 2.1 模块级如果是图2.8中的处理器子系统，考虑先将DMA（Direct Memory Access）、Cache缓存和 Core0/Core1分别展开模块验证。每个模块验证首先要考虑的是，哪些功能点可以在模块一级完全验证。 决策基于如下因素： 内部功能如状态机验证； 内部数据存储验证； 数据打包功能、编解码功能； 指令执行； 寄存器配置。 同时需要考虑哪些功能无法在模块一级被验证到： 与其他相邻模块的互动信号； 与其他子系统的互动信号； 与芯片外部的互动信号； 与电源开关的验证。 我们需要考虑在更高的层次来验证这些部分。 2.2 子系统级一个成熟的子系统，既拥有完备的功能可以执行专门的任务，也有足够稳定的接口用来在更高层做集成。与模块相比，子系统更稳定也更封闭，这对顶层集成是有好处的。也正是这种便于集成和相对封闭的特征，使得我们可以从公司外部或内部得到不同的子系统。 合格交付的子系统应该包含： 设计包； 验证包； 回归测试表； 覆盖率收集脚本和数据； 完整的文档（设计、验证、集成、后端）。 完备的交付可以增强顶层集成的信心，同时减少在集成过程中发生的一些接口理解分歧和参数化配置问题。单就验证而言，除了充分验证内部功能，如果对子系统的外部接口需要进行参数或编译预处理（compiler directive），验证人员则需要就这些参数和不同的编译选项（可能因此产生不同的硬件结构功能）给出完备验证。从子系统的封闭性和复用性来看，它们会在多个芯片项目中被使用，这对设计复用来讲是一件好事，而验证也需要将验证环境参数化以适应硬件的参数化配置。只有充分验证了参数化的子系统，才可能让它在不同的芯片项目中实现预期的功能。对验证管理而言，子系统验证是一个理想的可以切分的单元。这一层下面的模块之间互动很多，而这一层本身趋于封闭，与外围的接口有限，所以便于在子系统层设置独立的验证小组——“包产到组”。 2.3 芯片系统级在芯片系统级，我们的验证平台的复用性较高，这主要是因为： 外围的验证组件不需要像模块级、子系统级的组件那样，数量多且需经常更新。它们主要侧重于验证芯片的输入输出。 芯片内部的子系统之间的交互、协作检查主要交给处理器和子系统，从寄存器检查和数据检查入手，实现定向测试（directed test）用例。 芯片系统级的验证侧重于不同子系统之间的信号交互以及实现更贴近实际场景的用例。这里的实际用例并非在系统软件层面，而是将系统软件层面的场景进一步拆分为多个模块互动情景后，再分开测试。 2.4 硅后系统级尽管硅前验证部分与硅后系统软件开发联系较少，但尽早将硅后软件开发的实际用例用在硅前测试，能够发现一些实际使用中的问题。实际上，系统软件用例和硅前的随机测试具有互补的特性，功能验证中的缺陷如果没有在硅后测试、软件开发、用户使用中发现，那么隐藏的缺陷会静静地躺在那里，也许永远不会被发现（没有零缺陷的芯片，却有用户未发现缺陷的芯片）。所以，将硅后的驱动、固件和系统软件尽早在硅前引入验证过程，则可以与硅前的验证方法形成互补，使验证更加完善。 前面介绍了验证的4个阶段，给出了它们各自使用的测试场景。这里再给出可以遵循的几点原则，帮助大家在验证时选择适合的级别： 能够在更低的级别完成某一项功能验证，就不要在更高层次上去验证。小的验证环境更有利于控制激励场景的产生，能更加全面地覆盖功能点。 低层次已经充分验证过某一项功能，高层次就不要重复验证。低层次无法完全覆盖功能点验证时，应在高层次完全覆盖。 在低层次的验证阶段应适当考虑高层次的测试用例，并在低层次创造一些条件模拟发生的条件和场景。 在高层次的验证阶段，验证环境中的参考模型、数据比对、监视器等模块应首先考虑从低层次环境复用，无法满足时再考虑重新构建。 对于新的模块或者新的功能，应投入更多精力、给于更高优先级，在不同层次充分验证。 通过表2.1来更好地理解不同验证层次的侧重、性能和 使用方法。选择一个合适的验证层次，通过在不同层次分配不同的功能验证点，是最终迈向验证完备性的一项必备技能。 3. 验证的透明度可以按照激励的生成方式和检查的功能点分布将验证划分为三种基本方式： 黑盒验证； 白盒验证； 灰盒验证。 接下来，我们逐一解释这三种不同透明度的验证特征。 3.1 黑盒验证如果验证人员对设计的细节缺乏认识，那么黑盒验证是一种合适的方式。因为验证环境只需要将激励给入设计的外部接口，检查设计的另一侧输出就足够了。测试成功与否只是根据一个输入是否得到一个正确的输出去判断，验证环境本身不会关注设计的内部。 图2.9是黑盒验证的结构。 从图2.9可以看到，激励生成器（stimulator）只负责给设计灌入激励，监视器（monitor）和检查器（checker）只查看和比较输出信号。黑盒验证的一个缺点是缺少设计的透明度和激励的可控性，由此带来的问题包括： 测试失败时无法更深层次地定位问题。验证人员只能判断测试是否成功，无法进一步定位到缺陷所在的位置进而与设计人员完成深度协作。 难以发现一些较深的缺陷。因为验证人员无法根据设计本身给出更窄的随机约束定向地生成一些激励，同时，这对设计内部功能点的功能覆盖率收敛没有太多的帮助。 设计的接口采用标准接口时，图2.9中的激励生成器或总线功能模型可以使用成熟度高的验证IP。这些验证IP一般由第三方公司提供，有时公司内部也有这样的IP，它们的特点是像标准接口一样易于在验证环境中插拔和控制，且接口时序严格按照总线文档定义。监测器也来自于验证IP，这减少了验证人员底层开发的工作量。所以，当模块的接口是标准接口时，验证环境可以复用一些验证IP。 由于黑盒验证本身不包含设计的内部逻辑信息，所以当设计因缺陷而更新或添加新的特性时，原有的测试列表仍然较稳定，验证人员只需要对新添加的特性考虑新的测试场景。黑盒验证有利于保持测试环境的稳定，当后续项目中更新了设计时，新的验证人员也只需要很少的力气来维护继承的验证环境。 3.2 白盒验证白盒验证可以弥补黑盒验证的一些不足。验证人员了解设计的内部工作逻辑、层次、信号等，他们因而可以对更底层的设计细节进行测试。这种验证方式检查设计是否严格遵循功能描述文档，测试发生失败时可以更快速地定位到缺陷。对于白盒验证的环境，我们的参考模型逻辑非常简略，甚至不需要参考模型，只需要植入监视器和断言来检查各个内部逻辑。这种环境配置背后的原则是，充分检查各个逻辑驱动和结构以后，就不需要测试它的整体功能了。不过，使用白盒验证也面临一些方法学上的缺陷： 由于本身专注于设计内部逻辑检查而忽略整体功能的测试，设计本身违反规范时，白盒验证难以发现缺陷。 在数据一致性检查方面，白盒验证难以从整体入手给出实际测试用例。 白盒验证的测试用例很多是从设计细节入手的，所以，设计发生更新时，验证环境的维护成本偏高。这一点在项目间复用方面带来的影响更多，新接手验证环境的人要付出很大的成本去理解设计细节和验证环境的细节；这时候白盒验证环境的低复用性缺点就暴露出来 了。 3.3 灰盒验证黑盒验证和白盒验证各有优势和劣势。在实际验证中，我们倾向于将黑盒和白盒两种方法结合起来，以一种称为灰盒验证的方式（其结构见图2.10），将监视器、断言、参考模型一同用来完善验证。这种糅合方式带来的好处包括： 监视器和断言可以有更好的透明度来着重检查设计的一些重要内部逻辑。 参考模型已经有了断言检查局部逻辑的帮助，所以可以降低一部分精确度，而主要专注在输入和输出数据的比较上。 从复用性角度考虑，灰盒验证也有灵活的变动方式： 对于新的设计，我们的验证人员需要更深入地理解设计本身。采用灰盒验证一开始通过监视器和断言来进行局部验证，待设计初步完善和趋于稳定时，验证人员就有了对设计更全局性的理解来构建参考模型。又因为前期监视器和断言保证局部逻辑的正确，参考模型的 构建不需要完全精确，只需要较少的精力来实现。 该设计移植到别的项目时，设计难免需要进行局部修改，这时，灰盒验证的复用性优势相对于验证环境就体现出来了。哪怕是新的验证人员接手这个验证环境，好的灰盒环境也可以清晰地将黑盒和白盒的部分划分开。在设计复用的项目中，建议首先打开黑盒开关， 这对新的验证人员来讲测试成本较低，也不需要对设计和验证环境了解太多。同时，这么做也可以第一时间保证原有功能的稳定性，并反馈给设计人员新的改动造成的影响。紧接着，验证人员可以针对新的特性创建特定的黑盒测试序列，新的黑盒测试序列因设计本身的稳定 而不需要关注设计内部的太多细节。 完成黑盒验证环节后，可以在时间允许的情况下有序引入白盒的开关。首先应考虑创建新的白盒断言点或功能检查点，关注新的功能部分；其次，完成新的功能点白盒覆盖后，考虑逐个打开原有的白盒功能检查开关。打开白盒检查开关时，我们也遵循着每次添加较少 的开关来跑回归测试的策略，便于发现问题后快速定位到新打开的开关一侧；另外，白盒检查点的开关有优先级，如果验证人员足够专业，在他的代码或者文档中会对这些白盒开关给出说明和重要性排列。文档说明有助于新的验证人员按照优先级的高低来打开不同的开关。 所以，灰盒验证不但可以继承黑盒验证和白盒验证的优势，而且对验证环境在新项目中的复用有明显优势。 最后，我们通过表2.2来总结黑盒验证、白盒验证和灰盒验证的特点。可以看出，灰盒验证可以最好地平衡设计增量和验证复用。在设计阶段，如果验证人员有充分的经验来实现灰盒验证环境，清晰划分黑盒部分和白盒部分，那么在后续的项目中，灰盒验证的良好复用性和灵活性会给模块的集成带来便利。在高度集成化的今天，我们对设计复用性的考量，是从整个设计交付包（design delivery package）出发的，包括之前提到的设计包、验证包、文档包、回归测试包和覆盖率包等。 无论设计人员还是验证人员，都需要从各自的角度考虑复用性，全盘考虑设计的整个流程。设计交付只有能带来更好的“用户体验”，缩短集成时间（设计和验证），这才是好的设计和验证方式。 4. 激励的原则激励的原则实际上就是为了解决一个问题，即如何保证激励源最大的自由度。只有从环境结构上保证了激励源最大的自由度，才能在输入一侧提供更丰富的组合，有条件地穷历一些测试序列。 按照这个核心原则，我们可以按下面这些因素评估激励的自由度： 接口类型； 序列颗粒度； 可控性； 组件独立性； 组合自由度。 下面我们具体了解激励在这些方面的表现和评估方法。 4.1 接口类型面对一个设计的输入接口，我们可以先判断接口的类型 （interface type）。如果设计的接口类型复杂多样，可以通过接口类型的划分，化繁为简地找到从哪里下手给出激励。常见的接口类型可以分为： 系统控制接口（system control interface）。例如，时钟、复位、安全、电源开关等，以及这些系统控制信号旁生出的控制信号，如时钟门控信号（clock gating signal）。 标准总线接口（standard bus interface）。公开的行业标准总线协议，例如常见的AMBA系列协议、OCP、MIPI系列协议等，其文档详细，同时有丰富的验证IP提供服务。 非标准总线接口（non-standard bus interface）。公司内部定义的接口，或者根据模块功能需求定义的接口。接口时序相对简单，文档也较粗略。公司内部即使有可复用的验证IP，验证IP本身也可能未经过充分测试，而且在非标准协议定制的背景下，验证IP的复用性较低。 测试接口（test interface）。该测试接口主要留给可测性（DFT,Design For Test）功能使用，在功能验证中禁用即可。 其他控制接口（miscellaneous control interface）。如果被测设计是处于子系统中的功能模块且与相邻多个模块交互，那么该控制接口的信号数量较多、功能较分散；如果该设计是子系统，则该类型的控制接口数量较少且功能较集中。 有了清晰的分类，验证人员就可根据不同的接口类型选择验证IP，或者自己着手搭建激励组件（verification component）了。 4.2 序列颗粒度对不同的接口我们会引入不同的验证组件。激励生成器（stimulus generator/driver）是接口验证组件的重要部分，它提供一些基本的功能方法用来生成小颗粒度的激励（sequence granularity）。用户也可以进一步做上层封装，从更高抽象级的角度生成大颗粒度或宏颗粒度的激励序列。我们按照软件层概念将激励序列颗粒度划分为下面的层级： 基本颗粒层； 高级颗粒层； 宏颗粒层； 用户自定义颗粒层。 从激励生成器提供的方法继承和封装入手，可以将这些颗粒层的关系表现为，基本颗粒层提供基本颗粒生成方法，而在其上，高级颗粒层和宏颗粒层做了深入的封装，帮助建立数据包（packet）和帧（frame）的概念。用户也可以依赖基本颗粒层，根据实际场景的需要实现自定义颗粒层，以方便特定场景的激励控制。序列的颗粒层次如图2.11所示。 我们以一个商业总线验证IP为例。该验证IP包具有基本颗粒层和高级颗粒层来生成不同级别的测试序列，在一些情况下，验证IP也提供宏颗粒层的定义来满足更高规模的数据传输。这里的抽象级指的是从时序和数据量传输的角度出发，越高的抽象级越不关注底层的时序而更重视数据的传输量，也是 TLM（Transaction Level Model）含义的延伸。当验证人员不能从已有的各种颗粒层中生成自己期望的测试序列时，便可以利用已有的基本颗粒层和高级颗粒层来构建自己的颗粒层。 4.3 可控性可控性（controllability）是从对不同颗粒层的控制角度出发的。按照序列颗粒度的划分，对应的可控性评估如表2.3所示。 在功能验证周期的初期阶段，应从基本颗粒层中选择激励方法，这有利于我们在接口的基本功能中调节测试不同的总线传输情况，这里的验证点侧重于协议功能和时序检查。随着设计趋于稳定，我们逐渐选择高级颗粒层和宏颗粒层，将验证精力转移到数据量的一致性传输和性能评估上，而这两层的颗粒控制性没有像基本颗粒层那样细致到可以调节每一个参数变量，它们会同验证重点保持一致，主要提供跟数据量有关的可约束参数。 4.4 组件独立性将一个设计的边界信号划分为不同的接口类型，并创建出对应的接口验证组件之后，我们就应该考虑各个组件之间的独立性了。组件的独立性（component independency）实际上也是协调性的基本保障，因为有了独立性，各个组件之间才会最大程度地不受其他组件的制约，同时又可以通过有效的通信机制实现组件之间的同步协调。我们接下来看看实现组件独立性需要考虑的因素： 必须按照接口类型来划分组件。 对于系统控制信号组件，尽可能将信号的关系按照实际集成关系做控制，例如，多个时钟是不是同步关系，多个复位信号是否可以单独控制等。 对于总线接口（标准或者非标准），实现一对一的控制关系。例如，若有两组相同的总线，则应引入两个总线组件分别控制，而非建立一个总线组件却拥有两套总线接口；后者有悖于可控性和复用性的要求。 对于其他控制接口，应从实际相邻设计那里准确了解各信号的使能极性、脉冲有效还是电平有效、是否存在握手关系、时序等真实的设计信息，来模拟高层集成环境中的控制场景。同时由于这部分信号偏于杂乱，在尽可能梳理信号的不同来源和功能后，需要在接口组 件中通过封装好的方法来实现灵活驱动。 验证环境中的系统控制信号组件会与其他接口组件发生连接，例如提供必要的时钟和复位信息，那么这些连接也应遵循实际集成的情况，确保组件驱动端的时钟输入与设计的时钟输入端同步。 4.5 组合自由度最后一个衡量因素——组合自由度（combination space）是对上述因素的整体评估。只有通过底层的精细划分，建立抽象级更高的颗粒度，通过独立组件之间的协调来给出激励，才能提供较高的组合自由度。在这里，除了组件的独立性外，需要考虑组件之间的协调方式。 一般将协调方式分为两种： 中心统筹式（centrally organized）。通过中心化的调遣，将不同的任务统一分派给各个接口组件，产生不同的激励组合场景。 分布事件驱动式（distributed event driven）。将激励控制权交给各个接口组件，通过接口组件之间的通信来实现分布式的事件驱动模式，即组件之间的通信通过事件（event）、信箱（mailbox）、接口信号（interface signal）等方式实现同步通信。 通过上述因素，我们可以评定出一个验证环境中各个接口组件之间的组合，是否可以提供足够的自由度，最终有可能穷历出预定的激励序列。 5. 检查的方法懂得了如何实现和评估激励自由度的方法后，需要考虑在各种可能的激励组合下如何选择适当的检查，以完成验证环境的另外一项核心要素——检查。检查就是查看设计是否按照功能描述做出期望的行为，识别所有错误的输出，发现设计缺陷。我们是按照接口类型来划分激励的； 对于检查，类型的划分方式则基于被检查逻辑的层次，这些层次包括： 模块的内部设计细节； 模块的输入输出； 模块与相邻模块的互动信号； 模块在芯片系统级的应用角色。 不同的检查层次，可以考虑采用不同的检查方法，如表2.4所示。 从表2.4可以看出，经常使用的方法有监测器（monitor）、断言（assertion）、参考模型（reference model）、比较器（comparator/scoreboard）、定向测试和形式验证等。接下来，我们简要分析不同检查方法的要点，关于这些方法的更多介绍，读者可以在8.6节详细了解。 一般而言，监测器（monitor）是必备的组件，它便于我们观察硬件信号。所以，在各个层次都可以找到监测器的身影。查看设计内部信号另外一个可行办法是使用 SystemVerilog绑定（bind）的特性。由于监测器可能被置入到各种方法中，我们需要从复用的角度，在构建监测器的时候考虑如下因素： 监测器一般跟激励发生器的作用域一致。这指的是，如果该激励发生器对应一组总线，那么应该有一个对应的监视器负责监视总线的传输。 监测器应根据检查的层次将信号监测分为模块内部和模块边界。 对于断言（assertion），我们主要依靠它检查模块的内部逻辑细节和时序信息。利用断言，我们可以通过仿真或形式验证来完成测试。是否选用仿真或形式验证的方式，这里给的建议是： 如果是模块级别，断言通过形式验证完全覆盖设计的多数功能点从效率和完备性来看是可靠的。同时建议在子系统或芯片一级创建基本的测试用例进行仿真，以作为形式验证的补充。 如果断言验证的功能点较分散或主要关切于模块的核心逻辑、时序，则倾向于使用仿真验证，采取灰盒模式，而用断言来验证重要设计细节。 如果断言总体可以覆盖模块的所有设计功能部分，采取形式验证或者白盒仿真验证两种方法都是可取的。 除了待测设计本身的尺寸、复杂度以外，参考模型（reference model）的构建也与验证方法有关。从2.3节来看，白盒验证对参考模型的要求最低，而黑盒验证却将最大的压力交给如何实现准确的参考模型。 比较器（comparator）的结构相对简单，一般依靠足够稳定的监测器和准确的参考模型，比较器只需要将监测的硬件输出和参考模型的输出做比较，给出充分的比较信息。测试用例结束时，给出自定义的测试报告即可。 当模块完成了模块测试、子系统测试，迁入到芯片系统级测试后，我们在系统一级复用监测器和断言。这些从低层次复用来的监测器和断言，在高层测试中主要用于覆盖目标模块与其他模块互动的功能点。在系统测试中，从实际应用场景出发，我们一般采用定向测试即C/C++代码，编译后由系统中的处理器来执行。定向测试的一个好处是为硅后测试提供可复用的测试代码。 6. 集成的环境分析完激励的原则和检查的方法后，验证平台（testbench）的核心要素就大致齐备了。接下来将进一步分析验证环境的集成需要考虑的因素，并梳理各部分之间的关系。从图2.12可以看出，验证集成环境分为： 验证平台（verification platform）； 待验设计（design under verification）； 运行环境（runtime environment）； 验证管理（verification management）。 6.1 验证平台验证平台是验证人员日常工作的对象。在建立或复用验证框架时，主要考虑激励分类和检查方法两部分，这两部分直接影响验证平台的框架。 激励分为如下两类： 定向激励。一般通过文本激励、C代码激励、预先生成激励码等形式给入。 随机激励。通过随机约束给入激励，这里的随机方式不局限于SV，也包括其他随机验证语言，或者利用脚本语言来产生随机激励。 检查一般分为如下三类： 线上检查（online check）。在仿真的过程中动态比对数据，并给出比较结果。 线下检查（offline check）。在仿真结束后比对仿真中收集的数据，给出比较结果。 断言检查（assertion check）。通过仿真或形式验证的方式利用断言检查设计的功能点。 6.2 待验设计根据功能描述的建模方式，硬件设计可以分为两类： HDL 硬件模型。即，使用 HDL 语言描述的硬件模型，按照硬件层次可以分为RTL和网表。该模型的特点是与硬件设计师距离最近，也是最贴合硬件逻辑行为的模型。 虚拟原型（virtual prototype）。在硬件定义的早期阶段，引入虚拟原型对硬件的框架和性能进行评估。在数字信号处理模块中需要复杂的算法参与，所以在硬件实现之前，可以采用软件算法模型来代替硬件的功能（不考虑时序替代）。常用的虚拟原型语言包括 SystemC、C/C++、MATLAB等。 仿真过程中可以将 HDL 硬件模型与虚拟原型混合，进行联合仿真。这时，需要考虑虚拟原型的接口是否可以在硬件仿真环境中较为方便地集成，以及是否有对虚拟原型的接口时序的要求。 6.3 运行环境运行环境的主要职责是将验证平台和待验设计进行融合（软件激励端和硬件模型端的互动）。 根据前面对验证平台和待验设计的分类，运行环境需要考虑的因素有： 验证平台。运行环境需要传入参数，根据测试场景选择测试序列、随机种子数值、参数化的环境结构和实例化验证平台。 待验模型。除了考虑如何实现HDL硬件模型与虚拟原型在仿真器中协同仿真之外，还需要实现验证平台和待验设计的接口对接，包括硬件信号接口连接和内部信号的接口监测。 仿真全流程建立。包括验证和设计的文件提取 （extraction）、文件依赖度分析（dependency analysis）、编译（compilation and elaboration）、仿真（simulation）、结果分析（result analysis）和回归测试（regression test）等。全流程的建立一般是由环境建设者（environment builder）通过脚本（script）语言来做管理的，用于仿真流程建立的常见脚本语言包括Shell、Makefile、Perl、Tcl、Python等。 6.4 验证管理无论芯片的尺寸有多大，验证人员和验证经理都需要对自己负责的模块或芯片做量化的验证管理。除常见的 Excel 表格管理外，也可使用其他验证管理工具进行管理。这些验证管理工具需要考虑的因素有： 验证计划和进度管理（verification plan and progress management）。验证计划需要将抽象内容与量化后的测试用例、功能覆盖率相对应，进而给出可视化的验证进度。 文件版本控制管理（file version control management）。文件版本控制在团队协作中几乎是必需品，常见的工具有SVN、Git、Clearcase等。 项目环境配置管理（project environment configuration management）。项目环境的配置文件不但包括项目中使用的各种工具的版本、单元库的版本、验证IP的版本，也包括验证环境的顶层配置。通过这些环境配置管理，每一个参与项目的人都可以很快地实现环境配置，省去同步验证环境的工作。 缺陷率跟踪管理（defect tracking management）。之前提到的缺陷率曲线，需要验证人员和验证经理保持记录的习惯，除了通过缺陷率曲线衡量验证的进度，还需要通过记录跟踪缺陷的修复、后续验证的工作。 足够稳定的验证平台，能够在更早期利用不同抽象级别的待验模型展开验证环境的搭建和验证工作。通过模块化和自动化的运行方式，实现环境的从建立到检查，一个完善的验证环境能够给验证人员助力不少。从项目管理的角度，也需要一个完善的工具（可能是几个工具共同协助）帮助我们完成验证管理，最终达到验证目标。 7. 作者结束语 笔者还记得接手的第一个验证环境是Specman eRM结构，当时苦于缺少合适的文档，很多代码和工具的使用让我吃了不少的苦头。经历了OVM的验证阶段后，再回头思考eRM，发现验证的思想有很多是可以借鉴和优化的。就是说，尽管我们验证者（Verifier）需要用更多的时间去适应变化更快的验证技术和工具，但在这背后都是逐步继承的关系。你学习到的知识，多年以后有一部分将被替代，而核心的部分还将被保留下来。本章关于验证策略的通识，就是属于那些不会被替代的部分。你会在任何一种验证语言或者验证方法学中捕捉到与验证策略有关的信息，因为它是验证作为一种综合技术能力的基础。","link":"/IC%E9%AA%8C%E8%AF%81/%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%97/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%972%E9%AA%8C%E8%AF%81%E7%9A%84%E7%AD%96%E7%95%A5/"},{"title":"芯片验证漫游指南3验证的方法","text":"到了目前的阶段，已经无法依赖单一的工具、语言或方法来达到验证的完备性。在实际的验证工作中，需要综合使用多种语言、方法、工具实现此目的。不同的语言、方法、脚本和工具之间没有绝对的优劣之分。比如，仿真验证协同形式验证一起完善功能覆盖率，也可以通过语言和脚本之间的整合完成一项验证流程。总而言之，作为一名有经验的工程师，需要掌握现有的各种方法和工具，通过合理的选择，“保质、高效、低耗”地完成验证任务。所以，我们在这里将验证方法分为若干类，梳理目前主流的验证方法和工具。 主要的验证方法包括： 动态仿真（dynamic simulation）； 静态检查（formal check）； 虚拟模型（virtual prototype）； 硬件加速（hardware acceleration）； 电源功耗（power consumption）； 性能评估（performance evaluation）。 基于此，我们引入一节“开发环境”，介绍日常的编码环境。所谓“工欲善其事，必先利其器”，一个应手的开发环境，是迈向高效的一步。 1 动态仿真动态仿真（dynamic simulation）: 最常见的验证方式——，是通过测试序列和激励生成器给入待验设计适当的激励，随着仿真进程的推进，判断输出是否符合预期。简而言之，我们需要仿真器来配合这一项工作，验证人员也需要查看比较结果和仿真波形，最终判定测试用例是否通过。按激励生成方式和检查方式，可以将动态仿真进一步划分为： 定向测试（directed test）； 随机测试（random test）； 参考模型检查（reference model check）； 断言检查（assertion check）。 参考模型一般伴随着定向测试或随机测试，所以我们接下来着重了解定向测试、随机测试和断言检查。 1.1 定向测试定向测试 ： 指的是激励内容在仿真之前已经决定下来，测试用例给出的激励序列不会在下一次提交任务时改变。 我们日常通过C/C++代码来实现子系统级或芯片系统级的测试，这是因为待验设计往往包含处理器，而且从硅后测试复用的角度来看，我们也倾向于运用C代码来编写高层次的测试用例。从图3.2可以看出，测试用例经过编译，转换为硬件存储器可以读入的文件（一般为二进制格式，主要包含地址和数据两部分）。待验设计经过上电复位（power up and reset），从存储器中读取二进制文件，处理器将二进制数据译码（decoding）为指令和数据，进行运算或存储访问。定向测试最终的数据比较分为两种情况： 通过内置的C代码进行数据正确性检查； 通过外置的参考模型或者其他检查器来进行信号一致性检查。 有时我们考虑直接将第三方提供的可执行文件或二进制文件作为激励源交给存储器，这就省略了C代码编译的步骤，但这需要相应的运行环境兼容。 将上述定向测试流程与实际项目进行对比，如图3.3所示，测试用例可以通过C代码交给处理器进行硬件行为的仿真检查。如果模块验证环境中缺少处理器，如何在这一级实现C代码的垂直复用（从模块级到芯片系统级）呢？ 可以考虑下面的步骤： 将C代码交给转换器将其转换为文本命令格式； 文本命令格式可以被总线翻译器识别进而转换为总线上的读写操作。 上面的步骤中需要引入转换器实现复用，也可以考虑将转换器和总线翻译器通过标准的SystermVerilog C-DPI接口，从而实现良好的复用性。关于如何应用C-DPI接口，读者可以在17.1节获取更多的进行 转换细节。 定向测试一般应用在模块测试的早期或者在系统级芯片测试场景中，它适合于测试设计的基本功能，能直接翻译出验证人员想要的场景。它的缺陷也很明显，就是每一个定向测试用例在通过之后的重复仿真是冗余的，因为这样无法产生新的测试序列，也不会带来更多的覆盖率。不过，正因为它的激励序列确定性（determinacy），定向测试可以用来构成基本测试表，在验证前期完成设计的基本功能检查。 1.2 随机测试与定向测试序列相对的是随机序列（random sequence）。随机序列通过预先定义的约束，每次随机产生合理的数值，通过激励产生器给出测试序列。图3.4可以说明，与定向测试相比，随机测试可以直接 通过激励生成器发送测试序列。 产生随机数的方法有很多种，并且有很多语言可以实现。但考虑到灵活地给随机绑定一些约束时，我们就需要特定的语言提供这样的属性，目前常用的语言有SystemVerilog和e语言。从图3.5来自Wilson2014年的调查数据来看，SystemVerilog的使用率大致已经上升到了75%左右。 约束实际上是决定随机激励能否符合接口协议的关键，也是朝向验证合理状态空间的关键。随机约束生成器一般通过静态约束或动态反馈约束给出每一轮的激励。从图3.6可以看出，在实际的验证环境中，往往有很多对随机约束起控制和反馈作用的因素，它们分别是： 静态随机约束。即默认的约束，一般与激励一起定义，不随测试而变化。 反馈的动态随机约束。在测试过程中通过上一轮的结果来对下一轮随机序列给予反馈，通过额外的偏置约束（biasing constraint）给出更小的随机域（random region）。 待验设计的功能验证开关。待验设计的功能点有时可以通过测试序列来关联，进而从该序列是否要验证某一项功能来决定某一组随机约束是否生效。 激励的结构成员。随机激励的成员一般分为接口成员（与设计进行交互）和成员间的逻辑变量（决定成员之间数值关系的变量）。 验证环境的配置参数。如果验证环境是可配置的，那么这些配置参数也可能会影响序列的产生。 验证环境中不同激励组件之间的同步通信。如果验证环境中包含多个激励组件，那么要实现这些随机组件之间的协同，就需要考虑通过同步通信（synchronization communication）来实现。 1.3 基于覆盖率驱动的随机验证目前常用的一种随机验证方式是基于覆盖率驱动的，这种方式与3.1.2节提到的影响随机生成的因素“反馈的动态随机约束”一样，有着类似的反馈控制原理。从图3.7可以看出，与常用随机约束验证方式不同的一点是，覆盖率收集器在每次测试中都通过监视器来收集覆盖率（主要指功能覆盖率），将其与已有的覆盖率数据库进行合并，同时根据现有的覆盖率数据库为下一次随机约束给出反馈。这些反馈被用来进一步缩窄随机约束域，使其偏置产生一些序列，覆盖那些未知的功能测试点。 1.4 基于TLM的随机验证测试用例可以指定每一次激励的数据内容，也可以在较高层次上指定每一次激励数据包（data packet）的内容。我们在2.1节中介绍了通过TLM在产品定义早期对设计建立模型。在抽象层次上，TLM比硬件时序行为更高一级，被用来描述设计或验证环境。基于TLM的随机验证方式，指的是在随机环境中使用的最小颗粒是 TLM 级别的数据包。该激励数据包不止包含一个时钟周期给出的激励，而是在更长的时间范围内（一般为一次完整的数据操作，例如完整的数据读写或数据包传输）定义更多且有内在联系的数据。 TLM验证带来的好处是，验证人员可以更便捷地描述一些测试场景，更贴近真实的用例。比如硅后系统测试和固件开发，是基于系统级别的，它们专注的并非单一模块的某一项功能，而是子系统或整个系统的复杂工作模式。从图3.8可以看到，TLM测试抽象级较高，需要由TLM2RTL激励生成器做进一步的转换。将TLM激励生成器进一步放大，可以看到它内部的一些转换模块，包括读写操作、复位操作、中断操作和其他操作。这些方法一般是根据TLM操作命令经过转换去调用的，我们将这样的激励生成器称为总线功能模型（BFM,Bus Functional Model）。 BFM的作用是将高抽象级的TLM命令转换为低抽象级的硬件端口时序。进一步看，在高抽象级到低抽象级的转换中，除了数据抽象度在降低外，激励所用的时间也在转换中被施加到待测接口上。因此，要完成一项 TLM 命令的转换，经常需要数十个甚至数百个时钟周期。 1.5 断言检查影响验证产出的一个重要因素是如何准确地描述功能。如图3.9所示，清晰的描述可以帮助设计人员更方便地实现设计功能，验证人员也需要检查各种可能的行为是否符合预期。 断言（assertion）提供了这样的特性，它善于针对某一特定的逻辑或时序进行预设，一旦设计的实际行为不符合断言的描述，则给出检查报告。 断言本身不限定于某一种语言或者工具，它的特性可以准确地描述出设计的预期行为。所以有多种实现断言的方法和工具，在过去的20年间，这些被业界支持的基于断言的验证方法和工具如图3.10所示。 在这里，我们按照断言方法不同的运用将它们分为如下几类： 商业开发的断言IP，可用来插入到HDL中做检查，例如CheckWare（0-In/Mentor）。 专门开发的断言语言，例如PSL（Property Specification Language）。 广义的验证模块，不依赖于特定的语言或工具，例如OVL（Open Verification Language/Accellera），这些验证库中含有多个常用的验证模块，可用来在设计中例化。 根据广义的验证语言描述而使用其他语言实现的验证库，例如按照OVL实现的QVL（Questa Verification Library/Mentor）和 OVA（OpenVera Assertion checker library/Synopsys）。 扩展某一种语言的特性，延伸出断言的功能，例如SVA（SystemVerilog Assertion）。 可以在验证平台中使用断言，也可以插入到设计中使用断言。断言可以同时为验证人员和设计人员所用。使用断言的优势在于以下几个方面： 由于断言的位置更贴近于不同功能点的源码位置，这使得相应检查的功能点发生错误时能更快、更清晰地定位出错误源。 断言自身可以表达更长的时序，覆盖任意长度的功能时序，这使得它可以在更高的抽象级别描述设计行为。 断言也有覆盖率的功能，通过断言覆盖率可以建立量化数据来衡量验证进度。 断言可以被直接置入到设计中（无论是设计人员置入还是验证人员置入），这使得断言可以在不同的层次上得到复用，使得它有更久的生命周期和验证延展。 这里谈到了断言的复用性，实际上断言的应用场景非常多，且它便捷的即插即用特性使得有多种商业断言 IP 可供植入到验证环境中。下面通过图3.11说明断言应用的场景及其垂直复用的特性。从应用场景来看，典型的断言场景包括： 集成连接。例如，片上网络多个发起端和目标端之间的访问路径检查，或者系统集成中各个模块之间的连接关系。 总线协议。针对工业标准总线，有商业验证 IP 可以协助验证设计是否按照总线协议实施。 仲裁机制。仲裁机制中的各种模式通过检查来保证仲裁执行的合理。 数据一致性。对于存储单元，数据的一致性检查可以通过检查端口读写来预期数据的一致性。 数据进出。对于队列设计，也可以建立模型来检查断言。 状态机。检查状态机的跳转是否正常。 输入限定。基于假设的输入限定可以通过断言来判断输入是否符合预期，这对错误源排查也有帮助。 自定义断言。用来检查各个设计的细节，通常这些细节属于设计人员和验证人员关注的功能焦点。 从复用性来看，断言可以实现从模块级到子系统级再到芯片系统级的垂直复用。从图3.11可以看出，从单元1在模块级验证时插入的断言“数据进出”和“状态机”，在子系统级和芯片系统级两个环境都可以保持监测检查状态。这一点要归功于断言可以作为非综合模块被植入到设计中，或者通过绑定的形式嵌入到设计中（不影响设计结构）。在子系统中，新的断言部分“子系统集成”又可以用来检查从单元1与从单元2之间的集成关系，该检查在芯片系统中也可以保留下来。 2 静态检查与动态仿真相对应的是静态检查，它本身不需要仿真、波形激励，验证人员通过工具的辅助即可以发现设计中存在的问题。静态检查可细分出更多种类，它们关注的领域各不相同，我们将这些方法概括为： 语法检查（syntax check）； 语义检查（linting check）； 跨时钟域检查（CDC,Cross-clock Domain Check）； 形式验证（formal verification）。 2.1 语法检查如大多数编译器（compiler）自带的功能一样，验证工具一旦需要建立模型（无论是针对动态仿真还是静态检查的模型），都需要编译器对目标语言提供语法检查。仿真编译器会帮助检查语法错误，例如拼写、声明、引用、例化、连接、定义等常见的语法错误。不同仿真工具对语言标准的解释也可能存在偏差，所以使用不同厂商工具提供的编译器时需注意以下几点： 某些不常见的语法使用，在编译器A中可以通过，却不见得在编译器B中也可以通过，这种差别通常跟仿真器的特性和支持有关。如果在设计验证中使用了不同的工具，那么我们要做的应该是让代码（无论是设计代码还是验证代码）满足所有工具的要求，确保它们跟工具 之间保持良好的语法兼容。 语言本身有不同年份的标准，所以需在编译过程中注意加注不同的选项。假如编译器默认按照VHDL93标准来编译VHDL文件，那么当显式声明文件为VHDL87格式时，需要额外加注编译选项。 除了语法检查，编译器也提供其他选项来检查设计代码风格是否符合可综合规范。建议在编译时添加这些选项，以帮助检查设计中较明显的漏洞。 值得注意的是，目前 SystemVerilog2012中的标准并没有全部被编译器支持，而且不同工具的支持程度不尽相同。如果准备使用一个较“偏门”的语言特性，在实现它之前可以查看工具支持文档，或者查看编译结果来获知该特性是否被支持。 对初步认识仿真工具的人而言，不同编译器对同一项语法错误给出的错误提示可能也不相同。这里我们给出的建议是： 认真阅读错误信息。没错，请你认真阅读错误信息。 在认真阅读无果的情况下，可以根据错误信息的代码，通过工具命令结合错误代码来查看错误信息的具体解释。 如果经过前两个步骤仍然无法解决，请找一位有经验的工程师帮你一起检查错误，并且给你一些如何理解错误、查找语法错误点的方法。 2.2 语义检查和语法检查相比，语义检查是在设计可行性上做深入检查的（当然前提也是首先通过了语法检查）。语义检查是通过专用的工具来协助完成的，如0-In（Mentor）和Spyglass。 语义检查的范围包括： 常见的设计错误； 影响覆盖率收敛的问题； 可能会产生X值以及受其影响的设计部分。 进一步细化这些检查项，它们会具体检查以下设计方面： 验证收敛性检查 无法达到的逻辑部分 无法跳转到的状态机状态 无法完成的状态机跳转逻辑 硅效用检查 寄存器被固定赋值 寄存器未初始化 X值的传播 功能问题检查 状态机检查 总线检查 case语句检查 数学逻辑检查 这些静态检查最大的便捷性在于，可以在早期发现一些功能实现以外的设计问题，而且也有助于完善设计代码，提高有效覆盖率以及RTL与网表的逻辑一致性（例如寄存器未初始化或者固定赋值）。语义检查最显著的两个优势在于： 不需要验证环境。设计人员可以在发布设计版本前用语义工具检查修改设计中的问题，这对在仿真之前扫清基本障碍、保证设计质量很有帮助。 不需要写断言。这与接下来介绍的形式验证有关；语义检查无关乎设计从功能描述到实现的翻译准确度，所以不需要断言参与进来。 2.3 跨时钟域检查大多数复杂的设计都拥有不止一个时钟，多个时钟之间也常表现为异步的关系。设计中的不同功能模块如果被不同的时钟驱动，就会形成不同的时钟域（clock domain）。单一时钟域模块的设计方式和验证环境较为简单，而拥有多时钟域的硬件，其跨时钟域的逻辑通信就需要考虑同步问题。在这里，用来验证这些设计要求的过程称为跨时钟域检查。 需要同步是因为考虑到不同时钟域的信号采样问题，当时钟域A的信号进入时钟域B被采样时，每个周期都有相对时钟B不同的延迟，这种随机性可能导致建立时间或保持时间无法满足，进而导致不可预期的功能失败。 这种跨时钟域问题无法通过常规的验证方法来分析，例如动态仿真，也不能被静态时序分析（static timing analysis）判断出来。而这里通过静态的跨时钟域检查就可以分析这一问题。如图3.12所示，通过该方法，可以在早期的 RTL 阶段识别出跨时钟域的通信电路上是否有合适的同步处理，所以，跨时钟域检查（CDC）是为了保证所有信号都能得到正确的同步。目前支持CDC检查的商业工具有Spyglass和0-In（Mentor）等。 2.4 形式验证形式验证分为两种方式： 等价检查（EC,Equivalence Check）。用来保证两个电路的行为是等价的，可用来检查不同抽象级的电路是否一致，例如RTL级和网表。 属性检查（PC,Property Check），又称为模型检查（MC,Model Check）。电路的行为通过验证语言来描述其属性（property），随后通过静态方式证明在所有状态空间下都满足该条件，否则举出反例（counter example）证明设计行为不符合属性描述（property description）。 我们这里介绍属性检查，即通过验证语言（PSL、SVA）来描述设计行为，用断言（assertion）结合静态工具进行空间穷举，证明设计行为同属性描述保持一致。属性检查的流程通常如图3.13所示。 在动态仿真验证中，我们是通过生成各种测试序列来访问设计中的状态（state）的，在理论上，所有可以跳转的设计状态总和被称为可及状态空间（reachable state space）。遍历可及状态空间的所有状态对动态仿真而言是非常大的挑战，这种通过访问状态、检查结果的方式，需要覆盖率反馈来衡量可及状态空间还有多少状态没有被访问。 动态仿真验证的方式实际上很难穷举所有可能的序列去完全覆盖可及状态空间，而形式验证可以通过数学方式来穷举出所有的状态空间，彻底验证设计。从图3.14可以看到，在仿真过程中，通过随机和覆盖率反馈的形式，可以产生不同的测试序列来访问状态空间，直到发现新的缺陷。这是一种实用的测试办法，但另一方面，动态仿真验证无法确定设计中不存在缺陷，因为图中其他隐藏缺陷依然存在尚未被探索到的状态空间内。 形式验证可以通过数学的方法遍历状态空间，进而证明设计行为符合属性描述。在遍历过程中，一旦遇到反例，形式验证工具便会停下来，报出反例情景，让用户核对错误是否属实，再考虑修改设计或者进一步约束属性使其更精确地描述设计行为。从图3.15中可以看到，在大量的状态空间中，形式验证工具只需要针对某一项属性描述举出反例，即可报告给验证人员，而并不需要穷举所有的反例。待设计缺陷被确认、修正之后，验证人员可以继续通过工具来对设计属性进行检查。 像上面所讲的将属性描述（由断言构成）与设计结合进行一致性检查的方法，自提出到现在已超过20年了，期间有不同的商业工具提供支持，如OneSpin、0-In和Jasper等。图3.16概括了这些工具的发展历程。 3 开发环境介绍一下验证人员日常编码SV的开发环境。 3.1 Vim开发环境3.2 商业SV开发环境——DVT在语言编辑和调试的基础上，DVT的测试平台语义检查器（testbench linter）可以通过静态代码分析，发现不合适的语句、代码风格、无用语句、性能问题以及与OVM/UVM相悖的使用方式。它可以通过改进验证代码的可靠性和可维护性来协助验证人员更好地完成 验证任务。与之相比，普通的编译器往往只会检查代码是否符合语言规范，不会给出代码可靠性和可维护性的报告，也无法进一步给出建议以使代码与方法学保持一致。此外，DVT自带的文档生成器可以用来从代码中的注释自动生成HTML文档。这种方式使得设计验证人员花费更少的精力便可得到一份结构良好的设计和验证文档，文档的内容包含类和成员介绍、继承树、设计结构、UML类图和验证框架等。 4 虚拟模型虚拟模型即高抽象级的硬件模型，软件模型可依赖虚拟模型在早期开发，并将反馈交给硬件设计。这种反馈在以往的瀑布模式开发周期中是无法实现的，因为软件的开发往往需要等到硬件设计制造完成之后才能展开。通过虚拟模型，硬件可以更早地获取软件反馈而对设计进行修改。这种硬件和软件更紧密的协作方式，可以体现更多的优势，比如利用虚拟模型获取的性能数据可以对硬件早期结构提供参考意见，或者判断硬件和软件的协同任务是否满足功耗目标。在目前多核的手机移动平台上，将不同的任务合理分配到多核上以取得更好性能的需求日益增长，这种软件层面的评估就可以在虚拟建模阶段完成。目前，我们通过多项虚拟建模的技术例如协同设计、协同仿真和验证，试图在早期发现设计缺陷，以便在相对容易实施的阶段完成这些缺陷的修改。如图3.17所示，通过这种将设计问题更早暴露出来的方式，可以达到芯片成功流片的目标，满足市场越来越紧迫的窗口需求。 广义的虚拟建模包括一系列的验证技术，如仿真（simulation）、模拟（emulation）和FPGA，而目前的现状是，验证人员往往综合使用这些方法获得更好的效果。在这里，我们将虚拟模型限定于仿真（simulation），而将模拟和 FPGA 归类为硬件加速技术，我们将在3.5节详细介绍硬件加速技术。那么，虚拟建模的优点有哪些呢？ 在早期通过软件测试发现硬件和软件的问题。这种方式可以提前进行软件开发，更早暴露软件和硬件之间的协作问题或功能边界定义不清晰的问题，在模块 RTL 阶段就发现和修改缺陷。 软件反馈进入硅前开发周期。软件和硬件的紧密协作使得软件也参与到了硬件结构定义和实现的工作中。 减少硬件协同软件的验证工作。虚拟模型使得硬件设计有源可寻，同时软件的早期进入也可以帮助硬件完成一些难以通过仿真完成的系统测试。 为用户建立硅前平台模型。早期的系统模型一旦经过软件测试，就可以为用户提供上层开发的环境。 硅后平台的参照模型。硅前平台模型有更多可见的内部结构，这些细节在物理芯片上是观察不到的。 虚拟建模是一项不断完善和发展的技术，正被广泛运用到芯片设计验证领域。那么，主要的虚拟建模平台有哪些呢？目前工业界一致推广利用TLM（Transaction Level Models）建立抽象模型，而TLM也已经发展到了TLM 2.0标准。主要的EDA建模仿真工具支持基于TLM 2.0的SystemC和UVM，我们将支持SystemC建模的仿真工具分为下面两种： 仿真器（simulator）。它们支持SystemC的编译和仿真。由于SystemC可以纵深硬件抽象度，所以模型既可以拥有TLM端口，也可以拥有硬件信号端口。如果模型在边界上规定了信号时序，那么可以将端口信号添加到波形窗口中查看，也可以通过断点的方式来调试SystemC模型。 专用的虚拟建模平台（virtual prototyping platforms）。这些平台专门服务于虚拟建模和仿真。从抽象级来看，它们的视野显著高于 RTL 仿真；从开发链来看，它们从更早期的产品定义阶段开始。这些虚拟建模平台主要的特性包括结构设计和评测、软硬件之间的权衡分析、早期的性能和功耗评估、软件集成测试、为 RTL 验证提供参考模型。不同 EDA 厂商提供的平台有 First Encounter（Cadence）、Vista（Mentor）和Virtualizer（Synopsys）等。 那么在这些平台上，虚拟模型建立的方式是什么呢？实际上，虚拟模型的建立与RTL建模类似，只是抽象层次变高了，或者代码量变少了（但不见得变简单了，这要看逻辑实现的细节程度）。芯片中各子模块对应不同的软件驱动库、应用库，要尽可能在系统建模中囊括各子模块 TLM 模型，这样才会给软件提供更贴近实际的环境（即可以将硅后开发的软件先在虚拟平台上测试）。在虚拟建模平台上，可以通过可视化界面和自动化方式集成已备好的模块。在集成过程中，我们将模型分为两个类别： 自建虚拟模型（即对照自定义硬件建立的虚拟模型）； 商业第三方IP（这些虚拟模型IP对应硬件IP模块，完善的商业IP交付包囊括多个设计验证部分，包括RTL、SystemC和验证平台等）。 此外，虚拟模型可以作为参考模型参与到RTL仿真中，这种SystemC同RTL的协同仿真模式包括： 协同设计（co-design）。将SystemC模型集成到现有的设计当中，作为暂时替代设计的一部分。对此种设计的要求是，虚拟模型的边界接口应有合适的时序与相邻模块完成信号交互。 协同验证（co-verification）。将虚拟模型作为参考模型集成在验证环境中，该方法也减轻了验证人员的负担。 越来越多的公司应用虚拟建模来尽可能地提前软件开发时间，同时此种方法对现有工作方式提出了挑战，比如团队学习，如何在硬件设计流程引入该方法，如何衡量虚拟建模的长远价值和人力额外投入，如何将虚拟模型团队同设计验证团队整合，等等。这需要团队整体看到它的优势并愿意为之改变，将它的优势更好地发挥出来。 5 硬件加速动态仿真和静态检查方法各自具有优势，然而它们都不具备的一个优势是速度。尤其是在SoC的设计体量越来越大时，仿真速度成为制约验证进度的重要障碍。由于仿真速度的限制，一些真实的用例无法在RTL级仿真很快地呈现结果，这种困难在硅后软件测试发现问题反馈给硬件团队时更加明显，因为通常这意味着硬件团队需要将耗时（仿真时间）很长的软件进行分析，找到可能的问题点，拆分软件场景，进而在硬件仿真上尝试重现问题。 仿真速度的限制使得无法通过仿真在早期测试软件，这一任务一般交给其他两种方法： 虚拟模型平台（virtual prototype platform）； 硬件加速（hardware acceleration）。 虚拟模型平台的一项优势是可以在硬件设计之前建立硬件模型，并通过集成来生成虚拟模型平台，当然，这也意味着新的工作量和技能学习。 那么，硬件加速的流程是什么呢？一般需要等到硬件设计初步稳定，进而将其映射到可配置的平台上。设计的数字电路部分可以通过更高的时钟频率（受限的，无法达到真实芯片频率）来仿真，这种方式比RTL仿真速度已有质的提升，稍后我们比较速度的提升优势。 目前，业界主要的硬件加速方式分为两种，即FPGA和专用的模拟器（emulator）。实际上，专用模拟器仍然是基于FPGA的定制产品，只不过比起商用的FGPA（Xilinx、Altera）在硬件加速方面还有其他显著的优点： 内部可编程单元网络的连接方式不同于商用FPGA，这使得它在综合布线效率上面显著优于FPGA，而且对内部可编程单元的利用率也高于FPGA。 外部连接的方式不同于FPGA，这使得它可以通过多路复用技术实现片上存储共享，而不再像FPGA一样需要定制的存储器。同时，通过扩大I/O引脚数目扩展器件之间的通信带宽，确保模拟器之间的通信速度不成为瓶颈。 智能的数据采集和内置追踪存储器的特性，使被映射到模拟器平台的所有逻辑单元在理论上都是可见的。这种采集方式在一开始建立平台时就可以通过定义采集信号列表来修改内部走线，同时不降低模拟速度。 模拟器的这些特点与FPGA可以显著地区分开，在实际工作中，FPGA和模拟器使用的场景也有所不同。FPGA原型验证主要是针对小型设计或单独的IP，而模拟器则用来面向更大、更复杂的SoC设计。FPGA主要为软件开发提供平台，而模拟器则是为了硬件和软件协同验证和整个系统的测试。最近10年，模拟平台技术日趋完，使用便利性越来越好，从而越来越多的公司开始考虑使用模拟器。这主要是基于以下因素： 更快的平台建立时间； 更快的编译综合时间（从RTL到仿真运行）； 良好的调试条件，如信号可追踪、波形可保存、设置断点等； 模拟器的高存储量、资源可裁剪，同时支持多任务； 通过云端购买使用流量使用远程服务，而不再像FPGA需要一次性购买，降低了开发投入成本； 易于操作。 FPGA与模拟器在各方面的对比展示于表3.1中。 目前业界的硬件加速标准并未达成一致，主流的三家公司实现硬件加速的具体技术也各有特点。我们在上面提到的模拟器（emulator），通过将设计逻辑映射到可编程单元的方式，主要有Veloce（Mentor）和 ZeBu（Synopsys）。Veloce 通过定制的可编程单元（非常类似于FPGA）、不同的内部连接网络结构以及透明的可调试电路实现其模拟器功能。平台上的每一块模拟器芯片都可用来模拟一部分的设计逻辑，而整个芯片的功能则通过集成各个模拟器芯片实现片间快速通信。ZeBu不一样的地方在于它直接采用FPGA，而且将透明的可调式电路技术和其他特性实现到FPGA中，多个FPGA进一步组成完整的模拟器功能。Cadence公司的仿真加速器（simulation accelerator）Palladium显得与众不同，作为独立的加速器平台，其内部包含数量巨大的简单处理器，每一块处理器又可以仿真一部分设计逻辑，将运算结果在它们之间传递。看起来，这些处理器的运算速度低于我们的桌面处理器，但由于成千上万个小的处理器并行工作，实际的仿真速率远超独立处理器的表现。同时，这些独立的小型处理器支持透明化的调试方式。 模拟器的高速性能使得其有望同真实世界中的电路交流，但需要注意速率差异的问题。假设我们要设计一个USB器件，可能会将物理层的USB与模拟器相连，进而与计算机或其他器件相连。这时候，我们将模拟器与真实世界的应用器件连接，随之而来的问题是，真实世界的频率高于模拟器的频率。我们需要为它们之间的频率差异搭建降速同步的桥接（speed bridge），通过主动降低快速端的速度并缓存快速端的数据，适配两端的数据交换。 如果要将RTL验证平台移植到模拟平台上，可以将硬件部分迁移到模拟平台，同时将验证环境继续运行在仿真平台一侧，这种方式称为联合仿真（co-simulation）。硬件的激励由仿真平台或真实世界的接口给入。硬件加速受到的限制是，它们没有办法像RTL仿真一样透明地观察硬件信号和内部逻辑，也无法随时设置断点调试硬件。在联合仿真平台中，加速因子最大的受限因素在于仿真平台的运行速度，以及它与模拟平台之间通信的频率。 因此，在构建一个联合加速平台时，需要考虑的是： 尽可能地将验证平台实现为可综合的，这样有助于它们被移植到模拟平台上，从而减少模拟平台与仿真平台的通信需求。 如果仍然有一些验证组件无法被移植到模拟平台上，那么需要考虑如何使仿真平台与模拟平台之间的通信速度变得更快，或者使通信次数更少。通过TLM通信方式提高每次通信的信息量从而减少它们之间需要同步的次数，是值得采用的加速方法。 6 效能验证在 PC 时代，少有人将处理器功耗提上验证的日程，因为大家对处理器性能的关注多于对功耗的考虑。我们十多前年使用2G的功能手机，“超长待机”一词渐渐作为广告主打语进入用户的视线，这得益于硬件本身的低功耗（对性能本身的要求不太突出）和大容量的电池。到了智能手机时代，随着对桌面办公和娱乐的移动化的需求增加，手持设备（手机）需要提供桌面机的性能，这催生了智能手机市场过去几年的蓬勃发展。软件对硬件性能日趋增长的要求，以及移动网络数据传输性能的不断提高，都在促进着硬件性能的革新。在移动时代，硬件提升性能的方式主要表现为以下几种： 提升原有处理器性能、存储器空间、数据总线带宽或者采取多核处理方式。 增加额外的协处理单元或新的功能模块（如Video/GPU单元）。 在后端允许的情况下提高工作时钟频率。 提升工艺制程。 总体上看，随着性能的提升，能耗也会逐步提高，这在过去的PC时代不是一个显著问题，但移动时代越发要求硬件的性能提升，同时要求能耗也可以接受。 本节以移动芯片为例，讨论目前对性能（performance）和效能（power consumption）的权衡。在图3.18中，无线通信技术被标注上了1G、2G、3G和4G。香农定律预测，传输性能每8个月提升一倍；摩尔定律指出，晶体管的单位密度每18个月提升一倍，处理器的性能也因此大约提升一倍。预测指出，电池生产商每10年左右将能源密度提升一倍，而存储器的性能大约每12年提升一倍。那么，从不同器件的性能增长差异来看，这也揭示了移动硬件的技术缺口： 处理器和存储器之间的带宽缺口。即处理器的性能同存储器的带宽缺口的差距逐步增大，进而存储性能无法满足运算性能。 效能缺口。传输和运算速率双双大幅提升，使得功耗迅速增长，但由于电池技术受限，使得功耗成为了瓶颈之一。 算法复杂度缺口。传输速率超过运算速率的涨幅，需要更多的处理器来并行完成越来越复杂的算法。 上面讲述的技术缺口与目前硬件提升性能的方式大致保持吻合，接下来主要就如何解决效能缺口入手，讨论目前主流的效能验证方式。 6.1 功率和能量首先我们引入基本的概念，功率和能量在日常器件效能讨论中经常会提起，它们是两个关联的术语。 功率=能量/时间（单位：瓦） 能量=功率×时间（单位：焦） 有时候，我们设法降低功率，能耗随之降低，但这不是绝对的，有些任务在高速高功率情况下可以用更短时间完成，而且实际功耗要比在低速低功率情况下更少。例如，如果静态功耗可以忽略，一个任务需要固定的时钟周期数完成，那么无论时钟快慢，它消耗的能量是一样的；当静态功耗无法忽略时（例如目前最先进的工艺制程已大致在7nm），反倒是时钟更快、功率更高的情况下完成这项任务更高效。所以，效能的验证和评估实际上就是对能量利用效率的优化途径。 6.2 静态功耗和动态功耗从上面的例子我们知道，如果要考虑功耗，需要考虑两部分即静态功耗和动态功耗，总功耗如下： 总功耗=开关功耗+短路功耗+静态功耗 这里开关功耗和短路功耗构成了动态功耗的部分。 开关功耗=C·V·V·F 其中，C是负载电容，V是电压，F是频率。 短路功耗=V·I（短路） I（短路）为在开关切换过程中N极和P极同时有效时发生的短路电流。 静态功耗=V·I（漏电） 静态功耗（或漏电功耗）则是晶体管在电路稳定时出现的漏电造成的功耗。 6.3 节能技术移动芯片节能（省电）技术是全方位的改进流程，从工艺制程到电路、封装到模块设计、SoC 设计、系统和应用软件开发，等等，整个环节都需要有效利用能量。表3.2是从芯片硬件和软件方面所采用的节能技术（省去工艺制程）。 与之前介绍过的硬件设计流程类似，节能的设计流程（见图3.19）也是从规划到实施最后到集成的。面对越来越复杂的系统，实用的方式还是从系统设计开始，逐步分解到电路设计，我们先从硬件层面考虑如何实现低功耗设计。 6.4 效能验证这里主要针对硅前设计阶段进行效能验证，涉及的流程分为两部分： 功能验证。主要采用PA（Power Aware）方式，包括UPF（Unified Power Format）和CPF（Comment Power Format）。通过与仿真器结合，模拟电源域的开关进行设计检查。 功耗预测与优化。使用第三方功耗分析工具，结合仿真数据（FSDB/VCD/SAIF），进行功耗预测并给出分析结果。 PA（Power Aware）效能设计流程 UPF/CPF这两种功耗格式较为类似，可以将它们的应用阶段分为4个部分： 规定功耗格式文件，指定电源掉电、触发隔离和状态保持等行为，以及它们的控制信号。 RTL仿真（门级仿真也可以支持）除了要保证功能正确，还要进行低功耗逻辑和断电控制功能验证，检查状态丢失、分离和保持。 逻辑功能检查和等价性检查（带有UPF/CPF插入的单元）。 逻辑综合和DFT（带有UPF/CPF插入的单元）。 对于硅前验证阶段，验证人员接触到的主要是RTL仿真。我们一般采取的策略是： 进行非效能的RTL仿真（不带PA）。 在RTL功能仿真通过的情况下，进行PA仿真。 在门级仿真阶段，如果时间允许，可以在后期进行门级PA仿真。 6.5 功耗预测与优化一般我们期望尽早获取功耗的估测信息，而这一期望与芯片开发过程相悖，因为往往在流片以后的软件开发阶段测量出来的功耗是更准确的。但是，等到流片之后才去测量功耗，低功耗设计的成本就很大了，这是因为一方面这使我们试错的成本增加，另一方面产品效能优化迭代的周期也变长了。所以，我们希望在硅前设计阶段甚至规划阶段（TLM虚拟模型）估测出芯片功耗，分析出可以降低功耗的设计方法。这里，我们将目光落在RTL和门级阶段，通过现有的功耗设计平台，在早期进行功耗估算、低功耗设计、电源效率提升等事务。 简而言之，目前使用这些工具都是为了查看、估算、分析和降低功耗，通过在 RTL级和门级功耗数据指标和报告，为设计和验证人员提供计算和跟踪功耗的方法。现有的功耗预测分析工具包括PowerArtist（Ansys）、Spyglass Power（Synopsys）、PrimeTime PX（Synopsys）和Redhawk（Ansys）等。我们通过对实际项目中不同工具的比较，提供如表3.3所示的建议。 在硅前验证阶段，目前相对容易做到的是运用PA设计流程进行相应的RTL仿真和后端流程。通过仿真器进行 PA 仿真，在保证原有功能实现的情况下，进一步检查低功耗逻辑和断电控制功能。对于功耗预测与优化，有几点因素值得考虑： 工具的评估和选择：不同的工具有不同的适应场景和性能。 如何将功耗分析与优化纳入项目流程：对于低功耗芯片设计，功耗分析的方向值得提上项目日程。 如何量化功耗优化成果：一方面需要考虑如何选取合适的测试场景来模拟芯片的实际应用，另一方面也需要选择合适的仿真时间窗口作为分析的数据来源。 对比分析不同代芯片的功耗，并给出节省功耗的建议：基于前几代芯片的实际功耗数据，利用功耗估测协助低功耗设计，再通过实际芯片的数据给出反馈，进一步修正估测数据。这种收敛方式有助于更准确的功耗预测。 7 性能验证在了解效能验证之后，我们来了解性能（performance）验证。性能验证中离不开大量的运算和数据传输。之前提到，硅前RTL验证的瓶颈之一在于仿真速度，且这一因素到了芯片级仿真阶段被进一步放大。在产品定义过程中，对系统的运算和数据传输都有要求，在产品实现阶段尽早地得出一些性能有关数据，不但可以帮助提前验证硬件性能是否满足要求，还可以在进度允许的情况下修改硬件设计完善其性能。这种将性能测试提前的方式也使硅前验证与硅后测试采用一致的测试用例，从而得出可比对的性能数据。 性能验证用来衡量一个系统在特定工作负载下的响应能力和稳定性，同时性能报告也可以用来分析和优化系统的质量标准，例如可靠性和资源使用能力。性能验证是实用的计算机科学工程方法，在软件工程测试中分类较多，如负载测试（load testing）、压力测试（stress testing）、浸泡测试（soak testing）、尖峰冲击测试（spike testing）、配置测试（configuration testing）和隔断测试（isolation testing）等。 在硅前验证阶段，目前性能验证还是一个新颖的概念，一方面是因为业界对这一测试还没有形成统一标准，另一方面是因为性能验证更多地是在衡量指标，与验证（判断设计是否与功能描述一致）本身的聚焦不太重合。但对一些性能要求严格的硬件设计，我们确实希望在更早期就得出一些数据，最好能够赶上给设计做出反馈并加以完善，以此降低开发成本。所以，这要求我们能够自己先定义出硅前性能验证的目标、环境和方法。 7.1 设定目标目前我们对性能验证的考虑主要侧重在负载测试和压力测试方面，完成下面的目标： 证明系统（或者子系统）的性能是否符合产品要求。 衡量哪一部分的子系统会成为整个系统或者某些特性要求的瓶颈。 开始性能测试之前，首先问一问自己“为什么要进行性能验证”，因为只有朝着明确的性能目标前进，才能得出下面的关键测试数据： 数据并发量（concurrency）/吞吐量（throughput）。测试数据并发量是系统整体性能的考量，因为在某一个时间段，多个子系统会并行工作，共享一些网络和内存资源；测试吞吐量是围绕一条完整的数据通路测算出它的最大吞吐量或传输速率，例如测试USB的传输速率。 响应时间。这集中体现在处理器访问寄存器和存储器的读写回路延迟，也适用于其他协处理器或者DMA（Direct Memory Access）。 在性能验证计划中描述测试方式和场景是一个难点，性能指标应出现在功能描述文档中。在实际项目中，虽然我们不能很好地知道软件使用硬件的场景以及软件如何调度各个硬件模块，但可以先着眼于单个子系统的性能测试，或者通过测试单一的数据链路找到最薄弱的节点，这种方式可以将问题的复杂性降低到可理解并且可描述测试场景的难度。 7.2 测试环境如果测试环境贴近用户实际使用的情况，我们得出的数据会更加真实有意义。然而在硅前硬件实现阶段，我们与用户之间存在不小的距离。退而求其次，我们希望和固件开发团队合作，找到一些典型的子系统应用场景，通过仿真来观察子系统的性能。为了将测试的成本降低，尽可能选择原有的验证环境，以动态的环境配置嵌入监视系统性能的组件。这些组件根据其特征分为： 在线监视（online monitoring）。一般将监视器（monitor）绑定到目标模块或总线上，动态监测目标的运算处理量或数据传输速度。 线下分析（offline analysis）。将监视到的数据记录下来，通过线下的脚本分析，绘制出性能的波动曲线。 7.3 验证方法从性能验证流程来看，我们可以考虑参照微软的性能测试方法学流程（见图3.20），它包括以下步骤： 构建验证环境：一般利用现有的功能验证环境，通过更新使其能够完成性能检测和分析的任务。 决定性能验收标准：在测试前限定反馈时间、吞吐量、资源利用率等验收标准。一般而言，对于硅前测试，我们可以测出反馈时间和吞吐量，而资源利用率是一个系统概念，较难测试。 制定计划和测试用例：需要与系统人员、固件人员一起列出重要的测试场景，同时建立可以衡量性能的标准。 配置测试环境：如果环境足够灵活，可以在回归测试（regression test）中打开或关闭性能检测功能，以此平衡性能测试可能带来的仿真效率降低。 开发用例和测试：开发测试用例，检测带验模块，收集性能检测数据。 分析结果、报告和再测试：分析测试数据，提交性能报告，如果硬件性能与计划的性能之间有缺口，做出硬件修改。再次测试，直到硬件性能符合预期、满足验收标准。 如前面提到的，实际项目中的性能测试除了不规范和较难实现以外，还缺少明确的验收标准。这使得不同验证人员编写的测试用例与实际应用各有不同，检查性能的标准也不同。目前，我们通过下面一些形式实现性能验证： 在芯片网络结构的端点处（network terminal）绑定总线协议的监测器，以此在网络核心处检测芯片整体的通信情况，计算网络的实时吞吐量，以及单个挂接的子系统的数据传输速率。 将一些 RTL 仿真较为耗时的测试用例迁移到硬件加速平台，利用模拟器来完成性能测试。 为测试用例提供一些宏定义，实现高密度数据传输，以此保证有足够的数据吞吐，来测试数据传输的峰值。 8 趋势展望目前主要的验证方法包括动态仿真、形式验证和硬件加速。如何选择验证方法，是否可以构建一个可复用的验证平台实现不同验证方法的跨越，是接下来我们关心的问题。设计的尺寸和复杂度的不断增长，即使可以利用IP缩短设计时间，但是更多模块之间的互动场景也要求更充分地验证这些状态空间。目前仿真技术的瓶颈在于速度，总结这几年项目的切身感受，笔者认为在仿真中，除了需要 EDA 厂商提供加速方式以外，也需要项目自身结合实际情况使仿真实现轻量化， 以进一步为仿真提速。 形式验证可以穷尽检验一些设计属性。对于合适尺寸的IP，只需要一些时间和运算资源，就可以穷尽检验出设计属性是否满足。例如一个32位的乘法器，动态验证可能需要几年的时间穷举出所有可能的情况，形式验证往往几分钟到数小时的时间就可以了。形式验证随着系统的复杂度提高、状态空间的急剧增长，运行速度也在不断下降。相比较而言，IP是适合形式验证的设计尺寸。 学术和工业领域对形式验证的算法研究非常活跃，但还需解决的问题是，使用者对形式验证语言依旧不精通。使用者需要保证属性描述精确地反映了设计的功能，同时属性描述的总和能够对应一个设计的所有功能，只有满足了这两点，才有足够信心确信形式验证的完备性。目前，我们可以通过 EDA 厂商提供的可复用的断言库来实现高层次的属性描述，弥补我们对断言描述本身的知识缺乏。此外，形式验证让我们“不那么放心”的一点是，它无法像仿真一样为我们提供一个动态的行为，而验证人员又需要“眼见为实”来亲自判断设计的实际行为是否正确。所以，如果采取形式验证，那么建议的一种方式是以动态仿真作为辅助手段完成基本的功能检查。 硬件加速的历史更悠久，可以回溯到20世纪80年代中期到90年代中后期。在RTL仿真还未被推出和广泛使用之前，占据验证市场的还是门级硬件模拟技术。随着 Verilog 和VHDL语言的推出及自动逻辑综合技术的应用，RTL仿真就逐渐取代了硬件加速技术。这一技术更迭的背后，关键因素还是速度，因为那一时期的设计还不足以复杂到仿真器性能无法满足的情况。而在20年后的今天，硬件加速技术显然又有着收复失地的趋势，三大主流工具商都提供各自的硬件加速解决方案。硬件加速的速度优势还是相当明显的。动态仿真的性能平均保持在1kHz，硬件模拟技术大致在1MHz，而FPGA在10MHz左右。无论硬件模拟还是 FPGA，都比动态仿真的速度提高不少。通过更快速的验证技术，我们才有可能抵消设计的复杂度增长和测试代码不断增大的体量。那么，硬件加速技术是不是未来的主流呢？仍然不是绝对的。目前硬件加速技术也有自己的不足，比如： 编译时间较长。硬件加速需要额外的逻辑综合和硬件映射的时间，然而综合、布局、布线和映射在动态仿真中是不必要的环节。 调试手段少且慢。最新的硬件加速技术可实现记录、修改或等待信号等常用的调试手段，然而由于技术限制，添加或修改新的信号仍然需要再次编译，消耗大量时间。此外，受限于可用的存储量，我们无法记录所有层次的信号，只能选择性地记录某些信号在某一段时间内的行为。从调试流程上来看，硬件加速技术仍然无法达到动态仿真的易调试程度。这么看来，尽管在速度上硬件加速有显著的优势，但动态仿真和形式验证在调试层也有其优点。 那么，实际工作中我们如何选择这些技术呢？一般地，我们倾向于以下方式： 在模块级或 IP 级验证中，更多使用动态仿真和形式验证，尽量将缺陷率曲线更快、更多地收敛在这一层次。 在芯片系统级验证过程中，使用动态仿真测试模块之间的集成关系。 对于耗时长的测试用例，如固件启动测试、性能测试、大规模数据存储测试等，在系统测试阶段使用硬件加速以更快地得到结果。 从验证平台搭建和复用的角度出发，需要考虑如何实现一个可以横跨这三种技术的可复用平台。通过一个统一平台，自如地在这三种技术之间实现横向跨越，完成从模块级到子系统级再到芯片级验证的纵向复用，将是接下来实现技术融合和验证复用的方向。 为探讨这一方向，我们就下面两个问题展开论述： 不同技术之间的验证平台横向跨越； 不同层次之间的验证平台纵向复用。 8.1 技术之间的横向跨越在解决横向跨越问题之前，需要理解为什么有这样的需求。从图3.21可以看到，这三种技术之间有着共通的技术桥接、共同的一些核心基础技术： 我们的核心基础技术有验证 IP、覆盖率、调试和软件驱动测试。三种验证方法构建于这些基础上，如它们都需要提供调试接口，也需要提供各自的覆盖率来完成验证。 形式验证和动态仿真之间，可以通过断言和 X-prop 技术来桥接，这两种验证方法都可以利用这些技术实施验证。 在动态仿真和硬件加速之间，可以通过软硬件协同验证的方式实现这两种技术的桥接。 对于断言VIP，可以利用它完成形式验证，或者植入到动态仿真环境中。一些可以综合的断言VIP，也可以移植到硬件加速平台中继续完成验证任务。 那么，如何基于这些项目实际中的桥接设计出可以合并的数据库和通用的验证平台就成为了关键。但对于这两点，目前三大工具厂商还缺乏一种完整的解决方案。例如，验证的覆盖率数据库如何在三种技术中实现互通和合并？如何定义出合理的结构完成形式验证平台到动态仿真平台的复用？什么样的动态仿真平台才可以顺利移植到硬件加速平台上？这些都还是有待解决的问题。 8.2 层次之间的纵向复用在不同验证层次之间进行复用，我们也会遇到实际的痛点。例如，随机约束的仿真方法（SystemVerilog,UVM/OVM或Specman/e）适合于模块级和子系统级验证，而定向测试方法（C/C++）则适用于子系统级和芯片系统级的验证过程。在这里，我们看到子系统级验证有两种可能的验证方法，我们需要考虑是选择其中一种还是两者兼具？如何实现模块级随机测试到子系统级随机测试的复用？如何实现子系统级定向测试到芯片系统级的定向测试复用？又比如，通过何种方式实现从随机约束测试到定向测试的复用？只有完成层次之间的垂直复用，验证的时间成本和人力成本才会降低，验证效率才会进一步提高。 面对目前这三种主流验证技术，我们需要从验证效率出发，合理选择使用这些技术，实现技术之间的横向跨越和层次之间的垂直复用，在不断提速的SoC集成设计过程中保持加速，与设计实现共同飞跃。 9 作者结束语 关于验证方法，其实在笔者多年的技术世界观中，曾一度认为只有随机测试和形式验证才能拯救设计漏洞。但后来发现，每一种验证方法都有其在各自领域、特定验证场景中的优势。尤其是，SoC在最近几年已经完美地翻越了10亿门的篱笆，让传统的仿真在这样大的庞然大物面前如临大敌。如何解决验证的完备性与速度之间的冲突，已经成为选择验证方法的重要考量标准。项目进度的不断压缩，对硬件和软件联合仿真提出更严格的要求，也为虚拟模型和硬件加速等新兴技术开拓了市场。 本书的主要内容着眼于动态仿真技术。这项技术在过去的20年一直是验证领域的主流，也是读者在验证领域亲密接触的对象。在本书出版的同时，硬件加速技术正以更快的步伐走入验证世界，读者需要对这些验证方法做好准备。","link":"/IC%E9%AA%8C%E8%AF%81/%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%97/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%973%E9%AA%8C%E8%AF%81%E7%9A%84%E6%96%B9%E6%B3%95/"},{"title":"芯片验证漫游指南4验证的计划","text":"1 计划概述在选择验证方法和构建验证环境之前，需要搞清楚验证计划是什么。在展开设计之前，设计人员和验证人员会阅读功能描述文档，以理解设计的各项功能为前提，考虑如何实现或验证各项功能。如果功能描述本身不清晰，则需要与系统人员沟通来修改功能描述文档；如果设计和验证双方人员对某一项功能理解有分歧，也需要与系统人员的解释保持统一。完成验证计划后，还需要对其进行修改吗？答案是肯定的。 因为在实际项目执行过程中功能描述文档和设计不断更新，直到流片前都有可能在进行更新，验证人员需要做好相应的验证计划更新。所以，验证计划的生命在设计被构建之前就诞生了，伴随着设计的周期，直到流片。验证计划从创建到执行分为以下几个阶段： 创建验证计划； 选择验证方法； 人力资源调配； 构建验证平台和环境组件； 开发测试用例。 创建一份验证计划是首要的任务，通过收集下列材料可以更好地组织出有价值的计划： 结构功能描述； 设计的各种操作使用模式； 在正常输入和错误输入情形下设计的行为； 设计的接口； 在一些边界情况下设计的行为； 设计在实际使用中的场景描述。 这些资料通常可以从硬件功能描述和系统文档中找到。同时，也可以从硅后测试、固件开发人员那里得到设计的实际使用配置情况。合理的验证计划可以为芯片开发带来很多好处： 使得设计和验证人员对功能描述文档的理解和翻译保持一致。 将自然语言描述的功能通过可测试的语言来描述。 可以更合理地评估出工作量、人力安排和进度节点。 为验证人员提供清晰的验证目标、任务和进度安排。 为功能文档提供反馈，修改文档中不明确、有歧义的描述。 从更宽泛的意义上来看，一份验证计划几乎囊括所有与验证相关的东西，其中不只包括要验证的设计功能，还包括验证方法、人力安排、进度评估，等等。验证计划的生命期很长，在实际环境中，很多因素会不断影响计划的更新，这些可能的因素包括： 会有不同人员更新验证计划。一份充分的验证计划，需要系统、设计、验证、软件人员给出意见，共同参与制定。 需要更新上百上千的测试用例，并与计划中的待测功能映射。 考虑选择不同的验证方法。针对不同的设计，需要考虑选择动态仿真、形式验证或者硬件加速方法。如果采用两种以上的方法，还需要考虑如何实现技术平台上的兼容和跨越式复用。 如果有新的设计要求，需要更新计划，同时设法把对人力和进度的影响降低到最小。设计人员在设计的过程中仍然可能收到新的功能需求，一旦确定要添加新的功能，就需要考虑额外的人力和进度受到的影响。 如果有多个组参与验证，则需要考虑如何协调。对于大型的SoC 项目，一般会有多个功能组参与，甚至他们可能工作在不同的城市，这时，协调组与组之间的工作并综合出整体进度结果就很重要了。 在早期制定一份验证计划，随着设计更新和验证进度跟踪，提高验证的质量，降低项目的风险。同时，验证计划对人力和时间进度的合理估计，也使得验证的流程和进度更加透明。 2 计划的内容在制定验证计划的具体过程中，我们将技术部分和项目部分都考虑进来。从技术角度而言，需要考虑的有验证的功能点、验证的层次、测试用例、验证方法和覆盖率要求。从项目管理角度，也需要考虑使用的工具、人力安排、进度安排和风险评估。 2.1 技术的视角验证的功能需要验证的功能点来自于功能描述文档，设计和验证人员在阅读文档的过程中，会将设计的功能、参数、性能从自然语言拆分转化为一个个可以单独验证的功能点，并用定性定量的语言描述这些功能。 我们将功能点按照优先级分为： 基本功能：通常包括时钟、电源、复位、寄存器访问和基本特性，这些可以在模块级完成验证。 互动功能：一些需要同其他模块互动的特性，需要在更高层次的子系统级或芯片级完成验证。 次要功能：通常这些功能在项目后期完成验证，如性能验证、效能验证。即使它们没有通过验证要求，也不会对芯片造成致命影响。 验证的层次结合验证的功能点，需要清楚该功能点是否可以在较低的层次完成验证。从验证效率和激励自由度来看，我们应该尽量在较低的层次验证更多的功能点。在较高的层次，如芯片级，应该侧重于系统集成测试。 验证方法需要考虑采取何种验证方法，动态仿真、形式验证还是硬件加速？采取什么样的透明度，黑盒、白盒还是灰盒？采用定向测试还是随机约束激励？在第3章，我们对比了不同方法适用的场景。 测试用例有了验证的目标，选择合适的层次和方法，在完成了验证平台搭建以后，我们就需要考虑如何利用验证平台给出适当的激励，检查测试结果。 覆盖率要求覆盖率是衡量激励生成种类和功能点验证的量化指标。无论通过何种验证方法，都需要采用覆盖率来确保给出了足够多的激励类型，并且设计的边界和内部穷历了可能的状态。除了给出合法的激励之外，也需要考虑给出一些错误的激励，测试设计的稳定性和纠错能力。 2.2 项目的视角工具选择对项目而言，需要通过验证计划中选择的方法考虑选择相应的工具，包括： 仿真工具； 形式验证工具； 验证IP； 断言IP； 调试器； 硬件加速器； 高层次验证语言（HVL,High-level Verification Language）。 选定验证方法和工具后，接下来需要考虑安排具备合适技能的验证人员完成工作。 人力安排进度安排风险评估在项目执行中，无论是设计人员、验证人员还是项目经理，都面临诸多不确定的因素： 芯片结构不稳定因素。在项目执行后期，如果突然面临结构的变化，肯定给相关设计带来很大影响，而验证任务量和时间也需要改变。 工具的不稳定因素。在新的项目中，我们倾向于使用新的工具版本，因为它们会带来新的性能提升和特性；而新版本工具的使用需要适应期，并非一帆风顺。替换工具时面临的工具替换成本、环境流程更新、技术培训都要更大一些。 人力的不稳定因素。我们希望在项目中人员结构可以稳定，这样就不会出现模块的验证人员被临时替换、加大验证风险的问题。同时，如果一个人投入到两个以上的项目，那么他在不同项目中的精力分配也需要考虑进来。 模块交付时间的不稳定因素。验证的展开与设计的交付时间密不可分，HDL 设计的交付时间对验证进度的影响非常大。所以，在计划初期，验证经理应从设计团队那里获取清晰的交付时间，在此基础上做进度和人力安排。 在清楚了一份验证计划中需要包含的各项因素之后，接下来就要考虑如何在项目初期准备这样一份关键计划，以及在项目执行过程中怎样针对不确定因素相应地更新计划，确保项目的进度受到的影响最小。 3 计划的实现一份细致的验证计划包括项目动向、更新内容和工程进度，面对人力资源总是紧张的窘境，只有清晰的计划才能够合理运用人力资源，保证时间和人力的平衡。在4.2节，我们列举了项目中诸多不稳定因素，它们使得验证计划需要时常保持更新，给出合理的安排，这样的过程就蕴含着从计划到实践再到反馈，最后到修改计划的周期。计划变更的周期在不断地发生，如图4.1所示。 在对设计进行验证以后，我们需要衡量验证的完备性，这时需要对覆盖率进行分析。当发现覆盖率无法满足要求时，要针对覆盖率漏洞更改验证计划并添加新的测试用例。通过这样的反馈环路，循序渐进地逼近功能验证的收敛目标。那么如何制定验证计划呢？通常按照如下步骤： 邀请相关人员参加会议； 开会讨论； 确定测试场景； 创建验证环境。 3.1 邀请相关人员邀请与系统设计和功能模块相关的人员参加会议，共同讨论。参加会议的人员一般包括： 设计人员； 验证人员； 硅后测试人员； 软件开发人员； 系统人员； 验证经理（或项目经理）。 这些人员在看待如何验证一个模块的问题上各有不同的角度。例如，系统人员关注功能描述是否被实现，测试场景是否可以覆盖到这些功能点；设计人员考虑具体的设计细节是否会被测试到；软件开发人员关心如何配置寄存器来使用某一项功能。我们将这些利益相关者看待验证模块的不同角度总结在表4.1。 在实际工作中，我们不一定可以面面俱到地同时邀请到这么多的项目角色，而且，这么多不同的角色一起开会，沟通起来难免存在一些障碍和分歧。所以，实际的建议可以变成分阶段进行： 验证经理、设计人员和验证人员一起开会，确定大致需要验证的功能点、进度和人力安排。 系统人员、设计人员和验证人员一起沟通对功能描述文档存在的分歧，确保理解一致。 设计人员、验证人员、硅后测试人员和软件人员一起为模块应用的实际场景添加测试用例。 3.2 开会讨论在开会讨论前，作为会议的组织者，需要搞清楚开会的目的和议题分别是什么。 验证计划的内容组成； 需要确定的验证功能点。 同时，需要一份合适的验证计划模板指导会议讨论的内容。验证计划的模板（或组织结构）应包括下面的内容： 设计功能简要描述； 硬件实现框图； 待验证的功能点； 验证环境搭建； 测试用例构成； 编译脚本和回归测试； 覆盖率分析。 在计划模板中，会议前需要了解的是功能描述和硬件实现方案；开会中只需要讨论和确定哪些功能点是要验证的、哪些是不需要验证的。至于验证环境搭建和测试用例构成，则是验证工作展开以后更新到计划中。面对不同背景的项目人员，我们在会议中需要注意几个方面，以使会议最终可以取得预期的结果。这些值得注意的方面包括： 由于与会人员具有不同的背景，在讨论中遇到分歧时，应换位思考，从对方的角度看待这个问题，给予理解。 需要覆盖设计在实际过程中软件的使用情况和在系统中的角色扮演，探明真实运用场景。 弄明白哪些功能是核心功能、哪些功能是次要功能。 确定所有需要验证的功能点，以及声明哪些功能点不需要验证、哪些场景是伪场景（不实际的运用）。 只有不同系统层面的人相互沟通，充分交流不同视角和观点，我们对验证功能点及其在系统运用中的认识才会更加清晰。 3.3 确定测试场景经过细致的讨论，可以确定哪些功能点需要测试，继而模拟实际场景给出激励。在考虑如何生成测试场景时，我们需要思考下面几个地方： 针对某些功能点，我们如何给出特定的测试场景。这些场景是否同实际情况一致或者类似，比如我们给出的时钟信号频率是否同设计要求的频率一致，不同时钟之间的同步异步关系是否参照系统要求。 需要测试的场景，需要待验设计的哪些功能模块参与。这种情况一般在模块级测试中，往往需要较多的子模块参与进来，而随着测试的层次升高，我们需要唤醒使能的模块数量就逐渐减少了。我们在构建测试用例前，心中已经模拟出测试序列，明确了参与进来的模块，以及如何配置寄存器、等待某些状态信号完成下一步功能设置，直到最后完成整个功能测试。 如果一些场景涉及电源开关，要考虑是否在PA（Power Aware）场景中完成测试。 如果一些场景与性能有关，要考虑如何发送大规模的数据量实现压力数据传输场景。 针对不同的功能点，要考虑选择合适的验证层次，以及对应的验证方法。 3.4 创建验证环境确定测试场景和验证方法后，要构建验证环境产生激励来实现场景。构建环境时，针对设计模块的接口信号需要实现对应的激励发生组件，通过控制协调不同的激励组件来构建场景。在实现激励发生组件中，需要考虑接口信号是标准总线还是系统控制信号。如果有可以复用的验证资源，那么会节省构建平台的时间。有些时候，如果接口是标准总线，且没有可复用的验证资源，就需要自己实现总线激励模型。从成本的角度来看，只需要实现设计中所纳入的总线特性即可。例如，如果设计实现的是 AHB 总线协议，但是只支持单次的读写访问，那么我们在实现AHB激励组件时，不必要实现AHB协议的全部，而只需要实现单次读写协议，满足设计接口的协议要求即可。 同时要考虑收集数据和对比结果，这就需要监视信号组件和检查组件的实现。监视信号组件的主要任务是监视设计的接口信号以及内部信号。如果是总线接口，那么需要在解析总线的情况下将观察到的数据打包整理；如果是控制信号或者其他信号，要按照信号的定义，在特定事件下捕捉有效信号。监视信号组件最终将分析整理好的数据发送给检查组件，由检查组件进行数据比较，给出比较信息和报告，最终判定测试是否成功。 4 计划的进程评估在验证过程中需要不断地更新验证进度，从各项参数综合评估验证的完备性。通过收集以下信息来评估验证计划的实施进程： 回归测试通过率（regression pass rate）； 代码覆盖率（code coverage）； 断言覆盖率（assertion coverage）； 功能覆盖率（function coverage）； 缺陷曲线（bug curve）。 接下来分别介绍这些信息的收集和分析过程。 4.1 回归测试通过率回归测试表是将测试设计所有功能点的用例合并为一个测试集。回归测试表的主要功能是在设计经过缺陷修复或性能提高后测试原有的所有功能点，确保设计正常工作。这种往复的测试方式不仅在于确保新的设计变化不影响之前的功能，也可以用来避免修改后的设计对别的模块造成的功能失效。所以，设计的维护不仅按照设计需求提供新的功能，也要保证新功能不影响原有的功能。不同的公司和团队之间，往往有着不同的回归测试工具和方法。这里需要注意的是工具和脚本的版本可能会对回归测试造成影响。例如，如果切换了仿真器的版本，那么可能出现新的问题需要调试，所以在项目后期阶段设计趋于稳定时，不建议切换工具或脚本的版本。另外一个重要的地方是，回归测试表中的测试用例需确保是可以重现激励场景的。这一点对于定向测试方法（例如C/C++）是容易实现的，而对随机约束测试而言，要在测试中显示出每次测试使用的随机种子（random seed），只有通过这个特定的种子，才可以重新产生之前的激励，跟踪调试失败的用例。 我们将回归测试的流程归纳为图4.2。值得注意的是，在某一个层次的回归测试通过，接下来可以向上迁移到新的验证层次，展开新的回归测试流程；或者在设计需求发生变化时，重新从模块级开始递交测试表。 不同层次的回归测试表，每个测试用例的仿真时间消耗也不一样。一般而言，模块级是最快的，到了芯片级，一个回归测试表如果包含数千规模的测试用例，往往需要若干天时间才能最终运行完毕得出结果。所以，不同层次、不同设计规模、不同测试场景复杂度，都会影响测试用例的仿真时间。递交测试表的重要因素就是仿真速度，由于考虑到递交测试表主要依靠计算资源和验证结构的性能表现，我们对验证平台的优化和运算资源都会在此时提出更高的要求。因为只有更快速地往复递交和得出结果，才能更快得知新的设计变动是否可靠。 4.2 代码覆盖率代码覆盖率是用来衡量RTL代码是否被充分运行的指标，目前的仿真器也都提供方法来收集代码覆盖率，并且进行合并和分析。通过回归测试表，我们可以产生基于测试用例的代码覆盖数据，并且在回归测试完成后，通过合并数据，生成总的数据来分析各个模块的覆盖率情况。常见的代码覆盖率包括： 语句覆盖率（statement coverage）：指的是程序的每一行代码是否被执行过。 条件覆盖率（condition coverage）：指的是每个条件中的逻辑操作数被覆盖的情况。 决策覆盖率（branch coverage）：指的是在if,case,while,repeat,forever,for和loop语句中各个分支执行的情况。 事件覆盖率（event coverage）：用来记录某一个事件被触发的次数。 跳转覆盖率（toggle coverage）：用来记录某个设计边界信号数据位的0/1跳转情况，如从0到1，或从1到0的跳转。 状态机覆盖率（finite stage machine coverage）：仿真器的覆盖率功能可以识别出设计中的状态机部分，记录各种状态被进入的次数，以及状态之间的跳转情况。 值得注意的一点是，仿真器在收集覆盖率数据的时候会牺牲一些运行效率，这是因为它需要对代码保持“更多的关注”，所以资源消耗要更多一些。我们建议只在需要收集覆盖率时传入一些仿真命令触发覆盖率收集，而更多情况下不需要传入这些命令，也不需要编译带有支持覆盖率收集的仿真目标。在项目执行中，一般在模块级验证节点结束后开始收集模块级的代码覆盖率，在芯片级验证节点结束后收集芯片级的代码覆盖率。在两部分的数据收集都完成后，进行这两个级别的覆盖率数据融合，生成总的数据库。一般项目中有专人来负责收集和分析覆盖率，各个模块的覆盖率数据分发给相应的验证人员，等待他们分析、过滤或添加新的测试用例，再次递交测试收集新的数据；以此循环往复，提高总体的覆盖率。 通常，我们比较关注语句覆盖率、决策覆盖率和跳转覆盖率，各个模块在这三项覆盖率上有相应的指标。只有至少达到了90%以上的覆盖率，才有足够的信心来分析下面的两类覆盖率。 4.3 断言覆盖率断言描述本身支持覆盖率收集，一般通过仿真或者硬件加速的方式收集，也可以通过形式验证的工具收集。在常见的仿真中，仿真器记录断言的先决条件是否被触发，以及判断语句成功还是失败。根据选择的验证方法，我们可以将断言覆盖率分为： 基于动态仿真或者硬件加速的断言覆盖率； 基于形式验证的静态断言覆盖率。 4.4 功能覆盖率功能覆盖率衡量是否实现设计的各项功能，且是否按预想的行为执行。功能覆盖率关注设计的输入、输出和内部状态，通常以如下方式描述信号采样要求： 对于输入，它检测数据端的输入和命令组合类型，以及控制信号与数据传输的组合情况。 对于输出，它检测是否有完整的数据传输类别，以及各种情况的反馈时序。 对于设计内部，需要检查的信号与验证计划中需要覆盖的功能点相对应。通过对信号的单一覆盖、交叉覆盖或时序覆盖来检查功能是否被触发，以及执行是否正确。 4.5 缺陷曲线验证过程中会不断发现新的设计缺陷，使用缺陷记录表或已有的商业工具将这些缺陷记录下来，提交给设计人员。设计人员在分析缺陷、修复缺陷后，也会修改缺陷记录，并通知验证人员。验证人员递交原有的回归测试，必要时添加新的测试用例，直到所有的测试通过，才能宣布新修复的缺陷是成功的。在缺陷被记录的过程中，我们通过时间坐标和特定时段的缺陷数量绘制出缺陷率曲线。在1.4节中，我们指出了缺陷曲线对验证计划的影响。从图1.8我们看到，尽早地将缺陷曲线收敛，意味着后期发现缺陷的数量和可能性越小。有时要当心的是，如果到了验证后期发现了一个基本功能存在重大缺陷，那就是一个危险信号：意味着很可能在之前验证过程中遗漏了一些重要的测试场景。实际项目的经验重复告诉我们，一份详尽准确、不断更新维护的验证计划是迈向成功验证的基石。 5 作者结束语 验证计划的制定不只是需要验证师，还需要其他相关领域的同事共同参与。验证师与验证经理对同一份验证计划的关注角度也不相同。在验证前期，整理好的验证功能测试点会便于验证的回顾；在验证中期，验证环境的结构框图让代码变得更加清晰易懂；在验证尾期，验证师需要收集回归测试通过率、代码覆盖率、断言覆盖率、功能覆盖率和缺陷曲线。这些内容将综合构成验证的量化指标，也让验证经理更容易评估验证的完备性。","link":"/IC%E9%AA%8C%E8%AF%81/%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%97/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%974%E9%AA%8C%E8%AF%81%E7%9A%84%E8%AE%A1%E5%88%92/"},{"title":"芯片验证漫游指南5验证的管理","text":"1 验证周期的检查清单如果能很清晰地知道一份验证周期的检查清单，那么对每一个项目节点需要做什么、上一个节点跟下一个节点有什么联系、不同节点在整个项目周期有什么作用，就有一个全面的认识。这样，作为验证新手，相信会更好地扮演验证角色。 如果每位验证人员都能充分了解各个验证环节，那么就可以更好地贯彻各项验证任务、保持信息通畅，项目整体的风险毫无疑问降低了。执行验证任务的动力来源于整个团队，验证经理背负的压力也由所有验证人员共同分担了。 所以，无论你担任什么样的验证角色，在执行日常事务时，如果心中已经有一幅通往流片大门的地图，那么整个团队的目标会更加清晰，验证人员同验证经理之间的沟通会更顺畅。接下来，我们一起看一看，验证周期各个关键节点的划分和每个节点需要完成的事情有哪些（见图5.1）。 从项目的启动阶段开始，历经RTL验证、门级验证（GLS,Gate Level Simulation）到最终的流片（TO,TapeOut），我们将各个环节分为如下几个环节，各环节的验证任务清单见表5.1～表5.6。 RTL0：芯片框架和模块功能定义完成，制定验证的策略。 RTL1：模块和子系统的功能信号定义完成，定制需要的存储模型。 RTL2：完成所有模块的设计，以及80%以上的模块和子系统的验证，核心功能全部完成验证。 RTL3：完成芯片系统的连线集成和验证，覆盖所有的功能验证点。 GLS：完成门级网表的验证。 TO：回顾验证的各项检查清单，最终流片。 在这里，我们指出几个需要注意的前提： 实际的芯片项目周期跨度要超过上面提到的验证周期，因为它往往会包含RTL0之前的产品可行性调查、项目立项和启动的过程。同时在TO后，仍然需要对硅后测试阶段提供支持，也需要对客户的集成使用提供支持，可能也要准备功能改进后的下一次流片（新的周期）。 不同公司的芯片项目对验证周期的划分和定义可能存在差别，但就芯片验证的一般流程来看，我们上面提到的各个环节是有普适性的。所以，通过进一步详细列举出上面各个环节需要完成的事项，我们对验证的生命周期会有一个全局的认识。 在上面列出的各个环节中，我们主要将注意力放在验证方面，系统定义、设计和后端的事项并没有在这里列出。 RTL0的验证任务清单: RTL1的验证任务清单: RTL2的验证任务清单: RTL3的验证任务清单: GLS的验证任务清单: TO的验证任务清单: 也许表5.1到表5.6的这一列验证任务清单对你而言还不是那么迫切，但要相信，随着经验和责任的增加，你会越来越意识到一幅验证周期的全视野地图多么重要。如果你需要管理一个验证项目，那么将这些任务清单放在枕边，可以让你在新的挑战面前睡得安稳一些。正所谓不打无准备之仗，“凡事预则立，不预则废”，多一些未雨绸缪，懂得一点“套路”，对一个新人来说不是什么坏事。 2 验证管理的三要素3 验证的收敛随机验证的方式使回归（regression）测试更加有意义。一般地，我们基于两种目的提交回归测试表： 随机验证环境每次仿真产生的激励序列不同，使得每次仿真均对覆盖率做出贡献，往复递交同样的测试变得有意义。 设计缺陷被发现后，回归测试序列需再次提交，以确保之前的功能点测试无误，同时设计缺陷也被修复。 通常，回归测试指的是每次将所有测试用例提交到服务器上运行，并且检查测试结果。这种方法在时间和计算资源上对模块级的回归测试也许是可行的，而对于芯片级，这种方式每次消耗的时间和资源恐怕需要重新考虑。在实际项目中进行回归测试，需要考虑下面的因素： 回归流程； 回归质量； 回归效率。 3.1 回归流程在芯片的开发周期中，通常是从模块级到子系统级再到芯片级，设计、集成和验证都按照这样的步骤。那么采取瀑布集成的方式是否可以完成快速的SoC芯片周期呢？恐怕很难。虽然我们之前列举了不同项目节点的内容，方便项目过程中参考，但实际的窘境是，由于紧张的节点安排，往往是“一波未平，一波又起”。例如，本应该在RTL2之前完成模块级验证工作、在RTL3完成芯片级验证，但实际情况往往是，在RTL2节点上可能只完成80%左右的模块验证工作，其余模块验证工作需和芯片验证工作一同完成。一方面，作为验证经理，需要顶着压力，在RTL2结束后开展芯片验证工作；另一方面需要同时追踪各个模块的验证进度。所以，回归流程没有一致的标准，更多的是要符合实际的项目需求，同时又要在节节落后的情况下保证最终流片能够按时完成。这看起来是一种与项目进度的妥协，但更多地需要验证经理清楚哪些任务是必须在节点前完成、哪些任务可以适当延迟，总体控制风险，如同走钢丝一样，平衡一词始终需要牢记心间。 如图5.2所示，接下来让我们看看如何在快速的项目周期中做出合理的回归流程。 在模块设计阶段，除了准备验证环境，在验证的基本功能完备之时就应创建一些基本测试用例，并形成一份基本功能回归列表。该列表在RTL2（模块周期）前必须全部通过。 同时，在保证基本功能回归列表时，一些高级、附加功能仍要尽可能多地在RTL2前完成验证。但这些功能可能有部分需要在RTL2和RTL3之间完成验证，所以按照优先级划分的高级功能回归列表也要作为模块验证完成的检查项。 由于在 RTL2节点时可以保证基本功能的正常工作，这一份回归测试表单也使得在RTL3开始时进行的芯片集成工作得到保证。完成集成后，各个模块之间的互动也可以初步完成测试。此时，各个模块同其他模块的通话依赖于这些基本功能的测试表单。 在RTL2与RTL3之间，完成模块级的高级功能验证后要反复提交回归测试列表，通过大规模的随机测试来检验设计的稳定性，并完成覆盖率收集。 模块功能验证必须在RTL3之前完成，芯片级验证则要在门级仿真之前完成，并尽可能减小落后于节点的差距。这样才会留给后端部门稳定的设计（出现更少新的缺陷）来做物理实现，为门级仿真尽早提供网表和时序反标文件（timing back-annotation）以便开展门级仿真。 那么在以上流程中出现了缺陷该怎么办呢？应该遵循的原则是： 选择更小的验证环境、给出更少的变量，实现更容易调试的环境。具体而言，在芯片级遇到缺陷，可以在模块级验证则优先在模块级验证，同时尽量缩小配置的变量数目，以此重现错误场景。这种方式更有利于错误定位和缺陷修正。缺陷修复后，可以在更小的验证环境中重复之前的测试，确保之前出错的场景通过。 缺陷完成修复后，仍要分别进行模块级验证和芯片级验证的回归测试表。确保除了缺陷修复之外不引入新的缺陷，所有之前测试通过的功能仍然可以正常工作。 3.2 回归质量在软件的迭代开发中，除了保证测试质量还要通过单元测试保证设计在每次提交之后（版本更新或缺陷修复）完成设计的自我检查，以便在提交给验证人员之前保证基本功能通过，减少明显设计错误带来的设计与验证人员之间的额外沟通和时间消耗。这种有效的方式越来越广泛地运用到芯片验证过程中。提高回归质量的策略在图5.3中给出。 每次完成芯片设计后，可以通过回归测试工具将设计、验证环境的编译、仿真、结果检查集成为一体，也可以通过一些简单的命令由设计者先查看基本功能是否正常工作。只有在保证基本功能回归列表测试完成以后，我们的版本管理工具才会允许设计文本的签入（check-in），同时通知验证人员设计的更新，由验证人员展开其他高级功能或者更高层次的验证工作。之前提到，如果验证人员发现了缺陷，在缺陷修复后，设计人员应先通过基本功能测试再递交给验证人员。验证人员需要做的是，检查之前错误的场景是否可以通过，同时创建专门针对该缺陷的基本测试来更有目的地完成验证。在这些激励确定性（determinacy）较明显的测试完成之后，我们也会给出更宽松的激励，对设计产生更丰富的测试场景。通过随机回归测试，我们可以在每次回归测试完成之后收集覆盖率，分析一些功能点覆盖漏洞，在下一次回归测试开始之前，有意地偏置（biasing）调整随机约束，使产生的激励更有可能填补那些功能点漏洞。 除了随机测试以外，我们也会通过形式验证的方式来完成验证。我们提供的多种属性检查分为基本功能属性和高级功能属性，这种简单的分类可以保证设计每次提交以后首先保证基本功能属性，而高级功能属性的验证由验证人员完成。同时，覆盖率也可以在形式验证中收集，并且和其他动态仿真的覆盖率数据实现合并和分析。随机测试的回归序列若要实现更高的覆盖率，就要运行多次。这种方式使得覆盖率收敛曲线随着回归往复的次数而提高，但是该方式非常消耗运算资源和时间。在通过回归方式完善功能覆盖率和检查设计功能时，建议将它们区别开来。比较合理的方式如下： 在前期设计不稳定的情况下，主要定向提交一些测试用例来快速检查功能是否通过。 在设计比较稳定后，可以规划用时较短、测试场景较简单的用例，检查核心功能点是否通过。 在设计后期，应一方面实现复杂场景，另一方面大量提交回归测试表来完善功能覆盖率。 3.3 回归效率回归测试是一种确保设计功能通过的稳妥手段，方便操作管理，也可以提升覆盖率。在追求验证完备性的同时，回归测试的效率问题越来越受到重视。回归效率的现状考量基于以下几个方面： 在模块验证阶段，随机测试方式使得倾向于反复提交测试表来产生各种可能场景，到了后期，覆盖率难以更多提升。那么如何精细控制随机约束，使每次回归测试总有新增覆盖率的收获，是要深入解决的问题。 在设计缺陷得到修复后，如何快速检查设计基本功能，保证设计版本提交的质量，进而转移到验证人员一侧，提升沟通效率，这也需要设计合适的回归表。 在芯片级验证阶段，由于测试用例时间明显加长，每次回归整个测试表（数以千计的测试用例）耗时极长。由于芯片级测试更多地是基于C的验证，在项目后期集成改动较小的情况下，反复回归的收益明显降低，而验证管理又需要这样的数据，这种矛盾也需要化解。 基于以上考虑，在日常工作中，建议采取以下办法提升回归效率： 在可实现的情况下，考虑切分测试场景，将一个长的测试序列切分为多个序列，并为其创建多个测试用例。这么做的好处是避免过于冗长复杂的测试，划分为多个用例可以实现并行提交测试，用计算资源换来时间的节省。 对一些较难切分测试向量的场景，例如芯片级仿真需要首先完成上电、复位、时钟使能，同时芯片处理器需要完成初始化、搬运执行代码的过程，可以考虑通过快速跳转到特定状态来实现缩短测试时间的要求。 针对第二条所描述的特定状态，即一些需要通过长时间运行来到达某一状态的测试，我们建议分为两个阶段。第一阶段检查跳转到该状态的条件是否满足，进而检查状态跳转。一旦第一阶段被验证通过，我们就可以让其余用例省略第一阶段，即通过直接初始化到该特定状态来节省时间，例如强行置位硬件寄存器、状态位等方式，使设计快速跳转到某一状态，缩短验证时间。 尽可能给予充分的计算资源。目前用于仿真的普遍方式是，中心化的服务器群提供计算和数据存储资源，通过资源分配管理实现充足的并行运算资源，使回归测试表尽快执行完毕。 从对回归测试的流程、质量和效率的论述可以发现，智慧合理的回归测试方式有利于设计的发布质量和快速稳定。 4 让漏洞无处可逃3节提到如何快速有效地进行验证收敛，即利用回归测试表产生更多复杂场景和提高验证的覆盖率。在验证收敛的过程中，无论你是验证人员、设计人员还是系统人员，都不可避免地会遇到一个问题，那就是——检测出了漏洞，应该怎么办？ 设计漏洞较易理解，因为一旦验证环境的参考模型与硬件设计的结果产出不一致，且最终分析得出设计并未完全遵循硬件功能描述时，那么设计漏洞便被发现了；而在验证的过程中，如果发现了硬件的问题，且最终回溯到硬件设计有遗漏并不完善的时候，硬件设计描述便产生了一个漏洞；容易被人忽视的是，发现验证环境的漏洞以后，经常是由发现者提交问题邮件、由环境构建者检查并最终确认和修改漏洞，这种局部的方式可能造成更多不知情的验证人员被该问题阻碍，或者新的项目仍然会重复之前的陷阱。所以，验证环境的漏洞（一般属于芯片级验证环境）也需要被记录；后期门级仿真中因综合时序不满足采样条件导致的门级验证失败，也需要将时序问题予以追踪，这种方式会提醒后期项目着重关注一些较长的或较难处理的时序路径，进行有针对性的优化。验证过程中还会遇到别的问题，如仿真工具问题、标准单元设计库问题、第三方IP问题，等等。 我们可以总结出，发现问题后进行跟踪的基本依据是：如果该问题明显影响项目进度，或者影响大范围的群体，或者对后续项目造成影响，就要记录这些问题并跟踪它们的解决情况。如果在项目实施中（这里专注在硅前验证阶段）发现了满足上述情况的问题，也要记录下来。在这里，我们将问题追踪分为下面的几种类型： 系统功能定义问题； 硬件设计问题； 芯片验证环境问题； 综合时序问题； 硅前工具问题； 引用库和IP问题。 对硅前问题进行分类后，接下来要将它们记录到合适的数据库中。该数据库不但要记录问题，还要起到分类、派发、查找、追溯、报告的作用。芯片设计项目除了在执行过程中参考软件项目的构建、分块、依赖路径、决策的方法，也在问题追踪上借鉴软件开发的方式。软件开发更早地使用标准化的问题追踪工具来执行项目，随着芯片开发的进度逐渐加快，一些商业的或免费的问题跟踪工具进入了芯 片开发的视野，例如以下这些问题追踪工具：： 商业工具: Team Foundation Server（Microsoft）,JIRA,Rational ClearQuest（IBM）,HP Quality Center（Hewlett-Packard）。 开源工具： Bugzilla（Mozilla）,Redmine,Trac（Edgewall）,Mantis。 这些问题追踪工具一般具备下面的功能： 记录：需要记录的内容有问题标题、内容、出错场景、背景描述、发布版本、测试用例和相关文件等。 分类：归属于哪个项目、哪个环节（系统、设计、验证还是其他）、哪个模块以及问题严重性（致命、重要、中级、改进）。 派发：在跟踪系统中，问题一旦提交，它的生命周期即开始。接下来由管理层指定问题回顾和修复的人员，再转由下一位问题持有者完成所需做的环节，继续指定问题的下一位持有者。在后面的问题跟踪流程中将详细介绍这一问题。 查找：遇到漏洞时，除了与漏洞相关人员沟通之外，在提交问题之前还要利用问题追踪工具数据库提供的查询功能判断，该问题以前是否发生过、有无解决方法；我们可以很方便地利用问题独一无二的ID编码在工具搜索栏中快速调出该问题的背景和进度。 追溯：问题从被提出到被派发、解决、验证和最终关闭，在一个项目中走完它的生命周期，但不排除它可能在下一个项目中“复活”。造成问题复活的可能因素有很多，比如问题重新发现、原解决方案不再满足、新项目继承上一个项目时一些问题修复没有被集成进来仍然需要再次修复，等等。所以，问题追溯的好处在于，可以看到同一个“顽固”的问题是如何在不同的项目之间（尤其是多个并行项目中）产生的。 报告：谁最喜欢看报告？当然是管理层！他们时间有限，若不能深入前线听到枪响、嗅到火药味，那么对他们而言，看到一份数据健全、有内容的报告必不可少。问题追踪工具从项目周期开始统计出多个维度的数据，如常见的设计问题提交、修复、验证和关闭趋势图，从这张图可以看出项目执行的健康状况；又如硬件设计缺陷提交曲线图，若曲率到项目后期仍居高不下，可能意味着结构性的严重错误，由此进一步导致项目延期乃至调整硬件结构。 了解问题追踪工具基本的功能之后，还要清楚如果在项目工作中发现问题，如何使用工具来提交、跟踪、修改和验证这个问题，状态之间的跳转通常在什么情况下发生。图5.4是针对硅前芯片开发流程的，实际上，问题跟踪周期要比这个状态更长，还包括了硅后测试周期。在这里我们集中在硅前芯片开发阶段，来依次解释各个状态的表征以及状态之间的跳转条件。 新的问题：在项目执行中发现一个新的问题，当它带来的影响满足提交的基本依据时，就要在问题追踪工具中提交这个问题，填写相应的内容，这对应步骤1。接下来，提交者将问题派发给需要解决问题的所有者。如果所有者发现该问题不属于他的模块，那么他应将该问题派发给真正的问题所有者，即步骤2。问题所有者进行研究，确定属于系统结构、设计或者验证问题，然后他可能进入开始状态，修复问题，即步骤3；如果问题所有者分析发现他的模块并不会导致该问题，问题是由其他模块引起的，那么他可以将状态重新修改为新的问题，即步骤4。该问题之前已经被发现过，则将状态修改为重复状态，即步骤5，同时需要备注已经提交相同问题的 ID 号，用来追溯该问题。该问题如果不严重影响项目进度且不是致命问题时，要同管理层商讨。假如最终确定有软件方法或其他修补方法时，可考虑修改为延后状态，即步骤6，待后续项目进行时，可以重启该问题。如果问题所有者发现该问题实际上已经在新的发布版本中修正，他可以将状态修改为解决状态，即步骤7。 开始：当问题开始进入修复过程时，问题所有者经过研究并做出修正，同时将问题修改为解决状态，即步骤8。在这一状态中，问题所有者仍然有可能将状态修改为重复或者延后，即步骤9和步骤10。 解决：问题修复后，问题所有者将该问题派发给验证人员。例如，设计人员派发给验证人员要求测试漏洞是否修复成功，系统人员派发给设计人员要求检查功能描述是否与设计相符等，这一过程即是图5.4的步骤11。 验证：问题得到修复和验证后，问题再次派发给当初的问题提交者或管理人员，由他们将状态修改为关闭状态，即步骤12。 关闭：问题关闭之后，问题的提交者如果在回顾问题时发现问题没有完全解决或者再次遇到此问题时，他可以重启问题，即步骤13。 重启：问题得到重启后，问题所有者需再次进入问题，检查新的问题场景，经过研究后 如果问题仍然需要再次修复，则进入开始状态，即步骤14。 如果问题的场景需要另外的软件配置，或者已经修复，则可转入解决状态，即步骤15。 如果问题受限于实际，暂时无法修复需要延迟，则需要步骤16。 以上各个状态以及状态之间的跳转，符合一般芯片开发中的问题追踪流程。从流程的细节中可以发现，问题追踪管理的特点是： 符合实际工程应用，状态之间的跳转合理。 问题一旦提交即有两方——提交者和所有者，且这种状态一直持续到问题的生命周期结束，即关闭状态。 追踪工具可以满足工程师和管理者的需求，让双方共同参与，深入记录第一线的资料（问题描述、解决方法、验证方案），同时提供整个项目的执行状态。 管理者并不需要在问题的生命周期内全程参与，他可以随时介入，但更多的状态跳转只需要由工程师执行。这样减轻了管理者的负担，为他们留出时间统揽全局。 至此，我们将问题追踪的需求、分类、工具和流程介绍完毕。有了团队间的协作，接下来我们将进入“人”的环节，看一看如何在长、中、短期建设验证团队，使验证团队成为公司的宝贵财富。 5 团队建设6 验证师的培养7 验证的专业化8 作者结束语 我们所处的时代对中国的IC行业而言可谓是黄金时代。在国家战略和市场需求的双重引导下，中国集成电路的产业规模持续扩大，发展质量不断提高，基础更加坚实。与快速发展的行业形势相比，国内的集成电路人才培养不容乐观。据估计，如果2020年芯片设计业达到4000亿元人民币产业规模，那么设计业的从业人数要从2017年的13万增长到2020年的28万，这中间存在着巨大的技术人才需求缺口。同时我们还要考虑到，“十年树木，百年树人”，人才培养并非朝夕之功。目前高校的集成电路类教育，面临着象牙塔教育与企业需求脱节的问题，给企业带来额外的时间和金钱上的培训成本。 笔者认为，结合目前国内的高等教育现状，较为可行的方式是将IC验证教育从研究生教育扩展到本科生教育。以本书的内容为例，它将验证的核心内容与虚拟的项目案例相结合，既有基础知识也有高阶知识，以培养人才的动手能力为目标，最终满足企业的用人需求。将芯片验证教育拓展到本科生教育，也可以减少本科生毕业后因就业不顺利而不得不放弃专业的尴尬现状。笔者相信，只要我们不断提升高校的IC教育质量，芯片验证的本科化教育一定能够为企业输送更多合格的IC人才，这也是本书希望推动的一件事情。","link":"/IC%E9%AA%8C%E8%AF%81/%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%97/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%975%E9%AA%8C%E8%AF%81%E7%9A%84%E7%AE%A1%E7%90%86/"},{"title":"芯片验证漫游指南6验证的结构","text":"1 测试平台概述测试平台（testbench）是整个验证系统的总称，包括验证结构中的各组件、组件之间的连接关系、测试平台的配置和控制；从更系统的意义来讲，还包括编译仿真的流程、结果分析报告和覆盖率检查等。狭义上我们主要关注验证平台的结构和组件，它们产生设计所需的各种输入，并在此基础上进行设计功能的检查。我们首先给出经典的测试平台结构，如图6.1所示。可以看到： 各个组件之间是相互独立的； 验证组件与设计之间需要连接； 验证组件之间需要进行通信； 验证环境需要时钟和复位信号的驱动。 从实现语言看，验证平台经过多年的需求变化，常用的语言有VHDL、Verilog、Open Vera、e、System C、C/C++、SystemVerilog等。测试平台对不同语言的使用趋势可以从图3.5看到，近年来SystemVerilog的使用比例明显占据主导地位，我们会在日后的SystemVerilog部分介绍它的主要特性，通过对比不同的语言，体现它在验证领域的优势。此外，对 SystemC 和C/C++在验证部分的应用，我们也会在验证方法的高级应用部分进行介绍。对于验证师而言，构建一个验证平台，除了对设计有充分了解之外，还要考虑在平台上给出更丰富完备的测试场景，并使验证组件针对丰富的激励可以做出细致的判断，最终分析设计的功能是否符合硬件描述。 接下来，我们将围绕设计实例MCDF进行介绍，包括它的结构、功能、时序描述。作为验证工作展开的第一步，我们有理由相信只有对设计结构足够了解，才能进行验证结构的规划和搭建。 2 硬件设计描述为了模拟实际情景，我们给出贯穿于SystemVerilog和UVM章节的硬件设计MCDF，并且遵循硬件设计描述的方式，介绍它的结构、功能、寄存器和时序。在以后的 SV 和 UVM部分中，我们也将围绕这个硬件设计来考虑测试平台的构成。日后对测试平台的构建论述，需要经常引用MCDF的功能描述，请读者注意这一点。同时，熟悉硬件描述的方式是进入验证领域的一项基本技能。那么，我们就从这个规模适中的设计开始了解。 2.1 功能描述我们称该设计为多通道数据整形器（MCDF,Multi-Channel Data Formatter），它可以将多个通道的上行 uplink）数据经过内部的FIFO以数据包（data packet）的形式送出。上行数据和下行数据的接口协议不同，我们将在后面的接口描述和时序部分进一步讲解。多通道数据整形器有寄存器的读写接口，可以支持更多的控制功能。 2.2 设计结构图6.2所示为MCDF的设计结构，主要分为如下几部分： 上行数据的通道从端（Channel Slave）：负责接收上行数据，并存储到其FIFO中。 仲裁器（Arbiter）：选择从不同的 FIFO 中读取数据，将数据进一步传送至整形器（Formatter）。 整形器（Formatter）：将数据按照一定的接口时序送至下行接收端。 控制寄存器（Control Registers）：有专用的寄存器读写接口，负责接收命令并修改MCDF的功能。 2.3 接口描述1.系统信号接口 CLK（0）：时钟信号。 RSTN（0）：复位信号，低位有效。 2.通道从端接口 CHx_DATA（31:0）：通道数据输入。 CHx_VALID（0）：通道数据有效标志信号，高位有效。 CHx_READY（0）：通道数据接收信号，高位表示接收成功。 3.整形器接口 FMT_CHID（1:0）：整形数据包的通道ID号。 FMT_LENGTH（4:0）：整形数据包长度信号。 FMT_REQ（0）：整形数据包发送请求。 FMT_GRANT（0）：整形数据包被允许发送的接收标识。 FMT_DATA（31:0）：数据输出端口。 FMT_START（0）：数据包起始标识。 FMT_END（0）：数据包结束标识。 4.控制寄存器接口 CMD（1:0）：寄存器读写命令。 CMD_ADDR（7:0）：寄存器地址。 CMD_DATA_IN（31:0）：寄存器写入数据。 CMD_DATA_OUT（31:0）：寄存器读出数据。 2.4 接口时序通道从端接口时序见图6.3。当valid为高时，表示写入数据。该时钟周期ready为高，表示已经将数据写入；该时钟周期ready为低，需等到ready为高的时钟周期才可以将数据写入。 整形器接口时序见图6.4。整形器是按照数据包的形式发送数据的，数据包的可选长度有4、8、16和32。整形器必须完整发送某一个通道的数据包后，才可以转而准备发送下一个数据包，在发送数据包期间，fmt_chid和fmt_length应保持不变，直到数据包发送完毕。 整形器准备发送数据包时，首先应该将fmt_req置为高，同时等待接收端的fmt_grant。当fmt_grant变为高时，应在下一个周期将fmt_req置为低。fmt_start也必须在接收到fmt_grant高有效的下一个时钟被置为高，且维持一个时钟周期。在fmt_start被置为高有效的同一个周期，数据开始传送，数据之间不允许有空闲周期，即应连续发送数据，直到发送完最后一个数据，fmt_end也应被置为高并保持一个时钟周期。 相邻数据包之间应至少有一个时钟周期的空闲，即fmt_end从高位被拉低以后，至少需经一个时钟周期fmt_req才可以被再次置为高。 控制寄存器接口时序见图6.5。在控制寄存器接口上，需要在每一个时钟解析cmd。当cmd为写指令时，需要把数据cmd_data_in写入到cmd_addr对应的寄存器中；当cmd为读指令时，即需要从 cmd_addr 对应的寄存器中读取数据，并在下一个周期，将数据驱动至cmd_data_out接口。 2.5 寄存器描述地址0x00 通道1控制寄存器32 bit读写寄存器： bit（0）：通道使能信号。1为打开，0为关闭。复位值为1。 bit（2:1）：优先级。0为最高，3为最低。复位值为3。 bit（5:3）：数据包长度，解码对应表为，0对应长度4,1对应长度8,2对应长度16,3对应长度32，其他数值（4～7）均暂时对应长度32。复位值为0。 bit（31:6）：保留位，无法写入。复位值为0。 地址0x04通道2控制寄存器32 bit读写寄存器：同通道1控制寄存器描述。 地址0x08通道3控制寄存器32 bit读写寄存器：同通道1控制寄存器描述。 地址0x10通道1状态寄存器32 bit只读寄存器： bit（7:0）：上行数据从端 FIFO 的可写余量，同 FIFO 的数据余量保持同步变化。复位值为FIFO的深度数。 bit（31:8）：保留位，复位值为0。 地址0x14 通道2状态寄存器32 bit只读寄存器：同通道1状态寄存器描述。 地址0x18 通道3状态寄存器32 bit只读寄存器：同通道1状态寄存器描述。 至此我们将MCDF的功能描述完毕，从下一节开始，我们将分析如何给出激励、检测以及比较数据，同时从验证效率的角度考虑，如何同时为各个模块构建模块验证平台，并最终组合为一个子系统验证平台，来完成MCDF的验证。 3 激励发生器Stimulator（激励发生器）是验证环境的重要部件，在一些场合中也被称为 driver（驱动器）、BFM（Bus Function Model，总线功能模型）、behavioral（行为模型）或generator（发生器）。激励发生器的主要职责是模拟与DUT相邻设计的接口协议。与真正的相邻设计相比，激励发生器（Simulator）只关注如何模拟接口信号，使其能够以真实的接口协议来发送激励给DUT。激励发生器并不需要模拟相邻设计内部的功能细节，这使得实现一个激励发生器的工作相对设计而言更容易，也更方便维护。 从模拟接口协议的角度来看，激励发生器不应该违反协议，但不拘束于真实的硬件行为，还可以给出更多丰富的协议允许的激励场景。比真实硬件行为更丰富的激励，会使模块级的验证更加充分，因为不但验证了硬件普通的接口协议情景，还模拟出更多复杂的、在更高系统级别无法产生的场景，而这些场景只有在模块级验证中才能产生和检查。这些复杂的边界场景（corner scenario）往往有可能有触发到由于考虑不充分导致的设计缺陷。对于边界情景所触发的设计缺陷，我们一般遵循立即修正的原则，即便该场景可能在系统集成后很难触碰到，但无法保证它在这个项目或下个项目中不会被系统触发。在构建激励发生器时，核心的准备工作就是熟读并正确理解接口协议。如果激励发生器无法完全实现协议，那么可以想象，我们利用激励发生器生成的场景是不完备的，这直接导致接口覆盖率的不完整，存在较大的验证风险隐患。 如果接口协议是成熟的商业协议，建议使用第三方的商用接口IP，这很大程度上节省了二次开发的成本和对激励发生器调校的精力。如果是较复杂的协议，我们可能面对激励发生器协议实现上的缺陷，或者未完全实现协议，而这对验证的成功和效率都有消极的影响。即便出于节约经济成本的考虑，仍然不建议使用不成熟的激励发生器，至少接口的激励发生器应经过足够的时间来开发、自我验证（仍然利用第三方商用接口IP来进行自我验证）。 如果接口协议较为简单，或者是内部设计之间规定的非标准接口，那么应该查阅相邻设计的硬件描述文档，如6.2节中展现的一样，充分理解接口的时序。如果你不幸遇到了一个没有接口时序的设计，恐怕你要与 DUT 和相邻设计的设计者沟通，从他们那里获得相关信息来理解接口协议；这样做也可以帮助双方在项目前期排除有关接口协议的实现分歧。需要注意的是，对接口的理解不能完全遵循设计者的描述，更不能看设计接口的实现代码，因为这违反了设计参照的来源应从系统定义中来的原则。验证者需要做的是调查、收集有用信息，但不完全采纳设计者关于接口的设定。 激励发生器的接口主要是与 DUT 之间的连接，此外，也应该有时钟和复位的输入，确保生成的数据与 DUT 的接口侧是同步的关系。较精细的激励发生器还可以有其他的配置接口用来控制接口的数据生成。最后，激励发生器具有存储接口数据生成历史的功能，用来在仿真运行时或结束后查看接口数据，方便统计和调试。 从激励发生器与 DUT 的连接关系来看，可以将其进一步分为两种：initiator（发起器）和responder（响应器）。就我们要验证的MCDF来看，与下行通道从端（channel slave）的连接或寄存器接口的连接，这两部分的激励发生器都属于initiator，它们的功能是主动发起接口数据传输；而与MCDF formatter接口的连接，该激励发生器则属于responder，它的职责是对接口的数据发送请求做出响应，本身并不主动发送数据。 接下来，我们从MCDF的接口协议和时序分析图6.6中三种激励发生器需要考虑的因素。 1.Channel initiator Channel从端接口协议上有握手信号，我们要遵照接口时序，确保chx_ready为低时，chx_data和chx_valid保持不变。 相邻数据之间没有数据包的限制，所以相邻数据之间的关系较弱。但也应考虑数据之间是否有空闲周期，以及整体数据的传输速率设定。 由于每一个数据从端都有对应的FIFO缓存数据，所以要考虑如何使FIFO的状态可遍历。例如，典型的 FIFO 状态分为 empty、full和中间状态（即有数据存储但未写满）。要使FIFO触发这些状态，就应该控制channel initiator的传输速率。 2.Register initiator 寄存器接口上cmd的默认状态应该为idle，但cmd_addr、cmd_data_in并未指出默认值应为何值，所以可以考虑给出随机数值测试DUT的接口协议稳定性。 在寄存器读写传输上，可以考虑连续的写、读或读写交叉的方式测试寄存器模块的读写功能。 测试应覆盖读写寄存器的所有比特位。 需要测试只读状态寄存器的设定是否为不可写入，同时要测试 读出的数值是否为真实的硬件状态。 3.Formatter responder 作为三种接口协议中相对复杂的一个，首先要侧重formatter接口协议是否充分遍历。 需要详细理解协议的要求，除了按照协议给出fmt_grant的响应以外，还要检查协议的时序。 fmt_grant的置高，代表formatter的从端有足够的存储空间，可以容纳formatter要传输的长度为fmt_length的数据包。为了模拟真实场景，可以考虑让fmt_grant采取立即拉高或延时拉高，测试formatter接口的响应时序。 至此，我们结合实际的MCDF，给出了激励发生器的连接关系以及实现时要注意的地方，在SystemVerilog和UVM的章节为大家提供可参考的代码实现。接下来，我们将进入Monitor（监测器），看一看如何放置监测器较为合理，它们的优劣势分别是什么？ 4 监测器Monitor（监测器）的主要功能是观察DUT的边界或内部信号，并将它们打包整理再传送给其他验证平台的组件如Checker（比较器）。从监测信号的角度来划分Monitor的功能，可以分为： 观察DUT边界信号。对于系统信号如时钟，可以监测其频率变化；对于总线信号，可以监测总线的传输类型和数据内容，以及检查总线时序是否符合协议。 观察DUT内部信号。灰盒验证往往需要探视 DUT 内部信号，以指导激励发生器的激励发送，或者完成覆盖率收集，或者完成内部功能的检查。 结合6.3节激励发生器的验证结构图布置，我们有如图6.7和图6.8所示的两种Monitor结构框图。 从图6.7可以看出，在验证平台中置入一个全局性的Monitor，监视整个环境中的信号，包括： 寄存器配置接口。 3个通道从端数据接口。 Formatter输出接口。 MCDF内部信号，包括Register、Arbiter和Formatter的关键信号。 我们再看图6.8中分布式的monitor是如何实现的。可以发现，每一个monitor对应一个激励发生器，所以，我们需要如下的Monitor： 3个Channel Monitor分别用来监测对应的channel initiator的接口。 Register monitor监测寄存器配置接口。 Formatter monitor监测formatter输出接口。 MCDF monitor监测register、arbiter和formatter的内部信号。 从功能的角度来看，无论是集为一体的monitor，还是相互分离、各司其职的monitor群，都可以完成监测全局的任务。那么，采用哪种方式好呢？我们试着从如下几个方面进行对比： 独立性：我们倾向于采用后者，即将不同接口信号的采集交给相应的 monitor。因为各接口的功能之间没有相关性，易于切割。 复用性：仍然采用后者。如果 MCDF 的接口可能运用到别的验证环境中，那么相对独立的 monitor 可以更好地作为验证 IP 被其他验证环境所复用。基于这个考虑，我们将通道从端数据接口的采集分别对应到3个channel monitor，每一个monitor只需要负责监视一组总线。 可维护性：后者优于前者。设计的外部接口必定先于内部信号趋于稳定，那么，平行的 monitor 组更有利于验证者在验证后期定向维护 MCDF monitor，而不需考虑其他monitor。同样到了后期项目或者设计遇到修改时，更有可能修改的是内部逻辑，而非接口信号；这种情况下也只需更新MCDF monitor，而不必更新其余接口类型的monitor。 封装性：后者的优势在于与各激励发生器一一对应，形成验证环境的小单位，这些小单位之间的通信按照统一的方式实现，可以保持各自的独立性。这样，就可以各小单位（即一个激励发生器对应一个 monitor）封装为独立的组件，使其提供激励和监测的功能。 从上面的分析可以得出，无论是 monitor 还是激励发生器，我们都倾向于将验证环境中的组件尽量做到功能单一，而非大而全，这种方式带来的好处，可以在以后的验证环境集成和垂直复用中得到印证。对于monitor的监测功能实现，我们遵循与激励发生器一样的要求，即验证人员应深入理解协议。这样，无论是按照协议采集数据还是检查 DUT 的接口是否按照协议实施，都是必需的。对于监测MCDF内部信号的要求，我们给出如下建议： 若无特殊需要，应采取灰盒（而非白盒）验证的策略。 观察的内部信号应尽量少，且应是表示状态的信号。不建议采集中间变量信号的原因在于，这些信号的时序、逻辑甚至留存性都不稳定，这种不稳定对验证环境的收敛是有害的。 能够通过接口信息计算的，尽量少去监测内部信号，因为这种方式有悖于假定设计有缺陷的验证思想。我们观测到的内部信号，有必要在被环境采纳之前确认它们的逻辑正确性，这一要求可以通过动态检查或断言触发的方式来实现。 在数据监测、覆盖率收集、协议检查功能覆盖率驱动验证之外，在高级的验证环境中，monitor也可以通过对覆盖率加以分析，来反馈指导激励发生器的激励数据生成，这种方式称之为功能覆盖率驱动验证（function coverage driven verification）。接下来，我们将介绍验证组件的最后一个成员——checker（比较器），看一看checker的功能和一些需要注意的问题。 5 比较器无论是从实现难度还是从维护人力上看，checker（比较器）都是最需要时间投入的验证组件。之所以这么说，是因为checker肩负了模拟设计行为和功能检查的任务。更细致地看，checker的功能包括： 缓存从各个monitor收集到的数据。 将DUT输入接口侧的数据汇集给内置的reference mode（l 参考模型）。reference model在这里扮演了模拟硬件功能的角色，也是需要较多精力维护的部分，因为验证者要在熟悉硬件功能的情况下实现该模型，同时不参考真实硬件的逻辑。 通过数据比较的方法，检查实际收集到的DUT输出端接口数据是否与reference model产生的期望数据一致。 对于设计内部的关键功能模块，也有相对应的线程进行独立的检查。 在检查过程中，可以将检查成功的信息统一纳入到检查报告中，便于仿真后的追溯。 如果检查失败，可以采取暂停仿真同时报告错误信息的方式进行在线调试。 关于checker细分的功能，我们需要记住几个关键词：数据缓存、参考模型和检查报告。我们在后期的代码实例中围绕这几个部分进行梳理。在实际项目中，各种 checker 的实现方式迥异，大致分为两类： 线上比较（online check）：在仿真时收集数据和在线比较，并实时报告。 线下比较（offline check）：将仿真时收集到的数据记录在文件中，仿真结束后通过脚本或其他手段进行数据比较。 在硬件设计发展初期，DUT的功能较为简单，采取定向测试（directed test）和线下比较的方式就不足为奇了。甚至，验证者没有数据处理脚本或参考模型，进行人为比较（manual check）的古老方式也是存在的。设计的功能愈加复杂，靠验证者每次进行烦琐检查的方式可靠性愈差。于是，我们将checker添加到验证环境中，用它分析DUT的边界激励，理解数据的输入，并按硬件功能来预测输出的数据内容。这种的过程发生在reference model 中，有时我们也将其称为预测predictor。 从 MCDF 的 checker 来看，对于数据的整形（formatter），寄存器模块可以控制数据包的长度，reference model也需要register monitor的观察数值进行数据包内容的预测。一般而言，reference model会内置一些缓存，分别存放从DUT输入端观察到的数据，以及经过功能转换的数据。同时，checker也有其他缓存来存放从输出端采集到的数据，即图6.9由formatter monitor存放到MCDF checker的formatter FIFO。 由于 MCDF 有数据通路的功能，我们认为 reference model 存储的数据内容顺序和formatter FIFO中数据的顺序是一致的。这种顺序一致性有利于我们做前后的数据比较，一旦data checker发现两者的FIFO都有数据，就从两侧读出等量数据来做比较。如果数据比较成功，则将数据信息和比较信息打印到仿真窗口和记录文件中；如果数据比较失败，则暂停仿真，将比较失败的数据信息提供给验证人员。 在前面介绍的reference model、formatter FIFO（output data buffer）和data checker之外，我们考虑引入更多细致的检查功能，这些功能和各个模块相对应，分别是： channel checker； arbiter checker； register checker； formatter checker。 回顾上一节讲到的monitor的分布不难发现，checker、monitor和stimulator与MCDF内部的各模块有一一对应的关系。我们之前建议将monitor和stimulator各自对应组成一个个的小单元，那么 checker是否也适合与其对应呢？应该怎么放置呢？在回答这些问题之前不妨考虑一下，对checker进行分散搁置与集群搁置的特点是什么？ 分散搁置的特点包括： 各自检查对应模块的功能； checker之间通信需要特殊连接； 报告信息较难统一； 对各个checker的使能控制因其分散变得复杂。 集群搁置的特点包括： 各自检查对应模块的功能； checker各自相邻，可以共享monitor的输入，减少复杂的连接关系； 可以按照统一的报告形式，写入记录文件中； 集中管理各个checker，例如在前期使能各个模块的checker，在后期可以将其作为黑盒验证，只使能data checker。 对于复杂的系统验证，我们倾向于集中管理stimulator和checker，因为它们都需要主动给出激励或判断结果，需要较多的协调处理。Monitor 则相对独立，它只是作为监测方，将自己兢兢业业观察到的数据一字不落地交给checker即可；至于checker怎么使用这些数据，monitor并不需要关心。我们接下来将再次分析DUT MCDF的结构，以及一个项目如何高效地完成实际的验证工作。这其中涉及验证师之间如何协作、验证进度与设计进度的关系。你也可以放开思路，考虑如果自己负责这个设计时将会如何展开验证工作。 6 验证结构本节将模拟实际的工作，抛出一系列的问题，启迪你的思考。这里给出的建议不是最好的，但至少从工程项目的观点来看是合理的。如果你有更棒的主意，欢迎在路科验证的微信订阅号留言。 6.1 项目背景现在，你是这个设计模块的负责人，需要考虑分配设计人员和验证人员。而笔者作为验证的老司机，对下面这些模块的实现难度做出了评估。 对MCDF设计的评估： channel slave（slave interface+FIFO）需要7个工作日； arbiter 需要10个工作日； formatter 需要5个工作日； registers 需要4个工作日； MCDF integration（模块集成）需要2个工作日。 目前共有3位设计师：肖、吕、高，你需要安排他们在最短的时间内完成设计工作。你考虑的人力安排是什么呢？由于MCDF模块之间有独立性，我们可以同时安排3名设计师展开工作。一种较为合理的建议 是： 肖：channel slave 7天+MCDF integration 2天=9天； 吕：arbiter 10天=10天； 高：formatter 5天+registers 4天=9天。 从设计完成的周期来看，一共需要10天（取设计者所用的最长时间）。那么，针对这份设计的进度安排，你又该怎么安排验证工作呢？ 6.2 MCDF验证进度安排在开展验证之前，首先恭喜你，运气还不错，你被分配了4位验证师：梅、尤、娄、董，比设计师还多呢。是啊，作为你的项目经理，笔者也知道验证的工作量要更重一些。那么，如果按照简单的人力比例，即验证人力与设计人力之比大致为1.5∶1的话，上述各个模块的验证人力需求大致如下： channel slave:11个工作日； arbiter:15个工作日； formatter:8个工作日； registers:6个工作日； MCDF integration的验证人力有待商榷，因为它不单单需要2×1.5个工作日，而是在MCDF集成以后，还需要各个模块在子系统完成集成验证。我们暂时按照30个工作日计算。 接下来，如果将验证师按照上述的人力估计进行分配，就更加有趣了，我们来看一看只有三名设计师，意味着在formatter完成的前5天，我们只有3个模块在设计中。接下来，我们可以等待设计师高将registers模块完成，再递交给相应的验证师。这些计划都是按照天数计算的，我们将这个时间进度表绘制成图，如图6.10所示。 我们来分析一下这张项目计划表： 从设计人力利用上来看，尽力做到了从各个模块设计开始到交付用了最短的时间。 从验证一侧看，验证师梅、尤、娄的验证开展时间要略晚于设计部分。这是因为只有在设计的边界和功能有初步版本时，验证才可以开始进入。 在验证师梅、尤、娄开始搭建验证环境的过程中，验证师董看似没有事情可以安排，因为设计师高的另外一个设计register还没有开始准备，那么验证师需要等待吗？相信我，验证师一旦闲置下来，在任何一个项目中都会引起项目经理的疑问。验证师董可以在其余三位验证师搭建模块验证环境一段时间以后着手准备顶层验证环境。 完成初步验证环境集成后，验证师董可以在适当的时间开始验证模块 register。在完成模块验证后，验证师董可以进行最后阶段的验证环境持续集成。 在验证师董进行验证环境的持续集成前后，验证师梅、尤、娄可以在完成模块验证之后进入顶层验证，检查各自的模块是否工作，而所用到的checker均来自于他们的模块验证环境。同时，验证师董也应该进行最后的顶层验证，检查模块register的功能。 最后值得注意的是，MCDF作为一个整体子系统，我们不能忽视各个模块的协调使用。这项工作我们交给验证师娄，因为他还有一定的时间来完成这项任务。完成 MCDF整体验证的任务包括协调stimulator和checker 来创建激励场景和检查数据。数据检查用到的reference model、formatter FIFO和data checker需要由验证师娄来实现。 在项目执行部分，我们围绕4位验证师如何从模块级验证环境开始搭建到顶层环境的集成。接下来SystemVerilog基础和应用部分将讲述这些内容，而MCDF模块的设计源代码，读者可以通过扫描二维码下载。从第7章开始，我们将进入SystemVerilog语言的基础部分，笔者将提炼语言的重要特性，同时结合实际应用，将SystemVerilog语言在验证环境中所需的知识点展示出来。也请读者在接下来的SV语言和UVM方法学中理解本书的指导方法，即，语言知识点为辅助，项目实际应用和思想为我们贯穿全书的核心基调。 7 作者结束语 无论接下来是学习SV还是学习UVM，在展开验证之前都需要仔细阅读硬件的设计描述，并要考虑验证结构的实施。对于子系统级别，还需要考虑如何划分模块和对应的模块验证环境，然后考虑如何复用模块验证环境，最终在子系统级别完成验证环境的集成和复用。 在动态仿真领域，读者需要了解的是，无论什么验证语言或方法学，都需要有激励发生器、监测器和比较器，也都需要有顶层的验证环境来封装它们。对于小组规模的验证场景，验证师之间还需要考虑整体验证进度的平稳推进、验证环境的统一化和系统层面的验证协作等。","link":"/IC%E9%AA%8C%E8%AF%81/%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%97/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%976%E9%AA%8C%E8%AF%81%E7%9A%84%E7%BB%93%E6%9E%84/"},{"title":"路科V0P13P18SV数组-类-对象-包","text":"数组操作 对于Verilog，数组用来做数据存储，比如 reg [15:0] RAM [0:4095]; //存储数组 数组的索引名在数组右侧，左侧是每个数据的大小 非组合型(unpacked)数组 非组合型(unpacked) : SV将以上Verilog的声明方式称为非组合型声明，即数组中的成员之间的存储是互相独立的。 会消耗更多的存储空间，但是利于查找元素； SV对Verilog的非组合数组进行了保留，并且允许在声明时指定类型，包括event logic bit byte int longint shortreal real等类型； SV也保留了Verilog索引非组合型数组或切片的能力，利于数组和切片的拷贝和查找； 栗子： int a1 [7:0][1023:0]; //非组合型数组 int a2 [1:8][1023:0]; a1 = a2; //拷贝整个数组 a2[3] = a1[3]; //拷贝数组的某个片段 声明非组合型数组的方式： 指定元素个数 ： logic [31:0] data[1024]; //从右到左读，1024个32位 指定元素索引值的范围： logic [31:0] data[0:1023]; 初始化： 对于非组合数组，需要用'{}对每个维度分别赋值： int d [0:1][0:3] = '{'{7, 3, 0, 5}, '{1, 2, 3, 4}}; 因为非组合型数组赋值繁琐，所以可以使用default关键字完成， int a [0:7][0:1023] = '{default: 8' h55}; 非组合型数组的数据成员和数组本身都可以为其赋值， byte a [0:3][0:3]; a[1][0] = 8' h5; // 为单个元素赋值 a[3] = '{'hF, 'hA, 'hC, 'hE}; //给切片赋值 非组合型的赋值和拷贝，必须两边的维度完全一模一样； 非组合型数组和组合型数组之间，不能直接赋值！ 组合型(packed)数组 组合型(packed) : SV将Verilog的向量作为组合型数组的声明方式 栗子： wire [3:0] select; // 4比特的组合型数组 reg [63:0] data; //64比特的组合型数组 logic [3:0][7:0] data; // 2维组合型数组，注意，每个元素是data[0][7:0]，索引在左侧，位宽在右侧，从左到右边读，4个8位，第二维4个，第一维8个 组合型数组更节省空间！规范了数据的存储方式，所以不需要关心编译器或者操作系统的区别； 组合型除了可以用数组的声明，还可以定义结构体的存储方式： typedef struct { logic [7:0] crc; logic [63:0] data; } data_word; data_word [7:0] darray; 组合型数组和其他数组片段也可以灵活选择，用来拷贝或者赋值： logic [3:0][7:0] data; wire [31:0] out = data; wire sign = data[3][7]; wire[3:0] nib = data[0][3:0]; byte high_byte; assign high_byte = data[3]; //8bit数组片段 logic [15:0] word; assign word = data[1:0]; 初始化 ： 组合型数组的初始化，和向量的初始化一致，对所有元素统一赋值： logic [3:0][7:0] a = 32'h0; //向量赋值 logic [3:0][7:0] a = {16'hz, 16'h0}; //连接运算符 logic [3:0][7:0] a = {16{2'b01}}; //复制运算符 组合型的赋值： logic [1:0][1:0][7:0] a; a[1][1][0] = 1'b0; a = 32'hF1A3C5E7; //整个数组赋值 a[1][0][3:0] = 4'hF; //切片赋值 a[0] = 16' hFACE; // 给切片赋值 a = {16' bz, 16' b0}; //通过连接运算符赋值 组合型数组会被视为向量，所以两边操作数大小维度不同时也可以做赋值，非组合型不可以！ 会将右侧的数据截取或者扩展，扩展时，是高位填充为0！ sv中的foreach foreach: 循环，对一维或者多维数组进行循环索引，不需要指定数组的维度大小！ 栗子： int sum [1:8][1:3]; foreach(sum[i, j]) { sum[i][j] = i + j; } }; //对数组进行初始化 foreach中的变量作用域只在循环中，且只读，无法修改； 一些系统函数 $dimensions(array_name) : 获取数组的维度大小； $left(array_name, dimension) : 返回指定维度的最左索引值； 栗子： logic [1:2][7:0] word [0:3][4:1]; 最高的二维是4乘4,非组合，最低的二维为2乘8,组合型； $left(word, 1) 返回的是0； $left(word, 2) 返回的是4； $left(word, 3) 返回的是1； $left(word, 4) 返回的是7； 类似，还有$right $low $high $size(array_name, dimension) : 返回指定维度的尺寸大小； $increment(array_name, dimension) : 如果指定维度的最左索引值大于最右索引值，返回1,否则-1； $bits(expression) : 返回数组存储的比特数目； 数组类型动态数组 动态数组在声明时，需要[]， 在编译时不会指定尺寸，在运行时才会确定； 动态数组开始时为空，需要new[]来分配空间；123456789101112int dyn[], d2[];initial begin dyn = new[5]; foreach (dyn[j]) dyn[j] = j; d2 = dyn; d2[0] = 5; $display(dyn[0], d2[0]); dyn = new[20](dyn); //分配20个整数并进行赋值 dyn = new[100]; //分配100个新的整数 dyn.delete(); // 删除所有元素end 内置方法size()可以返回动态数组的大小。 delete()清空动态数组，使它尺寸变为0； 动态数组在声明时也可以初始化1bit [7:0] mask[] = '{8'b0000_0000, 8'b0000_0001, 8'b0000_0010, 8'b0000_0011, 8'b0000_0100, 8'b0000_0101, 8'b0000_0110, 8'b0000_0111}; 队列 sv引入了队列类型，它结合了数组和链表； 可以在队列的任何位置添加或者删除数据成员； 也可以索引访问队列的任何成员； 通过[$]声明队列， 队列的索引值从0到$; 可以通过队列的内建方法push_back(val)、push_front(val)、pop_back()、pop_front()来操作； 在指定位置插入成员，可以使用insert(val, pos)； 可以使用delete(pos)删除指定位置的元素； 可以使用{}连接运算符对队列进行拼接； 栗子： 12345678910111213141516int j = 1, q2[$] = {3, 4}, // 队列常量不需要' q[$] = {0, 2, 3};initial begin q.insert(1, j); q.delete(1); q.push_front(6); j = q.pop_back(); q.push_back(8); j = q.pop_front(); foreach (q[i]) $display(q[i]); q.delete();end 关联数组 处理器在访问存储时是随机或者散乱的，所有测试中，处理器也许只会访问几百个存储地址，其他的初始化为0,浪费了仿真时的存储空间。 SV中的关联数组，存放散列的数据成员，关联数组的索引类型，除了为整型之外还可以是字符串或者其他类型，而且关联数组存储的数据成员也可以是任意类型！ 栗子： 123456789101112131415161718byte assoc[byte], idx = 1;initial begin do begin assoc[idx] = idx; idx = idx &lt;&lt; 1; end while (idx != 0); foreach (assoc[i]) $display(\"assoc[%h] = %h\", i, assoc[i]); if (assoc.first(idx)) do $display(\"assoc[%h] = %h\", idx, assoc[idx]); while (assoc.next(idx)); void'(assoc.first(idx)); void'(assoc.delete(idx)); $display(\"The array now has %0d elements\", assoc.num());end 栗子2：输入文件 1234567891011121314151617181920int switch[string], min_address, max_address, i, file;initial begin string s; file = $fopen(\"switch.txt\", \"r\"); while (!$feof(file)) begin $fscanf(file, \"%d %s\", i, s); switch[s] = i; end $fclose(file); min_address = switch[\"min_address\"]; if (switch.exists(\"max_address\")) max_address = switch[\"max_address\"]; else max_address = 1000; foreach (switch[s]) $display(\"switch[%s] = %0d\", s, switch[s]);end 以上三种数组：动态数组、队列、关联数组，都是大小可变的数组，下面，讨论他们的公共方法！ 缩减方法 缩减方法指的是把一个数组缩减为一个值 最常见的是sum对数组元素求和； 还有and、or、or(异或) 栗子： 12345byte b[$] = {1,2,3,4};int w;w = b.sum(); //求和w = b.product(); //求积w = b.and(); //求元素依次按位与 定位方法 对于非合并数组，可以使用数组定位方法，返回值是一个队列，而不是数据成员； 包括min、max、unique d.find_ with(expression) 栗子： 1234567891011121314151617181920int f[6] = '{1,2,2,3,4,5,6}; //定长数组int d[] = '{2,4,6}; //动态数组int q[$] = {1,3,5,7}, tq[$]; //队列tq = q.min(); //{1}tq = d.max();tq= f.union();int d[] = '{9,6,8,8}, tq[$];tq = d.find with (item &gt; 3); //找出所有大于3的元素tq.delete();foreach (d[i]) if(d[i] &gt; 3) tq.push_back(d[i]);tq = d.find_index with (item &gt;3);tq = d.find_first with (item &gt;3);tq = d.find_first_index with (item &gt;3);tq = d.find_last with (item &gt;3);tq = d.find_last_index with (item &gt;3); 排序方法 通过排序方法，改变数组中元素的顺序，对他们进行正向、逆向、或者乱序的排序； reverse : 反转 sort ： 从小到大 rsort shuffle 类的封装 类是一种可以包含数据和方法(function、task)的类型； 例如一个数据包，可以定义为一个类，类中可以包含指令、地址、队列ID、时间戳和数据等成员； 类的概述 软件的类和硬件的module都可以理解为容器，但是类对于构建验证环境更加灵活！ OOP可以使用户能够创建复杂的数据类型，并且将他们和能够使用这些数据类型的程序结合在一起； 用户可以在更加抽象的层次建立测试平台和系统级模型，通过调用函数来执行一个动作而不是简单的改变信号的电平； 验证环境的stimulator、monitor、checker以及其他验证组件都可以按照OOP方式来构建； SV在类的定义中，只需要构建函数new，不需要定义析构函数 new函数的作用： 例化对象时开辟内存空间； 对对象的成员变量初始化； 执行完之后，返回对象实例的句柄； 1234567891011121314151617181920212223242526272829303132333435class Packet: bit [3:0] command; bit [40:0] address; bit [4:0] master_id; integer time_requested; integer time_issued; integer status; typedef enum {ERR_OVERFLOE=10, ERR_UNDERFLOW=1123} PCKT_TYPE; const integer buffer_size=100; const integer header_size; function new(): command = 4'd0; address = 41'b0; master_id = 5'bx; header_size = 10; endfunction task clean(): command = 0; address = 0; master_id = 5'bx; endtask task issue_request(int delay): //向总线发送请求 endtask function integer current_status(): current_status = status; endfunctionendclassPacket p; //p是一个句柄指针，而不是对象，new之前是悬空状态p = new(); class和struct的区别： 结构体可以包含数据成员，但是不能有成员方法，也无法进行例化； static和其他： 句柄：指向对象的指针； 原型：程序的声明部分，包括程序名、返回类型和参数列表； 类在定义时，如果没有构建函数，系统会自动定义一个空的构建函数； 对象需要先声明再例化，或者同时进行； 类的成员变量和方法默认都是动态的，即每个对象的变量和方法都会相应的开辟新的内存空间； 如果多个对象要共享一个成员变量或者方法，可以使用static关键字修饰！ 对于静态成员变量，在类没有例化的时候，就可以访问到，使用p.val或者Packet::val 注意：静态方法不能访问动态成员变量，否则报错！ this this是用来明确索引当前所在对象的成员（变量、参数、方法）； this只能用在类的非静态成员方法、约束、和覆盖中。 this的使用可以明确所指向变量的作用域,避免变量指向不清晰的问题； 123456class Demo: integer x; function new(integer x): this.x = x; endfunctionendclass 对象拷贝句柄的传递 区分类和对象之后，还要区分对象和句柄。对象创建之后，在内存的位置就不会改变了，但是指向该空间的句柄可以有不止一个； 1234Transaction t1, t2; //声明句柄t1 = new(); //例化对象，并返回句柄给t1t2 = t1; // t1和t2指向同一个对象了t1 = new(); //例化了第二个对象，返回句柄给t1,现在t1和t2指向不同对象了 赋值和拷贝 声明变量和创建对象是两个过程 Packet p1; p1 = new(); 如果将p1赋值给p2，那么还是只有一个对象，但是有两个句柄； p1和p2指向不同的对象，在创建p2时，从p1拷贝其成员变量，这种方式称为浅拷贝 栗子： 123Packet p1, p2;p1 = new;p2 = new p1; //拷贝一个对象 如果两个句柄指向同一个对象，那么一个句柄修改了成员变量，另一个也会受影响； 如果想要拷贝一个对象，则可以使用p2 = new p1;的形式； 深入理解浅拷贝栗子： 123456789101112131415class rgb: byte red; byte green; byte blue;endclassclass pixel: int x; int y; rgb color;endclasspixel dot = new;pixel dot2 = new dot; //浅拷贝pixel dot3 = dot.copy(); //深拷贝 SV中，对象的拷贝，只针对成员变量； 如果对象中还有别的句柄，那么在new拷贝对象时，只能对color句柄拷贝，而不会对它指向的对象再做拷贝，称为浅拷贝！ pixel dot2 = new dot; //浅拷贝 pixel dot3 = dot.copy(); //深拷贝 SV的new只能浅拷贝，需要深拷贝时，需要用户自己定义copy函数！ 类的成员在默认情况下，是公共属性的，表示对于类自身和外部都可以访问该成员变量和成员函数； 可以隐藏和封装，限制外部访问； local：只有该类可以访问该成员，子类和外部都不能访问； protected：该类和子类都可以访问该成员，但是外部不能访问； 通过接口函数完成local的修改，开发者只需要维护接口函数即可； 栗子： 1234567891011121314151617181920class Packet: local integer i; function integer compare(Packet other): compare = (this.i == other.i); endfunctionendclassclass clock local bit is_summer = 0; local int nclock = 6; function int get_clock(); if(!is_summer) return this.nclock; else return this.nclock+1; endfunction function bit set_summer(bit s); this.is_summer = s; endfunctionendclass 类的继承继承和子类 比如，在Packet类扩展一个新的类LinkPacket； 通过extends关键字，LinkedPacket继承父类Packet，所有的方法和成员变量；所以，LinkedPacket对象中也包含Packet类的成员； 所以，父类的句柄也可以指向子类的对象！ 如果子类中声明了与父类同名的成员，那么子类对他的同名成员的访问都指向子类，父类的成员被隐藏了！ —&gt; 成员覆盖！ 123456789class LinkPacket extends Packet; LinkPacket next; function LinkPacket get_next(); get_next = next; endfunctionendclassLinkPacket lp = new;Packet p = lp; 成员覆盖的栗子： 1234567891011121314151617181920class Packet; integer i=1; function integer get(); get = i; endfunctionendclassclass LinkedPacket extends Packet; integer i=2; function integer get(); get = -i; endfunctionendclassLinkedPacket lp = new;Packet p = lp;j = p.i; //j=1,是用的父类的j = p.get(); //j=1,还是父类的// 如果使用lp去访问，得到的也都是子类的，这才是覆盖！！！ super super ： 用来访问当前对象的父类的成员； 尤其当子类的成员和父类的成员同名时，需要使用super来指定访问父类的成员，而不是默认的子类成员； super的栗子： 12345678910111213class Packet; integer value; function integer delay(); delay = value * value; endfunctionendclassclass LinkedPacket extends Packet; integer value; function integer delay(); delay = super.delay() + value * super.value; endfunctionendclass 验证环境中的案例 已经有了generator和driver两个组件，第一个单纯产生激励数据，第二个单纯使用激励数据发送时序激励； 这种单一职责划分，使得各个组件的任务十分明确； 如果要将数据发送到DUT，需要以下的基本元素和数据的处理方法，我们把他们封装在Transaction类中； 如果为了测试DUT的稳定性，需要加入一些错误的数据测试DUT的反馈，但是又想尽量复用原有的环境和各种已经定义好的类，则可以使用继承的方法，创建一个类BadTr 123456789101112131415161718192021222324class Transaction; rand bit [31:0] src, dst, data[8]; bit [31:0] crc; virtual function void calc_crc(); crc = src ^ dst ^ data.xor; endfunction virtual function void display(input string prefix=\"\"); $display(\"%sTr: src=%h, dst=%h, crc=%h\", prefix, src, dst, crc); endfunctionendclassclass BadTr extends Transaction; rand bit bad_crc; virtual function void calc_crc; super.calc_crc(); if (bad_crc) crc = ~crc; endfunction virtual function void display(input string prefix=\"\"); $write(\"%sBadTr bad_crc=%b, \", prefix, bad_crc); super.display(); endfunctionendclass : BadTr 包的使用两个模块同名会出现错误或者后面的覆盖了前面的， 大型项目中，容易出现模块重名； 对于重名的硬件模块，可以将他们放到不同编译的库中； 对于重名的软件类、方法，可以放入不同的包中； 使用不同的验证IP时，不知道是否会有重名的类，所以使用包package将关联的方法和类放入同一个逻辑集合； package还可以在多个模块或者类之间共享用户定义的类型； 用户自定义的类型，比如类、方法、变量、结构体、枚举都可以在package .. endpackage中定义； 在module、class、interface中，都可以使用包中定义或者声明的内容； 通过域索引符，::可以直接使用 definitions::parameter 可以通过import指定索引一些需要的包中定义的类型到指定的域中，或者使用*把包中的类型都导出： 12345module M; import definitions::instruction_t; instruction_t inst; import definitions::*;endmodule 建议在不同包中的类名，命名时要加上包的前缀。 123456789101112package definitions; parameter VERSION = \"1.1\"; typedef enum {ADD, SUB, MUL} opcodes_t; typedef struct { logic [31:0] a, b; opcodes_t opcode; } instruction_t; function automatic [31:0] multiplier(input[31:0] a, b); return a * b; endfunctionendpackage 包和库的区分 package容器可以对类型做一个隔离作用； package的意义是把软件中的类、方法、变量封装在各自不同的域中，与全局域做好隔离； lib库是编译的产物，硬件的module、interface、program都会编译到库中，如果不指定编译库的话，会编译到默认的库中； lib库可以容纳硬件类型，也能容纳软件类型（类、方法和包等） package包只能容纳软件类型，比如类、方法和参数；","link":"/IC%E9%AA%8C%E8%AF%81/%E8%B7%AF%E7%A7%91V0/%E8%B7%AF%E7%A7%91v0p13p18sv%E6%95%B0%E7%BB%84-%E7%B1%BB-%E5%AF%B9%E8%B1%A1-%E5%8C%85/"},{"title":"路科V0P19P22随机变量-随机约束-约束控制-任务和函数","text":"随机变量 随着设计越来越大，要产生完整的激励来测试设计的功能变得越来越困难； 定向激励的测试方法已经无法满足检查功能完整性的要求； Soc集成度提高带来的模块之间交互的复杂性也指数提高，验证工程师无法预测用户使用过程中发生什么样的情况； 概述： 随机-约束： 构成目前动态仿真验证的主流方法； 随机约束测试：CRT， constrained-random test，即能够产生感兴趣的、想不到的测试向量，通过回归测试、替换随机种子的方式来提高单位测试用例的覆盖率收集效率； 随机测试带来的负担是验证环境的复杂度提高，不再只需要发送激励的组件，还包括监测器、比较器等； 对环境复杂度还包括环境的复用和测试的复用，带来组件封装要求，使得代码量增大； 产生一个随机数 利用系统函数产生一个随机数 randomize函数产生随机数，如果随机成功，返回1,否则0； 通过系统函数std::randomize()对一些变量完成随机化，即产生随机数并赋值给这些向量； 还有一些其他的系统函数： $urandom() 产生一个32位无符号的随机数； $urandom_range(max_val, minval=0)， 可以生成介于maxval和minval之间的随机数； 123456789module stim; bit [15:0] addr; bit [31:0] data; function bit get_stim(); bit success, rd_wr; success = randomize(add, data, rd_wr); return rd_wr; endfunctionendmodule 系统有机的组织随机变量 比起独立的产生随机数，在向DUT产生随机激励时，为了符合协议、满足测试需求，还需要添加一些约束； 这些约束会使得变量朝着希望他们变化的方向去随机； 这些约束也会对变量和变量之间的关系生效； 需要一个载体去容纳变量和他们之间的约束； 这个载体是类，类的成员变量可以声明“随机”属性，用rand或者randc表示； 随机变量 任何类中的整型（bit、byte、int）变量都可以声明为rand、randc； 定长数组、动态数组、关联数组和队列都可以声明为rand、randc； 可以对动态数组和队列的长度加以约束； 指向对象的句柄，也可以声明为rand，不能randc，随机时该句柄指向的对象中的随机变量会一起被随机化； 非组合型结构体可以声明为rand，非组合型的成员也可以声明为rand、randc； 12345678910rand bit [7:0] len;rand integer data[];constraint db {data.size == len;}typedef struct { randc int addr = 1 + constant; int crc; rand byte data [] = {1,2,3,4};} header;rand header h1; rand和randc rand： 表示在可生成范围内，每个值得可能性是相同的–&gt;每次都是有放回！！ rand bit [7:0] y; randc: 它的值会随机，并且遍历可取值范围，–&gt;无放回！！ 随机约束带有随机约束的简单类1234567891011121314class Packet; rand bit [31:0] src, dst, data[8]; randc bit [7:0] kind; // src的约束 constraint c {src &gt; 10; src &lt; 15;}endclassPacket p;initial begin p = new(); if (!p.randomize()) $finish; transmit(p);end 约束块 有用的激励不仅会约束随机变量，变量之间也存在互相约束关系； 没有约束的随机变量会包含很多无效的和非法的值，会使得有效激励变得低效； 类需要用一个或者多个约束块来描述变量之间的关系； 约束块支持整型通过inside操作符来设置可取值的范围； 123456789rand integer x,y,z;constraint c1 {x inside {3, 5, [9:15], [24:32], [y:2*y], z};}rand integer a,b,c;constraint c2 {a inside {b, c};}integer fives[4] = '{5, 10, 15, 20};rand integer v;constraint c3 {v inside {fives};} 权重分布 除了成员集合设置，约束块也支持设置可取值的同事为其设置随机时的权重； := : 表示每个值的权重都是相同的； :/ : 表示权重会平均分配到每一个值； 12x dist { [100:102] := 1, 200 := 2, 300 := 5}; // 权重分布：1 1 1 2 5x dist { [100:102] :/ 1, 200 := 2, 300 := 5}; // 权重分布：1/3 1/3 1/3 2 5 唯一标识 unique : 可以用来约束一组变量，使得其随机后变量之间不会有相同的数值； 123456rand byte a[5];rand byte b;rand byte excluded;constraint u {unique {b, a[2:3], excluded};}constraint exclusion {excluded == 5;} 条件约束 可以使用if-else或者-&gt;操作符表示条件约束； 1234567891011121314constraint c1 { mode == little -&gt; len &lt; 10; mode == big -&gt; len &gt; 100;}bit [3:0] a, b;constraint c2 {(a==0) -&gt; (b==1);}constraint c3 { if (mode == little) len &lt; 10; else if (mode == big) len &gt; 100;} 迭代约束 foreach可以用来迭代约束数组中的元素，这些数组可以是定长数组、动态数组、关联数组或者队列； 1234567891011class C; rand byte A[]; constraint c1 { foreach (A[i]) A[i] inside {2,4,6,8}; } constraint c2 { foreach (A[j]) A[j] &gt; 2*j; }endclass 也可以用数组的缩减方法进行迭代约束 12345class C; rand bit [7:0] A[]; constraint c1 {A.size() == 5;} constraint c2 {A.sum() &lt; 1000;}endclass 函数调用 有时候，在一些表达式中不能简单的描述约束，比如计算一个组合数组中的’1’； 可以写成一个函数，然后约束调用这个函数； 123456function int count_ones (bit [9:0] w); for (count_onts=0; w!=0; w = w&gt;&gt;1) count_ones += w &amp; 1'b1;endfunctionconstraint C1 {length == count_ones(v);} 软约束 和 硬约束 为了防止约束冲突时执行失败，分为软约束和硬约束； soft : soft描述的约束是软，没有soft是硬； 如果用户在使用时，制订了外部约束对同一个变量做了二次约束，或者用户定义了子类，也对同一个变量做了二次约束，那么硬约束可以覆盖软约束，不会导致随机失败； 1234567class Packet; rand int length; constraint deflt {soft length inside {32, 1024};}endclassPacket p = new();p.randomize() with {length == 1512;} // 覆盖了内部的软约束，执行成功 约束控制随机方法 类的声明中的随机变量，需要伴随类的句柄的调用randomize()，这是SV的内建方法virtual function int randomize(); 随机化成功返回1,否则0； 随机化之前需要先对对象完成例化，例化时没有随机的过程； 内嵌约束 在调用randomize()时伴随with，称为内嵌约束； 1234567class C; rand integer x;endclassfunction int F(C obj, integer y); F = obj.randomize() with (x) {x &lt; y;}; //这种方式对x的指向明确了，不在参数列表中，所以是C的xendfunction local域指向 同名的变量处于不同的域中，可能出现指向模糊，可以使用上文的方法； 也可以使用local::域索引到方式； 1234567class C; rand integer x;endclassfunction int F(C obj, integer x); F = obj.randomize() with{x &lt; local::x;}; //第一个x是C的，第二个local的x是参数endfunction 随机控制 rand_mode可以用来使能或者禁止成员变量的随机属性； 当随机模式被禁止时，就相当于一个普通变量了； 可以禁止某个变量的随机模式，也可以对整个对象调用rand_mode进行控制； constraint_mode()用来关闭或者使能约束块； 12task object[.random_variable]::rand_mode(bit on_off);function int object.rand_variable::rand_mode(); 内嵌变量控制 一个有意思的点，如果在randomize()中有参数，则只会对这个参数进行随机化，别的就算是rand也不随机化了； 任务和函数概述 function和task都是提高代码复用性和整洁度； function： 首要目的在于为运算表达式提供返回值，便于简化原有代码，提高维护性； void函数无返回值； 一个function只能有一个返回值，所以函数可以作为表达式的操作数，因为就一个值； 函数的参数方向可以声明为：input、output、inout、ref 函数可以调用函数，但是必须立即返回，不能阻塞等待！ 函数返回方式有两种，一个是return直接返回，一个是将值或者表达式赋给函数的同名变量； 区别在于return会立即返回，但是赋值同名变量之后，后续的代码还会执行下去； 可以对有返回值的函数进行类型转换，void'(func1),这时候用不到函数的返回值； task： 同样的参数列表指名四个方向； task无返回值！ task可以用来消耗仿真时间，内置一些阻塞语句； 可以使用return立刻结束task； task可以调用task和function，但是function只能调用function，不能调用task； 1234567891011logic red;parameter red_tics = 100;always begin red = on; light(red, red_tics);endtask light(output color, input [31:0] tics); repeat(tics) @(posedge clock); color = off;endtask: light 参数传递 input ： 在方法调用时，属于值传递，在传递的过程中，外部变量的值经过拷贝，赋值给输入参数； output、inout都是值传递，发生在方法调用和返回时； ref参数不会传递值拷贝，而是将变量指针传递到方法中，所以方法内部的操作会影响到外部的变量； 为了避免外部传入的ref参数被方法修改，可以添加const修饰符； SV允许在声明输入参数时，指定参数的默认值； 除了按照参数位置传递参数，SV也允许像module例化一样，用参数名字映射的方式传递参数； 123456789task read(int j=0, int k, int data=1);endtaskread(,5); // 即0 5 1function int func(int j=1, string s= \"no\");endfunctionfunc(.j(2), .s(\"yes\")); // 即2 yes","link":"/IC%E9%AA%8C%E8%AF%81/%E8%B7%AF%E7%A7%91V0/%E8%B7%AF%E7%A7%91v0p19p22%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F-%E9%9A%8F%E6%9C%BA%E7%BA%A6%E6%9D%9F-%E7%BA%A6%E6%9D%9F%E6%8E%A7%E5%88%B6-%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%87%BD%E6%95%B0/"},{"title":"路科V0P1P2P4验证概览","text":"什么是验证 什么是验证? 测试平台： 验证的任务和目标验证的目标： 验证的周期","link":"/IC%E9%AA%8C%E8%AF%81/%E8%B7%AF%E7%A7%91V0/%E8%B7%AF%E7%A7%91v0p1p2p4%E9%AA%8C%E8%AF%81%E6%A6%82%E8%A7%88/"},{"title":"路科V0P1SV学习","text":"Bilibili 几个必备技术要求： 动态验证技术 代码覆盖率 功能覆盖率 断言 随机约束 静态验证技术 人工的形式验证（属性检查） 自动的形式验证 硬件加速技术 Emulation以及FPGA原型开发 背景要求： 课程： 数字电路 Verilog C/C++","link":"/IC%E9%AA%8C%E8%AF%81/%E8%B7%AF%E7%A7%91V0/%E8%B7%AF%E7%A7%91v0p1sv%E5%AD%A6%E4%B9%A0/"},{"title":"路科V0P23P25线程控制-线程同步-线程通信","text":"线程控制什么是线程 线程是独立运行的程序； 需要被触发，可以结束或者不结束； 在module中的initial和always，都可以看做独立的线程，会在仿真0时刻开始，选择结束或者不结束； 硬件模型中，由于都是always语句块，所以可以看成是多个独立运行的线程，他们一直占用着仿真资源，因为不会结束； 验证环境中需要由initial语句块去创建，在仿真过程中，验证环境中的对象可以创建和销毁，因此验证环境中的资源是动态的。 验证环境中的initial语句块有两种分组方式，begin..end和fork..join begin..end ： 顺序方式执行 fork..join ： 并发方式执行 与fork..join类似的，还有fork..join_any和fork..join_none 线程的执行轨迹是树状结构，任何线程都有父线程； 父线程可以开辟若干个子线程，父线程可以暂停或者终止子线程； 子线程终止时，父线程可以继续执行； 父线程终止时，它的所有子线程都会终止； 并行线程 fork..join : 等待所有子线程结束，才会继续执行后面的； fork..join_any : 只要有一个子线程结束(最短的先结束)，就会继续执行后面的； fork..join_none : 不需要等待任何子线程结束，就可以继续执行后面的； 注意 ： 虽然无需等待，但是fork..join_any和fork..join_none执行后面的时候，前面的子线程还在执行； 如果要等待这些子线程都完成，或者停止这些子线程，可以使用wait fork或者disable fork； 12345678910111213141516171819202122fork begin $display(\"First Block\\n\"); # 20ns; end begin $display(\"Second Block\\n\"); @eventA; endjointask do_test; fork exec1(); exec2(); join_any fork exec3(); exec4(); join_none wait fork //等待所有子线程结束endtask 时序控制 SV中可以通过延迟控制或者事件等待来完成时序控制； 延迟控制通过#完成； #10 rega = regb; 事件控制（event）通过@完成； @r rega = regb; @(posedge clock) rega = regb; wait语句可以与事件或者表达式结合，来完成时序控制； real AOR[]; initial wait(AOR.size() &gt; 0) ...; 线程同步概述 测试平台中所有线程都需要同步并交换数据； 一个线程等待另外一个，比如验证环境需要等待所有激励结束，比较结束才能结束仿真； 比如监测器需要将数据发送到检查器，检查器又需要从不同的缓存获取数据进行比较； 线程同步的第一个类型：event事件 可以通过event声明一个event变量，并且触发它； 这个event变量可以用来控制多个线程间的同步；一端触发，另一端阻塞等待； 通过-&gt;操作符触发事件； 其他等待该事件的线程可以通过@操作符或者wait()来检查event的触发状态； wait_order()方法： 可以使线程保持等待，直到在参数列表中的事件event按照从左到右的顺序依次完成； 如果参数列表中的事件被触发，但是没有按照要求顺序，也会失败； 1234567891011121314151617181920212223242526event done, blast;event done_too = done;task trigger(event ev); -&gt; ev;endtaskfork @ done_too; #1 trigger(done);joinfork -&gt;blast; wait(blast.triggered);join// wait_orderwait_order(a,b,c) else $display(\"Error: events out of order\");bit success;wait_order(a,b,c) success = 1;else success = 0; 线程同步的第二个类型：旗语semaphore 旗语可以看做打开共享资源大门的钥匙；用于访问控制保护； 创建旗语时，会为其分配固定的钥匙数量； 使用旗语时，必须先获得钥匙，才能继续执行； 旗语的钥匙数量可以有多个，等待旗语钥匙的线程也可以有多个； 旗语通常用于互斥，对共享资源的访问控制，以及基本的同步； 旗语的创建 创建旗语，并为他分配钥匙的方式： semaphore sm; sm = new(); 创建一个固定钥匙数量的旗语，new(N) 从旗语那里获取一个或者多个钥匙（阻塞型）： get(N=1) 将一个或者多个钥匙返回到旗语中： put(N=1) 尝试获取一个或者多个钥匙，而不阻塞： try_get(N=1) new函数默认为0,但是可以put超过开始的数量值； new()返回旗语的句柄； put() : 如果其他进程在等待旗语，则应该在该进程有足够数量钥匙的情况下返回； get() : 如果指定数量的钥匙可用，则方法返回并继续执行，如果不足，进程阻塞直到钥匙数目充足； 旗语的等待队列是FIFO的，先排队的先获得； try_get() : 如果指定数目可用，返回正数并继续执行，否则，返回0； 线程通信 除了event、semaphore之外，还有mailbox信箱 信箱可以放置任何类型，可以设置尺寸大小，防止存储数据过多占用资源，信箱也是FIFO的 信箱的内建方法 new() : 创建信箱，默认尺寸bound为0，表示不限制大小，否则限制为最大值N； put() : 将信息写入信箱，如果信箱已满，则put被挂起，直到可以有新的空间； try_put() : 尝试写入信箱，不发生阻塞；如果满，不阻塞，返回0,否则成功返回1； get() : 从信箱中获取信息，并取出 peek() : 获取信息，但是不取出，只是拷贝，如果信箱为空，peek会挂起，直到有消息； try_get() try_peek() : 非阻塞取出 num() : 获取信箱信息的数目； 参数化信箱 虽然信箱可以存放各种数据类型，但是为了之后用的方便，在声明时最好指定存储类型； 这种参数化信箱的方式可以在编译时就能检查出类型不匹配的情况； 123456typedef mailbox #(string) s_box;s_box sm = new;string s;sm.put(\"hello\");sm.get(s); 信箱和队列的区别 信箱必须通过new例化，但是队列只需要声明即可； 信箱的存取方法put()和get()是阻塞方法，但是队列的存取方法，push_back()和pop_front()方法是非阻塞的，会立即返回； 在传递形参时，如果是input方向，信箱类型传递到是句柄，而队列类型则是完成的队列内容的拷贝； 线程通信的比较 event ： 最小信息量触发，即单一通知功能，可以用来做事件的触发，也可以多个事件组合起来用作线程同步； semaphore : 共享资源的卫士，如果多线程对某一共享资源做访问，则可以使用这个要素； mailbox ： 精小的SV原生FIFO，在线程之间做数据通信或者内部数据缓存时考虑使用这个元素；","link":"/IC%E9%AA%8C%E8%AF%81/%E8%B7%AF%E7%A7%91V0/%E8%B7%AF%E7%A7%91v0p23p25%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"},{"title":"路科V0P26P29-MCDT测试结构-实现激励发生器-监测器和检查器-顶层环境和测试用例","text":"MCDT测试结构 MCDT测试平台结构 要区分哪部分是硬件、哪部分是软件 HW ： 待测的设计 SW ： 测试环境 软硬件之间交互通过interface 要清楚验证环境的各个组件之间的位置层次关系和它们之间是否有数据通信！ 验证组件之间的通信都是基于事务级的传送； 验证组件和硬件的通信必须依赖接口，通过硬件时序才能实现； 理解仿真如何开始运转，各个验证组件如何工作，最后仿真如何结束 一些要注意的细节： channel initiator 和 channel monitor一一对应； initiator和monitor被封装在了agent中； 由于arbiter不需要与下行握手，所以只外置了mcdt monitor而不需要mcdt responder； 所有的monitor都将监测到的数据送到mcdt checker； MCDT checker内部例化了若干FIFO，是为了接收从MCDT的输入端和输出端的数据； 由于checker输入端和输出端FIFO中存放的数据类型一致，也为数据比较带来了方便； 激励发生器 监测器 比较器 实现激励发生器实现 channel stimulator 数据事务：12345678910111213141516171819202122232425262728293031323334class chnl_trans; rand bit[31:0] data[]; rand int ch_id; rand int pkt_id; rand int data_nidles; rand int pkt_nidles; bit rsp; local static int obj_id=0; constraint cstr { soft data.size inside {[4:8]}; foreach (data[i]) data[i] == 'hC000_0000 + (this.ch_id &lt;&lt; 24) + (this.pkt_id &lt;&lt; 8) + i; soft ch_id == 0; soft pkt_id == 0; data_nidles inside {[0:2]}; pkt_nidles inside {[1:10]}; }; function new(); this.obj_id++; endfunction function chnl_trans clone(); chnl_trans c = new(); c.data = this.data; c.ch_id = this.ch_id; c.pkt_id = this.pkt_id; c.data_nidles = this.data_nidles; c.pkt_nidles = this.pkt_nidles; c.rsp = this.rsp; return c; endfunctionendclass: chnl_trans 驱动激励的组件： chnl_initiator的作用是从chnl_generator中获取chnl_trans的数据，并将其驱动到接口chnl_interface上面； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class chnl_initiator; local string name; local virtual chnl_intf intf; mailbox #(chnl_trans) req_mb; mailbox #(chnl_trans) rsp_mb; function new(string name = \"chnl_initiator\"); this.name = name; endfunction //从外部获得虚拟指针，并赋值给自己的虚接口成员变量 function void set_interface(virtual chnl_intf intf); if(intf == null) $error(\"interface handle is NULL, please check if target interface has been intrantiated\"); else this.intf = intf; endfunction task run(); this.driver(); endtask task drive(); chnl_trans req, rsp; @(posedge intf.rstn); //系统复位信号 forever begin this.req_mb.get(req); // 获取激励 this.chnl_write(req); // 写出到接口 rsp = req.clone(); //发送完毕之后克隆一份 rsp.rsp = 1; this.rsp_mb.put(rsp); end endtask task chnl_write(input chnl_trans t); foreach(t.data[i]) begin @(posedge intf.clk); intf.ch_valid &lt;= 1; //在时钟上升沿置为有效 intf.ch_data &lt;= t.data[i]; @(negedge intf.clk); wait(intf.ch_ready == 'b1); $display(\"%0t: channel initiator [%s] sent data %x\", $time, name, t.data[i]); repeat(t.data_nidles) chnl_idle(); //插入空闲周期 end repeat(t.pkt_nidles) chnl_idle(); endtask task chnl_idle(); @(posedge intf.clk); intf.ch_valid &lt;= 0; intf.ch_data &lt;= 0; endtaskendclass: chnl_initiator chnl_generator 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class chnl_generator; rand int pkt_id = -1; rand int ch_id = -1; rand int data_nidles = -1; rand int pkt_nidles = -1; rand int data_size = -1; rand int ntrans = 10; mailbox #(chnl_trans) req_mb; mainbox #(chnl_trans) rsp_mb; constraint cstr { soft ch_id == -1; soft pkt_id == -1; soft data_size == -1; soft data_nidles == -1; soft pkt_nidles == -1; soft ntrans == 10; } function new(); this.req_mb = new(); this.rsp_mb = new(); endfunction // 调用了多次创建数据事务，并且发送给chnl_initiator的任务send_trans task run(); repeat(ntrans) send_trans; run_stop_flags.put(); endtask // 生成transaction并put进入maibox task send_trans(); chnl_trans req, rsp; req = new(); assert(req.randomize with { local::ch_id &gt;=0 -&gt; ch_id == local::ch_id; local::pkt_id &gt;=0 -&gt; pkt_id == local::pkt_id; local::data_nidles &gt;=0 -&gt; data_nidles == local::data_nidles; local::pkt_nidles &gt;=0 -&gt; pkt_nidles == local::pkt_nidles; local::data_size &gt;=0 -&gt; data_size == local::data_size; }) else $fatal(\"[RNDFAIL] channel packet randomization failure!\"); this.pkt_id++; this.req_mb.put(req); this.rsp_mb.get(rsp); assert(rsp.rsp) else $error(\"[RSPERR] %0t error response received!\", $time); endtaskendclass: chnl_generator 监测器和检查器监测器 用户自定义结构体mon_data_t用来存放监测到的数据，被chnl_monitor和mcdt_monitor使用 1234567891011121314151617181920212223242526272829303132333435// chnl_monitortypedef struct packed { bit[31:0] data; bit[1:0] id;} mon_data_t;class chnl_monitor; local string name; local virtual chnl_intf intf; mailbox #(mon_data_t) mon_mb; function new(string name = \"chnl_monitor\"); this.name = name; endfunction function void set_interface(virtual chnl_intf intf); if(intf == null) $error(\"interface handle is NULL, please check if target interface has been intrantiated\"); else this.intf = intf; endfunction task run(); this.mon_trans(); endtask // 三个等号判断四值逻辑变量是否相等 task mon_trans(); mon_data_t m; forever begin @(posedge intf.clk iff (intf.ch_valid==='b1 &amp;&amp; intf.ch_ready ==='b1)); m.data = intf.ch_data; mon_mb.put(m); $display(\"%0t %s channel monitor data %8x\", $time, this.name, m.data); end endtaskendclass: chnl_monitor 再实现一个mcdt_monitor 12345678910111213141516171819202122232425262728293031// mcdt_monitorclass mcdt_monitor; local string name; local virtual mcdt_intf intf; mailbox #(mon_data_t) mon_mb; function new(string name = \"mcdt_monitor\"); this.name = name; endfunction function void set_interface(virtual mcdt_intf intf); if(intf == null) $error(\"interface handle is NULL, please check if target interface has been intrantiated\"); else this.intf = intf; endfunction task run(); this.mon_trans(); endtask task mon_trans(); mon_data_t m; forever begin @(posedge intf.clk iff intf.mcdt_val==='b1); m.data = intf.mcdt_data; m.id = intf.mcdt_id; mon_mb.put(m); $display(\"%0t %s mcdt monitor data %8x and id %0d\", $time, this.name, m.data, m.id); end endtaskendclass: mcdt_monitor 检查器12345678910111213141516171819202122232425262728293031323334353637383940414243// mcdt_checkerclass mcdt_checker; local string name; local int error_count; local int cmp_count; mailbox #(mon_data_t) in_mbs[3]; mainbox #(mon_data_t) out_mb; function new(string name = \"mcdt_checker\"); this.name = name; foreach(this.in_mbs[i]) this.in_mbs[i] = new(); this.out_mb = new(); this.error_count = 0; this.cmp_count = 0; endfunction task run(); this.do_compare(); endtask // 每次从输出端out_mb中取出一个数据，然后通过id判断从哪个输入端获取数据，比较 task do_compare(); mon_data_t im, om; forever begin out_mb.get(m); case(om.id) 0: in_mbs[0].get(im); 1: in_mbs[1].get(im); 2: in_mbs[2].get(im); default: $fatal(\"id %0d is not available\", om.id); endcase if(om.data != im.id) begin this.error_count++; $error(\"[CMPFAIL] Compared failed! mcdt out data %8x ch_id %0d is not equal with channel in data %8x\", om.data, om.id, im.data); end else begin $display(\"[CMPSUCD] Compared success! mcdt out data %8x ch_id %0d is equal with channel in data %8x\", om.data, om.id, im.data); end this.cmp_count++; end endtaskendclass: mcdt_checker 顶层环境和测试用例实现顶层环境1-agent1234567891011121314151617181920212223242526class chnl_agent; local string name; chnl_initiator init; chnl_monitor mon; virtual chnl_intf vif; function new(string name = \"chnl_agent\"); this.name = name; this.init = new({name, \".init\"}); this.mon = new({name, \".mon\"}); endfunction // 自身获得虚接口，然后传递给ini和mon function void set_interface(virtual chnl_intf vif); this.vif = vif; init.set_interface(vif); mon.set_interface(vif); endfunction task run(); fork: init.run(); mon.run(); join endtaskendclass: chnl_agent 实现顶层环境2-mcdt_root_test1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// mcdt_root_test// 包含3个gen，3个agent，1个checkerclass mcdt_root_test; chnl_generator gen[3]; chnl_agent agents[3]; mcdt_monitor mcdt_mon; mcdt_checker chker; protected string name; event gen_stop_e; function new(string name = \"mcdt_root_test\"); this.name = name; this.chker = new(); foreach(agents[i]) begin this.agents[i] = new($sformatf(\"agent%0d\", i)); this.gen[i] = new(); this.agents[i].init.req_mb = this.gen[i].req_mb; this.agents[i].init.rsp_mb = this.gen[i].rsp_mb; this.agents[i].mon.mon_mb = this.chker.in_mbs[i]; end this.mcdt_mon = new(); this.mcdt_mon.mon_mb = this.chker.out_mb; $display(\"%s instantiated and connected objects\", this.name); endfunction virtual task gen_stop_callback(); endtask // 等待三个gen都发送完激励数据后，交还钥匙给旗语run_stop_flags virtual task run_stop_callback(); $diplay(\"run_stop_callback enterred\"); $display(\"%s: wait for all generators have generated and tranferred transcations\", this.name); run_stop_flags.get(3); $finish(); endtask virtual task run(); this.do_config(); //决定产生多少个怎样的随机数据 fork agents[0].run(); agents[1].run(); agents[2].run(); mcdt_mon.run(); chker.run(); join_none fork : gen_threads gen[0].run(); gen[1].run(); gen[2].run(); join run_stop_callback(); endtask virtual function void set_interface(virtual chnl_intf ch0_vif, virtual chnl_intf ch1_vif, virtual chnl_intf ch2_vif, virtual mcdt_intf mcdt_vif); agents[0].set_interface(ch0_vif); agents[1].set_interface(ch1_vif); agents[2].set_interface(ch2_vif); mcdt_mon.set_interface(mcdt_vif); endfunction virtual function void do_config(); // 在这里配置gen的参数,用一个子类的方法去实现他 endfunctionendclass: mcdt_root_test 实现测试用例123456789101112131415class mcdt_basic_test extends mcdt_root_test; function new(string name = \"mcdt_basic_test\"); super.new(name); endfunction virtual function void do_config(); super.do_config(); assert(gen[0].randomize() with {ntrans==100; data_nidles==0; pkt_nidles==0; data_size==8;}) else $fatal(\"[RNDFAIL] gen[0] randomize failed\"); assert(gen[1].randomize() with {ntrans==50; data_nidles inside {[1:2]}; pkt_nidles inside {[3:5]}; data_size==6;}) else $fatal(\"[RNDFAIL] gen[1] randomize failed\"); assert(gen[2].randomize() with {ntrans==80; data_nidles inside {[0:1]}; pkt_nidles inside {[1:2]}; data_size==32;}) else $fatal(\"[RNDFAIL] gen[2] randomize failed\"); endfunctionendclass: mcdt_basic_test","link":"/IC%E9%AA%8C%E8%AF%81/%E8%B7%AF%E7%A7%91V0/%E8%B7%AF%E7%A7%91v0p26p29-mcdt%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%84-%E5%AE%9E%E7%8E%B0%E6%BF%80%E5%8A%B1%E5%8F%91%E7%94%9F%E5%99%A8-%E7%9B%91%E6%B5%8B%E5%99%A8%E5%92%8C%E6%A3%80%E6%9F%A5%E5%99%A8-%E9%A1%B6%E5%B1%82%E7%8E%AF%E5%A2%83%E5%92%8C%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"},{"title":"路科V0P30P33-覆盖率-代码覆盖率-功能覆盖率-从功能描述到覆盖率","text":"覆盖率 随机测试比定向测试多了很多的可能性，但是需要考虑，什么时候结束验证呢？涉及到覆盖率指标的问题。 是否所有设计的功能在验证计划中都已经验证了？ 是否代码中的某些部分从未执行过？ 覆盖率 用来衡量设计验证完备性的通用词语； 覆盖率工具会在仿真过程中收集信息，然后进行后续处理并得到覆盖率报告。 通过覆盖率报告找到覆盖率之外的盲区，然后修改现有的测试用例或者创建新的测试来填补这些盲区； 一直迭代进行，直到覆盖率满足要求； 覆盖率反馈回路 ： 优化验证效率 通过覆盖率量化验证之后，可以在更复杂的情况下捕捉一些功能特性是否被覆盖： 在测试X特性时，Y特性是否同时被使能和测试？功能之间存在关联 是否可以精简已有的测试来加速仿真？并取得同样的覆盖率。冗余问题 观察覆盖率在达到一定数值之后，是否停滞不再上升？ 覆盖率是用来衡量验证精度和完备性的数据指标； 可以告诉用户哪些结构在仿真时被触发，哪些没有； 覆盖率分类 代码覆盖率 功能覆盖率 断言覆盖率 按照覆盖率生成的方法，分为两类： 隐形生成： 代码覆盖率，仿真工具可以自动分析RTL设计代码的执行结果得到代码覆盖率 显性生成： 断言覆盖率 功能覆盖率，需要依照功能描述去定义的覆盖率； 按照覆盖率溯源，分两类： 从功能描述而来： 功能覆盖率 从设计实现而来 代码覆盖率 断言覆盖率 代码覆盖率 包含未知错误的设计的问题在于它看起来很好，但是绝对不可能知道被验证的设计在功能上是完全正确的； 即使所有测试平台都成功仿真，但是只要有部分RTL代码未执行，都可能触发功能错误，因此需要代码覆盖率！ 代码覆盖率的优势在于可以由仿真工具自动收集； 一般只关注设计的代码覆盖率，不关注测试平台的代码覆盖率； 行覆盖率（statement/line） 衡量源码哪些行被执行，哪些行没有； 每一行执行的最小次数也可以设置为一个指标； 代码覆盖率可以指出在缺乏激励的情况下，某些赋值的代码行没有被执行的情况，也可以指出一些漏洞影响或者无用代码的影响下，一些代码行也无法被执行的情况； 对于无用代码，即永远不会执行的代码，可以从覆盖率中过滤掉； 行覆盖率也叫做块覆盖率，块是在灾星单个语句时语句序列； 比如，只要if为true，就会执行名为acked的块，因此这个块的执行等同于四个单独语句的执行； 123456if (data == 1'b1) begin: acked as &lt;= 1'b0; data &lt;= 16'hzzzz; bus_rq &lt;= 1'b0; state &lt;= IDLE;end: acked 分支覆盖率（branch） 分支覆盖率是用来对条件语句if/else case ?:，指出其执行的分支轨迹； 条件覆盖率（condition/expression） 条件覆盖率用来衡量一些布尔表达式的各个条件真伪判断的执行轨迹； 比如下面的if中两个条件是否各自衡量为true、false； if (parity == ODD || parity == EVEN) begin 状态机覆盖率（FSM） 仿真工具可以自动识别状态机，因此在收集覆盖率时，可以将覆盖率状态的执行情况监测到； 可以反映到每个状态的进入次数、状态之间的跳转次数、以及多个状态的跳转顺序等； 因为FSM中的每个状态通常使用case语句中的选项进行编码，所以任务没有访问到的状态都可以通过未覆盖的语句清楚的识别到； 跳转覆盖率（toggle） 用来衡量寄存器跳转次数（0-&gt;1, 1-&gt;0）； 一般项目会要求模块的端口实现至少一次1到0和一次0到1的跳转；，以保证模块的集成和模块之间的互动； 也有项目要求所有的寄存器和端口一样，满足跳转的最小次数； 端口跳转覆盖率常用来测试IP模块之间的基本连接性，比如检查一些输入端口是否没有连接，已经连接的端口的比特位数是否不匹配，一些已连接的输入是否被给定的固定值等； 代码覆盖率100%的含义 表明整个设计都已执行； 表示验证环境运行设计源码的彻底程度，但是没有提供有关验证组件的正确性和完整性的指示； 代码覆盖率应该用于帮助识别验证未执行的边界情况或者依赖于设计实现的特性； 对于未覆盖的场景，考虑更新和添加测试； 功能覆盖率 功能验证的目标，在于确定设计有关的功能描述是否都实现了； 可能存在的不期望的情况： 哪些功能没有被实现； 实现错误； 哪些没有要求的功能也实现了； 覆盖组（covergroup） 覆盖组和类相似，在一次定义之后可以多次例化； 覆盖组含有覆盖点（cover point）、选项（option）、形式参数（argument）和可选触发（trigger event）； 一个覆盖组包含的一个或者多个数据点，都是在同一时间采集； 覆盖组可以定义在类里，也可以定义在模块或者程序中； 覆盖组可以采集任何可见变量，比如程序或模块变量、接口信号、或者设计中的任何信号； 在类中的覆盖组也可以采集类的成员变量； 覆盖组应该定义在适当的抽象层次上； 对任何事务的采样都必须等到数据被待测设计接收到以后； 一个类也可以包含多个覆盖组，每个覆盖组可以根据需要将它们使能或者禁止； 内部可以定义多个coverpoint，如果不在covergroup声明时指定采样事件，那么默认该覆盖组只能依赖于另一个手动采样函数sample(); 12345678910enum {red, green, blue} color;bit[3:0] pixel_adr, pixel_offset, pixel_hue;covergroup g2 @(posedge clk); Hue: coverpoint pixel_hue; Offset: coverpoint pixel_offset; AxC: cross color, pixel_adr; // cross 2变量 all: cross color, Hue, Offset; // cross 1变量和2个coverpointendgroupg2 cg_inst = new(); 其他： 更多的时候，将覆盖组定义在类中，从而去覆盖类的成员变量； 在类中声明covergroup的方式称为嵌入式覆盖组声明，以下栗子声明一个覆盖组cov1和它的实例c1; 1234567891011121314class xyz; bit[3:0] m_x; int m_y; bit m_z; covergroup cov1 @m_z; coverpoint m_x; coverpoint m_y; endgroup function new(); cov1 c1 = new(); endfunctionendclass 覆盖点（coverpoint） 一个covergroup可以包含一个或者多个coverpoint，一个coverpoint可以用来采样数据或者数据的变化； 一个coverpoint可以对应多个bin（仓）； 这些bin可以显性指定，也可以隐性指定； coverpoint对数据的采样发生在covergroup采样的时候； 建议给不同的覆盖点不同的名字，以便于查看； 有名字的coverpoint可以用来进一步处理，比如在交叉覆盖率中使用某个coverpoint； 可以通过iff在一些情况下禁止coverpoint采集 1234567891011covergroup g4; coverpoint s0 iff(!reset);endgroupcovergroup cg (ref int x, ref int y, input int c); coverpoint x; b: coverpoint y; cx: coverpoint x; d: coverpoint y[31:24]; cross x, y; // 创建交叉覆盖率endgroup 仓：值覆盖 关键字bins可以用来将每个感兴趣的数值均对应一个独立的bin，或者将所有值对应到同一个bin； iff语句也可以用在bin的定义，表示条件为false，在采集该bin的时候，该bin的采样数目不会增长； bins除了可以覆盖数值，还可以覆盖数值的变化 value1 =&gt; value2; 语法：trans_item[* repeat_range] 3[* 5] 表示3=&gt;3=&gt;3=&gt;3=&gt;3 3[* 3:5] 表示(3=&gt;3=&gt;3),(3=&gt;3=&gt;3=&gt;3)或者(3=&gt;3=&gt;3=&gt;3=&gt;3) 如果coverpoint没有指定任何bin，则sv会为他自动生成bin，遵循原则： 如果变量是枚举类型，则bin的数量是枚举类型的基数（所有枚举值得和）； 如果变量是整型（位宽为M），则bin的类型是2^M和auto_bin_max的较小值； 12345678910bit [9:0] v_a;covergroup cg @(posedge clk); coverpoint v_a { bins a = {[0:63], 65}; // a是变量，表示在以下条件的话采样 bins b[] = {[127:150], [148:191]}; //b[]是个数组，表示满足以下条件的话分别采集一次 bins c[] = {200, 201, 202}; bins d = {[1000:$]}; bins others[] = default; // default表示其他的值都采样一次 }endgroup 仓： 忽略类型和非法类型 ingnore_bins用来将其排除在有效统计的bin集合之外 illegal_bins用来指出采样的数值为非法，如果illegal_bins被采样到，那么仿真会报错！ 12345678910111213covergroup cg23; coverpoint a { ignore_bins ignore_vals = {7, 8}; ignore_bins ignore_trans = (1=&gt;3=&gt;5); }endgroupcovergroup cg3; coverpoint b { illegal_bins bad_vals = {1,2,3}; illegal_bins bad_trans = (4=&gt;5=&gt;6); }endgroup 交叉覆盖率 cross covergroup可以在两个或者更多的coverpoint或者变量之间定义交叉覆盖率； 在对a和b产生交叉覆盖率之前，系统会先为他们隐性生成对应的coverpoint和bin，每个coverpoint都有16个自动产生的bin； 两个coverpoint交叉产生256个bin； 注意：被声明为default、ignore、illegal的bin不会被交叉覆盖率计算； 交叉覆盖率只允许在同一个covergroup中定义的覆盖点参与运算。 1234567891011bit [3:0] a, b;covergroup cov @(posedge clk); aXb : cross a, b;endgroupbit [31:0] a_var;bit [3:0] b_var;covergroup cov3 @(posedge clk); A : coverpoint a_var {bins yy[] = {[0:9]};} CC : cross b_var, A;endgroup 从功能描述到覆盖率概述 提取接口功能点 提取内部功能点 提取结构功能点 标记功能点 验证分层 优先级划分 从随机测试到功能覆盖率 覆盖率实现的考量 MCDT功能测试清单","link":"/IC%E9%AA%8C%E8%AF%81/%E8%B7%AF%E7%A7%91V0/%E8%B7%AF%E7%A7%91v0p30p33-%E8%A6%86%E7%9B%96%E7%8E%87-%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87-%E5%8A%9F%E8%83%BD%E8%A6%86%E7%9B%96%E7%8E%87-%E4%BB%8E%E5%8A%9F%E8%83%BD%E6%8F%8F%E8%BF%B0%E5%88%B0%E8%A6%86%E7%9B%96%E7%8E%87/"},{"title":"路科V0P5P9SV入门","text":"SV以及UVM概述 UVM类库地图 ： UVM常用的十大类： 数据类型 Verilog的数据类型： 线网类型： 变量类型： SV新添加的数据类型： 自定义类型SV的自定义类型： 枚举类型： verilog实现枚举 SV实现枚举： 定义枚举值： 自定义枚举类型： 枚举类型赋值： 结构体类型： 字符串类型SV中的字符串类型： 字符串类型的常见使用方式： 接口 verilog无接口代码： 接口的优势： SV接口代码： 接口的内容： 接口的声明： 接口的例化： modport: 接口在验证中的应用： 总结：","link":"/IC%E9%AA%8C%E8%AF%81/%E8%B7%AF%E7%A7%91V0/%E8%B7%AF%E7%A7%91v0p5p9sv%E5%85%A5%E9%97%A8/"},{"title":"路科V0SV和Verilog的对比总结","text":"Verilog：变量类型 veriables四值逻辑01X用来捕获设计错误，比如寄存器未初始化Z用来表示未连接或者三态的设计逻辑但是在系统级或者事务级，Z和X很少使用 reg用来描述 逻辑， integer 用来描述循环变量和计算reg并不一定要被综合为register，它只是用来与线网类型相对，表示存储数据的变量integer和time类似，像有相同位数的reg一样运转，表达式的integer值作为 有符号数 处理， reg 和 time 作为无符号数处理 time和realtime类似， 用来保存测试装置的仿真时间real在系统模型中使用realtime变量类型是保存在initial always task function中赋的值只能用 过程赋值 来完成线网类型 nets四值逻辑01XZwireworwand用于建模连接线路，值由 线网驱动器决定线网驱动器：可以是门或者模块的实例，也可以是连续赋值的输出SV :&nbsp;在与C交互时，可以使用二值逻辑使接口参数更加简单， 因为构建验证驱动组件时，不关注硬件底层逻辑X，Z 硬件信号类型变量 var线网类型 wire数据类型四值逻辑 logic构成的vector都是无符号类型 用来表示通用的存储硬件数据####### logic resetN;&nbsp; &nbsp; // 1位宽的四值逻辑 ####### logic&nbsp; [63:0] data;&nbsp; &nbsp; &nbsp;// 64位宽的变量 ####### logic [0:7} array [0:255];&nbsp; &nbsp; // 由8位向量元素构成的数组 虽然只表示数据类型，但是在声明时，会默认表示为变量var，用户可以显式声明其类型####### var logic [63:0] addr;&nbsp; &nbsp; // 64位宽的变量类型 ####### wire logic [63:0] data;&nbsp; &nbsp; // 64位宽的线网类型 二值逻辑 bit帮助更高级抽象的建模，比如，事务级模型####### bit ： 1位二值逻辑变量 构成的vector是无符号类型 ####### byte ： 8位二值逻辑，类似于C语言中的char ####### shortint ： 16位，类似short ####### int : 32位，类似int ####### longint : 64位，类似longlong bit类型默认也是变量类型，除了bit的其他二值逻辑类型的verctor，默认都是有符号类型 可以使用unsighed表示无符号类型， 比如 byte unsigned####### 表示的范围从[-128, 127]， 变为了[0, 255] 自定义类型优势可以用更少的代码表示更多的功能代码可读性更好通过typedef创建用户自定义类型通过enum创建枚举通过struct创建结构体类型Verilog无法使用户扩展变量和线网类型SV提供的自定义类型使用户构建更高层次抽象的数据类型比如： typedef int unsigned uint;&nbsp; uint a, b;一般对自定义类型加个_t后缀enum枚举每个值都要一个用户自定义的名字，比如枚举类型RGBenum {red, green, blue} RGB;Verilog没有枚举，为了提供描述变量的范围，使用参数来表示可取值的范围，或者宏定义定义各个合法值的名称定义枚举值默认为int，32位二值逻辑但是，SV也允许指明数据类型，比如： enum bit {TRUE, FALSE} Boolean;&nbsp; enum logic [1:0] {WAITE, LOAD, READY} state;如果枚举类型被赋值，那么所赋值应该在其数据范围内&nbsp; &nbsp;enum logic [2:0] {WAITE = 3’b001, Load = 3’b010, READY = 3’b100} state;如果枚举变量是四值逻辑，那么赋值为X或者Z也是合法的&nbsp; &nbsp;enum logic {ON=1’b1, OFF=1’bz} out;自定义枚举类型如果枚举类型没有伴随typedef，那么该枚举类型是个匿名枚举类型将它typedef为自定义类型，就可以用同一个枚举类型来声明多个变量或者线网&nbsp; &nbsp; typedef enum {WAITE, LOAD, READY} state_t;&nbsp; &nbsp;state_t state next_state;枚举类型赋值赋值要求很严格，=两端必须是相同的枚举类型；int foo; states_t state; foo = state + 1; // 可以&nbsp; &nbsp; state = foo +1; // 不可以&nbsp; state = states_t’(foo+1); // 可以 state++; //不可以 state= state + 1; //不可以 state = states_t’(state+1);&nbsp; // 可以 struct 结构体优势经常遇到数据表示逻辑相关的数据信号组，比如总线协议的所有控制信号，或者在状态控制器中用到的所有信号，verilog不方便SV的结构体，成员可以是任意变量类型，包括自定义和其他常量类型struct {&nbsp; int a,b; &nbsp; opcode_t opcode; &nbsp; logic [23:0] address; &nbsp; bit error; } Instruction_Word; 结构体是变量的合集，所以结构体的变量一可以索引到其内部，用.符号，和C一样Instruction_Word.address = 32’hF000001E; 结构体类型默认为变量类型，用户也可以显式声明为var或者wire结构体也可以typedef为自定义类型，然后使用typedef struct { &nbsp; …; &nbsp; …; } instruction_word_t; instruction_word_t IM; 可以通过索引到成员，依次赋值也可以通过分号’和花括号{}实现整体赋值IW = ‘{100, 3, 8’hFF, 0};IW = ‘{address:0, opcode:8’hFF, a:100, b:5}; 字符串类型优势Verilog没有string，SV引入string容纳可变长度的字符串string类型的存储单元为byte类型，即char在string变量长度为N时，索引是0到N-1和C的差别字符串结尾没有\\0内存动态分配，用户不需要担心内存管理使用typedef logic [15:0] r_t;r_t r; integer i = 1; string b = “”; string a = {“Hi”, b}; r = r_t’(a); b = string’(r); b = “Hi”; b = {5{“Hi”}}; a = {i{“Hi”}};&nbsp; &nbsp; //可以，非常量复制 a = {a, b}; a = {“Hi”, b}; b = {“Hi”, “”}; a[0] = “h”; 内置函数str.len()&nbsp; &nbsp;返回string的长度str.putc(i, c)&nbsp; &nbsp; 将第i个字符替换为字符c，等同于 str[i] = cstr.getc(i)&nbsp; &nbsp; 返回第i个字符str.substr(i, j)&nbsp; &nbsp; 返回第i个字符到第j个字符另外，SV有其他的系统函数####### $sformatf()&nbsp; &nbsp;用来生成一个格式化的字符串 ####### $display()&nbsp; &nbsp; 打印输出 接口优势Verilog通过模块之间的端口连接，进行模块间的通信，但是大型设计，端口连接很容易出错，所以，SV扩展了接口interface接口提供了面向抽象级建模的方式可以简化建模和验证大型复杂的设计尤其是标准总线端口，Verilog需要在多个模块重复声明，通信协议也是多次定义，变更之后的更改也很麻烦接口允许多个信号被整合到一起，用于表示单一的抽象端口多个模块可以使用同一个接口，避免分散端口信号连接内容interface main_bus;&nbsp; &nbsp;…; &nbsp; &nbsp;…; endinterface main_bus bus();&nbsp; &nbsp;// 接口实例 接口不止可以包含 变量或者线网，还可以封装模块之间通信的协议还可以嵌入与协议有关的断言检查、功能覆盖率收集等模块接口不同于模块的地方在于，接口不允许包含设计层次，即接口无法例化模块，但是接口可以例化接口可以在接口的声明modport，来约束不同模块连接时信号灯方向声明接口定义和模块定义类似也可以有端口，例如外部接入的时钟或者复位信号；interface main_bus (input logic clock, resetN, test_mode); 例化接口的例化方式和模块的例化方式一致模块的端口如果声明为input、output、inout，那么在例化时可以不连接模块的端口如果声明为interface，那么在例化时必须连接到一个接口的实例，或者另一个接口端口如果一个模块拥有一个接口类型的端口，那么索引这个接口中的信号，需要通过.操作符，bus.resetN modport接口的线网信号或者变量，对于连接到这个接口的不同模块可能有不同的连接方向，所以引入modport表示不同模块看到同一组信号时的视角方向在接口中声明modport，需要指名modport中各个信号灯方向当一个模块在例化时，可以选择连接到interface端口中具体的某一个modport这种方式可以降低连接方向错误的可能，避免信号多驱动的情况interface chip_bus(…);modport master(...); modport slave(…); endinterface module primary(interface pins); //通用接口端口 … endmodule module secondary (chip_bus pins);&nbsp; &nbsp;// 特定接口端口 … endmodule module chip (…); &nbsp; &nbsp;chip_bus bus(..);&nbsp; &nbsp; // 接口实例 &nbsp; &nbsp;primary i1 (bus.master);&nbsp; &nbsp; // 使用master modport方式 secondary i2(bus.slave);&nbsp; &nbsp;// 使用slave modport方式 endmodule 应用利用接口，可以将测试平台和DUT连接在一起总结接口对于设计复用很有利接口减少了模块之间错误连接的可能性如果添加了新的信号，只需要在接口中声明，不需要在每个模块中声明由于接口可以将有关信号都集合在一起，可以在使用这些信号时，需要添加接口实例名一种接口往往将有关信号集合在一起，因此，对于拥有多组不相关信号的设计而言，需要多个接口才能完成与其他模块的连接其他注意点：四值逻辑，比如reg、logic、integer，在仿真开始时的初始值为X二值逻辑bit在仿真开始的初值为0如果四值逻辑和二值逻辑发生转换，则把X和Z都转为0二值逻辑也可以实现可综合电路，但是由于没有X、Z，可能出现仿真行为和综合电路的结果不一致的情况SV中还新增了void类型，用于在函数定义时表示无返回值，同CSV中添加了shortreal表示32位单精度浮点数，同float；而verilog中的real表示双精度浮点型，同double","link":"/IC%E9%AA%8C%E8%AF%81/%E8%B7%AF%E7%A7%91V0/%E8%B7%AF%E7%A7%91v0sv%E5%92%8Cverilog%E7%9A%84%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93/"},{"title":"路科V0SVP10P12验证环境","text":"验证环境结构 测试平台testbench是整个验证系统的总称； 包括验证结构中的各个组件、组件之间的连接关系、测试平台的配置和控制 还包括编译仿真的流程、结果分析报告和覆盖率量化等； 主要关注验证平台的结构和组件部分，他们产生设计需要的各种输入，也会在此基础上进行设计功能检查； 各个验证组件相互独立 各个验证组件和设计需要互相连接 各个验证组件也需要进行通信（线程通信方式） 验证环境也需要时钟和复位信号的驱动 设计由多个层次构成，无论是物理分区FPGA/ASIC，还是逻辑分区合成单元/核心子系统； 验证也可以按照不同级别安排目标： 每个验证级别都有最合适的验证目标 较小的模块更容易验证，他们提供了更大的可控性和可观察性； 较小的模块容易设置条件和状态组合，观察反应是否符合预期； 而他们组成的子系统，以较低的可控性和可观察性为代价； 任何层次的待验设计，都应该有稳定的接口和预期功能； 理想情况，每个子系统和模块都要有硬件描述文档； 如果接口和功能变化，则会影响testbench随之变化，会影响项目进度； 对设计稳定性的要求，一般是先接口稳定下来，再功能稳定下来； 硬件设计描述MCDF简介： 遵循硬件设计描述的方式，介绍它的结构、功能、寄存器、和时序； 多通道数据整形器，可以将上行多个通道数据经过内部的FIFO，最终以数据包的形式送出； 上行数据和下行数据的接口协议不同； 多通道数据整形器也有寄存器的读写接口，支持更多的控制功能； MCDF的结构： 通道模块(可以同时接收3路通道的输入数据) slave FIFO 但是由于带宽限制，每个时钟周期只有一路数据可以通过仲裁模块，到达整形器模块！ 寄存器模块 控制通道开关 控制仲裁器的选择 控制整形器打包带长度 获取每个通道的FIFO余量 仲裁模块 整形模块 将指定通道的数据重新打包，以新的总线形式发送出去 MCDF的接口描述： MCDF的接口时序： 如果当前周期的valid和ready同时为高，则表示可以发送数据； 读写寄存器时，需要给地址端口和指令端口对应的值 读取的寄存器数值将在下一个时钟周期由寄存器模块输出 当整形器要发送某一个通道的数据时，会拉高req信号，同时也更新chid和长度length信息，等待下行模块接收信号grant为高，其下个周期req应该拉低，同时，start拉高，这时候发送第一个有效数据，发送数据应该连续，发送这段数据的最后一个时，end拉高，start和end的间隔内，data发送完毕！ MCDF的寄存器描述： MCDF mini版结构移除了寄存器模块和整流模块！ 功能变成了由多个通道输入，然后仲裁器选择一个通道进行输出。。 验证环境组件激励发生器 stimulator（激励发生器）：也称为驱动器driver、总线功能模型BFS、行为模型behavioral 或者 发生器generator。 stimulator的主要职责是模拟与DUT相邻设计的接口协议，只需要关注如何模拟接口信号，使它能够以真实接口协议发送激励给DUT 激励器组件结构 按照stimulator和DUT的连接关系，激励发生器分为两种：initiator发起器 和 responder响应器 由于channel从端口协议上有握手信号，所以需要遵照接口时序，当chx_ready为低时，保证chx_data和chx_valid保持不变。 channel initiator 组件： 监测器 monitor（监测器）：主要功能是用来观察DUT的边界或者内部信号，并且经过打包整理传送给其他验证平台的组件，比如checker比较器。 安装监测信号灯层次划分monitor的功能，分为观测DUT边界信号和观测DUT内部信号。 监测器的组件结构 另外一些要求和建议： 比较器 checker（比较器）：投入时间最多的组件，肩负了模拟设计行为和功能检查的任务，而且缓存各个monitor收集到的数据； 将DUT输入接口侧的数据汇集给内置的reference model，reference model扮演了模拟硬件功能的角色。 checker将实际收集到的DUT输出数据和reference model产生的数据进行对比； 对于内部设计的关键功能模块，应该有相应的线程进行独立的检查； 检查过程中，可以将检查成功的信息统一纳入检查报告中，便于仿真后的追溯，如果检查失败，也可以暂停仿真同时报告错误，在线调试。 线上比较：在仿真时收集数据，在线比较，并实时报告。 线下比较：仿真时收集的数据记录在文件中，仿真结束后，通过脚本或者其他手段，进行数据比较。 比较器组件结构 比较器实现的建议","link":"/IC%E9%AA%8C%E8%AF%81/%E8%B7%AF%E7%A7%91V0/%E8%B7%AF%E7%A7%91v0svp10p12%E9%AA%8C%E8%AF%81%E7%8E%AF%E5%A2%83/"},{"title":"野火RT1052开发板1创建环境","text":"野火RT1052开发板1 – NXP MCU-Link Pro + Keil V5 编译环境创建 野火i.MX RT1052 EVK Pro是个很好的学习工具，野火不仅做了汉化，另外，把所有的Pin脚都做了引出，虽然是个老产品，但是一通百通所以这个系列准备使用野火的板子来入门，具体要更几篇待定…，但是尽量每一篇都有真东西，这是第一篇：使用NXP MCU-Link Pro + Keil V5，创建编译环境运行第一个demo。 芯片Part Number： 196pin 的工业级的 MIMXRT1052CVL5B 安装Keil V5 参考这个视频： https://www.bilibili.com/video/av544829324/?vd_source=e742ab928a70238934780b04b84d177d 安装芯片包 KEIL5 需要自己安装对应芯片的芯片包。直接去 keil 的官网下载：http://www.keil.com/dd2/pack/ 下载之后双击安装即可！ 更换编译器Keil的新版本不再提供ARM Compiler V5，因此需要自己下载，去百度这个关键词：**ARMCompiler_506_Windows_x86_b960.zip** 找到的就是最后一个V5编译器，下载并安装。 安装地址推荐：**C:\\Keil_v5\\ARM\\ARMCC** (新建一个ARMCC文件夹，安装到这个文件夹) 然后，需要在project中手动增加这个编译器： Add another Arm Compiler Version to List： 在项目中改为这个编译器： 更换Flash下载算法i.MX RT 系列芯片内部不具备 FLASH 存储器，即其程序代码需要存储在外部的存储器中，使用时需要自己提供对应 FLASH 的下载算法给 KEIL 软件，野火 i.MX RT1052 系 列开发板使用 32MB 的 SPI-NorFlash 芯片存储程序。野火提供了自己的Flash下载算法，有两个版本，寄存器版本和库函数版本： iMXRT1052_W25Q256JV_CFG_By_Fire.FLM(寄存器版本工程使用) Embedfire_RT1052_QSPI_R1.FLM（库函数版本工程使用） 需要把这两个文件复制到Keil的安装目录下：**C:\\Keil_v5\\ARM\\Flash** ====&gt; 到此为止，编译所需的软件基本整理完毕！== 硬件连接先把载板丢一边，看看这个核心板，核心板有一个供电口，一个SWD debug口，还有一个三线的UART接口。 原装的DAP下载器不见了，刚好试试NXP更为强大的MCU-Link Pro ! 小试牛刀！ MCU-Link ProMCU-Link Pro的官方主页在这：MCU-Link Pro硬件调试器 | NXP 半导体 支持很多NXP产品的调试，而且可以方便的烧录CMSIS-DAP和JLink的固件，虽然贵点，但是相当于一颗更比两颗强，值了！ 看一下这里对它的总体介绍： MCU-Link Pro基于恩智浦的MCU-Link架构，可以在MCU-Link低成本硬件调试器和板载评估板中找到，所有这些版本都运行相同的固件。 除了基本MCU-Link中的SWD调试、SWO分析和USB到UART桥接功能(VCOM)之外，MCU-LinkPro型号还增加了J-Link LITE固件选项、能量测量、模拟信号监视器、USB转SPI和I2C桥接功能，以及外设仿真的板载LPC804。 MCU-Link Pro基于Arm® Cortex-M33®双核LPC55S69微控制器，并具有高速USB接口，提供低成本、高性能的调试。 在这个用法中，我们主要用到J7连接板子，J19中的UART信号接出来到板子上：RX &lt;—&gt; TX TX &lt;—&gt; RX JTAG接口转接由于配备的cable是个小口，还需要一个小转大的转接板，因此，需要找个20PinJTAG口的定义，查阅这个链接：JTAG各类接口针脚定义、含义以及SWD接线方式_jtag接口定义_学海无涯_come on的博客-CSDN博客 注意，方形焊盘都是1号Pin脚； ==—》至此，硬件连接部分搞定！== 跑Demo！先展示一下硬件连接 注意： 一定要先给板子上电，再给debugger上电，不然有可能通信失败！ 运行自带的验证程序 1052-H1核心板测试代码\\1052-H1测试程序 先编译看看： 🆗！ 再烧录进来： 看看使用VCOM的串口输出： 完美运行按键检测的demo~ 后续可以看一下按键中断是如何实现的，以及，继续看一下RT库开发手册！ — 2023/11/30","link":"/NXP/RT1050/%E9%87%8E%E7%81%AB/%E9%87%8E%E7%81%ABrt1052%E5%BC%80%E5%8F%91%E6%9D%BF1%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83/"},{"title":"链表01--移除链表元素","text":"203 Remove Linked List Elements Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head. 示例1： 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5] 示例2： 输入：head = [], val = 1 输出：[] 示例3： 输入：head = [7,7,7,7], val = 7 输出：[] 思路 然后，对于C、CPP，要注意从内存中删除不要的节点，清理内存之后： 上面的移除操作，就是让节点next指针直接指向下下一个节点。 那么因为单链表的特殊性，只能指向下一个节点，刚刚删除的是链表的中第二个，和第四个节点，那么如果删除的是头结点又该怎么办呢？ 这里就涉及如下链表操作的两种方式： 直接使用原来的链表来进行删除操作。 设置一个虚拟头结点在进行删除操作。 直接使用原来的链表来进行移除如果要移除非头节点，需要next指针指向下一个节点，但是，当需要移除头节点时，因为没有更前面的节点，所以操作发生了变化！ 移除头节点的操作，只需要head后移一位； 但是会导致代码逻辑更复杂！ 设置一个虚拟头结点在进行删除操作设置一个虚拟头结点，原链表的所有节点就都可以按照统一的方式进行移除了。 来看看如何设置一个虚拟头。依然还是在这个链表中，移除元素1。 最后，return头结点的时候，别忘了 return dummyNode-&gt;next;， 这才是新的头结点。 Solution使用原来的链表123456789101112131415161718192021222324class Solution {public: ListNode* removeElements(ListNode* head, int val) { // 删除头结点 while (head != NULL &amp;&amp; head-&gt;val == val) { // 注意这里不是if ListNode* tmp = head; head = head-&gt;next; delete tmp; } // 删除非头结点 ListNode* cur = head; while (cur != NULL &amp;&amp; cur-&gt;next!= NULL) { if (cur-&gt;next-&gt;val == val) { ListNode* tmp = cur-&gt;next; cur-&gt;next = cur-&gt;next-&gt;next; delete tmp; } else { cur = cur-&gt;next; } } return head; }}; 设置虚拟头节点1234567891011121314151617181920class Solution {public: ListNode* removeElements(ListNode* head, int val) { ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点 dummyHead-&gt;next = head; // 将虚拟头结点指向head，这样方面后面做删除操作 ListNode* cur = dummyHead; while (cur-&gt;next != NULL) { if(cur-&gt;next-&gt;val == val) { ListNode* tmp = cur-&gt;next; cur-&gt;next = cur-&gt;next-&gt;next; delete tmp; } else { cur = cur-&gt;next; } } head = dummyHead-&gt;next; delete dummyHead; return head; }}; 再来个C语言版本比较一下： 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */struct ListNode* removeElements(struct ListNode* head, int val){ typedef struct ListNode ListNode; ListNode *shead; shead = (ListNode *)malloc(sizeof(ListNode)); shead-&gt;next = head; ListNode *cur = shead; while(cur-&gt;next != NULL){ if (cur-&gt;next-&gt;val == val){ ListNode *tmp = cur-&gt;next; cur-&gt;next = cur-&gt;next-&gt;next; free(tmp); } else{ cur = cur-&gt;next; } } head = shead-&gt;next; free(shead); return head;}","link":"/Leetcode/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A801-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/"},{"title":"链表00--链表理论基础","text":"链表理论基础 链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。 链接的入口节点称为链表的头结点也就是head。 如图所示： 链表的几种类型单链表 如上文所示，就是单链表。 双链表 单链表中的指针域只能指向节点的下一个节点。 双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。 双链表既可以向前查询也可以向后查询。 如图所示： 循环链表循环链表，顾名思义，就是链表首尾相连。 循环链表可以用来解决约瑟夫环问题。 链表的存储方式 数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。 链表是通过指针域的指针链接在内存中各个节点。 所以链表中的节点在内存中不是连续分布的，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。 链表的定义链表节点的定义，很多同学在面试的时候都写不好。这是因为平时在刷leetcode的时候，链表的节点都默认定义好了，直接用就行了，所以同学们都没有注意到链表的节点是如何定义的。 而在面试的时候，一旦要自己手写链表，就写的错漏百出。 给出C/C++的定义链表节点方式，如下所示： 123456// 单链表struct ListNode { int val; // 节点上存储的元素 ListNode *next; // 指向下一个节点的指针 ListNode(int x) : val(x), next(NULL) {} // 节点的构造函数}; 不定义构造函数行不行? —&gt; 答案是可以的，C++默认生成一个构造函数。 但是这个构造函数不会初始化任何成员变量，下面举两个例子： 通过自己定义构造函数初始化节点： 1ListNode* head = new ListNode(5); 使用默认构造函数初始化节点： 12ListNode* head = new ListNode();head-&gt;val = 5; 所以如果不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值！ 链表的操作删除节点删除D节点，如图所示： 只要将C节点的next指针，指向E节点就可以了。 那么，D节点不是依然存留在内存里么？只不过是没有在这个链表里而已。 是这样的，在C++里最好是再手动释放这个D节点，释放这块内存。其他语言例如Java、Python，就有自己的内存回收机制，就不用自己手动释放了。 添加节点 链表的增添和删除都是O(1)操作，也不会影响到其他节点。 但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作， 查找的时间复杂度是O(n)。 性能分析链表和数组的特性对比： 另： python的链表： 1234class ListNode: def __init__(self, val, next=None): self.val = val self.next = next","link":"/Leetcode/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A800-%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"},{"title":"Icarus User Guide - CDN Providers","text":"Choosing the right CDN providers can significantly reduce the page loading time of your viewers. Icarus lets you pick among several built-in CDN provider options for serving third-party libraries and asset files used by Icarus. This article is also available in 简体中文. The following CDN functionalities are provided by ppoffice/hexo-component-inferno. Please refer to it for a complete list of supported providers and their configuration details. Built-in CDN providersCurrently, Icarus offers the following built-in CDN providers: CDNs for JavaScript Libraries cdnjs.com (cdnjs) jsDelivr (jsdelivr) UNPKG (unpkg) loli.net (loli) CDNs for Web Fonts Google Fonts (google) loli.net (loli) font.im (fontim) ustc.edu.cn (ustc) FontAwesome Font Icon CDNs FontAwesome 5 (fontawesome) loli.net (loli) The default CDN settings are: _config.icarus.yml1234providers: cdn: jsdelivr fontcdn: google iconcdn: fontawesome Custom CDN providersAdditionally, you can also custom CDN providers via URL templates. The template formats for each type of CDN provider are listed below: CDNs for JavaScript LibrariesCDN URL Template1https://some.cdn.domain.name/${package}/${version}/${filename} You need to replace the actual package name, version of the package, and relative file path with ${package}, ${version}, and ${filename} placeholders. For example, a JavaScript library with the following URL: UNPKG CDN URL Example1https://unpkg.com/d3@5.7.0/dist/d3.min.js can be generalized to this: UNPKG CDN URL Template1https://unpkg.com/${package}@${version}/${filename} Some CDN providers may adopt different URL schemes. For example, the moment.js library has the URL like this on CDN.js: CDN.js CDN URL Example1https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment.js while has the following URL on UNPKG: UNPKG CDN URL Example1https://unpkg.com/moment@2.22.2/min/moment.min.js Therefore, you should be aware of the URL format of your custom CDN provider. By default, Icarus will try to pass in the parameter using npm package name and relative file path (e.g., moment@2.22.2/min/moment.min.js). This npm scheme is used by jsDelivr and UNPKG. Otherwise, if you are using a CDN.js like provider, please prepend [cdnjs] to its URL template: CDN.js-style URL Template1[cdnjs]https://some.cdn.domain.name/${package}/${version}/${filename} CDNs for Web FontsYou can pass in the URL of a Google Font mirror or compatible webfont CDN. Icarus depends on the Ubuntu, Oxanium, and Source Code Pro fonts, so make sure your CDN provides those. The URL template should have two placeholders for font type (icon or font) and fontname: Webfont CDN URL Template1https://some.google.font.mirror/${type}?family=${fontname} FontAwesome Font Icon CDNsYou can pass in the URL to a custom FontAwesome CDN. No placeholders are required. The provided custom CDN should at lease have FontAwesome 5 icons as some of them are used in this theme. Icon Font CDN URL Template1https://custom.fontawesome.mirror/some.stylesheet.css All of the above should be put in the providers section of the theme configurations: _config.icarus.yml1234providers: cdn: 'https://some.cdn.domain.name/${package}/${version}/${filename}' fontcdn: 'https://some.google.font.mirror/${type}?family=${fontname}' iconcdn: 'https://custom.fontawesome.mirror/some.stylesheet.css' CDN helper functionsThree helper functions have been defined to help developers include third-party libraries easily with custom CDN support. You can check them out at ppoffice/hexo-component-inferno. Something wrong with this article? Click here to submit your revision.","link":"/Configuration/icarus-user-guide-cdn-providers/"},{"title":"Icarus User Guide - Comment Plugins","text":"This article covers comment plugins supported by Icarus 5. This article is also available in 简体中文. The following comment plugins are provided by ppoffice/hexo-component-inferno. Please refer to it for a complete list of supported plugins and their configuration details. ChangyanInstallation Guide First, log into Changyan. Get the comment HTML code by following this article. Copy the value of appid and conf to the corresponding settings in the theme configurations. For example, the following HTML code Changyan Installation Code &gt;folded123456789&lt;!--PC版--&gt;&lt;div id=\"SOHUCS\" sid=\"...\"&gt;&lt;/div&gt;&lt;script charset=\"utf-8\" type=\"text/javascript\" src=\"https://cy-cdn.kuaizhan.com/upload/changyan.js\" &gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;window.changyan.api.config({ appid: '????appid????', conf: 'prod_xxxxxxxxxxxxxxxxxxxxxxx'});&lt;/script&gt; maps to the following theme configuration: _config.icarus.yml1234comment: type: changyan app_id: ????appid???? conf: prod_xxxxxxxxxxxxxxxxxxxxxxx Disqus Installation GuidePreview First, log into Disqus. Click the “GET STARTED” button on the front page or visit here and click “I want to install Disqus on my site” to create a new Disqus comment service. On the create new site page, fill in the “Website Name” and “Category”, then click the “Create Site” button. Select a subscription plan if you want to. You can also skip this by clicking “Install Disqus” on the left. Next, choose the platform where Disqus is to be installed. Select the “I don’t see my platform listed, install manually with Universal Code” on the bottom of the page. Click the “Configuration” button on the bottom of the page to skip the “Universal Code install instructions”. Make customizations to your Disqus service on the “Configure Disqus” page. Then, click the “Complete Setup” and “Dismiss Setup” buttons to finish the setup. Next, click the “Edit Settings” button on the top right corner of the comment service home page. Find the value of “Shortname” on the “Configure Disqus for Your Site” page, and copy it to the comment settings in the theme configurations. For example, the “Shortname” in the following screenshot is my-hexo-blog-1: which maps to the following theme configuration: _config.icarus.yml123comment: type: disqus shortname: my-hexo-blog-1 (Optional) You can add disqusId in the front-matter of the post as the unique Disqus ID. Thereby, you can change the location of the post in the future without losing all your comments: source/_post/some-post.md12345title: My first postdate: 2015-01-01 00:00:01disqusId: some-disqus-id---# Hello world DisqusJSDisqusJS is an alternative for Disqus in areas where Disqus is restricted. You can refer to https://github.com/SukkaW/DisqusJS for the detailed configuration process of DisqusJS. Installation GuidePreview Log into Disqus and visit here. Click the “Register new application” button or “registering an application” to create a new Disqus application. Fill in the “Label”, “Description”, and “Website” on the next page. Then, click “Register my application”. After creating the application, go to the “Settings” tab of the application, fill in the domain name of your Hexo site, e.g., ppoffice.github.io, in the “Domains” field. Then, click the “Save Changes” button on the bottom of the page. Click the “Details” link on the current page to go to the home page of the current application. Copy the “API Key” in the “OAuth Settings” section to the corresponding setting in the theme configurations. For example, the “API Key” in the following screenshot: maps to the following theme configuration: _config.icarus.yml12345678comment: type: disqusjs shortname: my-hexo-blog-1 api_key: xxxxxxxxxxxxxxxxxxxxxxxxxxxxx api: https://disqus.skk.moe/disqus/ # Optional admin: ppoffice # Optional admin_label: Admin # Optional nesting: 4 # Optional To learn more about DisqusJS and its configuration, visit SukkaW/DisqusJS documentation or hexo-component-inferno. Facebook Some AD blockers may block this comment plugin. Use it with caution. Installation GuidePreview To enable Facebook comment, set the type of comment to facebook: _config.icarus.yml12comment: type: facebook GiscusA comments system powered by GitHub Discussions. Installation GuidePreview Prepare a public GitHub repository. Go to GitHub Apps - giscus and click “Install”. (Optional) Select the user to install giscus to on the next page if you also have organizations under your account. On the next page, you can choose to install giscus to “All repositories” or “Only select repositories”. Then, click the “Install” button. You will be redirected to the giscus official site if the installation completes. You can review each configuration option and customize your giscus setup. When finished, move to the “Enable giscus” and copy the attribute values from the giscus HTML code to the corresponding settings in your theme configurations. For example, the giscus code below: giscus Installation Code &gt;folded12345678910111213141516&lt;script src=\"https://giscus.app/client.js\" data-repo=\"usr/repo\" data-repo-id=\"X_xxxxxxxxxx\" data-category=\"Announcements\" data-category-id=\"XXX_xxxxxxxxxxxxxxxx\" data-mapping=\"pathname\" data-strict=\"0\" data-reactions-enabled=\"0\" data-emit-metadata=\"0\" data-input-position=\"top\" data-theme=\"noborder_light\" data-lang=\"en\" data-loading=\"lazy\" crossorigin=\"anonymous\" async&gt;&lt;/script&gt; maps to the following theme configuration: _config.icarus.yml123456789101112131415161718192021comment: type: giscus repo: Your-GitHub-Username/Your-Public-Repo-Name issue_term: pathname # Required if issue_number is not set issue_number: 100 # Required if issue_term is not set. Every post can be mapped to a separate, manually-created GitHub issue. label: some-issue-label # Optional theme: github-light # Optionalcomment: type: giscus repo: usr/repo # Required repoId: X_xxxxxxxxxx # Required category: Announcements # Optional, default: Announcements categoryId: XXX_xxxxxxxxxxxxxxxx # Required mapping: pathname # Optional, default: pathname strict: false # Optional reactionsEnabled: false # Optional emitMetadata: false # Optional inputPosition: top # Optional, default: top theme: noborder_light # Optional lang: en # Optional, default: en lazy: true # Optional, default: false Gitalk Installation GuidePreview Log into GitHub and click here to register a new OAuth application. Fill in the “Application name”, “Homepage URL”, and “Application description”. Then, type in the root URL of your Hexo site in the “Authorization callback URL” field. Click the “Register application” button to go to the application details page. Copy the values of “Client ID” and “Client Secret” to the corresponding settings in the theme configurations. For example, the following “Client ID” and “Client Secret”: GitHub OAuth Application1234Client IDxxxxxxxxxxxxxxxxxxxxClient Secretxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx maps the following Gitalk configuration: _config.icarus.yml12345678910111213141516comment: type: gitalk client_id: xxxxxxxxxxxxxxxxxxxx client_secret: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx repo: Some-of-Your-GitHub-Repo owner: you_github_name admin: - you_github_name per_page: 20 # Optional distraction_free_mode: false # Optional pager_direction: last # Optional create_issue_manually: false # Optional proxy: # Optional flip_move_options: # Optional enable_hotkey: true # Optional language: zh-CN # Optional You can review the description and possible values of the above configuration at Gitalk documentation or hexo-component-inferno. Gitment The maintenance of Gitment seems to be discontinued. You can choose Gitalk or utterances as an alternative GitHub Issue-based comment system. Installation Guide Follow the steps in the Gitalk section to register a GitHub OAuth application. Copy the values of “Client ID” and “Client Secret” to the corresponding settings in the theme configurations. Here is an example of the Gitment configuration: _config.icarus.yml123456789comment: type: gitment owner: you_github_name repo: Some-of-Your-GitHub-Repo client_id: xxxxxxxxxxxxxxxxxxxx client_secret: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx theme: gitment.defaultTheme # Optional per_page: 20 # Optional max_comment_height: 250 # Optional For more details on the above configuration, refer to Gitment documentation or hexo-component-inferno. IssoIsso is a valid choice if you wish to set up a self-hosted social comment system instead of relying on third-party ones. However, unlike the other services, Isso requires a web host for running the Isso server. Installation Guide Follow the Isso documentation to install and run the Isso server. Fill in the HTTP URL of Isso server to the corresponding setting in the theme configurations. For example, if your service URL is https://posativ.org/isso/api/, you will have the following comment configuration: _config.icarus.yml123comment: type: isso url: posativ.org/isso/api LiveRe Some AD blockers may block this comment plugin. Use it with caution. Installation Guide First, log into LiveRe. Click “Install” on the navigation bar to go to the installation page. Select the free “City” tier on the installation page and click the “Install Now” button. Fill in the “Site URL”, “Name of website”, and “Choose site category” on the “Get LiveRe City code” page. Check “I have check the advertising terms…” and click the “Get code” button to be redirected to the LiveRe HTML code page. Copy the value inside the quotes of data-uid=\"...\" to the corresponding setting in the theme configurations. For example, the LiveRe code below: LiveRe Installation Code &gt;folded123456789101112131415161718&lt;!-- LiveRe City install code --&gt;&lt;div id=\"lv-container\" data-id=\"city\" data-uid=\"ABCD1234O0OxxxxXXXX000==\"&gt; &lt;script type=\"text/javascript\"&gt; (function(d, s) { var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === 'function') { return; } j = d.createElement(s); j.src = 'https://cdn-city.livere.com/js/embed.dist.js'; j.async = true; e.parentNode.insertBefore(j, e); })(document, 'script'); &lt;/script&gt;&lt;noscript&gt; Please activate JavaScript for write a comment in LiveRe&lt;/noscript&gt;&lt;/div&gt;&lt;!-- completed City install code --&gt; maps to the following theme configuration: _config.icarus.yml123comment: type: livere uid: ABCD1234O0OxxxxXXXX000== TwikooTwikoo is a self-hosted comment system based on cloud functions. Unlike other third-party comment services, the Twikoo backend needs to be deployed to a cloud environment before being configured and used by Icarus. Installation GuidePreview Follow the Twikoo documentation to deploy the Twikoo cloud function to a cloud service provider of your choice. Fill in the env_id of your deployment to the corresponding setting in the theme configurations. _config.icarus.yml12345comment: type: twikoo env_id: xxxxxxxx region: ap-guangzhou # Optional lang: zh-CN # Optional utterances Installation GuidePreview Prepare a public GitHub repository. Go to GitHub Apps - utterances and click “Install”. (Optional) Select the user to install utterances to on the next page if you also have organizations under your account. On the next page, you can choose to install utterances to “All repositories” or “Only select repositories”. Then, click the “Install” button. You will be redirected to the utterances official site if the installation completes. You can review each configuration option and customize your utterances setup. When finished, move to the “Enable utterances” and copy the attribute values from the utterances HTML code to the corresponding settings in your theme configurations. For example, the utterances code below: utterances Installation Code &gt;folded1234567&lt;script src=\"https://utteranc.es/client.js\" repo=\"Your-GitHub-Username/Your-Public-Repo-Name\" issue-term=\"pathname\" theme=\"github-light\" crossorigin=\"anonymous\" async&gt;&lt;/script&gt; maps to the following theme configuration: _config.icarus.yml1234567comment: type: utterances repo: Your-GitHub-Username/Your-Public-Repo-Name issue_term: pathname # Required if issue_number is not set issue_number: 100 # Required if issue_term is not set. Every post can be mapped to a separate, manually-created GitHub issue. label: some-issue-label # Optional theme: github-light # Optional Valine Installation GuidePreview A vulnerability has been found in Valine that the comment service exposes IP addresses of all commenters (xCss/Valine#336). Please use alternative comment services until this issue has been fixed. Create a LeanCloud application following the Quickstart guide. Copy the “App ID” and “App Key” of your LeanCloud application to the corresponding settings in the theme configurations. In addition, you can refer to the Config Reference to find out the details and possible values of the optional settings. Here is an example configuration: _config.icarus.yml123456789101112131415161718comment: type: valine app_id: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx app_key: xxxxxxxxxxxxxxxxxxxxxx placeholder: \"\" # Optional avatar: mm # Optional avatar_force: false # Optional meta: [\"nick\", \"mail\", \"link\"] # Optional page_size: 10 # Optional lang: zh-CN # Optional visitor: false # Optional highlight: true # Optional record_ip: false # Optional server_urls: # Optional emoji_cdn: # Optional emoji_maps: # Optional enable_qq: false # Optional required_fields: [] # Optional Waline Installation GuidePreview Create a LeanCloud application and a Vercel project following the Get Started guide. Copy the “Server URL” of your Vercel project to the corresponding setting in the theme configurations. It is usually something like https://your-domain.vercel.app. In addition, you can refer to the Client Configuration to find out more details and possible values of the optional settings. Here is an example configuration: _config.icarus.yml12345678910111213141516171819202122comment: type: waline server_url: https://your-domain.vercel.app path: window.location.pathname # Optional lang: en-US # Optional locale: # Optional placeholder: 'Comment here...' emoji: # Optional - '//unpkg.com/@waline/emojis@1.0.1/weibo' dark: auto # Optional meta: [\"nick\", \"mail\", \"link\"] # Optional required_meta: [] # Optional login: enable # Optional word_limit: 0 # Optional page_size: 10 # Optional image_uploader: false # Optional highlighter: true # Optional tex_renderer: false # Optional search: false # Optional pageview: false # Optional comment: false # Optional copyright: true # Optional Something wrong with this article? Click here to submit your revision.","link":"/Plugins/Comment/icarus-user-guide-comment-plugins/"},{"title":"Icarus User Guide - Configuring the Theme","text":"Icarus’ default theme configuration file is _config.icarus.yml. It defines the global layout and style settings of the theme and controls external features such as plugins and widgets. This article details the general configurations of the theme. It also explains what configuration files are used and how Icarus generate and validate these configurations. This article is also available in 简体中文. General Theme ConfigurationsConfiguration VersionThis version code is related to and but not always the same as the theme version code. Icarus uses it to determine whether to upgrade the default theme configuration file. You should not change it by yourself. _config.icarus.yml1version: 5.0.0 Theme VariantChoose a skin for Icarus. \"default\" and \"cyberpunk\" are supported values currently. You can take a look at the Cyberpunk variant here. _config.icarus.yml1variant: default LogoSet the logo of your site. It will display on the navigation bar and the footer. The value of the logo can either be the path or URL to your logo image: _config.icarus.yml1logo: /img/logo.svg or text if you set it like the following: _config.icarus.yml12logo: text: My Beautiful Site FaviconYou can specify the path or URL to your site’s favicon in the head section. _config.icarus.yml12head: favicon: /img/favicon.svg Web App ManifestIcarus supports basic PWA manifest.json generation and meta tags. To enable web app manifest, use the following configuration in your theme configuration file. You can also refer to MDN for details on each manifest configuration setting. _config.icarus.yml &gt;folded123456789101112131415161718192021222324252627282930manifest: # Name of the web application (default to the site title) name: Icaurs - Hexo Theme # The displayed name of the web application # when there is not enough space to display full name short_name: Icarus # The start URL of the web application start_url: https://ppoffice.github.io/ # The default theme color for the application theme_color: \"#3273dc\" # A placeholder background color for the application page to display # before its stylesheet is loaded background_color: \"#3273dc\" # The preferred display mode for the website display: standalone # Image files that can serve as application icons for different contexts icons: - # The path to the image file src: icons/touch-icon-iphone.png # A string containing space-separated image dimensions sizes: 144x144 # A hint as to the media type of the image (optional) type: image/png - src: icons/touch-icon-ipad.png sizes: 152x152 - src: icon/logo.ico sizes: 72x72 96x96 128x128 256x256 Open GraphYou can set up Open Graph in the head section. You should leave most of the settings blank in the configuration file. Only set those settings in the front-matter of your post if you need them. Please refer to Hexo documentation for details on each setting. _config.icarus.yml &gt;folded12345678910111213141516171819202122232425262728head: open_graph: # Page title (og:title) (optional) title: # Page type (og:type) (optional) type: blog # Page URL (og:url) (optional) url: # Page cover (og:image) (optional) image: # Site name (og:site_name) (optional) site_name: # Page author (article:author) (optional) author: # Page description (og:description) (optional) description: # Twitter card type (twitter:card) twitter_card: # Twitter ID (twitter:creator) twitter_id: # Twitter Site (twitter:site) twitter_site: # Google+ profile link (deprecated) google_plus: # Facebook admin ID fb_admins: # Facebook App ID fb_app_id: Google Structured DataYou can set up Google Structured Data in the head section. You should leave most of the settings blank in the configuration file. Only set those settings in the front-matter of your post if you need them. Please refer to Search for Developers for details on each setting. _config.icarus.yml &gt;folded12345678910111213141516head: structured_data: # Page title (optional) title: # Page description (optional) description: # Page URL (optional) url: # Page author (article:author) (optional) author: # Page images (optional) image: # The publisher of the article (optional) publisher: # The logo of the publisher (optional) publisher_logo: Page MetadataYou can add custom &lt;meta&gt; tags to the generated HTML from the meta setting in the head section. Each meta tag should appear as an item of the meta array. The value of each meta item should be in the &lt;field_name&gt;=&lt;field_value&gt; format with field_name and field_value represent the field and value of the &lt;meta&gt; tag respectively. Separate the &lt;field_name&gt;=&lt;field_value&gt; pairs with ; if the &lt;meta&gt; tag has multiple fields and values. _config.icarus.yml1234head: meta: - 'name=theme-color;content=#123456' - 'name=generator;content=\"Hexo 4.2.0\"' RSSYou can add a link to your RSS feed at the rss setting in the head section. _config.icarus.yml12head: rss: /path/to/atom.xml Navigation BarThe navbar section defines the menu items and links in the navigation bar. You may put any menu item in the navigation bar by adding &lt;link_name&gt;: &lt;link_url&gt; to the menu setting. To put links on the right side of the navigation bar, add &lt;link_name&gt;: &lt;link_url&gt; to the links setting. _config.icarus.yml1234567891011121314navbar: # Naviagtion menu items menu: Home: / Archives: /archives Categories: /categories Tags: /tags About: /about # Links to be shown on the right of the navigation bar links: GitHub: 'https://github.com' Download on GitHub: icon: fab fa-github url: 'https://github.com/ppoffice/hexo-theme-icarus' You can display a FontAwesome icon instead of text-only link with the following format: Link format123&lt;link_name&gt;: icon: &lt;fontawesome_icon_class_name&gt; url: &lt;link_url&gt; FooterThe footer section defines the links on the right side of the page footer. The link format is exactly the same as links in the navbar section. _config.icarus.yml1234567891011footer: links: Creative Commons: icon: fab fa-creative-commons url: 'https://creativecommons.org/' Attribution 4.0 International: icon: fab fa-creative-commons-by url: 'https://creativecommons.org/licenses/by/4.0/' Download on GitHub: icon: fab fa-github url: 'https://github.com/ppoffice/hexo-theme-icarus' You can also display custom copyright text at the footer section: _config.icarus.yml12footer: copyright: Made with 💖 Code HighlightIf you have enabled code highlighting in Hexo, you can customize the code blocks with highlight settings in the article section. Choose a theme from all themes listed under highlight.js/src/styles. Then, copy the file name (without the .css extension) to the theme setting. To hide the “copy” button of every code block, set clipboard to false. If you wish to fold or unfold all code blocks, set the fold setting to \"folded\" or \"unfolded\". You can also disable the folding feature by leaving the fold setting empty. _config.icarus.yml123456789article: highlight: # Code highlight themes # https://github.com/highlightjs/highlight.js/tree/master/src/styles theme: atom-one-light # Show copy code button clipboard: true # Default folding status of the code blocks. Can be \"\", \"folded\", \"unfolded\" fold: unfolded Additionally, you can fold an individual code block in the Markdown file using the following syntax: 123{% codeblock \"optional file name\" lang:code_language_name &gt;folded %}...code block content...{% endcodeblock %} Cover &amp; ThumbnailYou can add a cover image to your post by adding the cover property in post’s front-matter: post.md1234title: Getting Started with Icaruscover: /gallery/covers/cover.jpg---Post content... Similarly, you may set the thumbnail of your post in the front-matter as well: post.md1234title: Getting Started with Icarusthumbnail: /gallery/covers/thumbnail.jpg---Post content... The thumbnail will show in the archive page as well as in the recent post widget. If you choose to use the image path in the front-matter, you need to ensure the path is absolute or relative to the source directory of your site. For example, to use &lt;your blog&gt;/source/gallery/image.jpg as a thumbnail image, you need to put thumbnail: /gallery/image.jpg in the front-matter. Read TimeYou can show a word counter and the estimated reading time of your article above the article title by setting readtime to true in the article section. _config.icarus.yml12article: readtime: true Update TimeTo show an update time of an article, set updated time in the article’s front-matter: post.md1234title: Getting Started with Icarusupdated: 2020-04-01 00:00:00---Post content... Then, set update_time to true in the article section of your theme configuration file: _config.icarus.yml12article: update_time: true You may also set update_time to false to hide update time for all articles, or auto to hide update time when it is the same as the article publication time. Article LicensingYou can show a section at the end of your posts/pages describing the licensing of your work. Both text and icons are accepted as license links. This configuration is the same as links in the navigation bar or the footer: _config.icarus.yml1234567article: # Article licensing block licenses: Creative Commons: icon: fab fa-creative-commons url: 'https://creativecommons.org/' 'CC BY-NC-SA 4.0': 'https://creativecommons.org/licenses/by-nc-sa/4.0/' SidebarTo make a sidebar fixed when you scroll the page, set the sticky setting of that sidebar to true in the sidebar section. _config.icarus.yml12345sidebar: left: sticky: false right: sticky: true Other ConfigurationsYou can refer to the Icarus User Guide to learn more about third-party plugins, widgets, and CDN provider configurations. Configuration Files and PriorityApart from the default theme configuration file _config.icarus.yml, Icarus also looks at the following locations for alternative configurations: The site configuration file at _config.yml Layout configuration files at _config.post.yml and _config.page.yml Post/page’s front-matter (Deprecated) Legacy theme configuration file at themes/icarus/_config.yml (Deprecated) Legacy layout configuration file at themes/icarus/_config.post.yml and themes/icarus/_config.page.yml Layout Configuration FilesLayout configuration files follow the same format and definitions as theme configuration files. The configurations in _config.post.yml apply to all posts, and those in _config.page.yml apply to all custom pages. They both override configurations in theme configuration files. For example, you can adopt a two-column layout for all posts in _config.post.yml: _config.post.yml12345678910widgets: - type: recent_posts position: left - type: categories position: left - type: tags position: left while keeping a three-column layout in all other pages: _config.icarus.yml12345678910widgets: - type: recent_posts position: left - type: categories position: right - type: tags position: right Post/Page Front-matterIf you wish to override theme configurations only for a certain post/page, you can set them in the front-matter of that post/page. For example, you can change the code block highlight theme of a single post by setting it in that post’s front-matter like the following: source/_post/some-post.md1234567title: My first postdate: '2015-01-01 00:00:01'article: highlight: theme: atom-one-dark---# Some Post The above setting will always override the article.highlight in _config.post.yml and _config.icarus.yml for that post. This layered configuration scheme is handy for differentiating page customizations and optimizations for different audiences. For instance, you can enable faster CDNs or a localized comment service based on the country and language of your page viewers. However, it should be noted that post or page attributes defined by Hexo will not override the theme configurations from the front-matter. Examples are title, date, updated, comments, layout, source, photos, and excerpt. Site Configuration FileAll configuration sources listed above, including theme configuration files, layout configuration files, and post/page front-matter, will override the site configuration file only for configurations used by Icarus. For instance, title in the _config.icarus.yml will override title in the _config.yml, but new_post_name will not since it is not used by Icarus. Also, the theme_config option in the site configuration file will merge with and override theme configurations from theme configuration files. However, using this option is highly discouraged. ConclusionIn conclusion, the scopes of the configuration sources and their priorities are: For a certain post or page Post/Page front-matter overrides all following sources. Layout configuration files override all following sources. theme_config option in the site configuration file overrides all following sources. Theme configuration files override all following sources. The site configuration file. For all posts or pages Layout configuration files override all following sources. theme_config option in the site configuration file overrides all following sources. Theme configuration files override all following sources. The site configuration file. For all posts, pages, and index pages theme_config option in the site configuration file overrides all following sources. Theme configuration files override all following sources. The site configuration file. Configuration Generation and ValidationAll Icarus theme configurations are written in YAML language. Icarus will automatically generate the default configuration file _config.icarus.yml from a set of JSON schemas if it does not exist. That’s why you don’t see an example configuration file (such as _config.yml.example) under the theme directory. Most of the JSON schemas are in the &lt;icarus_directory&gt;/include/schema directory, while the others are in the ppoffice/hexo-component-inferno repository. You can attach the --icarus-dont-generate-config flag to your hexo commands to prevent automatic configuration generation. The theme also validates your configurations against these schemas every time you execute a hexo command. If anything goes wrong during the validation, Icarus will print out the exact location of the misconfiguration and its error type. For example, the following messages tell us that the value of the logo setting should be either a string or an object, instead of an integer. You may skip the validation by appending the --icarus-dont-check-config flag to your hexo commands, but it is not recommended to do so. hexo log1234567891011121314INFO === Checking package dependencies ===INFO === Checking the configuration file ===WARN Configuration file failed one or more checks.WARN Icarus may still run, but you will encounter unexcepted results.WARN Here is some information for you to correct the configuration file.WARN [ { keyword: 'type', dataPath: '.logo', schemaPath: '#/properties/logo/type', params: { type: 'string,object' }, message: 'should be string,object' }] Additionally, Icarus will execute migration scripts to upgrade the default theme configuration file to the newest version if it is not. These scripts are in the &lt;icarus_directory&gt;/include/migration directory. You may disable the upgrade by appending the --icarus-dont-upgrade-config flag to your hexo commands. Finally, Icarus will also check the Node.js package dependencies and remind you to install them if you haven’t. Something wrong with this article? Click here to submit your revision. Vector Landscape Vectors by Vecteezy","link":"/Configuration/icarus-user-guide-configuring-the-theme/"},{"title":"Custom Hexo Tag Helpers","text":"Apart from the tag helpers supported by Hexo natively, as described in Hexo Built-in Tag Helpers, Icarus also offers several other useful tag helpers to customize the display of your content. This article is also available in 简体中文. The following tag helpers are provided by ppoffice/hexo-component-inferno. Please refer to it for a complete list of supported helpers and their configuration details. .example-tab-container { margin: 0 0 20px 0; padding: 10px 20px 20px 20px; border-radius: 6px; box-shadow: 0 0.5em 0.75em -0.125em rgba(10,10,10,0.1), 0 0px 0 1px rgba(10,10,10,0.02); } MessageMessage blocks are a colorful way to emphasize part of text in your post. Its syntax is defined as follows: 123{% message color:&lt;color&gt; size:&lt;size&gt; icon:&lt;icon&gt; title:&lt;title&gt; %} &lt;content&gt;{% endmessage %} colorThe color of message block. It is optional. Available values and their examples are: default A message block when color is not specified. dark A dark message block. primary A primary message block. info A info message block. success A success message block. warning A warning message block. danger A danger message block. sizeThe size of message block. It is optional. Available values and their examples are: small A small message block. default A message block when size is not specified. medium A medium message block. large A large message block. iconThe icon shown in the message block header. It is optional. The value should be valid FontAwesome icon class name. If the icon class name contains space(s), this option and its value should be wrapped with quotes. Message block with a GitHub icon A message with \"icon:fa-brands fa-github\" as icon. Message block with a Node.js icon A message with \"icon:fa-brands fa-node-js\" as icon. Message block with an NPM icon A message with \"icon:fa-brands fa-npm\" as icon. titleTitle of the message block. It is optional. If the title contains space(s), this option and its value should be wrapped with quotes. Message block with title A message block with a title (\"title:Message block with title\"). A message block without a title. A message block without a title. A message block without a title. A message block without a title. A message block without a title. A message block without a title. A message block without a title. TabsThe tabs tag helper is a powerful tool to display parallel content. Only content in the active tab can be displayed to the user at a time. Its syntax is defined as follows: 123456789{% tabs size:&lt;size&gt; align:&lt;align&gt; style:&lt;style&gt; %}&lt;!-- tab id:&lt;tab_id&gt; icon:&lt;icon&gt; title:&lt;tab_title&gt; active --&gt;&lt;content&gt;&lt;!-- endtab --&gt;&lt;!-- tab id:&lt;tab_id&gt; icon:&lt;icon&gt; title:&lt;tab_title&gt; --&gt;&lt;content&gt;&lt;!-- endtab --&gt;...{% endtabs %} Tab ContainerA tab container has the following options: sizeSize of the tabs. It is optional. Available values and their examples are: Tab 1 Tab 2 This is tab 1 of a small tab container. This is tab 2 of a small tab container. Tab 1 Tab 2 This is tab 1 of a tab container when size is not specified. This is tab 2 of a tab container when size is not specified. Tab 1 Tab 2 This is tab 1 of a medium tab container. This is tab 2 of a medium tab container. Tab 1 Tab 2 This is tab 1 of a large tab container. This is tab 2 of a large tab container. alignAlignment of the tab buttons. It is optional. Available values and their examples are: Tab 1 Tab 2 This is tab 1 of a tab container when align is not specified. This is tab 2 of a tab container when align is not specified. Tab 1 Tab 2 This is tab 1 of a centered tab container. This is tab 2 of a centered tab container. Tab 1 Tab 2 This is tab 1 of a right tab container. This is tab 2 of a right tab container. Tab 1 Tab 2 This is tab 1 of a fullwidth tab container. This is tab 2 of a fullwidth tab container. styleStyle of the tab buttons. It is optional. Additionally, you can combine the style with fullwidth alignment. Available values and their examples are: Tab 1 Tab 2 This is tab 1 of a boxed tab container. This is tab 2 of a boxed tab container. Tab 1 Tab 2 This is tab 1 of a toggle tab container. This is tab 2 of a toggle tab container. Tab 1 Tab 2 This is tab 1 of a toggle-rounded tab container. This is tab 2 of a toggle-rounded tab container. Tab 1 Tab 2 This is tab 1 of a fullwidth boxed tab container. This is tab 2 of a fullwidth boxed tab container. Tab 1 Tab 2 This is tab 1 of a fullwidth toggle tab container. This is tab 2 of a fullwidth toggle tab container. Tab 1 Tab 2 This is tab 1 of a fullwidth toggle-rounded tab container. This is tab 2 of a fullwidth toggle-rounded tab container. TabA tab has the following options: idThe unique identifier of the tab element. It is required. An ID of a tab should be unique across the entire page so that Icarus can location the right tab content to show or hide. activeWhether the current tab element is shown. It is optional. Only one tab can be active at a time for a tab group. iconThe icon shown in the tab button. It is optional. The value should be valid FontAwesome icon class name. If the icon class name contains space(s), this option and its value should be wrapped with quotes. GitHub Node.js This tab has an icon of \"icon:fa-brands fa-github\". This tab has an icon of \"icon:fa-brands fa-node-js\". GitHub Node.js This tab has an icon of \"icon:fa-brands fa-github\". This tab has an icon of \"icon:fa-brands fa-node-js\". titleTitle of the tab button. It is required. If the title contains space(s), this option and its value should be wrapped with quotes. Tab with title Tab also with title This tab has a title (\"title:Tab with title\"). This tab also has a title (\"title:Tab also with title\").","link":"/uncategorized/custom-hexo-tag-helpers/"},{"title":"Icarus User Guide - Donation Buttons","text":"This article covers donation button configurations supported by Icarus 5. If you need to display multiple donation buttons at once, add individual button configuration to the donates array like the following: _config.icarus.yml1234567donates: - type: ... # Button 1 ... - type: ... # Button 2 ... This article is also available in 简体中文. The following donation buttons are provided by ppoffice/hexo-component-inferno. Please refer to it for a complete list of supported buttons and their configuration details. Afdian.netInstallation Guide Register for Afdian.net and copy the URL to your personal page. Add the following configuration to your theme configurations: _config.icarus.yml12345donates: - type: afdian # Path to your afdian.net personal page url: /path/to/afdian.net/personal/page AlipayInstallation Guide Log into Alipay and export payment QR code. Save the QR code picture to the asset directory of your Hexo website, or upload it to an image sharing service. Add the following configuration to your theme configurations: _config.icarus.yml12345donates: - type: alipay # Path to your QR code image qrcode: /path/to/alipay/qrcode.png Buy me a CoffeeInstallation Guide Register for Buy me a Coffee and copy the URL to your personal page. Add the following configuration to your theme configurations: _config.icarus.yml12345donates: - type: buymeacoffee # Path to your Buy me a Coffee personal page url: /path/to/buymeacoffee/personal/page PaypalInstallation Guide Log into Paypal, click here to create a Paypal donation button. Select “Country/Region” and “Language” in the “Choose button style” page and click “Continue” to advance to the next page. Select “Use account ID” or “Use email address” as the unique identifier of your account in the “Add organization details” page. Then, click “Continue” to go to the next page. Choose the “Currency you’ll receive donations in” and set “Amount donors can give” to “Any amount” in the “Set donation amounts” page. We currently do not support the option of donating in “An exact amount”. Click “Finish and Get Code” to go to the next page. Copy business and currency_code from the “Button HTML” on the page. Put them to the business and currency_code settings in your theme configurations. For example, the following Paypal donation button code: Paypal HTML code123456&lt;form action=\"https://www.paypal.com/cgi-bin/webscr\" ...&gt;&lt;input type=\"hidden\" name=\"cmd\" value=\"_donations\" /&gt;&lt;input type=\"hidden\" name=\"business\" value=\"XXXXXXXXXXXXX\" /&gt;&lt;input type=\"hidden\" name=\"currency_code\" value=\"USD\" /&gt;...&lt;/form&gt; maps to the following configuration: _config.icarus.yml12345donates: - type: paypal business: XXXXXXXXXXXXX currency_code: USD PatreonInstallation Guide Register for Patreon and copy the URL to your personal page. Add the following configuration to your theme configurations: _config.icarus.yml12345donate: - type: patreon # Path to your Patreon personal page url: /path/to/patreon/personal/page WeChatInstallation Guide Log into WeChat and export payment QR code. Save the QR code picture to the asset directory of your Hexo website, or upload it to an image sharing service. Add the following configuration to your theme configurations: _config.icarus.yml12345donates: - type: wechat # Path to your QR code image qrcode: /path/to/wechat/qrcode.png Something wrong with this article? Click here to submit your revision.","link":"/Plugins/Donation/icarus-user-guide-donation-buttons/"},{"title":"FAQ","text":"The article answers some frequently asked questions about Icarus. If your question is not answered here, you can also refer to Icarus User Guide, Hexo documentation, and GitHub Issues. Additionally, you may find help from other Icarus users on GitHub Discussions. This article is also available in 简体中文. Site I can't generate my site. / I met some errors when I generate my site. Icarus 5 runs on Node.js 12.4.0 or a newer version. It also requires Hexo 6.0.0 or a newer version. Apart from that, make sure you have all the Node.js dependencies installed. You can find them in the dependencies section of the &lt;icarus_directory&gt;/package.json file. Also, remove all unused Node.js dependencies from your site, or they may cause strange problems to Icarus. How do I change the language of my site? Open the site configuration file _config.yml under the root directory. Change the following setting: _config.yml12- language: en+ language: &lt;language_name&gt; You can find all available translations under the &lt;icarus_directory&gt;/languages directory. The &lt;language_name&gt; is the translation file name without the .yml extension. Layout How do I change the page width? How do I use the one/two/three-column layout? To change the page width, edit the style file &lt;icarus_directory&gt;/include/style/responsive.styl. It defines the container width under different screen sizes. To change the width of the widgets or main content, edit &lt;icarus_directory&gt;/layout/common/widgets.jsx and &lt;icarus_directory&gt;/layout/layout.jsx. Find the CSS class names like is-12, is-8-tablet, and is-4-widescreen in these files. The number in the class names marks the number of columns a widget or main content takes. The screen size after the number, such as tablet and widescreen, refers to the condition when the column sizes take effect. Change the number in the class names such that the column count of main column and widget column(s) add up to 12 under the same screen size. For example, to have the main content column wider on widescreen, you can make the following changes: &lt;icarus_directory&gt;/layout/layout.jsx &gt;folded12345678 &lt;div class={classname({ column: true, 'order-2': true, 'column-main': true, 'is-12': columnCount === 1,- 'is-8-tablet is-8-desktop is-8-widescreen': columnCount === 2,+ 'is-8-tablet is-8-desktop is-9-widescreen': columnCount === 2, 'is-8-tablet is-8-desktop is-6-widescreen': columnCount === 3 &lt;icarus_directory&gt;/layout/common/widgets.jsx &gt;folded1234567 function getColumnSizeClass(columnCount) { switch (columnCount) { case 2:- return 'is-4-tablet is-4-desktop is-4-widescreen';+ return 'is-4-tablet is-4-desktop is-3-widescreen'; case 3: return 'is-4-tablet is-4-desktop is-3-widescreen'; You can refer to Bulma documentation for more details on the column system. Here are some tips for creating a one/two/three-column layout: You can remove all widgets from your theme configurations to create a one-column layout. You can move all your widgets to the same side of the page to create a two-column layout. You can place widgets on both sides of the page to create a three-column layout. To change the layout for a single or all posts/pages, refer to Configuration Files and Priority. Where are the layout files for widgets/comments/share...? How do I customize built-in widgets/comments/share...? The layout files for plugins and widgets have been moved to a separate Node.js package called hexo-component-inferno. This help theme developers better reuse common components across different themes and make overriding these components easy for average users. To customize these components, copy the layout files from the hexo-component-inferno repository and place them in the corresponding directories under &lt;icarus_directory&gt;/layout. For example, if you want to customize the Valine comment plugin, you can copy src/view/comment/valine.jsx from the hexo-component-inferno repository to &lt;icarus_directory&gt;/layout/comment/valine.jsx. Also, remember to fix Node.js imports like the following: &lt;icarus_directory&gt;/layout/comment/valine.jsx12- const { cacheComponent } = require('../../util/cache');+ const { cacheComponent } = require('hexo-component-inferno/lib/util/cache'); Finally, hexo clean your site before regenerating the HTML. Similarly, you can override static files like asset/js/insight.js in the same way. Why don't my layout changes take effect when I refresh the page (assuming I am running the hexo server? Icarus caches the layout files when you start the local Hexo server with the hexo server command. To make the layout changes take effect, restart the local server. Other times some intermediate data may be cached by Hexo in the memory or db.json database. Execute hexo clean before running hexo server or hexo generate should resolve this issue. Content My images are not showing up. / My images only show in index pages but not in posts. Make sure you use the absolute paths to your images. For example, your site is in a subdirectory of your domain name like https://ppoffice.github.io/hexo-theme-icarus and your image image.jpg under source/gallery/. You should include your image like this: /hexo-theme-icarus/gallery/image.jpg. You can also use Hexo’s {% img %} tag like the following to include an image automatically: 1{% img /gallery/image.jpg \"Image title\" %} In this case, you may omit the subdirectory from your image path. You can refer to Hexo documentation for more details. How to add an excerpt for a post? How to display the \"Read more\" button? Put a &lt;!-- more --&gt; tag in your post. Post content before this tag will be marked as an excerpt. Content after this tag will not show up on index pages. You can also specify a custom excerpt in the post’s front-matter. some-post.md12345title: Some Postdate: 2020-01-01excerpt: This is an article about ...---# Post content... How do I encrypt my posts? Use third-party Hexo plugins such as hexo-blog-encrypt. How do I use those fancy elements in this article for my posts? Refer to Bulma documentation for all available elements and styles. Copy the HTML snippets and put them in your Markdown files directly. Widgets and Plugins How can I get rid of those red alerts that are showing on the page and warning me of configuration value not set? Those alerts usually show up when you miss out on some plugin or widget configurations. If you don’t want to enable a certain plugin or widget, delete it or comment it out from your theme configurations. For example, you can disable the comment plugins by commenting out the following lines: _config.icarus.yml123456- comment:- type: disqus- shortname: + # comment:+ # type: disqus+ # shortname: Something wrong with this article? Click here to submit your revision. Vector Landscape Vectors by Vecteezy","link":"/uncategorized/faq/"},{"title":"Getting Started with Icarus","text":"Welcome to the Icarus documentation site! Icarus is a simple, delicate, and modern theme for the static site generator Hexo. It strives to be elegant in design while simple and straightforward to use. Its versatile and flexible configuration system enables power users lay out their sites to the finest details. Icarus also offers a wide range of plugins and widgets to meet your various customization and optimization needs. Moreover, its refreshed implementation enables better IDE support and third-party integration, which open to a sea of improvement possibilities. This article is also available in 简体中文. Before you continue to the installation of Icarus, take some time to review the Hexo documentation. To install Icarus, take one of the following approaches: Install from source Install via NPM Download the source code tarball from the GitHub and extract it to your Hexo site’s theme directory. Alternatively, you can use Git to clone the Icarus repository to the themes directory: Git Bash/Shell1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus -b &lt;version number&gt; --depth 1 You can omit -b &lt;version number&gt; to get the latest development version of Icarus. Leave --depth 1 out if you want to download full Git commit history of Icarus as well. Furthermore, you can install Icarus as a Git submodule with the following command: Git Bash/Shell1git submodule add https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus To install Icarus as a node package via NPM, run the following command from the root of your Hexo site: Shell1npm install -S hexo-theme-icarus hexo-renderer-inferno Next, activate Icarus in your site’s _config.yml file: _config.yml1theme: icarus or use the hexo command to change the theme to Icarus: Shell1hexo config theme icarus Finally, use the following command to start the Hexo local server and begin composing! Shell1hexo server To learn more about the theme, widgets, and plugins, check out the Icarus User Guide. You can also refer to the source code of this site for more examples. It is in the site branch of the Icarus repository on GitHub. Additionally, you may find help from other Icarus users on GitHub Discussions. Additional Resources Here are some other resources that you may find useful to further customize your site. You can also submit your Icarus tutorial through this link. Hexo documentation Something wrong with this article? Click here to submit your revision. Vector Landscape Vectors by Vecteezy","link":"/uncategorized/getting-started-with-icarus/"},{"title":"Icarus User Guide - Other Plugins","text":"This article covers other plugins supported by Icarus 5. This article is also available in 简体中文. The following plugins are provided by ppoffice/hexo-component-inferno. Please refer to it for a complete list of supported plugins and their configuration details. GalleryInstallation Guide The gallery plugin of Icarus contains both lightGallery and Justified Gallery extensions. To enable it, set plugins &gt; gallery to true in your theme configurations. _config.icarus.yml12plugins: gallery: true Additionally, in order to use Justified Gallery, wrap your images with the &lt;div class=\"justified-gallery\"&gt; and &lt;/div&gt; HTML tag pair. Also, if you are using Markdown syntax to include images, add additional empty lines between the HTML tags and Markdown tags. For example, the Markdown code of the gallery preview below is Justified-Gallery-Markdown.md &gt;folded12345678910&lt;div class=\"justified-gallery\"&gt;![Elephant](/hexo-theme-icarus/gallery/animals/elephant.jpeg)![Dog](/hexo-theme-icarus/gallery/animals/dog.jpeg)![Birds](/hexo-theme-icarus/gallery/animals/birds.jpeg)![Fox](/hexo-theme-icarus/gallery/animals/fox.jpeg)![Horse](/hexo-theme-icarus/gallery/animals/horse.jpeg)![Leopard](/hexo-theme-icarus/gallery/animals/leopard.jpeg)&lt;/div&gt; Meanwhile, we can use pure HTML to create Justified Galleries as well. In this case, we will not need the empty lines between HTML tags. Justified-Gallery-HTML.md &gt;folded12345678&lt;div class=\"justified-gallery\"&gt;&lt;img src=\"/hexo-theme-icarus/gallery/animals/elephant.jpeg\" alt=\"Elephant\" /&gt;&lt;img src=\"/hexo-theme-icarus/gallery/animals/dog.jpeg\" alt=\"Dog\" /&gt;&lt;img src=\"/hexo-theme-icarus/gallery/animals/birds.jpeg\" alt=\"Birds\" /&gt;&lt;img src=\"/hexo-theme-icarus/gallery/animals/fox.jpeg\" alt=\"Fox\" /&gt;&lt;img src=\"/hexo-theme-icarus/gallery/animals/horse.jpeg\" alt=\"Horse\" /&gt;&lt;img src=\"/hexo-theme-icarus/gallery/animals/leopard.jpeg\" alt=\"Leopard\" /&gt;&lt;/div&gt; Preview Here is an image grid created by Justified Gallery. You can also view the full image using lightGallery by clicking on any image. The following photos come from pexel.com KaTeXInstallation Guide You can use the KaTeX plugin to render \\(\\TeX\\) expressions. To enable KaTeX, please set plugins &gt; katex to true in your theme configurations. _config.icarus.yml12plugins: katex: true Please also use \\\\( and \\\\) to wrap your inline expressions and $$ or \\\\[ and \\\\] pair to wrap block expressions. For example, Some-Post.md &gt;folded123456789This is an inline expression: \\\\(ax^2+bx+c=0\\\\).This is a block expression:$$\\displaystyle \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} = 1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}} {1+\\frac{e^{-8\\pi}} {1+\\cdots} } } }$$This is another block expression:\\\\[f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)e^{2 \\pi i \\xi x}d\\xi\\\\] Sometimes your \\(\\TeX\\) syntax will be mistaken as Markdown syntax, which will result in rendering error. For instance, the following equation will not work since it contains more than one _ (underscores), which are mistaken for the italic text when processed by the Markdown renderer: Some-Post.md123$$\\hat{x}_{k}=\\hat{x}_{k}^{-}+K_{t}\\left(y_{k}\\right)$$ In this case, you can either escape every character that may cause confusion: Some-Post.md123$$\\hat{x}\\_{k}=\\hat{x}\\_{k}^{-}+K\\_{t}\\left(y\\_{k}\\right)$$ or simply wrap the whole equation with an additional pair of HTML tags: Some-Post.md12345&lt;div&gt;$$\\hat{x}_{k}=\\hat{x}_{k}^{-}+K_{t}\\left(y_{k}\\right)$$&lt;/div&gt; MathJaxInstallation Guide You can use MathJax to render \\(\\TeX\\), MathML, or AsciiMath expressions. To enable MathJax, please set plugins &gt; mathjax to true in your theme configurations. _config.icarus.yml12plugins: mathjax: true When using the \\(\\TeX\\) syntax, please use $ or \\\\( and \\\\) to wrap your inline expressions and and $$ or \\\\[ and \\\\] pair to wrap block expressions. You can also use \\(\\LaTeX\\) environments directly. For example, Tex-Example.md &gt;folded123456789101112131415161718This is an inline expression: \\\\(ax^2+bx+c=0\\\\). This is another inline expression: $ax^2+bx+c&gt;0$.This is a block expression:$$\\displaystyle \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} = 1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}} {1+\\frac{e^{-8\\pi}} {1+\\cdots} } } }$$This is another block expression:\\\\[f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)e^{2 \\pi i \\xi x}d\\xi\\\\]Or use \\\\(\\LaTeX\\\\) environment:\\\\begin{equation}A =\\\\begin{bmatrix} a &amp; b \\\\\\\\ c &amp; c\\\\end{bmatrix}\\\\end{equation} Or you can use MathML syntax. For example, MathML-Example.md &gt;folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950When &lt;math xmlns=\"http://www.w3.org/1998/Math/MathML\"&gt; &lt;mi&gt;a&lt;/mi&gt; &lt;mo&gt;≠&lt;/mo&gt; &lt;mn&gt;0&lt;/mn&gt;&lt;/math&gt;, there are two solutions to &lt;math xmlns=\"http://www.w3.org/1998/Math/MathML\"&gt; &lt;mi&gt;a&lt;/mi&gt; &lt;msup&gt; &lt;mi&gt;x&lt;/mi&gt; &lt;mn&gt;2&lt;/mn&gt; &lt;/msup&gt; &lt;mo&gt;+&lt;/mo&gt; &lt;mi&gt;b&lt;/mi&gt; &lt;mi&gt;x&lt;/mi&gt; &lt;mo&gt;+&lt;/mo&gt; &lt;mi&gt;c&lt;/mi&gt; &lt;mo&gt;=&lt;/mo&gt; &lt;mn&gt;0&lt;/mn&gt;&lt;/math&gt; and they are&lt;math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"&gt; &lt;mi&gt;x&lt;/mi&gt; &lt;mo&gt;=&lt;/mo&gt; &lt;mrow&gt; &lt;mfrac&gt; &lt;mrow&gt; &lt;mo&gt;-&lt;/mo&gt; &lt;mi&gt;b&lt;/mi&gt; &lt;mo&gt;±&lt;/mo&gt; &lt;msqrt&gt; &lt;msup&gt; &lt;mi&gt;b&lt;/mi&gt; &lt;mn&gt;2&lt;/mn&gt; &lt;/msup&gt; &lt;mo&gt;-&lt;/mo&gt; &lt;mn&gt;4&lt;/mn&gt; &lt;mi&gt;a&lt;/mi&gt; &lt;mi&gt;c&lt;/mi&gt; &lt;/msqrt&gt; &lt;/mrow&gt; &lt;mrow&gt; &lt;mn&gt;2&lt;/mn&gt; &lt;mi&gt;a&lt;/mi&gt; &lt;/mrow&gt; &lt;/mfrac&gt; &lt;/mrow&gt; &lt;mtext&gt;.&lt;/mtext&gt;&lt;/math&gt; Similarly, you can also use AsciiMath supported by MathJax. Expressions should be wrapped in \\` in this case. AsciiMath-Example.md &gt;folded1When \\`a != 0\\`, there are two solutions to \\`ax^2 + bx + c = 0\\` and they are &lt;p style=\"text-align:center\"&gt;\\`x = (-b +- sqrt(b^2-4ac))/(2a)\\`.&lt;/p&gt; Sometimes your latex syntax will be mistaken as Markdown syntax, which will result in rendering error. Please refer to the KaTeX section for solutions to this. Preview(\\(\\TeX\\) &amp; \\(\\LaTeX\\)) This is an inline expression: \\(ax^2+bx+c=0\\). This is another inline expression: $ax^2+bx+c&gt;0$. This is a block expression: $$\\displaystyle \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} = 1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}} {1+\\frac{e^{-8\\pi}} {1+\\cdots} } } }$$ This is another block expression: \\[f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)e^{2 \\pi i \\xi x}d\\xi\\] Or use \\(\\LaTeX\\) environment: \\begin{equation} A = \\begin{bmatrix} a &amp; b \\\\ c &amp; c \\end{bmatrix} \\end{equation} Preview(MathML) When a ≠ 0 , there are two solutions to a x 2 + b x + c = 0 and they are x = - b ± b 2 - 4 a c 2 a . Preview(AsciiMath) When `a != 0`, there are two solutions to `ax^2 + bx + c = 0` and they are `x = (-b +- sqrt(b^2-4ac))/(2a)`. Cookie ConsentInstallation Guide You can show a cookie consent dialog to your visitor by enabling the Cookie Consent plugin. Please refer to Download Cookie Consent and Documentation for the Cookie Consent plugin for details on each configuration setting. You can also disable the cookie consent dialog by commenting out the configurations. _config.icarus.yml123456789101112plugins: cookie_consent: # The compliance type. Can be \"info\", \"opt-in\", or \"opt-out\" type: info # Theme of the popup. Can be \"block\", \"edgeless\", or \"classic\" theme: edgeless # Whether the popup should stay static regardless of the page scrolls static: false # Where on the screen the consent popup should display position: bottom-left # URL to your site's cookie policy policyLink: 'https://www.cookiesandyou.com/' Outdated BrowserInstallation Guide You can use the Outdated Browser plugin to detect outdated browsers used by your site’s visitors and remind them to upgrade their browsers. To enable it, please set plugins &gt; outdated_browser to true in your theme configurations. Click here to see a live preview of this plugin. _config.icarus.yml12plugins: outdated_browser: true Page Loading AnimationsInstallation Guide Page Loading Animations are enabled by Icarus by default. To disable it, please set plugins &gt; animejs to false in your theme configurations. _config.icarus.yml12plugins: animejs: false Also, to disable the page loading progressbar, please set plugins &gt; progressbar to false in your theme configurations. _config.icarus.yml12plugins: progressbar: false Something wrong with this article? Click here to submit your revision.","link":"/Plugins/Other/icarus-user-guide-other-plugins/"},{"title":"Icarus User Guide - Search Plugin","text":"This article covers search plugin configurations supported by Icarus 5. This article is also available in 简体中文. The following search plugins are provided by ppoffice/hexo-component-inferno. Please refer to it for a complete list of supported plugins and their configuration details. Algolia Installation GuidePreview Install the hexo-algolia plugin under the root directory of your Hexo site. Register and log into Algolia. Click the “Create Index” button on the dashboard when you log in for the first time. Then, enter the name of the index and click the “Create” button to complete index creation. Next, click “API Keys” on the left navigation bar, copy “Application ID” and “Search-Only API Key” on the page. Open site configuration file _config.yml under the root directory of your Hexo site and fill in the above information to the hexo-algolia plugin configurations. For example, the following Aloglia index information: Algolia Index Information123Algolia Index Name: My-Hexo-SiteApplication ID: ABCDEFGHIJKLSearch-Only API Key: 7b08fca7d42412cee901a25643124221 maps to the following plugin configuration: _config.yml1234algolia: applicationID: My-Hexo-Site indexName: ABCDEFGHIJKL apiKey: 7b08fca7d42412cee901a25643124221 Go back to the “API Keys” page from the Algolia dashboard and switch to the “All API Keys” tab. Click the “New API Key” button. On the popup “Create API Key” dialog, select the index you created in the last step in “Indices” select box. Then, add addObject, deleteObject, listIndexes, deleteIndex to the “ACL” field. Click the “Create” button to finish key creation. Copy the API key you just created, e.g., 727fbd8c998fe419318fa350db6793ca. Open a Windows Command Prompt (CMD) or Linux/macOS terminal and change the working directory to the root directory of your Hexo site. Set the HEXO_ALGOLIA_INDEXING_KEY environment variable to the API key you created in the last step. This variable is used by hexo-algolia when uploading indices to Algolia. On Windows: Windows Command Prompt (CMD)12C:\\Users\\you&gt; cd path/to/your/hexo/siteC:\\Users\\you&gt; set HEXO_ALGOLIA_INDEXING_KEY=727fbd8c998fe419318fa350db6793ca On Linux/macOS: Linux/macOS Terminal12$ cd path/to/your/hexo/site$ export HEXO_ALGOLIA_INDEXING_KEY=\"727fbd8c998fe419318fa350db6793ca\" Then, run the following commands to clean up your site and upload indices to Algolia: Windows Command Prompt or Linux/macOS Terminal12$ hexo clean$ hexo algolia Finally, set the search engine to Algolia in your theme configurations: _config.icarus.yml12search: type: algolia Baidu SearchInstallation Guide Open theme configuration file and set search engine to Baidu: _config.icarus.yml12search: type: baidu Google Custom Search Engine (CSE) Installation GuidePreview Log into your Google account and visit Google CSE to create a CSE. Type in the URL of your site (without http:// or https://) in the “Sites to Search” field. Select the correct language from the “Language” select box. Then, fill in the “Name of the search engine”. Click the “Create” button to finish engine creation. Then, click the “Get code” button on the right side of “Add it to your site”. Copy the value of cx to the search settings in your theme’s configurations. For example, the following HTML code: Google CSE HTML code12&lt;script async src=\"https://cse.google.com/cse.js?cx=012345601234560123456:abcdefghijklmn\"&gt;&lt;/script&gt;&lt;div class=\"gcse-search\"&gt;&lt;/div&gt; maps to the following theme configuration: _config.icarus.yml123search: type: google_cse cx: 012345601234560123456:abcdefghijklmn InsightInstallation Guide Insight is the default search engine of this site. You can enable it using the following theme configuration: _config.icarus.yml123search: type: insight include_pages: true # Optional. Set to `false` to exclude pages from search results. Something wrong with this article? Click here to submit your revision.","link":"/Plugins/Search/icarus-user-guide-search-plugin/"},{"title":"Icarus User Guide - Share Buttons","text":"This article covers share buttons supported by Icarus 5. This article is also available in 简体中文. The following share buttons are provided by ppoffice/hexo-component-inferno. Please refer to it for a complete list of supported plugins and their configuration details. AddThis Some AD blockers may block this share button service. Use it with caution. The Baidu share button service is no longer available. Use other services as alternatives. Installation GuidePreview Register for AddThis. Select the “Share Buttons” on the “Select a Tool” page after submitting the registration form. Select the style and buttons on the “Select a Tool Type” page and click “Continue”. Make further customizations on the next page and click the “Activate Tool” button when finished. Find the HTML code from the “Get The Code” page, copy the URL in the src attribute to the share button configuration. For example, the URL in the following AddThis code: AddThis Code12&lt;!-- Go to www.addthis.com/dashboard to customize your tools --&gt;&lt;script type=\"text/javascript\" src=\"//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-xxxxxxxxxxxxx\"&gt;&lt;/script&gt; maps to the following theme configuration: _config.icarus.yml123share: type: addthis install_url: //s7.addthis.com/js/300/addthis_widget.js#pubid=ra-xxxxxxxxxxxxx AddToAny Installation GuidePreview You can activate AddToAny without user registration. Just put the following code to your theme configurations: _config.icarus.yml12share: type: addtoany Take the following steps if you want to customize the share buttons: Visit AddToAny official site and click on the “Get the Share Button”. Then, select “Any Website” and complete the configuration of the buttons. Click “Get Button Code” after you finish. Since the share buttons of Icarus is provided by ppoffice/hexo-component-inferno, you need to copy the layout file (src/view/share/addtoany.jsx) of AddToAny from this repository to &lt;icarus_directory&gt;/layout/share/addtoany.jsx. Then, replace the AddToAny code in addtoany.jsx and fix the package import in the file header. For example, assume the following code is what you get from the last step: AddToAny Code &gt;folded123456789&lt;!-- AddToAny BEGIN --&gt;&lt;div class=\"a2a_kit a2a_kit_size_32 a2a_default_style\"&gt;&lt;a class=\"a2a_dd\" href=\"https://www.addtoany.com/share\"&gt;&lt;/a&gt;&lt;a class=\"a2a_button_facebook\"&gt;&lt;/a&gt;&lt;a class=\"a2a_button_twitter\"&gt;&lt;/a&gt;&lt;a class=\"a2a_button_email\"&gt;&lt;/a&gt;&lt;/div&gt;&lt;script async src=\"https://static.addtoany.com/menu/page.js\"&gt;&lt;/script&gt;&lt;!-- AddToAny END --&gt; then you should make the following changes to addtoany.jsx: &lt;icarus_directory&gt;/layout/share/addtoany.jsx &gt;folded12345678910111213141516171819202122232425262728293031const { Component, Fragment } = require('inferno');- const { cacheComponent } = require('../../util/cache');+ const { cacheComponent } = require('hexo-component-inferno/lib/util/cache');...Some code is skipped here...class AddToAny extends Component { render() { return &lt;Fragment&gt;- &lt;div class=\"a2a_kit a2a_kit_size_32 a2a_default_style\"&gt;- &lt;a class=\"a2a_dd\" href=\"https://www.addtoany.com/share\"&gt;&lt;/a&gt;- &lt;a class=\"a2a_button_facebook\"&gt;&lt;/a&gt;- &lt;a class=\"a2a_button_twitter\"&gt;&lt;/a&gt;- &lt;a class=\"a2a_button_telegram\"&gt;&lt;/a&gt;- &lt;a class=\"a2a_button_whatsapp\"&gt;&lt;/a&gt;- &lt;a class=\"a2a_button_reddit\"&gt;&lt;/a&gt;- &lt;/div&gt;- &lt;script src=\"https://static.addtoany.com/menu/page.js\" defer={true}&gt;&lt;/script&gt;+ &lt;!-- AddToAny HTML code you just got... --&gt;+ &lt;div class=\"a2a_kit a2a_kit_size_32 a2a_default_style\"&gt;+ &lt;a class=\"a2a_dd\" href=\"https://www.addtoany.com/share\"&gt;&lt;/a&gt;+ &lt;a class=\"a2a_button_facebook\"&gt;&lt;/a&gt;+ &lt;a class=\"a2a_button_twitter\"&gt;&lt;/a&gt;+ &lt;a class=\"a2a_button_email\"&gt;&lt;/a&gt;+ &lt;/div&gt;+ &lt;script async src=\"https://static.addtoany.com/menu/page.js\"&gt;&lt;/script&gt; &lt;/Fragment&gt;; }}...The following code is skipped here... Baidu Share Some AD blockers may block this share button service. Use it with caution. The Baidu share button service seems to be no longer maintained. Use other services as alternatives. Installation Guide You can activate Baidu Share without user registration. Just put the following code to your theme configurations: _config.icarus.yml12share: type: bdshare Share.js The Share.js button service is no longer maintained. Use other services as alternatives. Installation GuidePreview You can activate Share.js without user registration. Just put the following code to your theme configurations: _config.icarus.yml12share: type: sharejs (Optional) Please refer to the customization steps in the AddToAny section and the share.js homepage for information about customizing the share buttons. ShareThis Installation GuidePreview Visit ShareThis and click the “Start with Share Buttons” button on the page. Select the type of buttons you need on the “Choose type of sharing button” page. Don’t enable the “GDPR compliance tool” since it may cause issues. You can also make advanced adjustments by clicking the “Customize your share buttons” link. Click “Next” when you are done. Select “HTML” on the “Choose your CMS platform” page and click “Next”. Enter your email and password to finish the registration for ShareThis on the “Register and get the code!” page. Finally, copy the src URL from the HTML code fragment to the share button configuration. For example, the following ShareThis code: AddThis Code1&lt;script type=\"text/javascript\" src=\"https://platform-api.sharethis.com/js/sharethis.js#property=xxxxxxxxxxxxx&amp;product=inline-share-buttons\" async=\"async\"&gt;&lt;/script&gt; maps to the following theme configuration: _config.icarus.yml123share: type: sharethis install_url: https://platform-api.sharethis.com/js/sharethis.js#property=xxxxxxxxxxxxx&amp;product=inline-share-buttons Something wrong with this article? Click here to submit your revision.","link":"/Plugins/Share/icarus-user-guide-share-buttons/"},{"title":"Upgrade Guide","text":"This article is also available in 简体中文. Upgrading from 5.x to 6.0 Upgrade Node.js to 14.0 or a newer version. Install Icarus 6.x either via source code dowload or NPM install. You can find instructions in Getting Started with Icarus. If you plan to customize the theme by altering its source code, you are required to install the theme from source code. Run hexo clean to clear cache files and let Icarus upgrade your theme configuration file for you. Check out the release notes and the latest documentation for more information of the new features. Upgrading from 4.x to 5.0 Upgrade Node.js to 12.4.0 or a newer version. Install Icarus 5.x either via source code dowload or NPM install. You can find instructions in Getting Started with Icarus. If you plan to customize the theme by altering its source code, you are required to install the theme from source code. Run hexo clean to clear cache files and let Icarus upgrade your theme configuration file for you. Check out the release notes and the latest documentation for more information of the new features. Upgrading from 3.x to 4.x Upgrade Node.js to 10.13.0 or a newer version. Install Icarus 4.x either via source code dowload or NPM install. You can find instructions in Getting Started with Icarus. If you plan to customize the theme by altering its source code, you are required to install the theme from source code. Run hexo clean to clear cache files. Install any missing packages as prompted by Icarus: Shell123456$ hexo clean...ERROR Please install the missing dependencies your Hexo site root directory:ERROR npm install --save hexo@^5.0.2 hexo-component-inferno@^0.8.2 hexo-log@^2.0.0 hexo-util@^2.2.0ERROR or:ERROR yarn add hexo@^5.0.2 hexo-component-inferno@^0.8.2 hexo-log@^2.0.0 hexo-util@^2.2.0 Run hexo clean again to let Icarus upgrade your theme configuration file for you. Icarus will back up and remove themes/icarus/_config.yml, and then create _config.icarus.yml as the new theme configuration file. You can refer to _config.icarus.yml.example for example configurations. Shell123456789$ hexo clean...WARN Your theme configuration is outdated (3.0.0 &lt; 4.0.0).INFO To skip the configuration upgrade, use \"--icarus-dont-upgrade-config\".INFO Backing up theme configuration files...INFO themes/icarus/_config.yml =&gt; themes/icarus/_config.yml.dc00f8b8f8bc03ede351d711e958dc4bINFO Upgrading theme configurations...INFO Theme configurations are written to /tmp/_config.icarus.yml.INFO Example configurations is at /tmp/_config.icarus.yml.example. Icarus now treats post thumbnails and cover images separately. For any posts/pages with an thumbnail image, change thumbnail: to cover: in the front-matter: post.md12345 title: Getting Started with Icarus date: 2020-04-01- thumbnail: /gallery/covers/vector_landscape_1.svg+ cover: /gallery/covers/vector_landscape_1.svg--- You can still set thumbnail in the front-matter to show a smaller thumbnail image for your posts in the archive page and in the recent post widget. Check out the release notes and the latest documentation for more information of the new features.","link":"/uncategorized/upgrade-guide/"},{"title":"Icarus User Guide - Web Analytics Plugins","text":"This article covers web analytics plugins supported by Icarus 5. This article is also available in 简体中文. The following web analytics plugins are provided by ppoffice/hexo-component-inferno. Please refer to it for a complete list of supported plugins and their configuration details. All plugins mentioned below may be blocked by AD blockers. Use them with caution. Baidu StatisticsInstallation Guide Log into Baidu Statistics. Click the “Add new website” button on the “Admin &gt; Site list” page and fill in the site information such as name and homepage URL. Click “OK” to complete site creation. On the next page, find the ID behind hm.baidu.com/hm.js? and set it as the value of plugins &gt; baidu_analytics &gt; tracking_id in the theme configurations. For example, the following Baidu Statistics code: Baidu Statistics code123456789&lt;script&gt;var _hmt = _hmt || [];(function() {var hm = document.createElement(\"script\");hm.src = \"https://hm.baidu.com/hm.js?3f06f2b732a5b1034c989f74e28d0eea\";var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s);})();&lt;/script&gt; maps to the following theme configuration: _config.icarus.yml123plugins: baidu_analytics: tracking_id: 3f06f2b732a5b1034c989f74e28d0eea Bing Webmaster ToolsInstallation Guide Log into Bing - Webmaster Tools. Then, choose “Add your site manually” and enter the URL to your site. Click “Add” button to continue. In the “Add &amp; verify site” panel, select “HTML Meta Tag” method. Copy value of the content attribute in the HTML meta tag to the plugins &gt; bing_webmaster &gt; tracking_id in the theme configurations. _config.icarus.yml123plugins: bing_webmaster: tracking_id: ABCDEFABCDEFABCDEFABCDEFABCDEFABCDEF BuSuanZi Web CounterInstallation Guide Set the plugins &gt; busuanzi to true to enable BuSuanZi web counter and display the number of visitors on the header of each blog post and the bottom of the page. _config.icarus.yml12plugins: busuanzi: true CNZZ StatisticsInstallation Guide Log into Umeng+. On the dashboard of Umeng+, click “Create new application” &gt; “Web application”. Then, fill in your site information such as “website name”, “site domain name”, and “site homepage URL”. Click “Confirm adding the site” after finished. Find the HTML code in the “text style” row on the get installation code page. Copy the values of id and web_id to the plugins &gt; cnzz &gt; id and web_id in the theme configurations, respectively. For example, the following CNZZ installation code: CNZZ installation code1&lt;script type=\"text/javascript\" src=\"https://s9.cnzz.com/z_stat.php?id=123456789000&amp;web_id=123456789000\"&gt;&lt;/script&gt; maps to the following theme configuration: _config.icarus.yml1234plugins: cnzz: id: 123456789000 web_id: 123456789000 Google AnalyticsInstallation Guide Log into Google Analytics and click the “Admin” on the left side of the user dashboard. On the admin page, click the “Create Property” button and set “What do you want to measure?” to “Web”. Click the “Continue” button after that. Then, fill in the Website Name, Website URL, Industry Category, and Reporting Time Zone. Click the “Create” button to finish the property creation. Find the value of “Tracking ID”, e.g., “UA-12345678-0”, on the “Tracking Code” page. Set it to the plugins &gt; google_analytics &gt; tracking_id in the theme configurations to enable the Google Analytics plugin. _config.icarus.yml123plugins: google_analytics: tracking_id: UA-12345678-0 HotjarInstallation Guide Log into Hotjar and click the ➕ (plus sign) &gt; “Add new site” link on the top left of the page. Fill in the “WEBSITE”, “SITE TYPE”, and “SITE OWNER”, then click the “Add Site” button. Find the newly created site on the “Sites &amp; Organizations” page you have been redirected to. Click the “Tracking Code” button on the right. Copy the value of “Site ID” (e.g., 1234567) from the popup dialog to plugins &gt; hotjar &gt; site_id in the theme configurations to enable the Hotjar plugin. _config.icarus.yml123plugins: hotjar: site_id: 1234567 StatcounterInstallation Guide Log into Statcounter. Click “Add New Project” button in the “Projects” page. Fill in the website URL and project title in the “Add Project” page. Tweak rest of the project settings if you need to. Then, click the “Add Project” button. Click “Continue to Default Installation” in the “Platform Check Complete” page. Finally, in the “Insert the Code on Your Website” page, copy the value of sc_project and sc_security variable in the HTML snippet to plugins &gt; statcounter &gt; project and plugins &gt; statcounter &gt; security in the theme configurations, respectively. For example, the following Statcounter code: Statcounter code12345678910&lt;script type=\"text/javascript\"&gt;var sc_project=12345678; var sc_invisible=1; var sc_security=\"abcdef12\"; var sc_https=1; &lt;/script&gt;&lt;script type=\"text/javascript\"src=\"https://www.statcounter.com/counter/counter.js\"async&gt;&lt;/script&gt;... maps to the following theme configuration: _config.icarus.yml1234plugins: statcounter: project: 12345678 security: abcdef12 Twitter Conversion TrackingInstallation Guide Follow How to set up conversion tracking to enable universal website tag of Twitter conversion tracking. Find the init (Pixel ID) in your conversion tracking code. Copy its value to plugins &gt; twitter_conversion_tracking &gt; pixel_id in the theme configurations. For example, the following Twitter conversion tracking code: Twitter conversion tracking code1234567891011&lt;!-- Twitter universal website tag code --&gt;&lt;script&gt;!function(e,n,u,a){e.twq||(a=e.twq=function(){a.exe?a.exe.apply(a,arguments):a.queue.push(arguments);},a.version='1',a.queue=[],t=n.createElement(u),t.async=!0,t.src='//static.ads-twitter.com/uwt.js',s=n.getElementsByTagName(u)[0],s.parentNode.insertBefore(t,s))}(window,document,'script');// Insert Twitter Pixel ID and Standard Event data belowtwq('init','abcdef');twq('track','PageView');&lt;/script&gt;&lt;!-- End Twitter universal website tag code --&gt; maps to the following theme configuration: _config.icarus.yml123plugins: twitter_conversion_tracking: pixel_id: abcdef Something wrong with this article? Click here to submit your revision.","link":"/Plugins/Analytics/icarus-user-guide-web-analytics-plugins/"},{"title":"Icarus User Guide - Widgets","text":"This article covers widgets supported by Icarus 5. To display multiple widgets at once, simply add individual widget configuration to the widgets array. They will appear in the order of their definitions. The type and position settings are required for every widget. Here is an example: _config.icarus.yml123456789widgets: - type: ... # Widget 1 position: left ... - type: ... # Widget 2 position: right ... This article is also available in 简体中文. The following widgets are provided by ppoffice/hexo-component-inferno. Please refer to it for a complete list of supported plugins and their configuration details. ProfileYou can showcase the post author/site admin information via the profile widget. Its configuration is listed below: _config.icarus.yml123456789101112131415161718192021222324widgets: - position: right type: profile # Author name author: hulatocat # Title of the author author_title: A GitHub Octocat # Author location/organization location: GitHub Inc. # URL of the avatar/profile picture avatar: https://octodex.github.com/images/hula_loop_octodex03.gif # Whether to show a round clip of the avatar avatar_rounded: false # The email address of the Gravatar service(if the `avatar` is not set) gravatar: # The follow link URL follow_link: 'https://octodex.github.com/hulatocat' # Social media link URLs social_links: Github: icon: fab fa-github url: 'https://github.com/' Icarus: 'https://github.com/ppoffice/hexo-theme-icarus' Some notes on the configuration: If you wish to use Gravatar instead of avatar as your profile picture, fill in the Gravatar email address in the gravatar setting and leave avatar empty; There two acceptable formats for social_links: Icon: social_links123&lt;link_name&gt;: icon: &lt;fontawesome_icon_class_name&gt; url: &lt;link_url&gt; Text: social_links1&lt;link_name&gt;: &lt;link_url&gt; Table of ContentsTo show the table of contents of the current post, add the following widget configuration to your theme configurations: _config.icarus.yml123456widgets: - type: toc position: left # Whether to number each table of contents item index: true Then, add toc: true to the front-matter of your post: Post.md1234title: A post with the table of contentstoc: true---Post content... External LinksYou can display a list of external sites with the external links widget. An example configuration is listed below: _config.icarus.yml12345678widgets: - position: left type: links # Name and URL of the external site links: Hexo: 'https://hexo.io' Bulma: 'https://bulma.io' Recent PostsUse the following configuration to enable the recent posts widget: _config.icarus.yml1234widgets: - position: right type: recent_posts ArchivesUse the following configuration to enable the archives widget: _config.icarus.yml1234widgets: - position: right type: archives CategoriesUse the following configuration to enable the categories widget: _config.icarus.yml1234widgets: - position: right type: categories TagsUse the following configuration to enable the tags widget: _config.icarus.yml1234567widgets: - position: right type: tags order_by: name # Optional. Order by tag name or length. Prefix with `-` to sort in descending order. amount: 20 # Optional. The maximum number of tags to show. Leave empty to show all. show_count: true # Optional. Whether to show post count right to tag name. Google Feedburner Google is shutting down the email subscription feature of Feedburner. You can switch to the follow.it widget or other email subscription services. To enable Google Feedburner email subscription widget, take the following steps: First, you need to generate the RSS feed of your Hexo site using a Hexo plugin like hexo-generator-feed. Then, go to Google Feedburner, log into your Google account, and add your RSS feed by typing in the RSS feed address to the input box and click “Next”. Next, fill in the “Feed Title” on the next page. Click “Next” to continue customizing your feed or click “Skip directly to feed management” to finish. When finished adding the feed, click the “My Feeds” link on the top of the page. Click your newly added feed on the “My Feeds” page. Switch to the “Publicize” tab and click the “Email Subscription” link on the left side of the page. Enable “Email Subscription” by clicking the “Activate” button. Find the following information in the HTML code on the “Email Subscription” page: Google Feedburner URL1https://feedburner.google.com/fb/a/mailverify?uri=****** Copy the ID after uri= (e.g., feedforall/ABCD) to the feedburner_id setting of the widget configuration: _config.icarus.yml1234567widgets: - position: left type: subscribe_email # (Optional) One line of description text description: Subscribe to get the lastest update! feedburner_id: feedforall/ABCD Google AdSenseCreate a new AD on Google AdSense. Then, copy the values of data-ad-client and data-ad-slot from the AD HTML code to the client_id and slot_id setting of the widget configuration, respectively. Here is an example: _config.icarus.yml123456widgets: - position: left type: adsense client_id: ca-pub-xxxxxxxx slot_id: xxxxxxx follow.itTo enable follow.it email subscription widget, take the following steps: First, you need to generate the RSS feed of your Hexo site using a Hexo plugin like hexo-generator-feed. Go to follow.it and enter the URL to your RSS feed file in the text input under “Add the follow feature to your site”, e.g., http://example.com/atom.xml. Then, click “Next”. Click the “Continue” button on the “Define the follow form’s design” page. Search for action= and copy the link between double quotes after action=. Paste the action link you copied to the action_url setting of the widget configuration. After that, click “Done”. _config.icarus.yml1234567widgets: - position: left type: followit description: action_url: https://api.follow.it/****** verification_code: '' Click the “Continue” button or the “Skip this” link to skip the “Pick the Follow icons you want” page and “Show a pop-up for maximum conversion” page. At the “Connect your feed to a follow.it account” page, enter your email address that you will use to create a follow.it account and manage followers in the text input. Then, click “Start”. You will then receive an email from follow.it. In that email, search for &lt;meta name=\"follow_it-verification-code\" content=\"******\"/&gt; and copy the content value between double quotes after content=. Paste the content value you copied to the verification_code setting of the widget configuration. _config.icarus.yml1234567widgets: - position: left type: followit description: action_url: https://api.follow.it/****** verification_code: ****** Generate and push your site to your server. Go back to follow.it and register an account using your email. Go back to the first email you receive and click on the “Click here to claim it” link to claim your feed. Something wrong with this article? Click here to submit your revision.","link":"/Widgets/icarus-user-guide-widgets/"},{"title":"Disqus Comment Plugin","text":"This page is for demonstration only. Please report your issues with this plugin to ppoffice/hexo-component-inferno.","link":"/uncategorized/disqus-comment-plugin/"},{"title":"DisqusJS Comment Plugin","text":"This page is for demonstration only. Please report your issues with this plugin to ppoffice/hexo-component-inferno.","link":"/uncategorized/disqusjs-comment-plugin/"},{"title":"Facebook Comment Plugin","text":"This page is for demonstration only. Please report your issues with this plugin to ppoffice/hexo-component-inferno. Please turn off your ad blockers if you do not see the comment section.","link":"/uncategorized/facebook-comment-plugin/"},{"title":"Giscus Comment Plugin","text":"This page is for demonstration only. Please report your issues with this plugin to ppoffice/hexo-component-inferno.","link":"/uncategorized/giscus-comment-plugin/"},{"title":"Gitalk Comment Plugin","text":"This page is for demonstration only. Please report your issues with this plugin to ppoffice/hexo-component-inferno.","link":"/uncategorized/gitalk-comment-plugin/"},{"title":"Twikoo Comment Plugin","text":"This page is for demonstration only. Please report your issues with this plugin to ppoffice/hexo-component-inferno.","link":"/uncategorized/twikoo-comment-plugin/"},{"title":"Utterances Comment Plugin","text":"This page is for demonstration only. Please report your issues with this plugin to ppoffice/hexo-component-inferno.","link":"/uncategorized/utterances-comment-plugin/"},{"title":"Valine Comment Plugin","text":"This page is for demonstration only. Please report your issues with this plugin to ppoffice/hexo-component-inferno. A vulnerability has been found in Valine that the comment service exposes IP addresses of all commenters (xCss/Valine#336). Please use alternative comment services until this issue has been fixed.","link":"/uncategorized/valine-comment-plugin/"},{"title":"Waline Comment Plugin","text":"This page is for demonstration only. Please report your issues with this plugin to ppoffice/hexo-component-inferno.","link":"/uncategorized/waline-comment-plugin/"},{"title":"Algolia Search Plugin","text":"This page is for demonstration only. Please report your issues with this plugin to ppoffice/hexo-component-inferno.","link":"/uncategorized/algolia-search-plugin/"},{"title":"Google CSE Search Plugin","text":"This page is for demonstration only. Please report your issues with this plugin to ppoffice/hexo-component-inferno.","link":"/uncategorized/google-cse-search-plugin/"},{"title":"AddThis Share Buttons","text":"This page is for demonstration only. Please report your issues with this plugin to ppoffice/hexo-component-inferno. Please turn off your ad blockers if you do not see the buttons.","link":"/uncategorized/addthis-share-buttons/"},{"title":"AddToAny Share Buttons","text":"This page is for demonstration only. Please report your issues with this plugin to ppoffice/hexo-component-inferno.","link":"/uncategorized/addtoany-share-buttons/"},{"title":"ShareThis Share Buttons","text":"This page is for demonstration only. Please report your issues with this plugin to ppoffice/hexo-component-inferno.","link":"/uncategorized/sharethis-share-buttons/"},{"title":"Share.js Share Buttons","text":"This page is for demonstration only. Please report your issues with this plugin to ppoffice/hexo-component-inferno.","link":"/uncategorized/share-js-share-buttons/"}],"tags":[{"name":"Demo","slug":"Demo","link":"/tags/Demo/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"NLP","slug":"NLP","link":"/tags/NLP/"},{"name":"数据探索","slug":"数据探索","link":"/tags/%E6%95%B0%E6%8D%AE%E6%8E%A2%E7%B4%A2/"},{"name":"PyTorch","slug":"PyTorch","link":"/tags/PyTorch/"},{"name":"BLE","slug":"BLE","link":"/tags/BLE/"},{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"Icarus用户指南","slug":"Icarus用户指南","link":"/tags/Icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/"},{"name":"ReferenceManual","slug":"ReferenceManual","link":"/tags/ReferenceManual/"},{"name":"PDF","slug":"PDF","link":"/tags/PDF/"},{"name":"TIMER","slug":"TIMER","link":"/tags/TIMER/"},{"name":"Getting Started","slug":"Getting-Started","link":"/tags/Getting-Started/"},{"name":"ROM","slug":"ROM","link":"/tags/ROM/"},{"name":"RAM","slug":"RAM","link":"/tags/RAM/"},{"name":"FLASH","slug":"FLASH","link":"/tags/FLASH/"},{"name":"NXP","slug":"NXP","link":"/tags/NXP/"},{"name":"hardware","slug":"hardware","link":"/tags/hardware/"},{"name":"原理图","slug":"原理图","link":"/tags/%E5%8E%9F%E7%90%86%E5%9B%BE/"},{"name":"RT1050","slug":"RT1050","link":"/tags/RT1050/"},{"name":"中断","slug":"中断","link":"/tags/%E4%B8%AD%E6%96%AD/"},{"name":"DMA","slug":"DMA","link":"/tags/DMA/"},{"name":"UART","slug":"UART","link":"/tags/UART/"},{"name":"vector","slug":"vector","link":"/tags/vector/"},{"name":"Thread","slug":"Thread","link":"/tags/Thread/"},{"name":"vim","slug":"vim","link":"/tags/vim/"},{"name":"ZigBee","slug":"ZigBee","link":"/tags/ZigBee/"},{"name":"GPIO中断","slug":"GPIO中断","link":"/tags/GPIO%E4%B8%AD%E6%96%AD/"},{"name":"pyTorch","slug":"pyTorch","link":"/tags/pyTorch/"},{"name":"GPIO","slug":"GPIO","link":"/tags/GPIO/"},{"name":"KW38","slug":"KW38","link":"/tags/KW38/"},{"name":"Numpy","slug":"Numpy","link":"/tags/Numpy/"},{"name":"ARM","slug":"ARM","link":"/tags/ARM/"},{"name":"设计流程","slug":"设计流程","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B/"},{"name":"Leetcode","slug":"Leetcode","link":"/tags/Leetcode/"},{"name":"二分查找","slug":"二分查找","link":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"代码随想录","slug":"代码随想录","link":"/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"英语","slug":"英语","link":"/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"考研英语100句","slug":"考研英语100句","link":"/tags/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD100%E5%8F%A5/"},{"name":"UVM","slug":"UVM","link":"/tags/UVM/"},{"name":"System Verilog","slug":"System-Verilog","link":"/tags/System-Verilog/"},{"name":"IC验证","slug":"IC验证","link":"/tags/IC%E9%AA%8C%E8%AF%81/"},{"name":"Icarus User Guide","slug":"Icarus-User-Guide","link":"/tags/Icarus-User-Guide/"}],"categories":[{"name":"NLP","slug":"NLP","link":"/categories/NLP/"},{"name":"PyTorch","slug":"NLP/PyTorch","link":"/categories/NLP/PyTorch/"},{"name":"Python","slug":"NLP/Python","link":"/categories/NLP/Python/"},{"name":"IoT协议","slug":"IoT协议","link":"/categories/IoT%E5%8D%8F%E8%AE%AE/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"Configuration","slug":"Configuration","link":"/categories/Configuration/"},{"name":"NXP","slug":"NXP","link":"/categories/NXP/"},{"name":"Plugins","slug":"Plugins","link":"/categories/Plugins/"},{"name":"BLE","slug":"IoT协议/BLE","link":"/categories/IoT%E5%8D%8F%E8%AE%AE/BLE/"},{"name":"STL","slug":"C/STL","link":"/categories/C/STL/"},{"name":"RT1050","slug":"NXP/RT1050","link":"/categories/NXP/RT1050/"},{"name":"ReferenceManual","slug":"NXP/ReferenceManual","link":"/categories/NXP/ReferenceManual/"},{"name":"RT1060","slug":"NXP/RT1060","link":"/categories/NXP/RT1060/"},{"name":"Comment","slug":"Plugins/Comment","link":"/categories/Plugins/Comment/"},{"name":"Donation","slug":"Plugins/Donation","link":"/categories/Plugins/Donation/"},{"name":"Search","slug":"Plugins/Search","link":"/categories/Plugins/Search/"},{"name":"Share","slug":"Plugins/Share","link":"/categories/Plugins/Share/"},{"name":"Other","slug":"Plugins/Other","link":"/categories/Plugins/Other/"},{"name":"Thread","slug":"IoT协议/Thread","link":"/categories/IoT%E5%8D%8F%E8%AE%AE/Thread/"},{"name":"总线协议","slug":"总线协议","link":"/categories/%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE/"},{"name":"开发工具","slug":"开发工具","link":"/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"Analytics","slug":"Plugins/Analytics","link":"/categories/Plugins/Analytics/"},{"name":"Widgets","slug":"Widgets","link":"/categories/Widgets/"},{"name":"RT1024","slug":"NXP/RT1024","link":"/categories/NXP/RT1024/"},{"name":"ZigBee","slug":"IoT协议/ZigBee","link":"/categories/IoT%E5%8D%8F%E8%AE%AE/ZigBee/"},{"name":"KW38","slug":"NXP/KW38","link":"/categories/NXP/KW38/"},{"name":"嵌入式基础","slug":"NXP/嵌入式基础","link":"/categories/NXP/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80/"},{"name":"嵌入式基础","slug":"嵌入式基础","link":"/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80/"},{"name":"数字IC","slug":"数字IC","link":"/categories/%E6%95%B0%E5%AD%97IC/"},{"name":"Leetcode","slug":"Leetcode","link":"/categories/Leetcode/"},{"name":"英语","slug":"英语","link":"/categories/%E8%8B%B1%E8%AF%AD/"},{"name":"IC验证","slug":"IC验证","link":"/categories/IC%E9%AA%8C%E8%AF%81/"},{"name":"UART","slug":"总线协议/UART","link":"/categories/%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE/UART/"},{"name":"vim","slug":"开发工具/vim","link":"/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/vim/"},{"name":"野火","slug":"NXP/RT1050/野火","link":"/categories/NXP/RT1050/%E9%87%8E%E7%81%AB/"},{"name":"原理图","slug":"NXP/RT1024/原理图","link":"/categories/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/"},{"name":"GPIO中断","slug":"NXP/KW38/GPIO中断","link":"/categories/NXP/KW38/GPIO%E4%B8%AD%E6%96%AD/"},{"name":"数据结构","slug":"Leetcode/数据结构","link":"/categories/Leetcode/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"漫游指南","slug":"IC验证/漫游指南","link":"/categories/IC%E9%AA%8C%E8%AF%81/%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%97/"},{"name":"路科V0","slug":"IC验证/路科V0","link":"/categories/IC%E9%AA%8C%E8%AF%81/%E8%B7%AF%E7%A7%91V0/"}],"pages":[{"title":"","text":"A simple, delicate, and modern theme for the static site generator Hexo. Preview | Documentation | Discuss on GitHub 💿 Installation12$ npm install hexo-theme-icarus$ hexo config theme icarus Please refer to Getting Started with Icarus for more details. 🎁 FeaturesCyberpunk Theme VariantTap into the future cyber world with the newly added Cyberpunk theme variant. Inspired by Cyberpunk 2077. Extensive Plugin SupportIcarus includes plentiful search, comment, sharing and other plugins out of the box that makes your blog feature-rich and powerful. Comment Changyan · Disqus · DisqusJS · Facebook · Gitalk · Gitment · Isso · LiveRe · Utterance · Valine Donate Button Afdian.net · Alipay · Buy me a coffee · Patreon · Paypal · Wecat Search Algolia · Baidu · Google CSE · Insight Share AddThis · AddToAny · Baidu Share · Share.js · ShareThis Widgets Google Adsense · Archives · Categories · External Site Links · Recent Posts · Google Feedburner · Tags · Table of Contents Analytics Baidu Statistics · Bing Webmaster · BuSuanZi Web Counter · CNZZ Statistics · Google Analytics · Hotjar · StatCounter · Twitter Conversion Tracking Other Plugins Cookie Consent · LightGallery · Justified Gallery · KaTeX · MathJax · Oudated Browser · Page Loading Animations Colorful Code HighlightIcarus directly import stylesheets from the highlight.js package and makes more than 90 code highlight themes available to you. Atom One Light Monokai Kimbie Dark Flexible Theme ConfigurationIcarus allows you to configure your site on a per-page or per-layout basis. _config.icarus.yml12345widgets: - type: profile position: left - type: recent_posts position: right post.md12345widgets: - type: profile position: left - type: recent_posts position: left _config.page.yml1widgets: null Responsive LayoutGive your audiences best viewing experience with Icarus’s mobile-friendly responsive layout. 🔨 DevelopmentThis project is built with Hexo Inferno.js Stylus Bulma Please refer to the documentation and contributing guide for implementation details. 🎉 ContributeIf you feel like to help us build a better Icarus, you can ✒ Submit a tutorial | 🌏 Add a translation | 🚩 Report a bug | 🔌 Suggest a new feature 📝 LicenseThis project is licensed under the MIT License - see the LICENSE file for details.","link":"/about/index.html"}]}