<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DustOfStars</title>
  
  <subtitle>--jxw</subtitle>
  <link href="https://dustofstars.github.io/atom.xml" rel="self"/>
  
  <link href="https://dustofstars.github.io/"/>
  <updated>2025-05-19T09:11:04.000Z</updated>
  <id>https://dustofstars.github.io/</id>
  
  <author>
    <name>Gavin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RT600 BootROM RM解析 (3)</title>
    <link href="https://dustofstars.github.io/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-3/"/>
    <id>https://dustofstars.github.io/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-3/</id>
    <published>2025-05-19T09:11:04.000Z</published>
    <updated>2025-05-19T09:11:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RT600-RM-CH41：RT6xx-非安全BootROM-3"><a href="#RT600-RM-CH41：RT6xx-非安全BootROM-3" class="headerlink" title="RT600 RM CH41：RT6xx 非安全BootROM (3)"></a>RT600 RM CH41：RT6xx 非安全BootROM (3)</h1><h2 id="41-4-引导模式"><a href="#41-4-引导模式" class="headerlink" title="41.4 引导模式"></a>41.4 引导模式</h2><p>ROM 引导加载程序支持以下引导模式：</p><ul><li>Master Boot 模式</li><li>Recovery Boot 模式</li><li>Serial Boot 模式</li><li>ISP Boot 模式</li></ul><span id="more"></span><h2 id="41-5-主引导模式"><a href="#41-5-主引导模式" class="headerlink" title="41.5 主引导模式"></a>41.5 主引导模式</h2><p>主引导模式支持以下引导设备：</p><ul><li>FlexSPI 引导</li><li>SD 引导</li><li>eMMC 引导</li><li>SPI NOR 引导</li></ul><p>引导加载程序从引导介质上的指定偏移量查找引导镜像。详情见表 1000。</p><p><strong>表 1000. 不同引导介质上的镜像偏移量</strong></p><table><thead><tr><th>引导介质</th><th>镜像偏移量</th></tr></thead><tbody><tr><td>FlexSPI 引导（串行 NOR 闪存设备）</td><td>0x1000</td></tr><tr><td>SD 引导（SD 卡）</td><td>0x1000</td></tr><tr><td>eMMC 引导（eMMC 存储器）</td><td>0x1000</td></tr><tr><td>SPI 1 位 NOR 引导</td><td>0x1000</td></tr></tbody></table><h3 id="41-5-1-FlexSPI-引导"><a href="#41-5-1-FlexSPI-引导" class="headerlink" title="41.5.1 FlexSPI 引导"></a>41.5.1 FlexSPI 引导</h3><p>引导加载程序通过 FlexSPI 接口，使用位于闪存设备偏移量 <code>0x400</code> 处的闪存配置块（FCB）<span style="color: green;">或 OTP 中指定的闪存自动探测功能</span>，支持访问各种厂商的不同 Quad/Octal SPI NOR 闪存设备，可使用 1 位、2 位（双）、4 位（四）或 8 位（八）模式。FCB 的详细信息见表 1001。</p><ul><li>若 <code>FLEXSPI_AUTO_PROBE_EN</code> 已熔断，引导加载程序将使用 <code>FLEXSPI_FLASH_PROBE_TYPE</code> 字段（定义闪存自动探测类型）、<code>FLEXSPI_FLASH_TYPE</code> 字段（定义闪存类型）和 <code>FLEXSPI_FLASH_BOOT_FREQ</code> 字段（定义闪存访问速度）中熔断的参数执行闪存自动探测序列。</li><li>若未熔断，引导加载程序将查看闪存设备上的偏移量 <code>0x400</code>。若偏移量 <code>0x400</code> 处的数据等于 <code>0x42464346</code>，引导加载程序将<span style="color: red; font-weight: bold; ">把整个 512 字节的 FCB 读入片上 SRAM，并使用该 FCB 相应地配置 FlexSPI 控制器。</span></li></ul><p>上述操作完成后，引导加载程序开始执行正常引导流程。更多细节见 图 187。</p><p><strong>表 1001. FlexSPI 闪存配置块</strong></p><table><thead><tr><th>字段</th><th>偏移量</th><th>大小（字节）</th><th>描述</th></tr></thead><tbody><tr><td>tag</td><td>0x000</td><td>4</td><td>配置块标签，必须为 <code>0x42464346</code>。</td></tr><tr><td>version</td><td>0x004</td><td>4</td><td>配置块版本，供引导 ROM 内部使用，固定为 <code>0x56020000</code>。</td></tr><tr><td>reserved</td><td>0x008</td><td>4</td><td>保留。</td></tr><tr><td><code>readSampleClkSrc</code></td><td>0x00C</td><td>1</td><td><span style="color: red; font-weight: bold; ">读取采样时钟源选项：</span> <br>0 - 内部环回 <br>1 - 来自 DQS 焊盘的环回 <br>2 - 来自 SCK 焊盘的环回 <br>3 - 外部 DQS 信号</td></tr><tr><td>csHoldTime</td><td>0x00D</td><td>1</td><td>CS 保持时间（以闪存时钟周期为单位），推荐值为 3。</td></tr><tr><td>csSetupTime</td><td>0x00E</td><td>1</td><td>CS 建立时间（以闪存时钟周期为单位），推荐值为 3。</td></tr><tr><td>columnAddressWidth</td><td>0x00F</td><td>1</td><td>列地址宽度： <span style="color: red; ">HyperFLASH 设为 3 其他闪存设备设为 0</span></td></tr><tr><td>deviceModeCfgEnable</td><td>0x010</td><td>1</td><td>启用 Device Mode Configuration 序列。</td></tr><tr><td>reserved</td><td>0x011</td><td>1</td><td>保留。</td></tr><tr><td>deviceModeSeq</td><td>0x014</td><td>4</td><td>设备模式配置序列： <br>字节 0：所需序列数 <br>字节 1：序列索引</td></tr><tr><td>deviceModeArg</td><td>0x018</td><td>4</td><td>设备模式配置参数（<span style="color: red;">如某些 QSPI 闪存设备状态寄存器 2 中的 QE 设置</span>）。</td></tr><tr><td>configCmdEnable</td><td>0x01C</td><td>1</td><td>配置命令使能： <br>0 - 忽略配置命令 <br>1 - 启用配置命令</td></tr><tr><td>configModeType</td><td>0x01D</td><td>3</td><td>配置命令类型，支持最多 3 种类型，每种类型与一个配置命令序列组合。</td></tr><tr><td>configCmdSeqs</td><td>0x020</td><td>12</td><td>配置命令序列，支持最多 3 个序列。</td></tr><tr><td>reserved</td><td>0x02C</td><td>4</td><td>保留。</td></tr><tr><td>configCmdArgs</td><td>0x030</td><td>12</td><td>配置命令参数，支持最多 3 个参数。</td></tr><tr><td>reserved</td><td>0x03C</td><td>4</td><td>保留。</td></tr></tbody></table><p><strong>表 1001. FlexSPI 闪存配置块（续）</strong></p><table><thead><tr><th>字段</th><th>偏移量</th><th>大小（字节）</th><th>描述</th></tr></thead><tbody><tr><td>controllerMiscOption</td><td>0x040</td><td>4</td><td>控制器杂项配置选项： <br>位 0 - 差分时钟使能，HyperFLASH 1V8 设备设为 1，其他设备设为 0 <br>位 3 - 字地址使能，HyperFLASH 设为 1，其他设备设为 0 <br>位 4 - 安全配置频率使能，若期望用安全频率配置设备则设为 1 <br>位 6 - DDR 模式使能，若需要 DDR 读取则设为 1 <br>其他位 - 保留，设为 0</td></tr><tr><td>deviceType</td><td>0x044</td><td>1</td><td>设备类型： 1 - 串行 NOR</td></tr><tr><td>sflashPadType</td><td>0x045</td><td>1</td><td>读取命令中使用的数据焊盘： <br>1 - 单焊盘 <br>2 - 双焊盘 <br>4 - 四焊盘 <br>8 - 八焊盘</td></tr><tr><td>serialClkFreq</td><td>0x046</td><td>1</td><td>Flash Frequency. <br>In Normal boot mode BOOT_CFG[0]:bit7=0 <br>- SDR 模式：1 - 24 MHz，2 - 48 MHz <br>- DDR 模式：1 - 12 MHz <br>高速引导模式 BOOT_CFG [0]:bit7=1：  <br>SDR 模式：1-30 MHz，2-50 MHz，3-60 MHz，4-80 MHz，5-100 MHz，6-120 MHz，7-133 MHz，8-166 MHz，9-200 MHz  <br>DDR 模式：1-30 MHz，2-50 MHz，3-60 MHz，4-80 MHz，5-100 MHz，6-120 MHz，7-133 MHz，8-166 MHz，9-200 MHz</td></tr><tr><td>lutCustomSeqEnable</td><td>0x047</td><td>1</td><td><span style="color: red; ">LUT 自定义使能：若编程 / 擦除无法在 SDR 模式下用 1 个 LUT 序列完成，则需要此功能（当前仅适用于 HyperFLASH）</span> <br></td></tr><tr><td>reserved</td><td>0x048</td><td>8</td><td>保留，供未来使用。</td></tr><tr><td>sflashA1Size</td><td>0x050</td><td>4</td><td>连接到 A1 的闪存大小。</td></tr><tr><td>sflashA2Size</td><td>0x054</td><td>4</td><td>连接到 A2 的闪存大小。</td></tr><tr><td>sflashB1Size</td><td>0x058</td><td>4</td><td>连接到 B1 的闪存大小。</td></tr><tr><td>sflashB2Size</td><td>0x05C</td><td>4</td><td>连接到 B2 的闪存大小。</td></tr></tbody></table><p><strong>表 1001. FlexSPI 闪存配置块（续）</strong></p><table><thead><tr><th>字段</th><th>偏移量</th><th>大小（字节）</th><th>描述</th></tr></thead><tbody><tr><td>csPadSettingOverride</td><td>0x060</td><td>4</td><td>CS 引脚的焊盘覆盖值。若非零，则使用此值配置 CS 引脚；否则使用默认 ROM 设置。</td></tr><tr><td>sclkPadSettingOverride</td><td>0x064</td><td>4</td><td>SCK 焊盘设置覆盖值。</td></tr><tr><td>dataPadSettingOverride</td><td>0x068</td><td>4</td><td>数据焊盘设置覆盖值。</td></tr><tr><td>dqsPadSettingOverride</td><td>0x06C</td><td>4</td><td>DQS 焊盘设置覆盖值。</td></tr><tr><td>timeoutInMs</td><td>0x070</td><td>4</td><td>终止忙检查的超时值（以毫秒为单位）。</td></tr><tr><td>commandInterval</td><td>0x074</td><td>4</td><td>两个命令之间的 CS 取消选择间隔。</td></tr><tr><td>dataValidTime</td><td>0x078</td><td>4</td><td>端口 A 和端口 B 的时钟边沿到数据有效时间。</td></tr><tr><td>busyOffset</td><td>0x07C</td><td>2</td><td>忙标志偏移量，有效值：0-31。</td></tr><tr><td>busyBitPolarity</td><td>0x07E</td><td>2</td><td>忙标志极性： 0 - 闪存设备忙时忙标志为 1 1 - 闪存设备忙时忙标志为 0</td></tr><tr><td>lookupTable</td><td>0x080</td><td>256</td><td><span style="color: red; font-weight: bold; ">16 个 LUT 序列，每个序列由 4 个字组成。更多细节见第 33 章 “RT6xx FlexSPI 闪存接口”。</span></td></tr><tr><td><code>lutCustomSeq</code></td><td>0x180</td><td>48</td><td>可自定义的 LUT 序列。</td></tr><tr><td>reserved</td><td>0x1B0</td><td>16</td><td>保留，供未来使用。</td></tr><tr><td>pageSize</td><td>0x1C0</td><td>4</td><td>闪存页大小。</td></tr><tr><td>sectorSize</td><td>0x1C4</td><td>4</td><td>闪存扇区大小。</td></tr><tr><td>ipcmdSerialClkFreq</td><td>0x1C8</td><td>1</td><td>IP 命令的串行时钟频率： <br>0 - 与读取命令相同 <br>其他值 - 与 serialClkFreq 定义相同</td></tr><tr><td>isUniformBlockSize</td><td>0x1C9</td><td>1</td><td>扇区大小是否与块大小相同。</td></tr><tr><td><code>isDataOrderSwapped</code></td><td>0x1CA</td><td>1</td><td>数据顺序（D0, D1, D2, D3）是否交换为（D1, D0, D3, D2）： <br>0 - 否 <br>1 - 是</td></tr><tr><td>reserved</td><td>0x1CB</td><td>1</td><td>保留，供未来使用。</td></tr><tr><td>serialNorType</td><td>0x1CC</td><td>1</td><td>串行 NOR 闪存类型： <br>0 - 标准 SPI <br>1 - HyperBus <br>2 - XPI <br>3 - NoCmd</td></tr><tr><td>needExitNoCmdMode</td><td>0x1CD</td><td>1</td><td>执行其他 IP 命令前是否需要退出 NoCmd 模式。</td></tr><tr><td>halfClkForNonReadCmd</td><td>0x1CE</td><td>1</td><td>非读取命令是否使用半速串行时钟：是 / 否。</td></tr><tr><td>needRestoreNoCmdMode</td><td>0x1CF</td><td>1</td><td>IP 命令执行后是否需要恢复 NoCmd 模式。</td></tr><tr><td>blockSize</td><td>0x1D0</td><td>4</td><td>闪存块大小。</td></tr><tr><td>flashStateCtx</td><td>0x1D4</td><td>4</td><td>闪存状态上下文，用于将闪存恢复为默认状态。</td></tr><tr><td>reserved</td><td>0x1D8</td><td>40</td><td>保留，供未来使用。</td></tr></tbody></table><h4 id="41-5-1-1-FlexSPI-闪存复位"><a href="#41-5-1-1-FlexSPI-闪存复位" class="headerlink" title="41.5.1.1 FlexSPI 闪存复位"></a>41.5.1.1 FlexSPI 闪存复位</h4><p>在 FlexSPI 引导期间，引导过程要求 FlexSPI 闪存设备处于特定模式（如 1 位 SPI 兼容模式）。上电复位（POR）后，闪存设备自然会进入此模式，因为上电序列会将其与 RT6xx 设备一起复位。然而，若闪存设备在非 POR 复位（如看门狗定时器或外部引脚复位）时被配置为 DPI 模式、QPI 模式或八进制模式，则不会处于 1 位 SPI 兼容模式。在这种情况下，引导过程需要进行特殊处理，以在继续访问闪存设备之前将其恢复为 1 位 SPI 兼容模式。通常，这可以通过使用 GPIO 断言闪存设备上的复位引脚来实现。</p><p>如果 <code>FLEXSPI_RESET_PIN_EN</code> 已熔断，引导加载程序可以使用 <code>FLEXSPI_RESET_PIN_PORT</code> 和 <code>FLEXSPI_RESET_PIN_GPIO</code> 组合指定的 GPIO 执行复位过程，将闪存设备复位为 1 位 SPI 兼容模式。</p><h5 id="41-5-1-1-1-闪存掉电"><a href="#41-5-1-1-1-闪存掉电" class="headerlink" title="41.5.1.1.1 闪存掉电"></a>41.5.1.1.1 闪存掉电</h5><p>闪存设备可配置为Power-Down模式以降低待机电流。对于 FlexSPI 引导，RT6xx 引导代码访问闪存之前，必须先将闪存从掉电模式中释放。<span style="color: red; font-weight: bold; ">在这种情况下，<code>FLEXSPI_RESET_PIN</code> 可用于在引导过程中切换闪存上的复位引脚，以将闪存从掉电模式中释放。</span></p><p>如果闪存不支持复位引脚，可以设计专用电路为闪存提供 VCC。<code>FLEXSPI_RESET_PIN</code> 可用于控制电路在引导时为闪存上电 / 断电，以将闪存恢复为初始状态。</p><h4 id="41-5-1-2-FlexSPI-引导在-OTP-中的配置"><a href="#41-5-1-2-FlexSPI-引导在-OTP-中的配置" class="headerlink" title="41.5.1.2 FlexSPI 引导在 OTP 中的配置"></a>41.5.1.2 FlexSPI 引导在 OTP 中的配置</h4><p>与 FlexSPI 引导相关的配置分配在 <code>BOOT_CFG1</code> OTP 字中，分配详情见 表 1002。</p><p><strong>表 1002. OTP 中的 FlexSPI 引导配置</strong></p><table><thead><tr><th>字段名称</th><th>枚举名称</th><th>描述</th><th>偏移量</th><th>宽度</th><th>值</th></tr></thead><tbody><tr><td>FLEXSPI_AUTO_PROBE_EN</td><td>-</td><td>Quad/Octal-SPI 闪存自动探测功能使能。</td><td>0</td><td>1</td><td>-</td></tr><tr><td>FLEXSPI_PROBE_TYPE</td><td>-</td><td>Quad/Octal-SPI 闪存探测类型： 000b - QSPI NOR <br>001b - Macronix Octal Flash<br>010b - Micron Octal Flash <br>011b - Adesto Octal Flash <br>100b-111b - 保留</td><td>1</td><td>3</td><td>-</td></tr><tr><td>FLEXSPI_FLASH_TYPE</td><td>-</td><td>定义典型串行 NOR 闪存类型： <br>000b - 设备默认支持 3B 读取 <br>010b - HyperFlash 1V8 <br>011b - HyperFlash 3V3 <br>100b - MXIC Octal DDR <br>101b - Micron Octal DDR <br>其他值 - 保留</td><td>4</td><td>3</td><td>-</td></tr><tr><td>FLEXSPI_DUMMY_CYCLES</td><td>-</td><td>读取命令的 Quad/Octal-SPI 哑周期： 0000b - 自动探测哑周期 <br>其他值 - 指定哑周期数</td><td>7</td><td>4</td><td>-</td></tr><tr><td>FLEXSPI_FREQUENCY</td><td>-</td><td>Quad/Octal-SPI 闪存接口频率： 000b - 100 MHz 001b - 120 MHz 010b - 133 MHz 011b - 166 MHz 100b - 200 MHz 101b - 80 MHz 110b - 60 MHz 111b - 50 MHz</td><td>11</td><td>3</td><td>-</td></tr><tr><td>FLEXSPI_RESET_PIN_ENABLE</td><td>-</td><td>使用 <code>FLEXSPI_RESET_PIN</code> 复位闪存设备： <br>0 - 未连接或不可用（NO_RESET） <br>1 - 连接到 GPIO（EN_RESET）</td><td>14</td><td>1</td><td>-</td></tr><tr><td>FLEXSPI_RESET_PIN</td><td>-</td><td>用于 Quad/Octal SPI 复位功能的 GPIO 端口和引脚号： <br>位 0-2：GPIO 端口 <br>位 3-7：GPIO 引脚号</td><td>15</td><td>8</td><td>-</td></tr><tr><td>FLEXSPI_HOLD_TIME</td><td>-</td><td>访问串行闪存前的等待时间： 00b - 500 微秒 01b - 1 毫秒 10b - 3 毫秒 11b - 10 毫秒</td><td>23</td><td>2</td><td>-</td></tr></tbody></table><p><strong>表 1002. OTP 中的 FlexSPI 引导配置（续）</strong></p><table><thead><tr><th>字段名称</th><th>枚举名称</th><th>描述</th><th>偏移量</th><th>宽度</th><th>值</th></tr></thead><tbody><tr><td>FLEXSPI_PWR_HOLD_TIME</td><td>-</td><td>除 FLEXSPI_HOLD_TIME 字段定义的延迟外，上电后访问 Quad/Octal-SPI 闪存设备前的延迟： 0000b - 无延迟 0001b - 额外等待 100 微秒 0010b - 额外等待 500 微秒 0011b - 额外等待 1 毫秒 0100b - 额外等待 10 毫秒 其他值 - 更多延迟（详见文档）</td><td>25</td><td>4</td><td>-</td></tr><tr><td>RESERVED</td><td>-</td><td>保留</td><td>29</td><td>3</td><td>-</td></tr></tbody></table><h4 id="41-5-1-3-FlexSPI-引导流程"><a href="#41-5-1-3-FlexSPI-引导流程" class="headerlink" title="41.5.1.3 FlexSPI 引导流程"></a>41.5.1.3 FlexSPI 引导流程</h4><p>下图说明了简要的 FlexSPI 引导流程。Keyblob 的详细信息见第 42 章 “RT6xx 安全引导 ROM”。正常镜像加载和认证流程的详细信息见图 188。</p><p><strong>图 188. FlexSPI 闪存引导流程</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">进入FlexSPI引导</span><br><span class="line">│</span><br><span class="line">├─── FLEXSPI_RESET_PIN_EN？</span><br><span class="line">│   ├─── 是 → 执行闪存复位</span><br><span class="line">│   └─── 否 → 跳过复位</span><br><span class="line">│</span><br><span class="line">├─── FLEXSPI_FLASH_AUTO_PROBE_EN？</span><br><span class="line">│   ├─── 是 → 执行闪存自动探测流程</span><br><span class="line">│   └─── 否 → 从闪存FCB区域（0x400或0x400+镜像重映射偏移量）读取FCB</span><br><span class="line">│</span><br><span class="line">├─── 闪存检测到？</span><br><span class="line">│   ├─── 是 → 生成FCB并配置FlexSPI</span><br><span class="line">│   └─── 否 → 进入ISP模式</span><br><span class="line">│</span><br><span class="line">├─── OTFAD启用？</span><br><span class="line">│   ├─── 是 → 读取Keyblob并配置OTFAD</span><br><span class="line">│   └─── 否 → 跳过</span><br><span class="line">│</span><br><span class="line">├─── 镜像有效？</span><br><span class="line">│   ├─── 是 → 正常镜像加载与认证</span><br><span class="line">│   └─── 否 → 进入恢复引导或ISP模式</span><br><span class="line">│</span><br><span class="line">└─── 跳转至应用程序</span><br></pre></td></tr></tbody></table></figure><h4 id="41-5-1-4-FlexSPI-双镜像乒乓引导"><a href="#41-5-1-4-FlexSPI-双镜像乒乓引导" class="headerlink" title="41.5.1.4 FlexSPI 双镜像乒乓引导"></a>41.5.1.4 FlexSPI 双镜像乒乓引导</h4><p><span style="color: red; font-weight: bold; ">FlexSPI 控制器支持重映射功能，可将串行 NOR 闪存的 AHB 访问地址重映射到另一个带偏移量的地址，从而在第一个镜像引导失败时支持第二个镜像引导。</span></p><h5 id="41-5-1-4-1-FlexSPI-重映射的基本功能"><a href="#41-5-1-4-1-FlexSPI-重映射的基本功能" class="headerlink" title="41.5.1.4.1 FlexSPI 重映射的基本功能"></a>41.5.1.4.1 FlexSPI 重映射的基本功能</h5><p>下图是 FlexSPI 重映射功能的简单示意图</p><p><strong>图 189. FlexSPI 镜像重映射（偏移量 = 0x200000）</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0x08000000  ── KeyBlob for 引导镜像0（256字节）</span><br><span class="line">0x08000400  ── FCB（闪存配置块）for 引导镜像0（512字节）</span><br><span class="line">0x08000600  ── 镜像0版本（4字节）</span><br><span class="line">0x08000800  ── KEY STORE for 引导镜像0</span><br><span class="line">0x08001000  ── 引导镜像0</span><br><span class="line">0x08200000  ── KeyBlob for 引导镜像1（256字节）</span><br><span class="line">0x08200400  ── FCB for 引导镜像1（512字节）</span><br><span class="line">0x08200600  ── 镜像1版本（4字节）</span><br><span class="line">0x08200800  ── KEY STORE for 引导镜像1</span><br><span class="line">0x08201000  ── 引导镜像1</span><br><span class="line">闪存设备（8MB）</span><br></pre></td></tr></tbody></table></figure><p>设置重映射偏移量后，FlexSPI 内存访问将按如下方式更改访问地址（添加偏移量）。例如，当偏移量设置为 2MB（0x200000）时，通过 FlexSPI 对 0x08000000 的访问将重映射到 0x08200000。通过这种方式，可以使用两个镜像实现双镜像引导。偏移量和镜像 1 的大小由用户通过 OTP 熔丝设置。</p><h3 id="41-5-1-4-2-OTP-中的-FlexSPI-重映射大小和引导镜像-1-偏移量配置"><a href="#41-5-1-4-2-OTP-中的-FlexSPI-重映射大小和引导镜像-1-偏移量配置" class="headerlink" title="41.5.1.4.2 OTP 中的 FlexSPI 重映射大小和引导镜像 1 偏移量配置"></a><strong>41.5.1.4.2 OTP 中的 FlexSPI 重映射大小和引导镜像 1 偏移量配置</strong></h3><p>FlexSPI 双镜像引导相关配置分配在 BOOT_CFG2 和 BOOT_CFG3 OTP 字中，更多细节见表 1003 和表 1004。</p><h4 id="表-1003-引导镜像-1-偏移量（BOOT-CFG3）"><a href="#表-1003-引导镜像-1-偏移量（BOOT-CFG3）" class="headerlink" title="表 1003. 引导镜像 1 偏移量（BOOT_CFG3）"></a><strong>表 1003. 引导镜像 1 偏移量（BOOT_CFG3）</strong></h4><table><thead><tr><th>字段名称</th><th>偏移量</th><th>宽度</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>第二镜像偏移量</td><td>22</td><td>10</td><td>x</td><td>x × 256 KB</td></tr></tbody></table><h4 id="表-1004-从-0x08001000-开始的-FlexSPI-重映射大小"><a href="#表-1004-从-0x08001000-开始的-FlexSPI-重映射大小" class="headerlink" title="表 1004. 从 0x08001000 开始的 FlexSPI 重映射大小"></a><strong>表 1004. 从 0x08001000 开始的 FlexSPI 重映射大小</strong></h4><table><thead><tr><th>字段名称</th><th>偏移量</th><th>宽度</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>FlexSPI 重映射大小 [1]</td><td>28</td><td>4</td><td>0</td><td>与第二镜像偏移量大小相同 13 - 256 KB 14 - 512 KB 15 - 768 KB x - x × 1 MB</td></tr><tr><td>[1]</td><td>-</td><td>注意：FlexSPI 重映射大小不能超过引导镜像 1 的起始地址。</td><td></td><td></td></tr></tbody></table><h3 id="41-5-1-4-3-双镜像乒乓引导"><a href="#41-5-1-4-3-双镜像乒乓引导" class="headerlink" title="41.5.1.4.3 双镜像乒乓引导"></a><strong>41.5.1.4.3 双镜像乒乓引导</strong></h3><p>对于双镜像乒乓引导，每个引导镜像都有自己的镜像版本，ROM 使用该版本首先选择最新的引导镜像。如果最新镜像引导失败，将尝试使用旧镜像引导。</p><p><strong>乒乓引导流程</strong>对于 FlexSPI 引导，ROM 始终尝试查找最新的引导镜像并引导。如果引导失败，ROM 将尝试查找旧的引导镜像。如果旧镜像引导仍失败，则 ROM 将进入 ISP 引导模式。下图是乒乓引导流程图。</p><p><strong>图 190. FlexSPI 引导镜像选择</strong></p><p>plaintext</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">进入FlexSPI引导</span><br><span class="line">│</span><br><span class="line">├─── 引导镜像0版本有效？</span><br><span class="line">│   ├─── 是 ──→ 引导镜像0版本 ≥ 引导镜像1版本？ ──→ 是 → 引导镜像0</span><br><span class="line">│   │                             └─── 否 → 引导镜像1</span><br><span class="line">│   └─── 否 ──→ 引导镜像1版本有效？ ──→ 是 → 引导镜像</span><br></pre></td></tr></tbody></table></figure><h3 id="图-191-FlexSPI-乒乓引导流程"><a href="#图-191-FlexSPI-乒乓引导流程" class="headerlink" title="图 191. FlexSPI 乒乓引导流程"></a><strong>图 191. FlexSPI 乒乓引导流程</strong></h3><p>plaintext</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">进入FlexSPI引导</span><br><span class="line">│</span><br><span class="line">├─── 获取FCB1（镜像1配置块）</span><br><span class="line">│</span><br><span class="line">├─── VER0 ≥ VER1？</span><br><span class="line">│   ├─── 是 ──→ 获取FCB0（镜像0配置块）</span><br><span class="line">│   │   ├─── FCB0有效？</span><br><span class="line">│   │   │   ├─── 是 ──→ 引导镜像0</span><br><span class="line">│   │   │   │   └─── 镜像0有效？ ──→ 是 → 跳转至应用程序；否 → 进入ISP模式</span><br><span class="line">│   │   │   └─── 否 ──→ FCB1有效？ ──→ 是 → 引导镜像1；否 → 进入ISP模式</span><br><span class="line">│   └─── 否 ──→ 获取FCB1</span><br><span class="line">│       ├─── FCB1有效？</span><br><span class="line">│       │   ├─── 是 ──→ 引导镜像1</span><br><span class="line">│       │   │   └─── 镜像1有效？ ──→ 是 → 跳转至应用程序；否 → 进入ISP模式</span><br><span class="line">│       └─── 否 ──→ FCB0有效？ ──→ 是 → 引导镜像0；否 → 进入ISP模式</span><br></pre></td></tr></tbody></table></figure><h3 id="41-5-1-4-4-引导镜像版本"><a href="#41-5-1-4-4-引导镜像版本" class="headerlink" title="41.5.1.4.4 引导镜像版本"></a><strong>41.5.1.4.4 引导镜像版本</strong></h3><p>每个引导镜像版本位于 FlexSPI 引导设备的偏移量 0x600 处（如图 189 所示）。镜像版本用 4 字节定义，低 2 字节为实际镜像版本号，高 2 字节为低 2 字节版本号的取反值。不遵循此规则的任何其他值都将被视为无效值。如果引导镜像版本无效，ROM 将完全不引导该镜像。</p><p>但如果镜像版本为全 0xFFFFFFFF（用户未编程镜像版本的情况），也将被视为有效值。当一个镜像版本为 0xFFFFFFFF，另一个为有效版本时，ROM 始终优先引导有效版本的镜像，而非 0xFFFFFFFF 的镜像。如果两个镜像版本均为 0xFFFFFFFF，ROM 始终引导 FlexSPI NOR 闪存设备中低地址的第一个镜像。</p><p>以下是引导镜像版本的一些示例：</p><ul><li><strong>0xFFFE0001</strong>：有效引导镜像版本，版本号为 1。</li><li><strong>0xFFFD0002</strong>：有效引导镜像版本，版本号为 2。</li><li><strong>0x00000003</strong>：无效引导镜像版本，不遵循版本规则。</li><li><strong>0xFFFFFFFF</strong>：有效镜像版本，但引导顺序较低。</li><li><strong>0x0000FFFF</strong>：有效镜像版本，版本号为最大 0xFFFF。</li></ul><h3 id="41-5-1-5-为-RT6xx-设备配置-FlexSPI-NOR-设备"><a href="#41-5-1-5-为-RT6xx-设备配置-FlexSPI-NOR-设备" class="headerlink" title="41.5.1.5 为 RT6xx 设备配置 FlexSPI NOR 设备"></a><strong>41.5.1.5 为 RT6xx 设备配置 FlexSPI NOR 设备</strong></h3><p>ROM 支持从外部 FlexSPI NOR 闪存设备引导镜像。本节介绍如何使用 blhost 工具将镜像编程到外部非易失性存储器中以进行引导。更多细节请参考第 41.8.16 节 “外部存储器支持”。blhost 工具通过 ROM ISP 模式使用 UART、SPI、I2C、USB HID 与 ROM 代码通信，RT6xx 上的引脚连接见表 1005。</p><h4 id="表-1005-blhost-工具通信的引脚分配"><a href="#表-1005-blhost-工具通信的引脚分配" class="headerlink" title="表 1005. blhost 工具通信的引脚分配"></a><strong>表 1005. blhost 工具通信的引脚分配</strong></h4><table><thead><tr><th>外设</th><th>端口</th><th>引脚</th></tr></thead><tbody><tr><td>USB</td><td>-</td><td>USB1_VBUS USB1_VDD1V8 USB1_VDD3V3 USB1_DM USB1_DP</td></tr><tr><td>SPI 从机</td><td>PIO1_11</td><td>HS_SPI_SCK (FC14)</td></tr><tr><td></td><td>PIO1_12</td><td>HS_SPI_MISO (FC14)</td></tr><tr><td></td><td>PIO1_13</td><td>HS_SPI_MOSI (FC14)</td></tr><tr><td></td><td>PIO1_14</td><td>HS_SPI_SSELN0 (FC14)</td></tr><tr><td>I2C 从机</td><td>PIO0_15</td><td>FC2_TXD_SCL_MISO</td></tr><tr><td></td><td>PIO0_16</td><td>FC2_RXD_SDA_MOSI</td></tr><tr><td>UART</td><td>PIO0_1</td><td>FC0_TXD_SCL_MISO</td></tr><tr><td></td><td>PIO0_2</td><td>FC0_RXD_SDA_MOSI</td></tr></tbody></table><h3 id="FlexSPI-NOR-闪存引导镜像编程"><a href="#FlexSPI-NOR-闪存引导镜像编程" class="headerlink" title="FlexSPI NOR 闪存引导镜像编程"></a><strong>FlexSPI NOR 闪存引导镜像编程</strong></h3><p>RT6xx ROM 支持从不同类型的 NOR 闪存（如连接到 FlexSPI 引脚的 Quad Flash、Octal Flash、Hyper Flash）引导，FlexSPI 引脚分配见表 1006。对于 FlexSPI NOR 引导，FCB 应编程在偏移量 0x08000400 处，引导镜像应编程在偏移量 0x08001000 处。以下部分将介绍如何为 5 种常见 NOR 闪存类型配置和编程引导镜像。</p><h4 id="表-1006-NOR-闪存连接的-FlexSPI-引脚分配"><a href="#表-1006-NOR-闪存连接的-FlexSPI-引脚分配" class="headerlink" title="表 1006. NOR 闪存连接的 FlexSPI 引脚分配"></a><strong>表 1006. NOR 闪存连接的 FlexSPI 引脚分配</strong></h4><table><thead><tr><th>外设</th><th>端口</th><th>引脚</th></tr></thead><tbody><tr><td>FlexSPI0 端口 A</td><td>PIO1_18</td><td>FLEXSPI0A_SCLK</td></tr><tr><td></td><td>PIO1_19</td><td>FLEXSPI0A_SS0_N</td></tr><tr><td></td><td>PIO1_20</td><td>FLEXSPI0A_DATA0</td></tr><tr><td></td><td>PIO1_21</td><td>FLEXSPI0A_DATA1</td></tr><tr><td></td><td>PIO1_22</td><td>FLEXSPI0A_DATA2</td></tr><tr><td></td><td>PIO1_23</td><td>FLEXSPI0A_DATA3</td></tr><tr><td></td><td>PIO1_24</td><td>FLEXSPI0A_DATA4</td></tr><tr><td></td><td>PIO1_25</td><td>FLEXSPI0A_DATA5</td></tr><tr><td></td><td>PIO1_26</td><td>FLEXSPI0A_DATA6</td></tr><tr><td></td><td>PIO1_27</td><td>FLEXSPI0A_DATA7</td></tr><tr><td></td><td>PIO1_28</td><td>FLEXSPI0A_DQS</td></tr><tr><td></td><td>PIO1_29</td><td>FLEXSPI0A_SS1_N</td></tr><tr><td>FlexSPI0 端口 B</td><td>PIO1_29</td><td>FLEXSPI0B_SCLK</td></tr><tr><td></td><td>PIO2_19</td><td>FLEXSPI0B_SS0_N</td></tr><tr><td></td><td>PIO1_11</td><td>FLEXSPI0B_DATA0</td></tr><tr><td></td><td>PIO1_12</td><td>FLEXSPI0B_DATA1</td></tr><tr><td></td><td>PIO1_13</td><td>FLEXSPI0B_DATA2</td></tr><tr><td></td><td>PIO1_14</td><td>FLEXSPI0B_DATA3</td></tr><tr><td></td><td>PIO2_17</td><td>FLEXSPI0B_DATA4</td></tr><tr><td></td><td>PIO2_18</td><td>FLEXSPI0B_DATA5</td></tr><tr><td></td><td>PIO2_22</td><td>FLEXSPI0B_DATA6</td></tr><tr><td></td><td>PIO2_23</td><td>FLEXSPI0B_DATA7</td></tr><tr><td></td><td>PIO2_21</td><td>FLEXSPI0B_SS1_N</td></tr></tbody></table><h3 id="41-5-1-5-2-FlexSPI-NOR-闪存配置参数"><a href="#41-5-1-5-2-FlexSPI-NOR-闪存配置参数" class="headerlink" title="41.5.1.5.2 FlexSPI NOR 闪存配置参数"></a><strong>41.5.1.5.2 FlexSPI NOR 闪存配置参数</strong></h3><p>不同 NOR 闪存需要不同的配置参数来启用和编程。以下是 NOR 闪存的配置参数定义。serial_nor_config_option_t 结构体的详细信息见表 1007、表 1008 和表 1009。</p><p>c</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">serial_nor_config_option</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">            <span class="type">uint32_t</span> max_freq : <span class="number">4</span>;     <span class="comment">//!&lt; 最大支持频率</span></span><br><span class="line">            <span class="type">uint32_t</span> misc_mode : <span class="number">4</span>;    <span class="comment">//!&lt; 杂项模式</span></span><br><span class="line">            <span class="type">uint32_t</span> quad_mode_setting : <span class="number">4</span>; <span class="comment">//!&lt; 四线模式设置</span></span><br><span class="line">            <span class="type">uint32_t</span> cmd_pads : <span class="number">4</span>;     <span class="comment">//!&lt; 命令焊盘</span></span><br><span class="line">            <span class="type">uint32_t</span> query_pads : <span class="number">4</span>;   <span class="comment">//!&lt; SFDP读取焊盘</span></span><br><span class="line">            <span class="type">uint32_t</span> device_type : <span class="number">4</span>;  <span class="comment">//!&lt; 设备类型</span></span><br><span class="line">            <span class="type">uint32_t</span> option_size : <span class="number">4</span>;  <span class="comment">//!&lt; 选项大小（以uint32_t为单位，大小=(option_size + 1)）</span></span><br><span class="line">            <span class="type">uint32_t</span> tag : <span class="number">4</span>;          <span class="comment">//!&lt; 标签，必须为0x0C</span></span><br><span class="line">        } B;</span><br><span class="line">        <span class="type">uint32_t</span> U;</span><br><span class="line">    } option0;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">            <span class="type">uint32_t</span> dummy_cycles : <span class="number">8</span>;    <span class="comment">//!&lt; 读取前的哑周期</span></span><br><span class="line">            <span class="type">uint32_t</span> status_override : <span class="number">8</span>; <span class="comment">//!&lt; 设备模式配置期间覆盖状态寄存器值</span></span><br><span class="line">            <span class="type">uint32_t</span> pinmux_group : <span class="number">4</span>;    <span class="comment">//!&lt; 引脚复用组选择</span></span><br><span class="line">            <span class="type">uint32_t</span> dqs_pinmux_group : <span class="number">4</span>;<span class="comment">//!&lt; DQS引脚复用组选择</span></span><br><span class="line">            <span class="type">uint32_t</span> drive_strength : <span class="number">4</span>;   <span class="comment">//!&lt; FlexSPI焊盘驱动强度</span></span><br><span class="line">            <span class="type">uint32_t</span> flash_connection : <span class="number">4</span>; <span class="comment">//!&lt; 闪存连接选项：0-单闪存连接到端口A，1-并行模式，2-单闪存连接到端口B</span></span><br><span class="line">        } B;</span><br><span class="line">        <span class="type">uint32_t</span> U;</span><br><span class="line">    } option1;</span><br><span class="line">} <span class="type">serial_nor_config_option_t</span>;</span><br></pre></td></tr></tbody></table></figure><h4 id="表-1007-serial-nor-config-option-t-定义"><a href="#表-1007-serial-nor-config-option-t-定义" class="headerlink" title="表 1007. serial_nor_config_option_t 定义"></a><strong>表 1007. serial_nor_config_option_t 定义</strong></h4><table><thead><tr><th>偏移量</th><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>Option0</td><td>详见 option0 定义。</td></tr><tr><td>4</td><td>Option1</td><td>可选，仅当 Option0 中的 option_size 字段非零时有效。详见 option1 定义。</td></tr></tbody></table><h4 id="表-1008-Option0-定义"><a href="#表-1008-Option0-定义" class="headerlink" title="表 1008. Option0 定义"></a><strong>表 1008. Option0 定义</strong></h4><table><thead><tr><th>字段</th><th>位</th><th>描述</th></tr></thead><tbody><tr><td>tag</td><td>31:28</td><td>配置选项标签，固定为 0x0C。</td></tr><tr><td>option_size</td><td>27:24</td><td>大小（字节）=(Option Size + 1) × 4。若仅需要 option0，则为 0。</td></tr><tr><td>device_type</td><td>23:20</td><td>设备检测类型： 0 - 读取 SFDP 用于 SDR 命令 1 - 读取 SFDP 用于 DDR 读取命令 2 - HyperFLASH 1V8 3 - HyperFLASH 3V 4 - Macronix Octal DDR 5 - Macronix Octal SDR 6 - Micron Octal DDR 7 - Micron Octal SDR 8 - Adesto EcoXiP DDR 9 - Adesto EcoXiP SDR</td></tr><tr><td>query_pad</td><td>19:16</td><td>查询命令（读取 SFDP 或 MID）期间的数据焊盘： 0 - 1 位 2 - 4 位 3 - 8 位</td></tr><tr><td>cmd_pad</td><td>15:12</td><td>闪存访问命令期间的数据焊盘： 0 - 1 位 2 - 4 位 3 - 8 位</td></tr></tbody></table><h3 id="表-1008-Option0-定义（续）"><a href="#表-1008-Option0-定义（续）" class="headerlink" title="表 1008. Option0 定义（续）"></a><strong>表 1008. Option0 定义（续）</strong></h3><table><thead><tr><th>字段</th><th>位</th><th>描述</th></tr></thead><tbody><tr><td>quad_mode_setting</td><td>11:8</td><td>四线模式使能设置： 0 - 未配置 1 - 设置状态寄存器 1 的位 6 2 - 设置状态寄存器 2 的位 1 3 - 设置状态寄存器 2 的位 7 4 - 通过 0x31 命令设置状态寄存器 2 的位 1 （此设置将闪存配置为 QPI 模式，用户代码必须将闪存重置为 SPI 模式，ROM 不会自动执行此操作。 注意：此字段仅适用于符合 JESD216 的设备（9 长字 SFDP 表））</td></tr><tr><td>misc_mode</td><td>7:4</td><td>杂项模式： 0 - 未启用 1 - 启用 0-4-4 模式以提高随机读取性能 3 - 数据顺序交换模式（仅适用于 MXIC OctaFlash） 5 - 选择 FlexSPI 数据采样源为内部环回（详见 FlexSPI 使用说明） 6 - 配置 FlexSPI NOR 闪存以标准 SPI 模式运行 （注意：实验性功能，产品中请勿使用，保持为 0。）</td></tr><tr><td>max_freq</td><td>3:0</td><td>最大闪存操作速度： 0 - 不更改 FlexSPI 时钟设置 其他值 - 见 FlexSPI 时钟设置熔丝图</td></tr></tbody></table><h4 id="表-1009-Option1-定义"><a href="#表-1009-Option1-定义" class="headerlink" title="表 1009. Option1 定义"></a><strong>表 1009. Option1 定义</strong></h4><table><thead><tr><th>字段</th><th>位</th><th>描述</th></tr></thead><tbody><tr><td>flash_connection</td><td>31:28</td><td>闪存连接选项： 0 - 单闪存连接到端口 A 1 - 并行模式 2 - 单闪存连接到端口 B</td></tr><tr><td>drive_strength</td><td>27:24</td><td>FlexSPI 焊盘驱动强度。</td></tr><tr><td>dqs_pinmux_group</td><td>23:20</td><td>DQS 引脚复用组选择。</td></tr><tr><td>pinmux_group</td><td>19:16</td><td>引脚复用组选择。</td></tr><tr><td>status_override</td><td>15:8</td><td>设备模式配置期间覆盖状态寄存器值。</td></tr><tr><td>dummy_cycles</td><td>7:0</td><td>读取命令的哑周期： 0 - 使用检测到的哑周期 其他值 - 闪存数据表中提供的哑周期数</td></tr></tbody></table><h3 id="41-5-1-5-3-NOR-闪存配置、擦除和编程"><a href="#41-5-1-5-3-NOR-闪存配置、擦除和编程" class="headerlink" title="41.5.1.5.3 NOR 闪存配置、擦除和编程"></a><strong>41.5.1.5.3 NOR 闪存配置、擦除和编程</strong></h3><p>以连接到 FlexSPI 端口 A 的 Macronix MX25L25645G 为例：</p><ol><li><p><strong>配置参数存储到 RAM</strong>：首先将配置参数存储在 RAM 中，供下一步配置 FlexSPI 使用。如图 192 所示，FlexSPI 的配置参数为 0xc0000002，该参数根据闪存类型选择。</p><p>bash</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\blhost\blhost&gt;blhost.exe -p com3 fill-memory 0x1c0004 0xc0000002</span><br><span class="line"><span class="comment"># 响应：成功注入命令，状态0（成功）</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>使用 RAM 中的参数配置 FlexSPI</strong>：如图 193 所示，配置完成后可读取、擦除、编程闪存。</p><p>bash</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\blhost\blhost&gt;blhost.exe -p com3 configure-memory 0x9 0x1c000</span><br><span class="line"><span class="comment"># 响应：成功配置内存，状态0（成功）</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>读取闪存</strong>：如图 194 所示，使用 blhost 工具读取闪存数据。</p><p>bash</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\blhost\blhost&gt;blhost.exe -p com3 read-memory 0x08000400 0x100</span><br><span class="line"><span class="comment"># 响应：读取256字节，状态0（成功）</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>擦除闪存</strong>：如图 195 所示，擦除指定区域。</p><p>bash</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\blhost\blhost&gt;blhost.exe -p com3 flash-erase-region 0x08000400 0x200</span><br><span class="line"><span class="comment"># 响应：成功擦除，状态0（成功）</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>编程引导镜像</strong>：如图 196 所示，将引导镜像写入闪存。</p><p>bash</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\blhost\blhost&gt;blhost.exe -p com3 write-memory 0x08001000 boot_image.bin</span><br><span class="line"><span class="comment"># 响应：写入5796字节，状态0（成功）</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>验证读取</strong>：如图 197 所示，读取已编程的镜像数据。</p><p>bash</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\blhost\blhost&gt;blhost.exe -p com3 read-memory 0x08001000 0x100</span><br><span class="line"><span class="comment"># 响应：读取256字节，显示镜像数据，状态0（成功）</span></span><br></pre></td></tr></tbody></table></figure></li></ol><h3 id="生成并编程-FlexSPI-NOR-FCB-到闪存"><a href="#生成并编程-FlexSPI-NOR-FCB-到闪存" class="headerlink" title="生成并编程 FlexSPI NOR FCB 到闪存"></a><strong>生成并编程 FlexSPI NOR FCB 到闪存</strong></h3><p>对于 FlexSPI 引导，需要在偏移量 0x08000400 处放置 FCB（闪存配置块），该 FCB 用于从外部 NOR 闪存通过 FlexSPI 接口引导镜像时配置 FlexSPI 接口。FCB 将根据之前的 FlexSPI 配置参数（如 0xc0000002）生成。</p><ol><li><p><strong>存储 FCB 生成参数到 RAM</strong>：如图 198 所示，将参数存入 RAM。</p><p>bash</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\blhost\blhost&gt;blhost.exe -p com3 fill-memory 0x1d0004 0xf000000f</span><br><span class="line"><span class="comment"># 响应：成功注入命令，状态0（成功）</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>生成并编程 FCB 到闪存</strong>：如图 199 所示，ROM 自动生成 FCB 并编程到偏移量 0x08000400 处。</p><p>bash</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\blhost\blhost&gt;blhost.exe -p com3 configure-memory 0x9 0x1d000</span><br><span class="line"><span class="comment"># 响应：成功配置，状态0（成功）</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>验证 FCB</strong>：如图 200 所示，读取 FCB 数据验证。</p><p>bash</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\blhost\blhost&gt;blhost.exe -p com3 read-memory 0x08000400 0x100</span><br><span class="line"><span class="comment"># 响应：读取FCB数据（如标签0x42464346等），状态0（成功）</span></span><br></pre></td></tr></tbody></table></figure></li></ol><h3 id="41-5-1-5-4-典型-NOR-闪存配置参数"><a href="#41-5-1-5-4-典型-NOR-闪存配置参数" class="headerlink" title="41.5.1.5.4 典型 NOR 闪存配置参数"></a><strong>41.5.1.5.4 典型 NOR 闪存配置参数</strong></h3><p>不同 NOR 闪存类型需要不同的配置参数，下表显示了一些典型闪存的配置参数。</p><h3 id="表-1010-典型-NOR-闪存配置参数（闪存连接到-FlexSPI-端口-A）"><a href="#表-1010-典型-NOR-闪存配置参数（闪存连接到-FlexSPI-端口-A）" class="headerlink" title="表 1010. 典型 NOR 闪存配置参数（闪存连接到 FlexSPI 端口 A）"></a><strong>表 1010. 典型 NOR 闪存配置参数（闪存连接到 FlexSPI 端口 A）</strong></h3><table><thead><tr><th>设备厂商</th><th>设备类型</th><th>闪存类型</th><th>配置参数</th><th>闪存模式</th><th>备注</th></tr></thead><tbody><tr><td>Aesto</td><td>Octal Flash</td><td>ATXP032</td><td>0xC0803006</td><td>DDR</td><td>ATXP032 有 3 个版本（REVA/B/C）。对于 REV A 版本，ROM 仅支持自动探测引导， OTP 熔丝字 BOOT_CFG [0] 应设为 0x7，且无需配置 FCB。</td></tr><tr><td>Spansion</td><td>Hyper Flash</td><td>S26KS512S</td><td>0xC0233006</td><td>DDR</td><td>对于 Hyper Flash 引导，引导前 BOOT_CFG [0] 应设为 0x20。</td></tr><tr><td>Macronix</td><td>Quad Flash</td><td>MX25L25645G</td><td>0xC0000002</td><td>SDR</td><td>-</td></tr><tr><td>Macronix</td><td>Quad Flash</td><td>MX25L25645G</td><td>0xC0100002</td><td>DDR</td><td>-</td></tr><tr><td>Macronix</td><td>Octal Flash</td><td>MX25UM51345G</td><td>0xC0403006</td><td>DDR</td><td>-</td></tr><tr><td>Micron</td><td>Octal Flash</td><td>MT35XL512ABA</td><td>0xC0603006</td><td>DDR</td><td>-</td></tr></tbody></table><h3 id="41-5-1-5-5-连接到-FlexSPI-端口-B-的典型-NOR-闪存配置参数"><a href="#41-5-1-5-5-连接到-FlexSPI-端口-B-的典型-NOR-闪存配置参数" class="headerlink" title="41.5.1.5.5 连接到 FlexSPI 端口 B 的典型 NOR 闪存配置参数"></a><strong>41.5.1.5.5 连接到 FlexSPI 端口 B 的典型 NOR 闪存配置参数</strong></h3><p>对于连接到 FlexSPI 端口 B 的闪存设备，配置时用户需指定参数以告知 ROM 闪存连接到端口 B。由于 FlexSPI 端口 B 没有 DQS 引脚，用户需根据闪存数据表为连接的闪存配置哑周期，参数存储在 Option1 中（见表 1009）。以下是配置连接到 FlexSPI 端口 B 的 MX25UM51345G 闪存的示例。</p><h4 id="表-1011-典型-NOR-闪存配置参数（闪存连接到-FlexSPI-端口-B）"><a href="#表-1011-典型-NOR-闪存配置参数（闪存连接到-FlexSPI-端口-B）" class="headerlink" title="表 1011. 典型 NOR 闪存配置参数（闪存连接到 FlexSPI 端口 B）"></a><strong>表 1011. 典型 NOR 闪存配置参数（闪存连接到 FlexSPI 端口 B）</strong></h4><table><thead><tr><th>设备厂商</th><th>设备类型</th><th>闪存类型</th><th>配置参数</th><th>闪存模式</th><th>备注</th></tr></thead><tbody><tr><td>Adesto</td><td>Octal Flash</td><td>ATXP032</td><td>0xC1903001 0x20000008</td><td>SDR</td><td>ATXP032 有 REVA/B/C 三个版本，REV A 仅支持自动探测引导，BOOT_CFG [0] 需设为 0x7，无需配置 FCB。</td></tr><tr><td>Macronix</td><td>Quad Flash</td><td>MX25L25645G</td><td>0xC1000001 0x20000008</td><td>SDR</td><td>-</td></tr><tr><td>Macronix</td><td>Octal Flash</td><td>MX25UM513(2)45G</td><td>0xC1503051 0x20000014</td><td>SDR</td><td>-</td></tr><tr><td>Micron</td><td>Octal Flash</td><td>MT35XL512ABA</td><td>0xC1703001 0x20000018</td><td>SDR</td><td>-</td></tr></tbody></table><p><strong>配置命令示例</strong>：</p><p>bash</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blhost.exe -p com3 fill-memory 0x1c000 4 0xC1503051    <span class="comment"># 配置Option1参数</span></span><br><span class="line">blhost.exe -p com3 fill-memory 0x1c004 4 0x20000014    <span class="comment"># 配置其他参数</span></span><br><span class="line">blhost.exe -p com3 configure-memory 0x9 0x1c000        <span class="comment"># 应用配置</span></span><br></pre></td></tr></tbody></table></figure><h3 id="41-5-1-6-为端口-B-连接的闪存启用八进制-DDR-模式"><a href="#41-5-1-6-为端口-B-连接的闪存启用八进制-DDR-模式" class="headerlink" title="41.5.1.6 为端口 B 连接的闪存启用八进制 DDR 模式"></a><strong>41.5.1.6 为端口 B 连接的闪存启用八进制 DDR 模式</strong></h3><p>考虑到 FlexSPI 性能和易用性，ROM 假定八进制闪存在 DDR 模式下始终使用 DQS 引脚。若支持外部 DQS 焊盘，FlexSPI IP 可自动检测哑周期数。使用配置选项配置设备时，不支持自定义八进制 DDR 读取的哑周期数，必须使用 DQS 焊盘。然而，RT6xx 系列的 FlexSPI 端口 B 没有 DQS 引脚。要在端口 B 上启用八进制 DDR 读取支持，用户必须准备完整的 FCB（闪存配置块）并在 LUT 中配置适当的哑周期。</p><p><strong>以 MX25UM51345G 为例</strong>：以下是用于在 FlexSPI 端口 B 上启用 DDR 模式的 FCB 二进制文件示例。请注意 FCB 中的两个字段需特别处理：</p><ul><li><strong>sflashA1Size</strong> 应设为 0x0，<strong>sflashB1Size</strong> 应设为外部闪存大小。</li><li><strong>FlexSPI LUT 表</strong> 需使用读取命令的正确哑周期更新。</li></ul><p><strong>图 201. 端口 B 连接的闪存启用八进制 DDR 模式示例</strong>（此处为 FCB 二进制数据示意图，具体数值需根据闪存规格配置）</p><p><strong>操作步骤</strong>：</p><ol><li><p>写入 FCB 二进制文件到 RAM：</p><p>bash</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blhost.exe -p comxx write-memory 0x1c000 MX25UM51345G_DDR_FCB.bin</span><br></pre></td></tr></tbody></table></figure></li><li><p>配置 FlexSPI 以应用 FCB：</p><p>bash</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blhost.exe -p comxx configure-memory 0x9 0x1c000</span><br></pre></td></tr></tbody></table></figure></li></ol><h3 id="41-5-2-SD-eMMC-引导"><a href="#41-5-2-SD-eMMC-引导" class="headerlink" title="41.5.2 SD/eMMC 引导"></a><strong>41.5.2 SD/eMMC 引导</strong></h3><p>引导加载程序支持将镜像从 SD/eMMC 加载到片上 SRAM，然后从片上 SRAM 引导。</p><h4 id="41-5-2-1-SD-eMMC-引导特性"><a href="#41-5-2-1-SD-eMMC-引导特性" class="headerlink" title="41.5.2.1 SD/eMMC 引导特性"></a><strong>41.5.2.1 SD/eMMC 引导特性</strong></h4><p>SD/eMMC 引导可通过 uSDHC 端口执行。引导加载程序支持以下标准卡类型（其他类型卡不保证支持）：</p><ul><li>eMMC 5.0 或更早版本</li><li>MMC 4.4 或更早版本</li><li>SD 3.0 或更早版本</li></ul><p>支持的标准模式：</p><ul><li>eMMC/MMC：4 位 / 8 位；全速率 SDR（26 MHz），高速 SDR/DDR（52 MHz）；</li><li>eMMC 4.4 或更高版本：支持快速引导。</li><li>SD：1 位 / 4 位；SDR12、SDR25、SDR50 和 SDR104。</li></ul><p>引导加载程序从 SD/eMMC 的固定地址加载用户应用镜像。为避免主引导记录（MBR）与用户应用镜像冲突，引导加载程序从 SD/eMMC 地址 4096（字节地址，块索引 8）加载镜像。</p><h3 id="41-5-2-2-OTP-中的-SD-eMMC-引导配置"><a href="#41-5-2-2-OTP-中的-SD-eMMC-引导配置" class="headerlink" title="41.5.2.2 OTP 中的 SD/eMMC 引导配置"></a><strong>41.5.2.2 OTP 中的 SD/eMMC 引导配置</strong></h3><p>与 SD/eMMC 引导相关的配置分配在 BOOT_CFG2 和 BOOT_CFG3 OTP 字中，分配详情见表 1002。</p><h4 id="表-1012-BOOT-CFG2-引导配置"><a href="#表-1012-BOOT-CFG2-引导配置" class="headerlink" title="表 1012. BOOT_CFG2 引导配置"></a><strong>表 1012. BOOT_CFG2 引导配置</strong></h4><table><thead><tr><th>字段名称</th><th>枚举名称</th><th>描述</th><th>偏移量</th><th>宽度</th><th>值</th></tr></thead><tbody><tr><td>SDHC_DEVICE_TYPE</td><td>-</td><td>连接到 SDHC 端口的设备类型： 0b - eMMC 设备 1b - SD 卡设备</td><td>0</td><td>1</td><td>-</td></tr><tr><td>SDHC_BUS_WIDTH</td><td>-</td><td>连接到 SDHC 的设备总线宽度： 00b - SD 卡使用 1 位数据总线，eMMC 使用 4 位 01b - SD 卡使用 4 位，eMMC 使用 8 位 10b - eMMC 使用 4 位 DDR 模式（需 SDHC_SPEED=HIGH） 11b - eMMC 使用 8 位 DDR 模式（需 SDHC_SPEED=HIGH）</td><td>1</td><td>2</td><td>-</td></tr><tr><td>SDHC_SPEED</td><td>-</td><td>eMMC 设备和 SD 卡的速度等级： 00b - 正常速度（eMMC）/SDR12（SD） 01b - 高速（eMMC）/SDR25（SD） 10b - SDR50（SD，需 SDHC_BUS_WIDTH=SD_4B_MMC_8B） 11b - SDR104（SD，需 SDHC_BUS_WIDTH=SD_4B_MMC_8B）</td><td>3</td><td>2</td><td>-</td></tr><tr><td>SDHC_PWR_CYCLE_EN</td><td>-</td><td>通过 USDHC_RST 焊盘启用 SDHC 电源循环： 0b - 禁用 1b - 启用</td><td>5</td><td>1</td><td>-</td></tr><tr><td>SDHC0_PWR_POL</td><td>-</td><td>SDHC0 端口电源使能信号极性： 0b - 高有效 1b - 低有效</td><td>6</td><td>1</td><td>-</td></tr><tr><td>SDHC1_PWR_POL</td><td>-</td><td>SDHC1 端口电源使能信号极性： 0b - 高有效 1b - 低有效</td><td>7</td><td>1</td><td>-</td></tr></tbody></table><h3 id="表-1012-BOOT-CFG2-引导配置（续）"><a href="#表-1012-BOOT-CFG2-引导配置（续）" class="headerlink" title="表 1012. BOOT_CFG2 引导配置（续）"></a><strong>表 1012. BOOT_CFG2 引导配置（续）</strong></h3><table><thead><tr><th>字段名称</th><th>枚举名称</th><th>描述</th><th>偏移量</th><th>宽度</th><th>值</th></tr></thead><tbody><tr><td>SDHC_PWR_CYCLE_WAIT</td><td>-</td><td>关闭 SDHC 设备电源后的等待时间： 00b - 20 毫秒 01b - 10 毫秒 10b - 5 毫秒 11b - 2.5 毫秒</td><td>8</td><td>2</td><td>-</td></tr><tr><td>SDHC_PWR_STABLE_WAIT</td><td>-</td><td>启用 SDHC 设备电源后电源稳定等待时间： 0b - 5 毫秒 1b - 2.5 毫秒</td><td>10</td><td>1</td><td>-</td></tr><tr><td>SDHC0_CARD_VOLTAGE</td><td>-</td><td>通过 USDHC_VSELECT 选择 SDHC0 电压： 0b - 3.3V 1b - 1.8V</td><td>11</td><td>1</td><td>-</td></tr><tr><td>SDHC1_CARD_VOLTAGE</td><td>-</td><td>通过 USDHC_VSELECT 选择 SDHC1 电压： 0b - 3.3V 1b - 1.8V</td><td>12</td><td>1</td><td>-</td></tr><tr><td>MMC_RESET_PRE_IDLE_STATE</td><td>-</td><td>启动引导模式前将 MMC 复位到预空闲状态： 0b - 复位到预空闲状态 1b - 不复位</td><td>13</td><td>1</td><td>-</td></tr><tr><td>SDHC_FASTBOOT_MODE</td><td>-</td><td>启用 eMMC 快速引导模式： 0b - 正常模式（传输模式） 1b - 引导模式</td><td>14</td><td>1</td><td>-</td></tr><tr><td>SDHC_FASTBOOT_ACK_EN</td><td>-</td><td>eMMC 快速引导确认功能： 0b - 禁用引导模式确认 1b - 启用引导模式确认</td><td>15</td><td>1</td><td>-</td></tr><tr><td>SDHC_PAD</td><td>-</td><td>SDHC 焊盘设置： 0b - 默认 SDIOPADCTL 1b - SDIOPADCTL=val（val 为自定义值）</td><td>16</td><td>1</td><td>-</td></tr></tbody></table><h4 id="表-1013-BOOT-CFG3-引导配置"><a href="#表-1013-BOOT-CFG3-引导配置" class="headerlink" title="表 1013. BOOT_CFG3 引导配置"></a><strong>表 1013. BOOT_CFG3 引导配置</strong></h4><table><thead><tr><th>字段名称</th><th>枚举名称</th><th>描述</th><th>偏移量</th><th>宽度</th><th>值</th></tr></thead><tbody><tr><td>SDHC_DLL_TUNING_OVERRIDE_ENABLE</td><td>-</td><td>DLL 延迟调整覆盖使能： 0 - 默认（DLL 延迟起始 10，步长 2） 1 - 通过 SDHC_DLL_TUNING_START 和 SDHC_DLL_TUNING_STEP 覆盖</td><td>7</td><td>1</td><td>-</td></tr><tr><td>SDHC_DLL_TUNING_START</td><td>-</td><td>DLL 延迟起始值（需 SDHC_DLL_TUNING_OVERRIDE_ENABLE=1）</td><td>8</td><td>8</td><td>-</td></tr><tr><td>SDHC_DLL_TUNING_STEP</td><td>-</td><td>DLL 延迟步长值（需 SDHC_DLL_TUNING_OVERRIDE_ENABLE=1）： 0 - 步长 = 1 非 0 - 步长 = val</td><td>16</td><td>3</td><td>-</td></tr></tbody></table><h3 id="41-5-2-3-SD-eMMC-引导流程"><a href="#41-5-2-3-SD-eMMC-引导流程" class="headerlink" title="41.5.2.3 SD/eMMC 引导流程"></a><strong>41.5.2.3 SD/eMMC 引导流程</strong></h3><p>图 202 说明了 SD/eMMC 的简要引导流程。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RT600-RM-CH41：RT6xx-非安全BootROM-3&quot;&gt;&lt;a href=&quot;#RT600-RM-CH41：RT6xx-非安全BootROM-3&quot; class=&quot;headerlink&quot; title=&quot;RT600 RM CH41：RT6xx 非安全BootROM (3)&quot;&gt;&lt;/a&gt;RT600 RM CH41：RT6xx 非安全BootROM (3)&lt;/h1&gt;&lt;h2 id=&quot;41-4-引导模式&quot;&gt;&lt;a href=&quot;#41-4-引导模式&quot; class=&quot;headerlink&quot; title=&quot;41.4 引导模式&quot;&gt;&lt;/a&gt;41.4 引导模式&lt;/h2&gt;&lt;p&gt;ROM 引导加载程序支持以下引导模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Master Boot 模式&lt;/li&gt;
&lt;li&gt;Recovery Boot 模式&lt;/li&gt;
&lt;li&gt;Serial Boot 模式&lt;/li&gt;
&lt;li&gt;ISP Boot 模式&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT600" scheme="https://dustofstars.github.io/categories/NXP/RT600/"/>
    
    <category term="BootROM" scheme="https://dustofstars.github.io/categories/NXP/RT600/BootROM/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="RT600" scheme="https://dustofstars.github.io/tags/RT600/"/>
    
    <category term="BootROM" scheme="https://dustofstars.github.io/tags/BootROM/"/>
    
  </entry>
  
  <entry>
    <title>RT600 BootROM RM解析 (2)</title>
    <link href="https://dustofstars.github.io/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-2/"/>
    <id>https://dustofstars.github.io/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-2/</id>
    <published>2025-05-19T09:10:09.000Z</published>
    <updated>2025-05-19T09:10:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RT600-RM-CH41：RT6xx-非安全启动-ROM-2"><a href="#RT600-RM-CH41：RT6xx-非安全启动-ROM-2" class="headerlink" title="RT600 RM CH41：RT6xx 非安全启动 ROM(2)"></a>RT600 RM CH41：RT6xx 非安全启动 ROM(2)</h1><h2 id="41-3-概述"><a href="#41-3-概述" class="headerlink" title="41.3 概述"></a>41.3 概述</h2><p>内部 ROM 存储器用于存储启动代码。复位后，ARM 处理器从该存储器开始执行代码。每次器件上电或复位时，都会执行BootROM代码。</p><p>由于 RT6xx 没有用于代码和数据存储的内部 Flash，因此必须将image存储在其他位置，以便在复位时下载，或者 CPU 可以从外部存储器（XIP）执行。image可以从外部 Flash 加载到片上 SRAM 中，也可以通过串行端口（UART、SPI、I2C、USB）下载。然后对代码进行验证，引导 ROM 会将向量指向片上 SRAM。</p><p><span style="color: red; font-weight: bold; ">引导加载程序根据 OTP 位和 ISP 引脚的值，以及image header类型定义，决定是将代码下载到片上 SRAM 中还是从外部存储器运行。</span></p><ul><li>BootROM 首先检查 OTP 位设置，然后检查 ISP 引脚。</li><li><span style="color: green;"><u>如果 OTP 字 BOOT_CFG [0] 中的位 [3:0] 未编程（4b’0000），则引导源由 ISP 引导引脚（PIO1_15、PIO1_16 和 PIO1_17）的状态决定</u></span>，见表 994。</li></ul><span id="more"></span><p><strong>表 994. 基于 BOOT_CFG [0] 中 PRIMARY_BOOT_SRC 位的主引导源</strong></p><table><thead><tr><th>引导模式字段</th><th>字段</th><th>主引导源（又称主引导源）</th></tr></thead><tbody><tr><td>ISP_PIN_BOOT</td><td>b’0000</td><td><span style="color: red;">ISP 引脚将决定引导源。</span></td></tr><tr><td>FLEXSPI_BOOT_PORT_A</td><td>b’0001</td><td>从 FlexSPI0 端口 A 的八 / 四路 SPI 闪存设备引导。</td></tr><tr><td>SDHC0_BOOT</td><td>b’0010</td><td>从连接到 SDHC0 端口的 eMMC 设备或 SD 卡引导。</td></tr><tr><td>SDHC1_BOOT</td><td>b’0011</td><td>从连接到 SDHC1 端口的 eMMC 设备或 SD 卡引导。</td></tr><tr><td>SPI_SLV_BOOT</td><td>b’0100</td><td>通过使用主引导模式的 SPI 从接口引导。</td></tr><tr><td>FLEXSPI_BOOT_PORT_B</td><td>b’0101</td><td>从 FlexSPI0 端口 B 的八 / 四路 SPI 闪存设备引导。</td></tr><tr><td>UART_BOOT</td><td>b’0110</td><td>通过使用主引导模式的 UART 接口引导。</td></tr><tr><td>SPI_FLASH_BOOT</td><td>b’0111</td><td>通过 SPI 接口从 1 位 NOR 闪存引导。使用的 SPI 实例由熔丝字 0x60 的位 17 到 19 选择，更多细节请参考熔丝图。</td></tr><tr><td>USB_HID</td><td>b’1000</td><td>通过使用主引导模式的 USB HID 接口引导。</td></tr><tr><td>ISP_BOOT</td><td>b’0101</td><td>进入 ISP 模式，熔丝字 0x60 的位 4 到 6 决定 ISP 模式使用的外设，更多细节请参考熔丝图。</td></tr><tr><td>–</td><td>b’1010</td><td>保留</td></tr><tr><td>FLEXSPI_REC_BOOT_PORT_B</td><td>b’1011</td><td>从 FlexSPI0 端口 B 的八 / 四路 SPI 闪存设备引导；如果未找到image，则通过 FlexComm 使用 SPI 闪存设备检查恢复引导。使用的 FlexComm 实例由熔丝字 0x60 的位 17 到 19 选择，更多细节请参考熔丝图。</td></tr><tr><td>FLEXSPI_REC_BOOT_PORT_A</td><td>b’1100</td><td>从 FlexSPI0 端口 A 的八 / 四路 SPI 闪存设备引导；如果未找到image，则通过 FlexComm 使用 SPI 闪存设备检查恢复引导。使用的 FlexComm 实例由熔丝字 0x60 的位 17 到 19 选择，更多细节请参考熔丝图。</td></tr><tr><td>SDHC0_REC_BOOT</td><td>b’1101</td><td>从 SDHC0 端口设备引导。如果未找到image，则通过 FlexComm 使用 SPI 闪存设备检查恢复引导。使用的 FlexComm 实例由熔丝字 0x60 的位 17 到 19 选择，更多细节请参考熔丝图。</td></tr><tr><td>SDHC1_REC_BOOT</td><td>b’1110</td><td>从 SDHC1 端口设备引导。如果未找到image，则通过 FlexComm 使用 SPI 闪存设备检查恢复引导。使用的 FlexComm 实例由熔丝字 0x60 的位 17 到 19 选择，更多细节请参考熔丝图。</td></tr><tr><td>–</td><td>b’1111</td><td>保留</td></tr></tbody></table><p>如果未设置 <code>PRIMARY_BOOT_SRC</code> 位，RT6xx 将读取 ISP 引脚的状态以确定引导源。见表 995。</p><p><strong>表 995. 基于 ISP 引脚的引导模式和 ISP 下载器模式</strong></p><table><thead><tr><th>引导模式</th><th>ISP2 引脚<br>PIO1_17</th><th>ISP1 引脚<br>PIO1_16</th><th>ISP0 引脚<br>PIO1_15</th><th>描述</th></tr></thead><tbody><tr><td>-</td><td>低</td><td>低</td><td>低</td><td>保留</td></tr><tr><td>SDIO0（SD 卡）</td><td>低</td><td>低</td><td>高</td><td><span style="color: red;">从连接到 SDIO 1 接口的 SD 卡设备引导。</span>RT6xx 将在 SD 卡设备中查找有效image。如果未找到有效image，RT6xx 将根据表 1114“BOOT_CFG [0] 位字段” 中定义的 OTP DEFAULT_ISP_MODE 位（6:4，BOOT_CFG [0]）进入 ISP 引导模式。</td></tr><tr><td>FlexSPI 从端口 B 引导</td><td>低</td><td>高</td><td>低</td><td>从连接到 FlexSPI 接口 0 端口 B 的四路或八路 SPI 闪存设备引导。RT6xx 将在外部四路 / 八路 SPI 闪存设备中查找有效image。如果未找到有效image，RT6xx 将进入恢复引导或 ISP 引导模式。</td></tr><tr><td>FlexSPI 从端口 A 引导</td><td>低</td><td>高</td><td>高</td><td>从连接到 FlexSPI 接口 0 端口 A 的四路或八路 SPI 闪存设备引导。RT6xx 将在外部四路 / 八路 SPI 闪存设备中查找有效image。如果未找到有效image，RT6xx 将进入恢复引导或 ISP 引导模式。</td></tr><tr><td>SDIO 0（eMMC）</td><td>高</td><td>低</td><td>低</td><td><span style="color: red; ">从连接到 SDIO 0 接口的 eMMC 设备引导</span>。RT6xx 将在 eMMC 设备中查找有效image。如果未找到有效image，RT6xx 将根据表 1114“BOOT_CFG [0] 位字段” 中定义的 OTP DEFAULT_ISP_MODE 位（6:4，BOOT_CFG [0]）的值进入 ISP 引导模式。</td></tr><tr><td>-</td><td>高</td><td>低</td><td>高</td><td>保留</td></tr><tr><td>串行 ISP（UART、SPI、I2C、USB-HID）</td><td>高</td><td>高</td><td>低</td><td>串行接口（UART、SPI 和 I2C、USB-HID）用于对 OTP、外部 Flash、SD 或 eMMC 设备进行编程。</td></tr><tr><td>111</td><td>高</td><td>高</td><td>高</td><td>串行主引导（SPI 从机、I2C 从机或 UART、USB-HID）用于通过串行接口（SPI 从机、I2C 从机或 UART、USB-HID）下载引导image。</td></tr></tbody></table><p>表 996 列出了 ISP 引脚分配，这些是 ROM 代码使用的默认引脚分配，无法更改。</p><p><strong>表 996. ISP 引脚分配</strong></p><table><thead><tr><th>引导接口</th><th>引脚 (s)</th><th>功能 / 注释</th></tr></thead><tbody><tr><td><strong>FlexSPI0 端口 A</strong></td><td>PIO1_18</td><td>FLEXSPI0A_SCLK</td></tr><tr><td></td><td>PIO1_19</td><td>FLEXSPI0A_SS0_N</td></tr><tr><td></td><td>PIO1_20</td><td>FLEXSPI0A_DATA0</td></tr><tr><td></td><td>PIO1_21</td><td>FLEXSPI0A_DATA1</td></tr><tr><td></td><td>PIO1_22</td><td>FLEXSPI0A_DATA2</td></tr><tr><td></td><td>PIO1_23</td><td>FLEXSPI0A_DATA3</td></tr><tr><td></td><td>PIO1_24</td><td>FLEXSPI0A_DATA4</td></tr><tr><td></td><td>PIO1_25</td><td>FLEXSPI0A_DATA5</td></tr><tr><td></td><td>PIO1_26</td><td>FLEXSPI0A_DATA6</td></tr><tr><td></td><td>PIO1_27</td><td>FLEXSPI0A_DATA7</td></tr><tr><td></td><td>PIO1_28</td><td>FLEXSPI0A_DQS</td></tr><tr><td></td><td>PIO1_29</td><td>FLEXSPI0A_SS1_N</td></tr><tr><td><strong>FlexSPI0 端口 B</strong></td><td>PIO1_29</td><td>FLEXSPI0B_SCLK</td></tr><tr><td></td><td>PIO2_19</td><td>FLEXSPI0B_SS0_N</td></tr><tr><td></td><td>PIO1_11</td><td>FLEXSPI0B_DATA0</td></tr><tr><td></td><td>PIO1_12</td><td>FLEXSPI0B_DATA1</td></tr><tr><td></td><td>PIO1_13</td><td>FLEXSPI0B_DATA2</td></tr><tr><td></td><td>PIO1_14</td><td>FLEXSPI0B_DATA3</td></tr><tr><td></td><td>PIO2_17</td><td>FLEXSPI0B_DATA4</td></tr><tr><td></td><td>PIO2_18</td><td>FLEXSPI0B_DATA5</td></tr><tr><td></td><td>PIO2_22</td><td>FLEXSPI0B_DATA6</td></tr><tr><td></td><td>PIO2_23</td><td>FLEXSPI0B_DATA7</td></tr><tr><td></td><td>PIO2_21</td><td>FLEXSPI0B_SS1_N</td></tr><tr><td><strong>USB</strong></td><td>USB1_VBUS</td><td></td></tr><tr><td></td><td>VDD1V8</td><td></td></tr><tr><td></td><td>USB1_VDD3V3</td><td></td></tr><tr><td></td><td>USB1_DM</td><td></td></tr><tr><td></td><td>USB1_DP</td><td></td></tr><tr><td><strong>SPI 从机</strong></td><td>PIO1_11</td><td>HS_SPI_SCK（Flexcomm 14）</td></tr><tr><td></td><td>PIO1_12</td><td>HS_SPI_MISO（Flexcomm14）</td></tr><tr><td></td><td>PIO1_13</td><td>HS_SPI_MOSI（Flexcomm14）</td></tr><tr><td></td><td>PIO1_14</td><td>HS_SPI_SSEL0（Flexcomm14）</td></tr><tr><td><strong>I2C 从机</strong></td><td>PIO0_15</td><td>FC2_TXD_SCL_MISO_WS</td></tr><tr><td></td><td>PIO0_16</td><td>FC2_RXD_SDA_MOSI_DATA</td></tr><tr><td><strong>UART</strong></td><td>PIO0_1</td><td>FC0_TXD_SCL_MISO_WS</td></tr><tr><td></td><td>PIO0_2</td><td>FC0_RXD_SDA_MOSI_DATA</td></tr></tbody></table><p><strong>表 996. ISP 引脚分配（续）</strong></p><table><thead><tr><th>引导接口</th><th>引脚 (s)</th><th>功能 / 注释</th></tr></thead><tbody><tr><td><strong>SDIO0</strong></td><td>PIO1_30</td><td>SD0_CLK</td></tr><tr><td></td><td>PIO1_31</td><td>SD0_CMD</td></tr><tr><td></td><td>PIO2_0</td><td>SD0_D[0]</td></tr><tr><td></td><td>PIO2_1</td><td>SD0_D[1]</td></tr><tr><td></td><td>PIO2_2</td><td>SD0_D[2]</td></tr><tr><td></td><td>PIO2_3</td><td>SD0_D[3]</td></tr><tr><td></td><td>PIO2_4</td><td>SD0_WR_PRT</td></tr><tr><td></td><td>PIO2_5</td><td>SD0_D[4]</td></tr><tr><td></td><td>PIO2_6</td><td>SD0_D[5]</td></tr><tr><td></td><td>PIO2_7</td><td>SD0_D[6]</td></tr><tr><td></td><td>PIO2_8</td><td>SD0_D[7]</td></tr><tr><td></td><td>PIO2_9</td><td>SD0_CARD_DET_N</td></tr><tr><td></td><td>PIO2_10</td><td>SD0_RESET_N</td></tr><tr><td></td><td>PIO2_11</td><td>SD0_VOLT</td></tr><tr><td><strong>SDIO1</strong></td><td>PIO3_8</td><td>SD1_CLK</td></tr><tr><td></td><td>PIO3_9</td><td>SD1_CMD</td></tr><tr><td></td><td>PIO3_10</td><td>SD1_D[0]</td></tr><tr><td></td><td>PIO3_11</td><td>SD1_D[1]</td></tr><tr><td></td><td>PIO3_12</td><td>SD1_D[2]</td></tr><tr><td></td><td>PIO3_13</td><td>SD1_D[3]</td></tr><tr><td></td><td>PIO3_14</td><td>SD1_WR_PRT</td></tr><tr><td></td><td>PIO3_15</td><td>SD1_D[4]</td></tr><tr><td></td><td>PIO3_16</td><td>SD1_D[5]</td></tr><tr><td></td><td>PIO3_17</td><td>SD1_D[6]</td></tr><tr><td></td><td>PIO3_18</td><td>SD1_D[7]</td></tr><tr><td></td><td>PIO3_19</td><td>SD1_CARD_DET_N</td></tr><tr><td></td><td>PIO3_20</td><td>SD1_RESET_N</td></tr><tr><td></td><td>PIO3_21</td><td>SD1_VOLT</td></tr><tr><td><strong>SPI 闪存（恢复引导）</strong></td><td>-</td><td>用于恢复 SPI 闪存引导的 Flexcomm 端口。</td></tr><tr><td></td><td>FC0</td><td>使用 Flexcomm0 引脚 PIO0_0（SCK）、PIO0_1（MISO）、PIO0_2（MOSI）、PIO0_3（SSEL）</td></tr><tr><td></td><td>FC1</td><td>使用 Flexcomm1 引脚 PIO0_7（SCK）、PIO0_8（MISO）、PIO0_9（MOSI）、PIO0_10（SSEL）[1]</td></tr><tr><td></td><td>FC2</td><td>使用 Flexcomm2 引脚 PIO0_14（SCK）、PIO0_15（MISO）、PIO0_16（MOSI）、PIO0_17（SSEL）</td></tr><tr><td></td><td>FC3</td><td>使用 Flexcomm3 引脚 PIO0_21（SCK）、PIO0_22（MISO）、PIO0_23（MOSI）、PIO0_24（SSEL）</td></tr><tr><td></td><td>FC4</td><td>使用 Flexcomm4 引脚 PIO0_28（SCK）、PIO0_29（MISO）、PIO0_30（MOSI）、PIO0_31（SSEL）</td></tr><tr><td></td><td>FC5</td><td>使用 Flexcomm5 引脚 PIO1_3（SCK）、PIO1_4（MISO）、PIO1_5（MOSI）、PIO1_6（SSEL）</td></tr><tr><td></td><td>FC6</td><td>使用 Flexcomm6 引脚 PIO3_25（SCK）、PIO3_26（MISO）、PIO3_27（MOSI）、PIO3_28（SSEL）</td></tr><tr><td></td><td>FC7</td><td>使用 Flexcomm 7 引脚 PIO4_0（SCK）、PIO4_1（MISO）、PIO4_2（MOSI）、PIO4_3（SSEL）</td></tr><tr><td><strong>ISP</strong></td><td>PIO1_17</td><td>ISP 选择位 2</td></tr><tr><td></td><td>PIO1_16</td><td>ISP 选择位 1</td></tr><tr><td></td><td>PIO1_15</td><td>ISP 选择位 0</td></tr></tbody></table><p>[1] 注：<span style="color: green;">SPI 闪存恢复引导引脚功能与 JTAG 边界扫描功能复用。为确保不会意外进入边界扫描模式，应使用弱下拉电阻（100 kohm）将 TRST 引脚外部拉低，以确保 SPI 闪存恢复引导操作正常。</span></p><style>.ehxbcfyflhmf{zoom:80%;}</style><img src="/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-2/TopLevelBootFlow.png" class="ehxbcfyflhmf" alt="TopLevelBootFlow"><p><strong>图 187. 顶层引导流程</strong></p><p>图 187 显示了顶层引导流程。引导流程在复位释放后开始。CPU 时钟由 OTP 字段 <code>BOOT_CLK_SPEED</code> 决定，<span style="color: red; font-weight: bold; ">默认情况下为来自 IRC48M 时钟源的 48 MHz</span>。如果 <code>PRIMARY_BOOT_SRC</code> = 4b’0000，引导 ROM 将根据 <code>PRIMARY_BOOT_SRC</code> 或复位期间 ISP 引脚的状态确定引导模式。当 Cortex-M33 启动引导加载程序时，SWD 访问将被禁用，直到引导image开始执行或引导加载程序进入 ISP 模式。</p><p>一旦确定引导模式，并且在所选外部 Flash 设备（SD、eMMC 或串行 NOR Flash）上存在引导image，ROM 引导加载程序将开始<span style="color: red; font-weight: bold; ">将image 头的前 64 字节</span>从外部 Flash 设备复制到片上 SRAM 中。image的开头遵循表 997 中提到的格式。如果boot image通过串行接口（通过 UART、SPI 或 USB）下载，则包括image头在内的整个image已加载到 SRAM 中。</p><p>BootROM 检查以下内容以确保image完整性：</p><ul><li>使用头和image标记验证image。</li><li>使用 CRC32 验证image（如果image头中启用了 CRC 检查功能）。</li></ul><p>引导加载程序通过检查位于偏移量 <code>0x24</code>（<code>imageType</code>）的image类型开始扫描用户image。如果检测到有效image类型，则开始验证image头。通过读取image头中偏移量 <code>0x34</code>（<code>imageLoadAddress</code>）处的image加载地址并将其<span style="color: red; font-weight: bold; ">用作指向有效image头结构的指针</span>，继续对image头进行鉴定。如果 imageType 和 imageLoadAddress 均不为零，则 imageLoadAddress 指向的地址必须包含正在检查的image头。</p><p>image头验证完成后，通过检查image类型字段继续进行鉴定。更多详细信息请参见表 998。<span style="color: green;">如果可引导（非 XIP）image位于外部闪存中，整个image将首先加载到片上 SRAM 中，然后如果启用了 CRC 校验功能，将使用image头中的 imageLength 字段作为长度来执行 CRC 校验。</span></p><p>如果 CRC 功能启用，将对image（片上或外部 XIP image）执行 CRC 校验。CRC 计算从image起始偏移 0x0 处开始，持续到 imageLength 字段指定的字节数（不包括 crcChecksum 字段）。CRC 计算完成后，通过将结果与image头中的 crcChecksum 字段进行比较来确定image有效性：若匹配，则判定image有效，否则判定为无效。</p><p><strong>表 997. image header 格式</strong></p><table><thead><tr><th>偏移量</th><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>0x00-0x1F</td><td>保留</td><td>-</td></tr><tr><td>0x20</td><td>imageLength</td><td>image长度</td></tr><tr><td>0x24</td><td>imageType</td><td>image类型 <br>0x0000 - 普通image <br>0x0001 - 普通签名image <br>0x0002 - 普通 CRC image <br>0x0003 - 加密签名image <br>0x0004 - 普通签名 XIP image <br>0x0005 - 普通 CRC XIP image <br>0x8001 - 包含KeyStore的普通签名image<br>0x8003 - 包含KeyStore的加密签名image</td></tr><tr><td>0x28</td><td>authBlockOffset/crcChecksum</td><td>认证块偏移量 或 CRC32 校验和</td></tr><tr><td>0x2C-0x33</td><td>保留</td><td>-</td></tr><tr><td>0x34</td><td><code>imageLoadAddress</code></td><td>image加载地址</td></tr><tr><td>0x38-0x3F</td><td>保留</td><td>-</td></tr></tbody></table><p><strong>表 998. Plain image布局</strong></p><table><thead><tr><th>偏移量</th><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>0x00</td><td>堆栈指针 Stack Pointer</td><td>普通 CM33 内核异常处理程序</td></tr><tr><td>0x04</td><td>复位处理程序 Reset Handler</td><td></td></tr><tr><td>0x08</td><td>NMI_Handler</td><td>不可屏蔽中断处理程序</td></tr><tr><td>0x0C</td><td>HardFault_Handler</td><td>硬错误处理程序</td></tr><tr><td>0x10</td><td>MemManage_Handler</td><td>内存管理错误处理程序</td></tr><tr><td>0x14</td><td>BusFault_Handler</td><td>总线错误处理程序</td></tr><tr><td>0x18</td><td>UsageFault_Handler</td><td>使用错误处理程序</td></tr><tr><td>0x1C</td><td>SecureFault_Handler</td><td>安全错误处理程序</td></tr><tr><td>0x20</td><td><code>imageLength</code></td><td>image长度</td></tr><tr><td>0x24</td><td><code>imageType</code></td><td>image类型 0x0000 - 普通image 0x0001 - 普通签名image 0x0002 - 普通 CRC image 0x0004 - 普通签名 XIP image 0x0005 - 普通 CRC XIP image 0x8001 - 包含密钥存储的普通签名image</td></tr><tr><td>0x28</td><td>authBlockOffset</td><td>认证块偏移量或 CRC32 校验和</td></tr><tr><td>0x2C</td><td>SVC Handler</td><td>普通 CM33 内核异常处理程序</td></tr><tr><td>0x30</td><td>DebugMon_Handler</td><td>调试监控处理程序</td></tr><tr><td>0x34</td><td><code>imageLoadAddress</code></td><td>image加载地址 <br><strong>注</strong>：imageLoadAddress 必须 ≥ <code>0x1C000</code>。<br>地址 0x0 - 0x1BFFF 由 ROM 使用，直至用户代码启动。</td></tr><tr><td>0x38</td><td>PendSV_Handler</td><td>PendSV 处理程序（普通 CM33 内核异常处理程序）</td></tr><tr><td>0x3C</td><td>SysTick_Handler</td><td>系统滴答定时器处理程序</td></tr></tbody></table><p><strong>表 999. XIP 镜像布局（FlexSPI）</strong></p><table><thead><tr><th>偏移量</th><th>宽度（字节）</th><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>0x0000_0000</td><td>256</td><td><span style="color: red; font-weight: bold; ">KeyBlob用于 OTFAD</span></td><td>可选。若未启用 OTFAD，则全部编程为 0x00。</td></tr><tr><td><code>0x0000_0400</code></td><td>512</td><td>闪存配置块（FCB）</td><td>OSPI 闪存配置块。若 OTP 中的 <code>FLEXSPI_AUTO_PROBE_EN</code> 未熔断，则需要此块。</td></tr><tr><td>0x0000_0600</td><td>4</td><td>Boot image version</td><td>使用双镜像乒乓引导时，此字段用于存储引导镜像版本。更多细节请参考 FlexSPI 引导。</td></tr><tr><td><code>0x0000_0800</code></td><td>2048</td><td>KeyStore</td><td>固定 KeyStore 字段。若启用 KeyStore 功能，则需要此字段。</td></tr><tr><td><code>0x0000_1000</code></td><td>image大小</td><td>Bootable image</td><td>引导镜像，以有效image header开始。</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RT600-RM-CH41：RT6xx-非安全启动-ROM-2&quot;&gt;&lt;a href=&quot;#RT600-RM-CH41：RT6xx-非安全启动-ROM-2&quot; class=&quot;headerlink&quot; title=&quot;RT600 RM CH41：RT6xx 非安全启动 ROM(2)&quot;&gt;&lt;/a&gt;RT600 RM CH41：RT6xx 非安全启动 ROM(2)&lt;/h1&gt;&lt;h2 id=&quot;41-3-概述&quot;&gt;&lt;a href=&quot;#41-3-概述&quot; class=&quot;headerlink&quot; title=&quot;41.3 概述&quot;&gt;&lt;/a&gt;41.3 概述&lt;/h2&gt;&lt;p&gt;内部 ROM 存储器用于存储启动代码。复位后，ARM 处理器从该存储器开始执行代码。每次器件上电或复位时，都会执行BootROM代码。&lt;/p&gt;
&lt;p&gt;由于 RT6xx 没有用于代码和数据存储的内部 Flash，因此必须将image存储在其他位置，以便在复位时下载，或者 CPU 可以从外部存储器（XIP）执行。image可以从外部 Flash 加载到片上 SRAM 中，也可以通过串行端口（UART、SPI、I2C、USB）下载。然后对代码进行验证，引导 ROM 会将向量指向片上 SRAM。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: red; font-weight: bold; &quot;&gt;引导加载程序根据 OTP 位和 ISP 引脚的值，以及image header类型定义，决定是将代码下载到片上 SRAM 中还是从外部存储器运行。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BootROM 首先检查 OTP 位设置，然后检查 ISP 引脚。&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: green;&quot;&gt;&lt;u&gt;如果 OTP 字 BOOT_CFG [0] 中的位 [3:0] 未编程（4b’0000），则引导源由 ISP 引导引脚（PIO1_15、PIO1_16 和 PIO1_17）的状态决定&lt;/u&gt;&lt;/span&gt;，见表 994。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT600" scheme="https://dustofstars.github.io/categories/NXP/RT600/"/>
    
    <category term="BootROM" scheme="https://dustofstars.github.io/categories/NXP/RT600/BootROM/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="RT600" scheme="https://dustofstars.github.io/tags/RT600/"/>
    
    <category term="BootROM" scheme="https://dustofstars.github.io/tags/BootROM/"/>
    
  </entry>
  
  <entry>
    <title>RT600 BootROM RM解析 (1)</title>
    <link href="https://dustofstars.github.io/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-1/"/>
    <id>https://dustofstars.github.io/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-1/</id>
    <published>2025-05-19T09:09:07.000Z</published>
    <updated>2025-05-19T09:09:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RT600-RM-CH41：RT6xx-非安全BootROM-1"><a href="#RT600-RM-CH41：RT6xx-非安全BootROM-1" class="headerlink" title="RT600 RM CH41：RT6xx 非安全BootROM (1)"></a>RT600 RM CH41：RT6xx 非安全BootROM (1)</h1><span id="more"></span><blockquote><style>.thgsgvehlghq{zoom:150%;}</style><img src="/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-1/image-20250519170750865.png" class="thgsgvehlghq" alt="image-20250519170750865"></blockquote><h2 id="41-1-如何阅读本章"><a href="#41-1-如何阅读本章" class="headerlink" title="41.1 如何阅读本章"></a>41.1 如何阅读本章</h2><p>本章适用于所有 RT6xx 器件。</p><h3 id="41-1-1-RT6xx-上的BootROM-有什么作用"><a href="#41-1-1-RT6xx-上的BootROM-有什么作用" class="headerlink" title="41.1.1 RT6xx 上的BootROM 有什么作用"></a>41.1.1 RT6xx 上的BootROM 有什么作用</h3><p>RT6xx 是一种无内部闪存的 MCU，因此在 MCU 启动前，启动镜像需要存储在外部非易失性启动介质中。读取启动镜像时，需要BootROM 支持访问外部非易失性存储。RT6xx BootROM 支持从外部非易失性存储器（如串行 NOR FLASH、SD 卡、eMMC 设备）启动。</p><p>BootROM 固定了 FlexSPI 模块（串行 NOR 闪存）/ uSDHC 模块（SD/eMMC 存储器）与 MCU 器件之间的外部存储设备引脚连接。因此，设计应用板时，必须为启动接口提供正确的引脚连接。有关引脚连接和其他细节，请参考 41.5 节 “主启动模式”。</p><p>由于 RT6xx 支持三种不同的启动设备，ROM 需要一种方式来决定从哪个设备启动。在 RT6xx ROM 中，通过 ISP 引脚（PIO1_17（ISP2）、PIO1_16（ISP1）、PIO1_15（ISP0））或 OTP 熔丝字 0x60 配置选择启动设备。</p><p>基于 ISP 引脚的启动模式 和 ISP 下载器模式的详细信息见表 995 “基于 ISP 引脚的启动模式和 ISP 下载器模式”，基于 BOOT_CFG [0] 中 <code>PRIMARY_BOOT_SRC</code> 位的 OTP 详细启动设备选择见表 994“基于 BOOT_CFG [0] 中 PRIMARY_BOOT_SRC 位的主启动源”。</p><p>RT6xx BootROM 支持在 ISP 模式（系统编程模式）下通过 ROM ISP 命令擦除 / 编程 / 读取外部非易失性存储器，以将启动镜像放置到外部非易失性存储器中。更多细节，请参考 41.8.16 节 “外部存储器支持”。</p><h3 id="41-1-2-RT6xx-如何启动"><a href="#41-1-2-RT6xx-如何启动" class="headerlink" title="41.1.2 RT6xx 如何启动"></a>41.1.2 RT6xx 如何启动</h3><p>RT6xx 通过BootROM 实现支持三种启动设备。</p><p><span style="color: green;  ">对于 FlexSPI 串行 NOR 闪存启动，有两种可能：</span></p><blockquote><p>加载到 RAM 启动和 XIP 启动。</p></blockquote><ol><li>对于加载到 RAM 启动，BootROM 运行后，会根据连接到 MCU 器件的外部 NOR 闪存类型初始化 FlexSPI 模块。ROM 从 NOR 闪存设备的偏移地址 <code>0x1000</code> 将启动镜像加载到 MCU 内部 SRAM 中，然后跳转到 SRAM 运行启动镜像。</li><li>对于 XIP 启动，BootROM 仅从 NOR 闪存设备引导镜像。启动镜像内部的镜像头会告诉 ROM 该启动镜像是加载到 RAM 的镜像还是 XIP 镜像。有关启动镜像头的更多细节，请参考 <span style="color: green;">表 997 “镜像头格式”</span>。</li></ol><blockquote><p>FlexSPI 启动还支持双镜像启动。如果选择 FlexSPI 作为启动设备，默认支持根据镜像版本选择引导哪个镜像，这称为乒乓启动。</p><p>在 FlexSPI 启动期间，ROM 始终尝试引导最新版本的镜像，如果最新启动镜像引导失败，ROM 会尝试引导旧版本的镜像。如果两个镜像引导都失败，ROM 将进入 ISP 模式。</p><p>有关乒乓启动的更多细节，请参考 41.5.1.4 节 “FlexSPI 双镜像乒乓启动”。</p></blockquote><hr><p>SD/eMMC 存储设备不支持 XIP 访问，因此BootROM 仅支持加载到 RAM 启动。与 FlexSPI NOR 闪存启动一样，ROM 在上电后初始化 uSDHC 接口，将启动镜像从设备偏移地址 <code>0x1000</code> 复制到内部 SRAM，然后跳转到 SRAM 运行启动镜像。</p><p>有关 FlexSPI NOR 闪存和 SD/eMMC 启动的更多细节，请参考 41.3 节 “概述”。</p><ul><li>当 LDO_ENABLE 外部接地为低电平时，用户必须在 VDDCORE=1.0V 或更高（低功耗 / 正常时钟模式）或 VDDCORE=1.13V（高速时钟）下启动。此后，VDDCORE 可以调整到所需电平。</li><li>此外，当执行任何 OTP 读 / 写功能时，无论 LDO_ENABLE 外部接地为高电平还是低电平，VDDCORE 电压必须设置为 1.0V 或更高。</li><li>对于 LDO_ENABLE=1，可以使用 <code>POWER_SetLdoVoltageForFreq</code> API 函数在内部将片上稳压器电压配置为 VDDCORE。</li></ul><h4 id="41-1-2-1-启动时的时钟速度"><a href="#41-1-2-1-启动时的时钟速度" class="headerlink" title="41.1.2.1 启动时的时钟速度"></a>41.1.2.1 启动时的时钟速度</h4><p><span style="color: red; font-weight: bold; ">设备启动时使用的时钟速率由 OTP 配置决定</span>。OTP 字 BOOT_CFG [0] 的位 7 包含 <code>BOOT_CLK_SPEED</code> 控制位，见表 990。<strong>表 990. 启动时钟速率</strong></p><table><thead><tr><th>模式</th><th>描述</th><th>ROM 支持的性能 [1]</th></tr></thead><tbody><tr><td>低功耗 / 正常时钟（BOOT_CLK_SPEED=0）</td><td>在此模式下，当 LDO_ENABLE 外部接高电平时，PMC 中连接到 VDDCORE 内核电压的片上稳压器设置为默认值 <code>1.05</code> V。<br>当 LDO_ENABLE 外部接低电平时，VDDCORE 必须设置为 <code>1.0V</code> 或更高。 <br>内核时钟（CPU + 系统时钟）： <br>- 频率：48 MHz <br>- 时钟源：48/60m_irc <br><br>UART、I2C、SPI： <br>- 时钟源：48/60m_irc <br><br>USB： <br>- USB IP 时钟源：来自晶体振荡器的 clk_in（24 MHz）</td><td>- 频率：48 MHz <br><br>UART：最高 1 Mbaud <br>I2C：最高 200 kHz <br>SPI：最高 12 Mbps <br><br>USB：2 Mbytes/s</td></tr><tr><td>高速时钟（OTP 熔丝决定时钟速度，BOOT_CLK_SPEED=1）</td><td>在此模式下，当 LDO_ENABLE 接高电平时，PMC 中连接到 VDDCORE 内核电压的片上稳压器设置为默认值 <code>1.13V</code>。<br>当 LDO_ENABLE 外部接低电平时，VDDCORE 必须设置为 <code>1.13V</code>。 <br><br>内核时钟（CPU + 系统时钟）： <br>- 频率：198 MHz <br>- 时钟源：main_clk（以 48/60m_irc 为 PLL 时钟源的 <code>main_pll_clk</code>） <br><br>USB： <br>- USB IP 时钟源：来自晶体振荡器的 clk_in（24 MHz） <br><br>FlexSPI： <br>- 时钟源：aux0_pll_clk <br>- 频率： <br>- SDR：30/50/60/80/100/120/133/166/200 MHz - DDR：30/50/60/80/100/120/133/166/200 MHz <br>eMMC/SD： <br>- 时钟源：主时钟（<code>main_pll_clk</code>）</td><td>- USB：2 Mbytes/s <br>FlexSPI：最高 166 MHz <br>uSDHC0=198 MHz <br>uSDHC1=99 MHz</td></tr></tbody></table><p>[1] 标注的速率为典型值。</p><blockquote><style>.iwurcwqcgrux{zoom:150%;}</style><img src="/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-1/image-20250519165019163.png" class="iwurcwqcgrux"></blockquote><h3 id="41-1-3-分步启动-RT6xx-器件"><a href="#41-1-3-分步启动-RT6xx-器件" class="headerlink" title="41.1.3 分步启动 RT6xx 器件"></a>41.1.3 分步启动 RT6xx 器件</h3><p>本节介绍如何通过 FlexSPI、uSDHC 和 SPI 接口启动 RT6xx 器件。</p><h4 id="41-1-3-1-FlexSPI-NOR-启动的基本说明"><a href="#41-1-3-1-FlexSPI-NOR-启动的基本说明" class="headerlink" title="41.1.3.1 FlexSPI NOR 启动的基本说明"></a>41.1.3.1 FlexSPI NOR 启动的基本说明</h4><p>本例将使用 FlexSPI NOR 闪存启动。如以上章节所述，用户需要准备一个可启动的镜像来启动设备。我们暂时称之为 image.bin 文件。</p><p>由于启动镜像需要放置在外部存储器中，ROM 支持将启动镜像编程到外部存储器中。要对外部存储器进行编程，用户首先需要获取 Bootloader 主机应用程序（<a href="https://www.nxp.com/webapp/sps/download/preDownload.jsp%EF%BC%89%EF%BC%8C%E8%AF%A5%E5%B7%A5%E5%85%B7%E7%A7%B0%E4%B8%BA">https://www.nxp.com/webapp/sps/download/preDownload.jsp），该工具称为</a> blhost 工具，用于与BootROM 通信。blhost 工具用户指南也可以在上述链接中找到。</p><p>在使用该工具向BootROM 发送 ISP 命令之前，<span style="color: blue; ">首先应将BootROM 配置为进入串行 ISP（系统编程）模式</span>。在开发周期中，我们建议通过以下 ISP 引脚选择来使用 ISP 引脚将BootROM 选择为进入串行 ISP 模式，更多信息请参考表 995 “基于 ISP 引脚的启动模式和 ISP 下载器模式”。<strong>表 991. 选择串行 ISP 模式</strong></p><table><thead><tr><th>启动模式</th><th>ISP2 PIO1_17</th><th>ISP1 PIO1_16</th><th>ISP0 PIO1_15</th><th>描述</th></tr></thead><tbody><tr><td>串行 ISP（UART、SPI、I2C、USB-HID）</td><td>高</td><td>高</td><td>低</td><td>使用串行接口（UART、SPI、I2C、USB-HID）对 OTP、外部 Flash、SD 或 eMMC 设备进行编程。</td></tr></tbody></table><p>进入 ISP 模式的步骤：首先，关闭电源；其次，将 ISP 引脚的跳线设置为下表所列状态；第三，给开发板上电。完成所有这些步骤后，BootROM 进入串行 ISP 模式。</p><p>当BootROM 处于 ISP 模式时，即可通过 blhost 工具与BootROM 进行 ISP 通信。</p><p>ROM 支持通过 UART、I2C、SPI、HID 四种接口与 blhost 工具通信。表 996 “ISP 引脚分配” 显示了这些接口的引脚分配。ROM 定义了用于命令和数据传输的通信协议。有关系统编程协议的更多细节，请参考 41.8 节 “RT6xx ISP 和 IAP”。</p><p><strong>表 992. UART 的串行 ISP 引脚</strong></p><table><thead><tr><th>启动接口</th><th>引脚</th><th>功能 / 注释</th></tr></thead><tbody><tr><td>UART</td><td>PIO0_1</td><td>FC0_TXD_SCL_MISO_WS</td></tr><tr><td>UART</td><td>PIO0_2</td><td>FC0_RXD_SDA_MOSI_DATA</td></tr></tbody></table><p>在本例中，我们将使用 UART。有关其他接口的使用，请参考 blhost 工具用户指南。在将 UART 用作通信接口之前，PC 的 COM 端口应将 TXD/RXD 引脚连接到BootROM 的 RXD/TXD 引脚。下表显示了BootROM 使用的 UART 引脚。</p><p>当引脚连接准备就绪，且BootROM 也处于 ISP 模式时，主机（blhost）与BootROM 之间的通信即可开始。在对串行 NOR 闪存设备进行编程之前，我们需要使用 blhost 工具告诉BootROM 配置 FlexSPI 接口，然后可以通过 blhost 工具向BootROM 发送其他 ISP 命令（如读 / 写 / 擦除）来访问连接在 MCU 的 FlexSPI 接口上的串行 NOR 闪存。以闪存 MX25UM51345G 为例，以下命令显示了配置、擦除和将启动镜像编程到连接到 FlexSPI 接口端口 A 的外部 NOR 闪存的步骤。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">blhost -p &lt;COM XX&gt; - fill-memory 0x1c000 0x04 0xc0403001  </span><br><span class="line">blhost -p &lt;COM XX&gt; - configure-memory 0x09 0x1c000  </span><br><span class="line">blhost -p &lt;COM XX&gt; – flash-erase-region 0x08000000 0x10000  </span><br><span class="line">blhost -p &lt;COM XX&gt; - fill-memory 0x1c004 0x04 0xf000000f  </span><br><span class="line">blhost -p &lt;COM XX&gt; - configure-memory 0x09 0x1c004  </span><br><span class="line">blhost -p &lt;COM XX&gt; - write-memory 0x08001000 image.bin  </span><br></pre></td></tr></tbody></table></figure><p>以下是 blhost 工具命令用法的一些细节：</p><ul><li><p><code>blhost -p &lt;COM XX&gt; - fill-memory 0x1c000 0x04 0xc0403001</code>这会将<code>闪存配置参数</code>填充到 SRAM 中，0x1c000 是设备上可用的 SRAM 地址，0x4 是参数长度，0xc0403001 是闪存配置参数。不同的闪存设备和不同的闪存工作模式（如四线、八线、SDR、DDR）可能有不同的配置参数。有关参数的详细信息，<span style="color: blue;  ">请参考表 1008 “Option0 定义” 和表 1009 “Option1 定义”</span>。更多细节请参考 41.8.16 节 “外部存储器支持”。</p></li><li><p><code>blhost -p &lt;COM XX&gt; - configure-memory 0x09 0x1c000</code>这是使用写入 RAM 地址 0x1c000 的参数来配置 FlexSPI 接口。发送此命令后，<span style="color: red; font-weight: bold; ">FlexSPI 完成配置，即可访问外部闪存。</span>更多细节请参考 41.8.16 节 “外部存储器支持” 或 blhost 用户指南。</p></li><li><p><code>blhost -p&lt;COM X X&gt; - flash-erase-region 0x08000000 0x10000</code>此命令从地址 0x08000000 开始擦除外部 NOR 闪存，擦除大小为 0x10000。</p></li><li><p><code>blhost -p &lt;COM XX&gt; - fill-memory 0x1c004 0x04 0xf000000f</code><code>blhost -p &lt;COM XX&gt; - configure-memory 0x09 0x1c004</code>此步骤用于填充为外部闪存生成闪存配置块（FCB）的参数，<span style="color: red; font-weight: bold; ">并触发生成 FCB 并将 FCB 编程到闪存偏移地址 <code>0x400</code> 处。</span>FCB 用于在启动过程中配置 FlexSPI 接口。</p><p><span style="color: red; font-weight: bold; ">当 FlexSPI 启动开始时，ROM 首先使用默认的 1 位模式在 <code>0x400</code> 处设置 FCB，然后使用 FCB 配置 FlexSPI 以访问 NOR 闪存</span>。更多细节，请参考 41.5 节 “主启动模式”。更多细节可参考 41.8.16 节 “外部存储器支持” 或 41.5.1.5.3 节 “NOR 闪存配置、擦除和编程”。</p></li><li><p><code>blhost -p &lt;COM XX&gt; - write-memory 0x08001000 image.bin</code>此步骤用于将启动镜像编程到外部 NOR 闪存地址 <code>0x08001000</code> 处。确保将启动镜像编程到外部闪存偏移地址 <code>0x1000</code> 处（参考表 1000 “不同启动介质上的镜像偏移”）。由于 0x08000000 是 FlexSPI 内存映射的 AHB 地址，要将其编程到闪存设备的 0x1000 处，blhost 的编程闪存地址为 0x08001000。</p></li></ul><p>FlexSPI 接口有两个端口，端口 A 和端口 B，BootROM 均支持从这两个端口启动。闪存配置参数存在一些差异。<span style="color: blue; font-weight: bold; ">对于端口 B，闪存数据采样没有 DQS 引脚，因此我们在 SDR 模式下使用内部环回采样时钟源，这需要设置Dummy Cycle。</span>请参考 NOR 闪存设备数据表来设置伪周期。<span style="color: red; font-weight: bold; ">如果使用 DDR 模式，用户需要手动准备 FCB。ROM 不支持为 FlexSPI PORT B 的 DDR 模式自动生成 FCB</span>。有关启用 DDR 模式的信息，请参考 41.5.1.6 节 “为连接在 PORT B 上的闪存启用八线 DDR 模式”。对于以下所示的配置参数 0xc1503051、0x20000014 的用法，请参考 41.5.1.5.2 节 “FlexSPI NOR 闪存配置参数”。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">blhost -p &lt;COM XX&gt; - fill-memory 0x1c000 0x04 0xc1503051  </span><br><span class="line">blhost -p &lt;COM XX&gt; - fill-memory 0x1c004 0x04 0x20000014  </span><br><span class="line">blhost -p &lt;COM XX&gt; - configure-memory 0x09 0x1c000  </span><br><span class="line">blhost -p &lt;COM XX&gt; – flash-erase-region 0x08000000 0x10000  </span><br><span class="line">blhost -p &lt;COM XX&gt; - fill-memory 0x1c008 0x04 0xf000000f  </span><br><span class="line">blhost -p &lt;COM XX&gt; - configure-memory 0x09 0x1c004  </span><br><span class="line">blhost -p &lt;COM XX&gt; - write-memory 0x08001000 image.bin  </span><br></pre></td></tr></tbody></table></figure><p>完成所有这些步骤后，启动镜像将成功编程到外部存储器的偏移地址 0x1000 处，FlexSPI 启动 FCB 也将编程到偏移地址 0x400 处，然后即可启动设备。ROM 支持 FlexSPI 端口 A 和端口 B 启动。关闭开发板电源，通过以下 ISP 引脚设置启动模式，然后给开发板上电，设备将引导之前编程的启动镜像。</p><p><strong>表 993. 从 FlexSPI 端口 A 和端口 B 启动</strong></p><table><thead><tr><th>启动模式</th><th>ISP2 PIO1_17</th><th>ISP1 PIO1_16</th><th>ISP0 PIO1_15</th><th>描述</th></tr></thead><tbody><tr><td>从端口 A 启动 FlexSPI</td><td>低</td><td>高</td><td>高</td><td>从连接到 FlexSPI 接口 0 端口 A 的四线 / 八线 SPI 闪存设备启动。RT6xx 将在外部四线 / 八线 SPI 闪存设备中查找有效镜像。如果未找到有效镜像，RT6xx 将进入恢复启动或 ISP 启动模式。</td></tr><tr><td>从端口 B 启动 FlexSPI</td><td>低</td><td>高</td><td>低</td><td>从连接到 FlexSPI 接口 0 端口 B 的四线或八线 SPI 闪存设备启动。RT6xx 将在外部四线 / 八线 SPI 闪存设备中查找有效镜像。如果未找到有效镜像，RT6xx 将进入恢复启动或 ISP 启动模式。</td></tr></tbody></table><h4 id="41-1-3-2-SD-eMMC-启动的基本说明"><a href="#41-1-3-2-SD-eMMC-启动的基本说明" class="headerlink" title="41.1.3.2 SD/eMMC 启动的基本说明"></a>41.1.3.2 SD/eMMC 启动的基本说明</h4><p>对于 SD/eMMC 启动，其过程与 FlexSPI 加载到 RAM 启动基本相同。以下是启动过程的主要步骤。有关SD/eMMC 启动的更多细节，请参考 41.5 节 “主启动模式” 中关于 SD/eMMC 启动的内容。通过 ISP 引脚将BootROM 设置为 ISP 模式。使用以下 blhost 命令将启动镜像写入 SD 卡：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">blhost -p &lt;COM XX&gt; - fill-memory 0x1c000 0x4 0xd0082100  </span><br><span class="line">blhost -p &lt;COM XX&gt; - configure-memory 0x120 0x1c000  </span><br><span class="line">blhost -p &lt;COM XX&gt; - flash-erase-region 0x0 0x2000 0x120  </span><br><span class="line">blhost -p &lt;COM XX&gt; - write-memory 0x1000 image.bin 0x120  </span><br></pre></td></tr></tbody></table></figure><p>使用以下 blhost 命令将启动镜像写入 eMMC 设备：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">blhost -p &lt;COM XX&gt; – fill-memory 0x1c000 0x4 0xC0721625  </span><br><span class="line">blhost -p &lt;COM XX&gt; – fill-memory 0x1c004 0x4 0x00000000  </span><br><span class="line">blhost -p &lt;COM XX&gt; - configure-memory 0x121 0x1c000  </span><br><span class="line">blhost -p &lt;COM XX&gt; - flash-erase-region 0x0 0x2000 0x121  </span><br><span class="line">blhost -p &lt;COM XX&gt; - write-memory 0x1000 image.bin 0x121  </span><br></pre></td></tr></tbody></table></figure><p>有关 SD/eMMC 配置参数的更多细节，请参考 41.8.16 节 “外部存储器支持”。将镜像编程到 SD/eMMC 设备后，设置引导 ISP 引脚（表 995 “基于 ISP 引脚的启动模式和 ISP 下载器模式”）以选择 SD/eMMC 引导模式，给开发板上电，设备将从 SD/eMMC 设备启动。</p><h4 id="41-1-3-3-1-位串行-NOR-SPI-启动的基本说明"><a href="#41-1-3-3-1-位串行-NOR-SPI-启动的基本说明" class="headerlink" title="41.1.3.3 1 位串行 NOR SPI 启动的基本说明"></a>41.1.3.3 1 位串行 NOR SPI 启动的基本说明</h4><p>对于 1 位 SPI NOR 闪存启动，<span style="color: green; font-weight: bold; ">其过程与 FlexSPI 加载到 RAM 启动基本相同</span>。选择 SPI NOR 启动时，ROM 尝试从连接到 SPI 接口的 NOR 闪存设备获取启动镜像。ROM 通过 SPI 模块使用主 1 位模式访问 NOR 闪存设备，将启动镜像复制到 SRAM，然后跳转到 SRAM 引导镜像。引导操作与 41.6 节 “恢复启动模式” 相同。<span style="color: green; font-weight: bold; ">不同之处在于，ROM 可以通过引导配置熔丝 BOOT_CFG [0] 的位 [3:0] 设置为 b’0111’ 直接选择 SPI 1 位启动。</span>更多细节，请参考表 994“基于 BOOT_CFG [0] 中 PRIMARY_BOOT_SRC 位的主启动源”。</p><p>将BootROM 设置为 ISP 模式，用户可以使用以下 blhost 命令将镜像编程到连接到 SPI 接口的串行 NOR 闪存存储器中：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">blhost -p &lt;COM XX&gt; - fill-memory 0x1c000 0x04 0xc010000  </span><br><span class="line">blhost -p &lt;COM XX&gt; - configure-memory 0x110 0x1c000  </span><br><span class="line">blhost -p &lt;COM XX&gt; - flash-erase-region 0x0 0x10000 0x110  </span><br><span class="line">blhost -p &lt;COM XX&gt; - write-memory 0x1000 image.bin 0x110  </span><br></pre></td></tr></tbody></table></figure><p>SPI 实例由熔丝字 0x60（BOOT_CFG [0] 的位 17 至位 19）选择。更多细节，请参考 41.9 节 “OTP 驱动 API”。SPI NOR 闪存配置参数 <code>0xc010000</code> 的定义可在 41.8.16 节 “外部存储器支持” 中找到。将启动镜像编程到 SPI NOR 闪存存储器后，将设备启动模式设置为 SPI NOR 启动，关闭并重新给开发板上电，设备将通过 SPI 从 1 位 NOR 闪存启动。</p><h4 id="41-2-功能"><a href="#41-2-功能" class="headerlink" title="41.2 功能"></a>41.2 功能</h4><p>256KB 片上BootROM，带引导程序，支持各种启动选项和 API。</p><ul><li>支持基于 ISP 引脚或 OTP 设置（PRIMARY_BOOT_SRC），从应用处理器通过串行接口（UART、SPI、USB-HID）启动，或从串行 NOR（四线或八线 SPI 闪存、HyperFlash）、SD 卡或 eMMC 设备自动启动。</li><li>支持从串行 NOR 闪存（单线、双线、四线或八线模式，<code>带 / 不带 OTFAD</code>）就地执行（XIP）。</li><li>提供用于 OTP 存储器编程的 OTP API，更多细节请参考 41.9 节 “OTP 驱动 API”。</li><li>提供访问串行闪存设备的外部闪存 API。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RT600-RM-CH41：RT6xx-非安全BootROM-1&quot;&gt;&lt;a href=&quot;#RT600-RM-CH41：RT6xx-非安全BootROM-1&quot; class=&quot;headerlink&quot; title=&quot;RT600 RM CH41：RT6xx 非安全BootROM (1)&quot;&gt;&lt;/a&gt;RT600 RM CH41：RT6xx 非安全BootROM (1)&lt;/h1&gt;</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT600" scheme="https://dustofstars.github.io/categories/NXP/RT600/"/>
    
    <category term="BootROM" scheme="https://dustofstars.github.io/categories/NXP/RT600/BootROM/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="RT600" scheme="https://dustofstars.github.io/tags/RT600/"/>
    
    <category term="BootROM" scheme="https://dustofstars.github.io/tags/BootROM/"/>
    
  </entry>
  
  <entry>
    <title>ARM核心--MemoryMap</title>
    <link href="https://dustofstars.github.io/ARM/MemoryMap/arm%E6%A0%B8%E5%BF%83-memorymap/"/>
    <id>https://dustofstars.github.io/ARM/MemoryMap/arm%E6%A0%B8%E5%BF%83-memorymap/</id>
    <published>2025-05-10T08:21:21.000Z</published>
    <updated>2025-05-10T08:22:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARMv7-M-Essentials-0"><a href="#ARMv7-M-Essentials-0" class="headerlink" title="ARMv7-M Essentials 0"></a>ARMv7-M Essentials 0</h1><blockquote><p>Link: <a href="https://www.bilibili.com/video/BV1MMVPzrE8S/?spm_id_from=333.1387.homepage.video_card.click&amp;vd_source=e742ab928a70238934780b04b84d177d">https://www.bilibili.com/video/BV1MMVPzrE8S/?spm_id_from=333.1387.homepage.video_card.click&amp;vd_source=e742ab928a70238934780b04b84d177d</a></p></blockquote><style>.stoklixmpflj{zoom:100%;}</style><img src="/ARM/MemoryMap/arm%E6%A0%B8%E5%BF%83-memorymap/image-20250510154619613.png" class="stoklixmpflj"><span id="more"></span><h2 id="1-可寻址空间大小-可寻址空间范围"><a href="#1-可寻址空间大小-可寻址空间范围" class="headerlink" title="1. 可寻址空间大小 / 可寻址空间范围"></a>1. 可寻址空间大小 / 可寻址空间范围</h2><ul><li>可寻址空间大小：4GB；</li><li>可寻址空间范围：0x0000_0000 ~ 0xFFFF_FFFF</li></ul><h2 id="2-分块"><a href="#2-分块" class="headerlink" title="2. 分块"></a>2. 分块</h2><ol><li>代码：指的是用户代码编译之后机器码存放在片内Flash区域；起始地址给的是<code>0x0</code>?</li><li>SRAM：即片内RAM；存放运行时的数据；一般起始地址就是<code>0x2000_0000</code>;</li><li>外设：用于访问外设；一般起始地址是<code>0x4000_0000</code></li><li>RAM: 指的是片外RAM，起始地址<code>0x6000_0000</code>,对应RT应该是SDRAM；</li><li>设备：</li><li>系统/供应商定义：其中有一个核销的系统控制空间，它里面有CPUID,地址是<code>0xE000_ED00</code>;</li></ol><h2 id="3-示例代码"><a href="#3-示例代码" class="headerlink" title="3. 示例代码"></a>3. 示例代码</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CODE_ADDR_START 0x00000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CODE_ADDR_END   0x1FFFFFFF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SRAM_ADDR_START 0x20000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SRAM_ADDR_END   0x3FFFFFFF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCB_CPUID_ADDR   0xE000ED00</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">example_function</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> example_value = <span class="number">0x12345678</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// get the address of the example function</span></span><br><span class="line">    <span class="type">uint32_t</span> function_addr = (<span class="type">uint32_t</span>)&amp;example_function;</span><br><span class="line">    <span class="keyword">if</span> （function_addr &lt; CODE_ADDR_START || function_addr &gt; CODE_ADDR_END)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// get the address of the example value</span></span><br><span class="line">    <span class="type">uint32_t</span> value_addr = (<span class="type">uint32_t</span>)&amp;example_value;</span><br><span class="line">    <span class="keyword">if</span> （value_addr&lt; SRAM_ADDR_START || value_addr &gt; SRAM_ADDR_END）</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>）;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//get the value of the SCB CPUID register</span></span><br><span class="line">    <span class="type">uint32_t</span> cpuid_value = *(<span class="keyword">volatile</span> <span class="type">uint32_t</span> *)SCB_CPUID_ADDR;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == cpuid_value)</span><br><span class="line">      {</span><br><span class="line">          <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">      }</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>这个工程是为了验证默认的代码和变量区域分别在哪里：</p><ol><li>代码：函数应该在代码区，对应为片内Flash；</li><li>变量：变量应该在SRAM，片内RAM中；</li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ARMv7-M-Essentials-0&quot;&gt;&lt;a href=&quot;#ARMv7-M-Essentials-0&quot; class=&quot;headerlink&quot; title=&quot;ARMv7-M Essentials 0&quot;&gt;&lt;/a&gt;ARMv7-M Essentials 0&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.bilibili.com/video/BV1MMVPzrE8S/?spm_id_from=333.1387.homepage.video_card.click&amp;amp;vd_source=e742ab928a70238934780b04b84d177d&quot;&gt;https://www.bilibili.com/video/BV1MMVPzrE8S/?spm_id_from=333.1387.homepage.video_card.click&amp;amp;vd_source=e742ab928a70238934780b04b84d177d&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;style&gt;.stoklixmpflj{zoom:100%;}&lt;/style&gt;&lt;img src=&quot;/ARM/MemoryMap/arm%E6%A0%B8%E5%BF%83-memorymap/image-20250510154619613.png&quot; class=&quot;stoklixmpflj&quot;&gt;</summary>
    
    
    
    <category term="ARM" scheme="https://dustofstars.github.io/categories/ARM/"/>
    
    <category term="MemoryMap" scheme="https://dustofstars.github.io/categories/ARM/MemoryMap/"/>
    
    
    <category term="ARM" scheme="https://dustofstars.github.io/tags/ARM/"/>
    
    <category term="MemoryMap" scheme="https://dustofstars.github.io/tags/MemoryMap/"/>
    
  </entry>
  
  <entry>
    <title>ARM核心启动流程</title>
    <link href="https://dustofstars.github.io/ARM/Boot/arm%E6%A0%B8%E5%BF%83%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <id>https://dustofstars.github.io/ARM/Boot/arm%E6%A0%B8%E5%BF%83%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</id>
    <published>2025-05-10T08:20:21.000Z</published>
    <updated>2025-05-10T08:20:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARMv7-M-Essentials-1"><a href="#ARMv7-M-Essentials-1" class="headerlink" title="ARMv7-M Essentials 1"></a>ARMv7-M Essentials 1</h1><blockquote><p>Link: <a href="https://www.bilibili.com/video/BV1tTVPz3EdA/?spm_id_from=333.1387.favlist.content.click&amp;vd_source=e742ab928a70238934780b04b84d177d">https://www.bilibili.com/video/BV1tTVPz3EdA/?spm_id_from=333.1387.favlist.content.click&amp;vd_source=e742ab928a70238934780b04b84d177d</a></p></blockquote><span id="more"></span><h2 id="1-框图"><a href="#1-框图" class="headerlink" title="1. 框图"></a>1. 框图</h2><style>.oinehjorvebi{zoom:100%;}</style><img src="/ARM/Boot/arm%E6%A0%B8%E5%BF%83%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image-20250510151632165.png" class="oinehjorvebi"><p>电源引脚上电–&gt; 复位 –&gt; Boot ROM –&gt; 根据VectorTable偏移0地址的内存地址设置MSP –&gt; 将M核心的PC寄存器设置为VectorTable的偏移4字节即复位向量 –&gt; 之后就可以依次执行指令了！</p><blockquote><p>Note: 中断向量表Vector Table：</p><ul><li><span style="color: red; font-weight: bold; ">中断向量表中每个元素都是4个Bytes；</span></li><li>每个元素用于指示MCU中的一个有效存储空间；代表一个内存地址或者函数地址；</li></ul><p>从上图的方框可以看到，VectorTable的内容：</p><ol><li>第一个元素是MSP的初始值；<span style="color: red; font-weight: bold; ">MSP指的是栈顶指针(Main Stack Pointer), 用于指示内存中某个具体地址；</span></li><li><span style="color: red; font-weight: bold; ">往后的元素都是函数地址；</span>最重要的是第二个，<span style="color: red; font-weight: bold; ">复位向量；它指示每次MCU复位后执行的第一条用户指令；</span></li></ol></blockquote><h2 id="2-示例工程"><a href="#2-示例工程" class="headerlink" title="2. 示例工程"></a>2. 示例工程</h2><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">"stm32f10x.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CODE_ADDR_START Ox00000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CODE_ADDR_END   0x1FFFFFFF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SRAM_ADDR_START Ox20000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SRAM_ADDR_END   0x3FFFFFFF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCB_CPUID_ADDR   OxE000ED00</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">example_function</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> example_value = <span class="number">0x12345678</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//get the address of the example function</span></span><br><span class="line">    <span class="type">uint32_t</span> function_addr=（<span class="type">uint32_t</span>)&amp;example_function;</span><br><span class="line">    <span class="keyword">if</span> （function_addr &lt;CODE_ADDR_START I1 function_addr &gt; CODE_ADDR_END)</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">while</span>(<span class="number">1</span>);  </span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// get the address of the example value</span></span><br><span class="line">    <span class="type">uint32_t</span> value_addr = (<span class="type">uint32_t</span>)&amp;example_value;</span><br><span class="line">    <span class="keyword">if</span> (value_addr &lt; SRAM_ADDR_START <span class="number">11</span> value_addr &gt; SRAM_ADDR_END)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    } </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h3><style>.dwxsxxldesrn{zoom:100%;}</style><img src="/ARM/Boot/arm%E6%A0%B8%E5%BF%83%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image-20250510153431340.png" class="dwxsxxldesrn"><ul><li><code>_estack</code>:即栈顶指针MSP；</li><li><code>Reset_Handler</code>: 即复位向量；</li></ul><p>当工程进入调试模式时可以看到，</p><ol><li>PC寄存器指向<code>main()</code>中的第一个指令地址；</li><li>M核心的MSP寄存器指向RAM中的某个地址；</li><li>使用gdb的<code>monitor system_reset</code>指令触发复位，观察PC和MSP两个寄存器的地址：<ul><li>PC：<code>0x8000088c</code> –&gt; 即 Reset_Handler;</li><li>MSP: <code>0x20002000</code> –&gt; 即map中的一致；</li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ARMv7-M-Essentials-1&quot;&gt;&lt;a href=&quot;#ARMv7-M-Essentials-1&quot; class=&quot;headerlink&quot; title=&quot;ARMv7-M Essentials 1&quot;&gt;&lt;/a&gt;ARMv7-M Essentials 1&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.bilibili.com/video/BV1tTVPz3EdA/?spm_id_from=333.1387.favlist.content.click&amp;amp;vd_source=e742ab928a70238934780b04b84d177d&quot;&gt;https://www.bilibili.com/video/BV1tTVPz3EdA/?spm_id_from=333.1387.favlist.content.click&amp;amp;vd_source=e742ab928a70238934780b04b84d177d&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="ARM" scheme="https://dustofstars.github.io/categories/ARM/"/>
    
    <category term="Boot" scheme="https://dustofstars.github.io/categories/ARM/Boot/"/>
    
    
    <category term="ARM" scheme="https://dustofstars.github.io/tags/ARM/"/>
    
    <category term="Boot" scheme="https://dustofstars.github.io/tags/Boot/"/>
    
  </entry>
  
  <entry>
    <title>RT1060 image里面有什么？</title>
    <link href="https://dustofstars.github.io/NXP/RT1060/binary/rt1060-image%E9%87%8C%E9%9D%A2%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>https://dustofstars.github.io/NXP/RT1060/binary/rt1060-image%E9%87%8C%E9%9D%A2%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F/</id>
    <published>2025-02-28T08:43:40.000Z</published>
    <updated>2025-02-28T08:43:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RT1060-image里面有什么？"><a href="#RT1060-image里面有什么？" class="headerlink" title="RT1060 image里面有什么？"></a>RT1060 image里面有什么？</h1><blockquote><p>RT MCU 学习有一段时间了，刚好得空，在这篇文章里面，我们一起分析一个完整的image bin文件，它有哪些部分？分别是什么作用？哪些是不可或缺的？哪些是可选的？</p></blockquote><span id="more"></span><p>我们知道，RT MCU作为跨界控制器/处理器，提供了一个高性能的平台，CM7核心的主频可以达到600MHz以上，可以说单凭这个系列，就打出了NXP的差异性和易用性。原来国外原厂也可以这么有性价比😍简直是Amazing -.-</p><p>但是同时呢，由于RT的flash是外置的嘛，它的image结构也和以往的通用MCU的image有很大区别。以我们本文要研究的Flash XIP的image为例，上电之后，BootROM会先把flexspi跑起来，用一个低速时钟去读flash中的配置参数，然后拿这个flash的配置头重配flexspi，就能高效获取image中的指令和数据啦！</p><p>同时呢，因为一些加密啊，外设配置啊，的需求，image不只是包含这个flash的配置header，还分为很多个其他部分，在这里，我们就一起看一下吧！</p><h2 id="FDCB-Header"><a href="#FDCB-Header" class="headerlink" title="FDCB Header"></a>FDCB Header</h2><blockquote><blockquote><p>再次呢，进入正文之前，提前说明一些东西以防止读者疑惑。</p><ul><li><p>使用的是*.bin格式的image，相比于hex或者s-record，它没有指示物理地址，只有offset，在使用JLink烧录时，我们使用如下命令：</p><p><code>jlink loadfile xxx.bin 0x6000_0000</code></p><p>从这里我们可以看出来，这个bin文件的offset，实际上就是从我们的Flash首地址开始偏移的，这是最重要的前置知识，请知悉。</p></li></ul></blockquote></blockquote><p>在MCU BootUtility中，它显示从<code>0x6000_0000</code>到<code>0x6000_0200</code>之前，都是FDCB段。那么它的大小就是<code>512 Byte</code>.</p><p>这里我们先不管，直接看对我们有用的部分。</p><style>.eyxnmayhofrc{zoom:100%;}</style><img src="/NXP/RT1060/binary/rt1060-image%E9%87%8C%E9%9D%A2%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F/image-20250228155429758.png" class="eyxnmayhofrc"><table><thead><tr><th>Offset</th><th>flash address</th><th>内容</th><th>小端</th><th>意义</th></tr></thead><tbody><tr><td>0x0</td><td>0x6000_0000</td><td>46 43 46 42</td><td>0x42462326</td><td>FCFB<br>flash配置头标志</td></tr><tr><td>0x04-0x07</td><td>0x6000_0004</td><td>00 04 01 56</td><td>0x56010400</td><td>version<br>表示使用flexspi v1.4.0配置</td></tr><tr><td>0x40-0x43</td><td>0x6000_0040</td><td>10 00 00 00</td><td>0x10</td><td>应该是flash的page size<br>16</td></tr><tr><td>0x80-0x83</td><td>0x6000_0080</td><td>EB 04 18 0A</td><td>0x0A1804EB</td><td>Flash的时钟频率<br>典型值133MHz<br>（600/43 x 19 / 2 = 133）</td></tr></tbody></table><h2 id="Image-Version"><a href="#Image-Version" class="headerlink" title="Image Version"></a>Image Version</h2><p>在Offset <code>0x600</code>的地方有个image版本号，用于双image的时候，还没用过。暂且不表。</p><style>.mxfatqsdtlqr{zoom:100%;}</style><img src="/NXP/RT1060/binary/rt1060-image%E9%87%8C%E9%9D%A2%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F/image-20250228155738390.png" class="mxfatqsdtlqr"><h2 id="IVT"><a href="#IVT" class="headerlink" title="IVT"></a>IVT</h2><style>.oupgfmaogprd{zoom:100%;}</style><img src="/NXP/RT1060/binary/rt1060-image%E9%87%8C%E9%9D%A2%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F/image-20250228161351059.png" class="oupgfmaogprd"><table><thead><tr><th>Offset</th><th>flash address</th><th>内容</th><th>小端</th><th>意义</th></tr></thead><tbody><tr><td>0x1000</td><td>0x6000_1000</td><td>D1 00 20 41</td><td>0x412000D1</td><td>IVT段的起始标志</td></tr><tr><td>0x1004</td><td>0x6000_1004</td><td>00 20 00 60</td><td>0x60002000</td><td>程序中断向量表地址<br>.isr_vector 以及 g_pfnVectors</td></tr><tr><td>0x1008</td><td>0x6000_1008</td><td>00 00 00 00</td><td>0x0</td><td>DCD地址<br>表示未启用DCD</td></tr><tr><td>0x1010</td><td>0x6000_1010</td><td>20 10 00 60</td><td>0x60001020</td><td>BootData地址<br>指向偏移量0x1020的地方</td></tr></tbody></table><h2 id="Boot-Data"><a href="#Boot-Data" class="headerlink" title="Boot Data"></a>Boot Data</h2><p>根据IVT中 Offset <code>0x1010</code>的指引，找到 Boot Data的地址是：<code>0x6000_1020</code></p><style>.buiilqiegmvn{zoom:100%;}</style><img src="/NXP/RT1060/binary/rt1060-image%E9%87%8C%E9%9D%A2%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F/image-20250228162214452.png" class="buiilqiegmvn"><table><thead><tr><th>Offset</th><th>flash address</th><th>内容</th><th>小端</th><th>意义</th></tr></thead><tbody><tr><td>0x1020</td><td>0x6000_1020</td><td>00 00 00 60</td><td>0x60000000</td><td>image的起始地址<br>在这时候就是flash的地址</td></tr><tr><td>0x1024</td><td>0x6000_1024</td><td>00 00 80 00</td><td>0x00800000</td><td>image的大小<br>这里默认是8MB</td></tr></tbody></table><h2 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h2><p>终于到了光秃秃的image部分了~</p><p>根据IVT中的指示，它是程序入口，地址是<code>0x6000_2000</code>!</p><style>.prpxezsqggyy{zoom:100%;}</style><img src="/NXP/RT1060/binary/rt1060-image%E9%87%8C%E9%9D%A2%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F/image-20250228162759478.png" class="prpxezsqggyy"><table><thead><tr><th>Offset</th><th>flash address</th><th>内容</th><th>小端</th><th>意义</th></tr></thead><tbody><tr><td>0x2000</td><td>0x6000_2000</td><td>00 00 02 20</td><td>0x2002_0000 (DTCM中的地址)</td><td><strong>初始SP</strong>栈指针</td></tr><tr><td>0x2004</td><td>0x6000_2004</td><td>1D 23 00 60</td><td>0x6000231D</td><td>ResetISR 的地址</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RT1060-image里面有什么？&quot;&gt;&lt;a href=&quot;#RT1060-image里面有什么？&quot; class=&quot;headerlink&quot; title=&quot;RT1060 image里面有什么？&quot;&gt;&lt;/a&gt;RT1060 image里面有什么？&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;RT MCU 学习有一段时间了，刚好得空，在这篇文章里面，我们一起分析一个完整的image bin文件，它有哪些部分？分别是什么作用？哪些是不可或缺的？哪些是可选的？&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1060" scheme="https://dustofstars.github.io/categories/NXP/RT1060/"/>
    
    <category term="binary" scheme="https://dustofstars.github.io/categories/NXP/RT1060/binary/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="image" scheme="https://dustofstars.github.io/tags/image/"/>
    
  </entry>
  
  <entry>
    <title>RT1024 EVK 学习笔记Part3</title>
    <link href="https://dustofstars.github.io/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part3/"/>
    <id>https://dustofstars.github.io/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part3/</id>
    <published>2024-12-24T11:47:46.000Z</published>
    <updated>2024-12-24T11:47:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RT1024-EVK-学习笔记Part3"><a href="#RT1024-EVK-学习笔记Part3" class="headerlink" title="RT1024 EVK 学习笔记Part3"></a>RT1024 EVK 学习笔记Part3</h1><blockquote><p>Page5 MCU PINOUT 部分！</p><p>以及额外的，Page14 BOOT！</p></blockquote><span id="more"></span><h2 id="U1D-SEMC-部分"><a href="#U1D-SEMC-部分" class="headerlink" title="U1D SEMC 部分"></a>U1D SEMC 部分</h2><style>.maudjldudrnr{zoom:100%;}</style><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part3/image-20241224104557031.png" class="maudjldudrnr"><p>SEM接口部分共有42个引脚，为<code>GPIO_EMC_00</code> ~ <code>GPIO_EMC_41</code>。 它的功能分组如下：</p><h3 id="引脚功能分组"><a href="#引脚功能分组" class="headerlink" title="引脚功能分组"></a>引脚功能分组</h3><ul><li>数据线: <code>SEMC_D0</code> ~ <code>SEMC_D15</code> <span style="color: green; font-weight: bold; ">(16位数据总线)；</span></li><li>地址线: <code>SEMC_A0</code> ~ <code>SEMC_A12</code> <span style="color: green; font-weight: bold; ">(13位地址总线)；</span></li><li>控制信号13个: <ul><li>SEMC_DM0, SEMC_WE, SEMC_CAS, SEMC_RAS, SEMC_CS0, <code>SEMC_BA0</code>, <code>SEMC_BA1</code>;</li><li>SEMC_CKE, SEMC_CLK, SEMC_DM1;</li><li>SAI3_MCLK, ENET_MDIO, ENET_MDC;</li></ul></li></ul><h3 id="数据选通信号DQS说明"><a href="#数据选通信号DQS说明" class="headerlink" title="数据选通信号DQS说明"></a>数据选通信号DQS说明</h3><ul><li><p><code>SEMC_DQS</code>: 数据选通信号,用于高速数据传输时的同步; 在MCU端的Pin是<code>GPIO_EMC_28</code>, 它默认用于<code>SAI3_MCLK</code>, 如果需要SEMC的DQS功能，则要断开0Ω电阻<code>R426</code>；</p><ul><li><p><code>SAI3_MCLK</code>: <span style="color: green; font-weight: bold; ">音频接口主时钟信号；</span></p><blockquote><p><span style="color: blue; font-weight: bold; ">如果使用了SEMC_DQS, 且读写时Pin脚float，则能达到133MHz；否则，不使用SEMC_DQS, 读写速度只能达到66MHz；</span></p></blockquote></li></ul></li></ul><h3 id="控制信号详解"><a href="#控制信号详解" class="headerlink" title="控制信号详解"></a>控制信号详解</h3><ul><li><p><code>SEMC_DM0 / SEMC_DM1</code> (Data Mask):</p><ul><li>这是数据掩码信号</li><li>分别控制低8位和高8位；</li></ul></li><li><p><code>SEMC_WE</code> (Write Enable):</p><ul><li>写使能信号</li><li>低电平有效</li><li>用于指示当前是写操作</li><li>与RAS/CAS配合使用来控制读写时序</li></ul></li><li><p><code>SEMC_CAS</code> (Column Address Strobe):</p><ul><li>列地址选通信号</li><li>低电平有效</li><li>用于锁存列地址</li><li><span style="color: green;">SDRAM访问需要先给行地址再给列地址；</span></li></ul></li><li><p><code>SEMC_RAS</code> (Row Address Strobe):</p><ul><li>行地址选通信号</li><li>低电平有效</li><li>用于锁存行地址</li><li>与CAS的组合可以产生不同的SDRAM命令</li></ul></li><li><p><code>SEMC_CS0</code> (Chip Select):</p><ul><li><span style="color: green;">片选信号；</span>–&gt; <span style="color: blue; font-weight: bold; ">因为只有一个片选信号，RT1024应该是只能外接一片SDRAM的；</span></li><li>低电平有效</li><li>系统可以有多个CS信号连接多个SDRAM</li></ul></li><li><p><code>SEMC_BA0/BA1</code> (Bank Address):</p><ul><li><span style="color: green;">SDRAM内部bank地址信号；</span></li><li>用于选择SDRAM内部的存储体</li><li>通常SDRAM有4个bank,需要2位地址</li><li>可以实现bank交错访问提高性能</li></ul></li></ul><h2 id="U1F-NVCC-SD-部分"><a href="#U1F-NVCC-SD-部分" class="headerlink" title="U1F NVCC_SD 部分"></a>U1F NVCC_SD 部分</h2><style>.vnxksgvvngjf{zoom:100%;}</style><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part3/image-20241224104624579.png" class="vnxksgvvngjf"><h3 id="电源设计"><a href="#电源设计" class="headerlink" title="电源设计"></a>电源设计</h3><ul><li><code>NVCC_SD</code>为SD接口<code>NVCC_SD0</code>供电；</li><li>使用两个去耦电容:<ul><li>C76(4.7μF): 大电容用于稳定电源</li><li>C77(0.1μF): 小电容用于滤除高频噪声</li></ul></li></ul><h3 id="SD卡接口信号-GPIO-SD-B0-xx组"><a href="#SD卡接口信号-GPIO-SD-B0-xx组" class="headerlink" title="SD卡接口信号(GPIO_SD_B0_xx组)"></a>SD卡接口信号(<code>GPIO_SD_B0_xx</code>组)</h3><p>（7个Pin：00~06）</p><ul><li><code>SD1_D0~D3</code>: <span style="color: green;"> 4位数据线，其中，D0有上拉到<code>NVCC_SD</code>高电平；</span></li><li><code>SD1_CMD</code>: <span style="color: green;">命令线，上拉到<code>NVCC_SD</code>高电平；</span></li><li><code>SD1_CLK</code>: 时钟线；</li><li><code>SD_CD_SW</code>: <span style="color: green;">SD卡检测信号，</span>注意这个Pin脚是<code>GPIO_SD_B0_06</code>；</li></ul><h3 id="其他复用功能-GPIO-SD-B1-xx组"><a href="#其他复用功能-GPIO-SD-B1-xx组" class="headerlink" title="其他复用功能(GPIO_SD_B1_xx组)"></a>其他复用功能(GPIO_SD_B1_xx组)</h3><p>（12个Pin：00~11）</p><ul><li><p><code>CAN1_TX/RX:</code> CAN通信接口；</p></li><li><p><code>I2C4_SCL/SDA</code>: I2C通信接口；</p></li><li><p><code>SAI3</code>相关信号: 音频接口信号：</p><ul><li><code>SAI3_TX_BCLK</code></li><li><code>SAI3_TX_SYNC</code></li><li><code>SAI3_TXD</code></li><li><code>SAI3_RXD</code></li></ul></li><li><p><code>INT1/2_COMBO</code>以及<code>AUD_INT</code>: 中断信号；</p><blockquote><p><span style="color: blue; font-weight: bold; ">其中<code>INT2_COMBO</code>通过DNP未连接0Ω电阻R243到<code>GPIO_SD_B1_05</code>，它也是FlexSPI DQS线，需要floating，使QSPI Flash读写速度达到133MHz；</span></p></blockquote></li><li><p><code>SD_PWREN</code>:<span style="color: green; ">这个也是个重要控制信号，来决定SD卡是否上电！</span></p></li></ul><h2 id="U1C-5V-USB-OTG-部分"><a href="#U1C-5V-USB-OTG-部分" class="headerlink" title="U1C 5V_USB_OTG 部分"></a>U1C 5V_USB_OTG 部分</h2><style>.igjgtyfpeijd{zoom:100%;}</style><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part3/image-20241224110847726.png" class="igjgtyfpeijd"><p>MCU的USB OTG接口电路部分</p><ol><li><strong>电源设计</strong><ul><li><code>5V_USB_OTG</code>: USB 5V供电，限流25mA，连接到<code>USB_OTG1_VBUS</code>引脚；</li><li><code>VDD_USB_3V</code>: 3.3V供电，连接到<code>VDD_USB_CAP</code>；</li></ul></li><li><strong>信号线</strong><ul><li><code>OTG1_DN / OTG1_DP</code>: USB差分数据对</li><li><code>USB_OTG1_VBUS</code>: VBUS电源检测引脚;</li><li><code>USB_OTG1_CHD</code>: 充电检测引脚;</li></ul></li></ol><h2 id="U1E-NVCC-GPIO-3V3-部分"><a href="#U1E-NVCC-GPIO-3V3-部分" class="headerlink" title="U1E NVCC_GPIO_3V3 部分"></a>U1E NVCC_GPIO_3V3 部分</h2><style>.bjozhrletotx{zoom:100%;}</style><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part3/image-20241224112223432.png" class="bjozhrletotx"><h3 id="电源设计-1"><a href="#电源设计-1" class="headerlink" title="电源设计"></a><strong>电源设计</strong></h3><ul><li><span style="color: green; font-weight: bold; "><code>DCDC_3V3</code>转换为<code>NVCC_GPIO_3V3</code>供电；</span></li><li>采用双级去耦电容设计：<ul><li>5个4.7μF大电容：处理低频噪声</li><li>5个0.1μF小电容：处理高频噪声</li></ul></li><li>这种配置确保了GPIO供电的稳定性</li></ul><h3 id="GPIO配置"><a href="#GPIO配置" class="headerlink" title="GPIO配置"></a><strong>GPIO配置</strong></h3><ul><li><code>NVCC_GPIO</code>：<span style="color: green;">5个Pin给GPIO组进行独立供电；</span></li><li><code>GPIO_AD_B0_xx</code>和<code>GPIO_AD_B1_xx</code>：两组GPIO端口，B0组有16个Pin，B1组有10个Pin；</li></ul><h4 id="GPIO-AD-B0-xx-组"><a href="#GPIO-AD-B0-xx-组" class="headerlink" title="GPIO_AD_B0_xx 组"></a>GPIO_AD_B0_xx 组</h4><ol><li><strong>调试接口</strong><ul><li>JTAG接口：<ul><li>JTAG_TMS：测试模式选择</li><li>JTAG_TCK：时钟</li><li>JTAG_TDI：测试数据输入</li><li>JTAG_TDO：测试数据输出</li><li>JTAG_nTRST：复位</li><li><span style="color: blue;">JTAG_MOD 默认接地；</span></li></ul></li><li>SWD接口：<ul><li>SWD_CLK：时钟，复用JTAG_TCK；</li><li>SWD_DIO：数据输入输出，复用JTAG_TMS;</li><li><code>TRACE_SWO</code>：<span style="color: blue; font-weight: bold; ">默认DNP的，复用了<code>GPIO_AD_B0_12</code>;</span></li></ul></li></ul></li><li><strong>通信接口</strong><ul><li>UART1_TXD / RXD：串口通信</li><li>ENET：以太网接口信号<ul><li>4个接收/发送数据线：<ul><li>ENET_RXD1/ ENET_RXD0；</li><li>ENET_TXD1/ ENET_TXD0；</li></ul></li><li>1个时钟线：ENET_TX_REF_CLK</li><li>1个使能线：ENET_TXEN</li><li>1个复位线：ENET_RST</li><li>其他控制线：<ul><li><code>ENET_RXER</code></li><li><code>ENET_CRS_DV</code></li></ul></li></ul></li></ul></li><li><strong>特殊功能</strong><ul><li><code>WDOG_B</code>：看门狗复位，和<code>JTAG_TDI</code>复用；</li><li><code>TRACE_SWO</code>：跟踪调试输出</li></ul></li></ol><h4 id="GPIO-AD-B1-xx-组"><a href="#GPIO-AD-B1-xx-组" class="headerlink" title="GPIO_AD_B1_xx 组"></a>GPIO_AD_B1_xx 组</h4><blockquote><p><span style="color: green; font-weight: bold; ">好像放的是一些外设的重要控制信号？！</span></p></blockquote><ul><li>ENET_INT：以太网中断信号</li><li>SD0_VSELECT：SD卡电压选择，支持1.8V/3.3V双电压模式；</li><li>USER_LED</li><li>USB_OTG1_PWR ： 控制外部USB设备供电</li><li>USB_OTG1_ID ： 用于确定USB角色(主机/设备)</li><li>USB_OTG1_OC ： 检测USB端口是否发生过流</li><li>CAN_STBY</li><li>I2C1_SCL / I2C1_SDA</li></ul><hr><h2 id="Page-14-BOOT"><a href="#Page-14-BOOT" class="headerlink" title="Page 14 BOOT"></a>Page 14 BOOT</h2><style>.kchlibaockdi{zoom:100%;}</style><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part3/image-20241224134408689.png" class="kchlibaockdi"><style>.nvrmtuqktvwc{zoom:100%;}</style><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part3/image-20241224134346036.png" class="nvrmtuqktvwc"><p>启动配置部分<code>BOOT_CFG[0:9]</code>：</p><ol><li><strong>FUSE MAP配置表</strong><ul><li><strong>FlexSPI - Serial NOR配置</strong>：<ul><li><code>HOLD TIME</code>可选：500us/1ms/3ms/10ms</li><li>FLASH类型支持多种选项：<ul><li><code>3B/4B读取模式</code></li><li>HyperFlash 1V8/3V3</li><li>QSPI设备 3B读取模式–&gt; <span style="color: blue; font-weight: bold; ">在secondary pinmux选项上；</span>；</li><li>Micron Octal DDR</li><li>MXIC Octal DDR</li></ul></li><li>EncryptedXIP：使能与否；</li></ul></li><li><strong>SD启动配置</strong>：<ul><li>SD/SDXC速度模式4种选择：<ul><li>Normal/SDR12</li><li>High/SDR25</li><li>SDR50</li><li>SDR104</li></ul></li><li><span style="color: green;">总线宽度：1-bit/4-bit</span></li><li>电源循环和时钟源选项</li><li>端口选择：eSDHC1/eSDHC2</li><li>快速启动选项</li></ul></li></ul></li><li><strong>硬件实现</strong><ul><li>**DIP开关(SW8)**：<ul><li>四个选项连接：BT_CFG[0]、BT_CFG[5]、BOOT_MODE[0]、BOOT_MODE[1]；</li><li>用于选择启动模式：<ul><li>Serial Download: 0001</li><li>FlexSPI Boot:       0010</li><li>SD Boot:              0110</li></ul></li></ul></li><li><strong>GPIO连接</strong>：<ul><li>使用GPIO_EMC_16到GPIO_EMC_27</li><li>这些引脚在启动时作为配置引脚</li><li>启动后可以作为普通GPIO使用</li></ul></li></ul></li><li><strong>特殊功能</strong><ul><li>支持加密XIP（Execute In Place）</li><li>可配置快速启动模式</li><li>支持多种存储设备类型</li><li>灵活的时序和总线配置</li></ul></li></ol><p>这种设计提供了灵活的启动选项，允许系统从不同类型的存储设备启动，并且可以通过DIP开关轻松更改启动配置，方便开发和调试。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RT1024-EVK-学习笔记Part3&quot;&gt;&lt;a href=&quot;#RT1024-EVK-学习笔记Part3&quot; class=&quot;headerlink&quot; title=&quot;RT1024 EVK 学习笔记Part3&quot;&gt;&lt;/a&gt;RT1024 EVK 学习笔记Part3&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Page5 MCU PINOUT 部分！&lt;/p&gt;
&lt;p&gt;以及额外的，Page14 BOOT！&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1024" scheme="https://dustofstars.github.io/categories/NXP/RT1024/"/>
    
    <category term="原理图" scheme="https://dustofstars.github.io/categories/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="hardware" scheme="https://dustofstars.github.io/tags/hardware/"/>
    
    <category term="原理图" scheme="https://dustofstars.github.io/tags/%E5%8E%9F%E7%90%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>RT1024 EVK 学习笔记Part2</title>
    <link href="https://dustofstars.github.io/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part2/"/>
    <id>https://dustofstars.github.io/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part2/</id>
    <published>2024-12-23T11:47:45.000Z</published>
    <updated>2024-12-23T11:47:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RT1024-EVK-学习笔记Part2"><a href="#RT1024-EVK-学习笔记Part2" class="headerlink" title="RT1024 EVK 学习笔记Part2"></a>RT1024 EVK 学习笔记Part2</h1><blockquote><p>POWER DOMAIN 部分！</p></blockquote><span id="more"></span><h2 id="功能模块供电"><a href="#功能模块供电" class="headerlink" title="功能模块供电"></a>功能模块供电</h2><h3 id="BUTTON部分"><a href="#BUTTON部分" class="headerlink" title="BUTTON部分"></a>BUTTON部分</h3><ul><li><p>包含三个按键：</p><ol><li>SW2: CPU <code>ONOFF</code>按键；–&gt; 连接到MCU <code>ONOFF</code>引脚；</li><li>SW3: 系统复位按键<code>POR_BUTTON</code>;–&gt; 连接到MCU <code>POR</code> 引脚；</li><li>SW4: 用户按键<code>USER_BUTTON</code>；–&gt; 连接到MCU的<code>WAKEUP</code>;</li></ol></li><li><p>每个按键的结构相似：</p><ol><li>SPST PB（Single Pole Single Throw Push Button）单刀单掷按钮</li><li><span style="color: green;">0.1uF的去抖电容；</span></li><li>接地连接</li></ol></li><li><p>按键工作原理：</p><ul><li>正常状态下通过上拉保持高电平<ul><li><span style="color: green;">按下时接地变为低电平；</span></li><li>电容用于消除按键抖动</li></ul></li></ul></li></ul><h3 id="USER-LED"><a href="#USER-LED" class="headerlink" title="USER LED"></a>USER LED</h3><blockquote><p>LED控制电路，使用了三极管驱动方案：</p></blockquote><ul><li><p>供电：<span style="color: red; font-weight: bold; ">(注意：DCDC_3V3 来自于 5V_SYS, 通过U4，有DCDC_3V3的输出！)</span></p><ul><li><p><code>DCDC_3V3</code>提供3.3V电源</p></li><li><p>R15（220Ω）作为LED**<u>限流电阻</u>**;</p></li></ul></li><li><p>LED部分：</p><ul><li><p><code>D5</code>是一个绿色LED</p></li><li><p><span style="color: blue;">阴极接三极管集电极；</span></p></li></ul></li><li><p>三极管驱动：</p><ul><li><p><code>Q521</code>是BC817-40LT1G <span style="color: green; ">NPN三极管；</span></p></li><li><p>R1870（2.2K）和R1856（22K）构成<span style="color: green; font-weight: bold; ">基极偏置网络；</span></p></li><li><p>MCU的<code>USER_LED</code>信号控制三极管导通；</p></li></ul></li><li><p>工作原理：</p><ul><li><p><code>USER_LED</code>低电平时，V(be) ≈0V, 三极管截止，LED熄灭；</p></li><li><p><code>USER_LED</code>高电平时，V(be) &gt; 0.7V, 三极管导通，LED点亮；</p></li><li><p>使用三极管可以提供更大的驱动能力</p></li></ul></li></ul><h2 id="关键电源管理"><a href="#关键电源管理" class="headerlink" title="关键电源管理"></a>关键电源管理</h2><style>.otbgihjutcgk{zoom:100%;}</style><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part2/image-20241223180155208.png" class="otbgihjutcgk"><h3 id="SD-Card-Power-Switch"><a href="#SD-Card-Power-Switch" class="headerlink" title="SD Card Power Switch"></a>SD Card Power Switch</h3><ul><li><p>电源路径：</p><ul><li>输入：<code>DCDC_3V3</code>（3.3V）</li><li>输出：<code>VSD_3V3</code>（SD卡供电）</li></ul></li><li><p>滤波：</p><ul><li><code>C171</code>（1.0μF/10V）：输入滤波</li><li><code>C30</code>（1.0μF/10V）：输出滤波</li></ul></li><li><p>控制逻辑：</p><ul><li><p>R28（10KΩ）上拉电阻到<code>DCDC_3V3</code>;</p></li><li><p>D7、D8二极管（RB521S30）构成AND门: 只有当<code>SD_PWREN</code>为高，且<code>POR_B</code>也为高时，<code>U27</code>才可以使能，有输出<code>VSD_3V3</code>;</p><blockquote><p>即：系统复位完成后，<code>POR_B</code>拉高，只有系统上电后、且SD卡使能 时，U27才工作，有输出：<code>VSD_3V3</code>!</p></blockquote></li></ul></li></ul><hr><style>.gvnoibbsioau{zoom:100%;}</style><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part2/image-20241223180059053.png" class="gvnoibbsioau"><h3 id="3V3-LDO-for-SNVS"><a href="#3V3-LDO-for-SNVS" class="headerlink" title="3V3 LDO for SNVS"></a>3V3 LDO for SNVS</h3><blockquote><p>这部分电路是 <strong>3.3V LDO（低压差稳压器）电源电路</strong>，用于为 <strong>SNVS（安全非易失性存储器供电域）</strong> 提供稳定的 3.3V 电压（<code>VLDO_3V3</code>）。</p></blockquote><p><span style="color: blue; font-weight: bold; ">电路组成：</span></p><ol><li><p><strong>输入电源部分：</strong></p><ul><li><strong>5V_SYS</strong> 是输入电源，提供5V电压。</li><li>C40 (10μF) 和 C41 (0.1μF)：<ul><li>是输入端的去耦电容，分别用于低频和高频噪声的滤波。</li><li><strong>C40</strong> 提供储能，减小输入电源的低频纹波。</li><li><strong>C41</strong> 用于滤除高频噪声，保护稳压器的输入端。</li></ul></li></ul></li><li><p><strong>LDO稳压器 (U3)：</strong></p><ul><li>U3 (UM1750S-00) 是一颗 LDO 稳压芯片，其主要引脚功能如下：<ul><li><strong>IN (1)：</strong> 输入引脚，连接 <code>5V_SYS</code>。</li><li><strong>OUT (5)：</strong> 输出引脚，生成稳定的 <code>VLDO_3V3</code>。</li><li><strong>GND (2)：</strong> 接地。</li><li><strong>FB (4)：</strong> 反馈引脚，用于调节和稳定输出电压，内部参考电压为 1V。</li><li><strong>SHDN (3)：</strong> 使能引脚，高电平使能稳压器，低电平关闭输出。</li></ul></li></ul></li><li><p><strong>反馈电路：</strong></p><ul><li><p>R32 (464kΩ) 和 R34 (200kΩ, 1%)：</p><ul><li><p>组成分压网络，用于将输出电压分压后反馈到 <strong>FB</strong> 引脚。</p></li><li><p>分压电路的电压关系为：</p><style>.ivsyrteastdg{zoom:100%;}</style><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part2/image-20241223180947687.png" class="ivsyrteastdg"></li></ul></li></ul></li><li><p><strong>输出滤波部分：</strong></p><ul><li>C42 (4.7μF, 6.3V) 和 C43 (0.1μF)：<ul><li><strong>C42</strong> 是主滤波电容，用于稳压器输出端的低频滤波，提供稳定的直流电压。</li><li><strong>C43</strong> 是高频滤波电容，用于抑制高频噪声和瞬态波动，提升稳定性。</li></ul></li></ul></li><li><p><strong>输出端：</strong></p><ul><li><code>VLDO_3V3</code>：<ul><li>是稳压器的输出电压，为后续电路提供稳定的 3.3V 电源，适用于 SNVS 域或其他低功耗模块。</li></ul></li></ul></li></ol><h3 id="SNVS"><a href="#SNVS" class="headerlink" title="SNVS"></a>SNVS</h3><p>在上面的输出<code>VLDO_3V3</code>，刚好就用于SNVS，产生<code>VDD_SNVS_3V3</code>,最终连接到MCU的引脚<code>VDD_SNVS_IN</code>:</p><style>.fjnxexwsfqrl{zoom:100%;}</style><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part2/image-20241223184723149.png" class="fjnxexwsfqrl"><hr><h3 id="NVCC-SD"><a href="#NVCC-SD" class="headerlink" title="NVCC_SD <SD3.0>"></a>NVCC_SD &lt;SD3.0&gt;</h3><blockquote><p>会根据 输入的 <code>SD0_VSELECT</code>信号，决定输出的<code>NVCC_SD</code>电压是1.8V或者3.3V，默认情况下是3.3V！</p></blockquote><style>.bjuuokjdrdaa{zoom:100%;}</style><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part2/image-20241223190241734.png" class="bjuuokjdrdaa"><hr><h2 id="核心电源域"><a href="#核心电源域" class="headerlink" title="核心电源域"></a>核心电源域</h2><style>.gwgwnckbcaon{zoom:100%;}</style><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part2/image-20241223182050938.png" class="gwgwnckbcaon"><h3 id="VDDHIGH-NVCC-xxx"><a href="#VDDHIGH-NVCC-xxx" class="headerlink" title="VDDHIGH/NVCC_xxx"></a>VDDHIGH/NVCC_xxx</h3><p>VDDHIGH/NVCC电源管理电路：</p><ol><li><strong>DC-DC转换器部分（U4 MP2144GJ）</strong>：<ul><li><p><strong>输入部分</strong>：</p><ul><li><code>5V_SYS</code>通过R38（0Ω）输入；</li><li>C49(10μF)/C50(10μF)/C51(0.1μF)输入滤波；</li></ul></li><li><p><strong>输出部分</strong>：</p><ul><li><code>L2</code>（1μH）储能电感；</li><li>C52(22μF)/C53(0.1μF)输出滤波；</li><li>输出<code>DCDC_3V3</code>（3.3V）；</li></ul></li><li><p><strong>使能部分：</strong></p><ul><li><span style="color: green;">通过<code>PMIC_ON_REQ</code>信号，当它为高时，才使能U4，有输出<code>DCDC_3V3</code>;</span></li><li>同时，控制U5的复位信号为低，不复位；否则U5会复位整个电路；</li></ul></li><li><p><strong>反馈控制</strong>：</p><ul><li>R40（180KΩ）/R42（40.2K）分压网络；计算得到输出为<code>3.28V</code>;</li><li>FB引脚监测输出电压；</li><li>注释显示R26/R30=4.5；<span style="color: blue; ">(???不知道是干嘛)</span></li></ul></li></ul></li><li><strong>复位控制电路（U5 UM605RE）</strong>：<ul><li><p><strong>输入信号</strong>：</p><ul><li><code>POR_BUTTON</code>：通过D9二极管</li><li><code>WDOG_B</code>：通过D10二极管</li><li>AND逻辑控制</li><li>当两者都为高时，才会使MR为高；只要有一个为低，都会导致MR使能；</li></ul></li><li><p><strong>电源监控</strong>：</p><ul><li>监控<code>VDD_SNVS_3V3</code></li><li>C60(0.1μF)去耦</li></ul></li></ul></li><li><strong>控制逻辑</strong>：<ul><li><p><strong>使能控制</strong>：</p><ul><li><code>PMIC_ON_REQ</code>信号</li><li>通过R41（10K）连接到EN引脚</li></ul></li><li><p><strong>PG（Power Good）</strong>：</p><ul><li>内部上拉到VIN，即<code>5V_SYS</code>;</li><li><code>DCDC_3V3_PG</code>信号输出;<span style="color: blue; font-weight: bold; ">(5V的PG怎么变成3V3的PG的？？搞不清楚)</span></li></ul></li></ul></li></ol><hr><h2 id="辅助电源"><a href="#辅助电源" class="headerlink" title="辅助电源"></a>辅助电源</h2><h3 id="ADC供电"><a href="#ADC供电" class="headerlink" title="ADC供电"></a>ADC供电</h3><p><code>DCDC_3V3</code>产生<code>VDDA_ADC_3V3</code>，供MCU端的引脚<code>VDDA_ADC_3P3</code>使用！</p><h3 id="DCDC-IN-VDD-HIGH-IN"><a href="#DCDC-IN-VDD-HIGH-IN" class="headerlink" title="DCDC_IN/VDD_HIGH_IN"></a>DCDC_IN/VDD_HIGH_IN</h3><p><code>DCDC_3V3</code>产生<code>MCU_DCDC_IN_3V3</code>，供MCU端的引脚<code>DCDC_IN</code>使用！</p><p><code>DCDC_3V3</code>产生<code>VDD_HIGH_IN_3V3</code>，供MCU端的引脚<code>VDD_HIGH_IN</code>使用！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>SOC的输入：(<code>VDD_SOC_IN</code>)的来源路径：</p><blockquote><p>5V_SYS -&gt; MP2144GJ(DC-DC) -&gt; DCDC_3V3/MCU_DCDC_IN_3V3 -&gt; DCDC_LP/DCDC_OUT -&gt; J4 -&gt; VDD_SOC_IN -&gt; MCU核心</p></blockquote></li><li><p>VDD_SNVS_IN</p><blockquote><p>5V_SYS -&gt; UM1750S-00 -&gt; VLDO_3V3 -&gt; VDD_SNVS_3V3</p></blockquote></li><li><p>VDD_HIGH_IN</p><blockquote><p>5V_SYS -&gt; MP2144GJ(DC-DC) -&gt; DCDC_3V3 -&gt; VDD_HIGH_IN_3V3</p></blockquote></li><li><p>VDDA_ADC_3P3</p><blockquote><p>5V_SYS -&gt; MP2144GJ(DC-DC) -&gt; DCDC_3V3 -&gt; VDDA_ADC_3P3</p></blockquote></li></ol><hr><style>.lwefvtzqzctn{zoom:100%;}</style><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part2/image-20241223192811426.png" class="lwefvtzqzctn"><ul><li>此外，先有 <code>MCU_DCDC_IN_3V3</code>, 然后才有 <code>MCU_DCDC_IN</code>。 <code>DCDC_LP</code> 引脚输出<code>DCDC_OUT</code>,供<code>VDD_SOC_IN</code>使用；</li><li><code>DCDC_PWITCH</code>引脚有一个PWITCH RC Delay电路，应该是用来保证上电时序的；</li><li><code>PMIC_ON_REQ</code>引脚对外输出该信号。决定了是否有<code>DCDC_3V3</code>的产生；</li><li><code>POR</code>引脚应该是低电平复位。接收输入的<code>POR_B</code>、<code>RST_TGTMCU_B</code>和U2。上电时，当电压达到阈值会释放复位，来确保上电时序。确保系统在电源稳定后才开始工作。</li><li><code>XTALI/XTALO</code>连接一个外部的24MHz晶振；<code>Y4</code></li><li><code>RTC_XTALI/RTC_XTALO</code>连接一个32.768KHZ的晶振：<code>Y2</code>;</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RT1024-EVK-学习笔记Part2&quot;&gt;&lt;a href=&quot;#RT1024-EVK-学习笔记Part2&quot; class=&quot;headerlink&quot; title=&quot;RT1024 EVK 学习笔记Part2&quot;&gt;&lt;/a&gt;RT1024 EVK 学习笔记Part2&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;POWER DOMAIN 部分！&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1024" scheme="https://dustofstars.github.io/categories/NXP/RT1024/"/>
    
    <category term="原理图" scheme="https://dustofstars.github.io/categories/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="hardware" scheme="https://dustofstars.github.io/tags/hardware/"/>
    
    <category term="原理图" scheme="https://dustofstars.github.io/tags/%E5%8E%9F%E7%90%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>RT1024 EVK 学习笔记Part1</title>
    <link href="https://dustofstars.github.io/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part1/"/>
    <id>https://dustofstars.github.io/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part1/</id>
    <published>2024-12-23T11:47:43.000Z</published>
    <updated>2024-12-23T11:47:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RT1024-EVK-学习笔记Part1"><a href="#RT1024-EVK-学习笔记Part1" class="headerlink" title="RT1024 EVK 学习笔记Part1"></a>RT1024 EVK 学习笔记Part1</h1><blockquote><p>Main Power &amp; USB &amp; FreeLink Debugger部分详细解释！</p></blockquote><span id="more"></span><h2 id="Page3-Main-Power"><a href="#Page3-Main-Power" class="headerlink" title="Page3 Main Power"></a>Page3 Main Power</h2><p>输入可以是三种电源选项，但是输出就一定是<code>5V_SYS</code>， 它用来给整个MCU系统供电。以下详细的从左到右：</p><ol><li><p><strong>电源输入部分</strong>：</p><ul><li>Barrel Connector（桶型接口）<code>J2</code>：用于连接外部5V的电源适配器；</li><li>C4 <code>0.1uF</code>电容：输入滤波电容，用于滤除输入电源的噪声;</li><li><code>TP1</code>：测试点，用于测量输入电压</li></ul></li><li><p><strong>MOSFET控制部分</strong>：</p><ul><li>FDMA530PZ（<code>Q1</code>）：功率MOSFET，用于电源开关控制；</li><li><code>D1</code>二极管：保护二极管，防止反向电流；</li><li><code>R3</code> 3.3K 电阻：限流电阻，保护MOSFET；</li></ul></li><li><p><strong>中间控制电路</strong>：</p><ul><li><code>SW1</code>：开关；</li><li>R4-R9：分压和偏置电阻网络</li><li>C5：稳定电容，用于滤波</li></ul></li><li><p><strong>LED指示电路</strong>：</p><ul><li><code>D3</code> LED_RED-GRN：双色LED，用于指示电源状态</li><li><code>Q4</code>（BSH1115）：控制LED的MOSFET</li><li>R10-R11：LED驱动电阻;</li></ul></li><li><p><strong>输出部分</strong>：</p><ul><li>C1-C3：输出滤波电容</li><li><code>J1</code>：输出接口;</li><li>C179-C180：去耦电容，用于稳定输出电压</li></ul></li></ol><blockquote><p><span style="color: red; font-weight: bold; ">关于J1短接选择不同的供电方式：</span></p><ul><li><p>1-2位置：<code>DC_5V_IN</code></p><ul><li><p>连接到<code>J2</code>的直流电源输入</p></li><li><p>适用于使用外部5V电源适配器供电的场景</p></li></ul></li><li><p>3-4位置：<code>5V_USB_OTG_S</code></p><ul><li>通过USB接口供电</li></ul></li><li><p>5-6位置：<code>P5V_SDA_S</code></p><ul><li><p>通过OpenSDA调试器供电</p></li><li><p>适用于使用调试器进行程序下载和调试的场景</p></li><li><p>集成了调试和供电功能</p></li></ul></li></ul></blockquote><p>那么，我们可以先看 <code>5V_USB_OTG_S</code>:</p><blockquote><p><span style="color: green; font-weight: bold; ">Page6 USB</span></p></blockquote><p>再看 <code>P5V_SDA_S</code>:</p><blockquote><p><span style="color: green; font-weight: bold; ">Page13 FREELINK</span></p></blockquote><h2 id="Page6-USB"><a href="#Page6-USB" class="headerlink" title="Page6 USB"></a>Page6 USB</h2><h3 id="USB-OTG-部分"><a href="#USB-OTG-部分" class="headerlink" title="USB OTG 部分"></a>USB OTG 部分</h3><ol><li><p><strong>接口部分</strong>：</p><ul><li>使用<code>USB AB 5</code>型接口，（指的是5Pin typeA/B）</li><li>包含5个引脚：VBUS（电源）、D+、D-（数据线）和GND（地）、和<strong>ID；</strong></li></ul></li><li><p><strong>保护电路</strong>：</p><ul><li>TVS二极管阵列（<code>U8</code> RClamp0854P）提供ESD保护;</li><li>保护USB接口免受静电和瞬态电压的损害</li><li>四个二极管保护四条信号线</li></ul></li><li><p><strong>EMI抑制</strong>：</p><ul><li>L3和L5（330Ω电感）用于抑制电磁干扰</li><li><span style="color: green;">L4（共模电感）用于抑制D+/D-信号线上的共模噪声；</span></li><li>这些元件确保信号传输的质量和稳定性</li></ul></li><li><p><strong>信号连接</strong>：</p><ul><li><code>OTG1_DN</code>和<code>OTG1_DP</code>是MCU的差分数据信号；</li><li>通过0Ω电阻（R68）连接ID线和<code>USB_OTG1_ID</code>信号，可以方便地断开或连接信号；</li><li><code>5V_USB_OTG</code>和<code>5V_USB_OTG_S</code>分别是USB供电的输入和输出</li></ul></li><li><p><strong>工作流程</strong>：</p><ul><li><p>当作为Host时：提供5V电源给外部设备</p></li><li><p>当作为Device时：接收外部供电</p></li><li><p>数据信号经过EMI滤波和ESD保护后与MCU连接</p><blockquote><p>作为device时，PC端供电，通过VBUS，提供给<code>5V_USB_OTG_S</code>，继而给整个MCU供电！</p></blockquote></li></ul></li></ol><style>.ztgusippowuu{zoom:100%;}</style><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part1/image-20241223152622192.png" class="ztgusippowuu"><h3 id="USB-POWER-部分"><a href="#USB-POWER-部分" class="headerlink" title="USB POWER 部分"></a>USB POWER 部分</h3><p>USB Power电路的工作原理如下：</p><ol><li><strong>核心控制芯片</strong>：<ul><li><code>U7</code>（NX5P3090UK）是一个专用的USB电源开关/限流器</li><li>主要功能如下，其中，<code>USB_OTG1_OC（过流检测信号）</code>，连接到<code>FAULT</code>引脚：<ul><li>电流限制</li><li>过流保护</li><li>电压监测</li><li>故障检测</li></ul></li></ul></li><li><strong>输入控制信号</strong>：<ul><li>EN（使能）引脚：控制电源开关的开启/关闭；</li><li>FAULT（故障）引脚：指示过流或短路故障；</li><li>VNT1/VNT2/VNT3：电压监测点；</li></ul></li><li><strong>工作流程</strong>：<ul><li>当MCU需要提供USB主机供电时：<ul><li>通过<code>USB_OTG1_ID</code>信号，自动检测是Device/Host，根据这个角色决定是否使能U7；<span style="color: green; font-weight: bold; ">工作在device模式，使能U7，对MCU供电；工作在Host模式，禁用U7；</span></li><li>U7监控输出电流和电压；</li><li>如果发生过流，FAULT信号激活；</li></ul></li></ul></li><li><strong>关键电路组件</strong>：<ul><li>C82/C83：输入滤波电容</li><li>C84：输出滤波电容</li><li>R67/R68：上拉电阻（100K）</li><li>R69/R70：配置电阻</li></ul></li><li><strong>应用场景</strong>：<ul><li>MCU作为USB主机时提供受控的5V电源</li><li>保护MCU和外部设备免受电气故障损坏</li></ul></li></ol><p>其中，两个最重要的信号线：</p><ol><li><p><code>USB_OTG1_OC</code> (Over Current):</p><ul><li><p>连接到U7的FAULT引脚</p></li><li><p>当发生过流时会触发</p></li><li><p>这个信号会反馈给MCU，用于过流保护</p></li></ul></li><li><p><code>5V_USB_OTG</code> VBUS:</p><ul><li><p>这是U7的输出端</p></li><li><p>提供受控的5V电源给USB接口</p></li><li><p>通过VBUS1/2/3引脚输出</p></li><li><p>经过C84去耦电容滤波</p></li></ul></li></ol><p>这两个信号构成了USB供电的核心监控和输出功能：</p><ul><li>一个负责监控安全（OC）</li><li>一个负责实际供电（VBUS）</li></ul><p>另外需要注意的是：</p><ol><li><p><strong>Device模式（作为设备被供电）</strong>：</p><ul><li>供电流程：<ul><li>外部USB Host提供5V电源</li><li>通过USB接口进入，形成<code>5V_USB_OTG</code></li><li>经过R312连接到<code>5V_USB_OTG_S</code></li><li>通过J1(3-4)选择作为<code>5V_SYS</code></li><li>为整个系统供电</li></ul></li><li><span style="color: green;">此时U7不工作，仅作为通路；</span></li></ul></li><li><p><strong>Host模式（作为主机供电）</strong>：</p><ul><li>供电流程：<ul><li>通过其他方式（DC或OpenSDA）产生<code>5V_SYS</code></li><li><span style="color: green;"><code>5V_SYS</code>作为<code>U7</code>的输入；</span></li><li>U7控制并输出<code>5V_USB_OTG</code>；</li><li>通过USB接口<code>VBUS</code>引脚对外供电<code>5V_USB_OTG</code>;</li></ul></li><li>U7提供电流限制和保护功能</li></ul></li><li><p><strong>关键理解点</strong>：</p><ul><li>5V_USB_OTG和5V_USB_OTG_S的关系：<ul><li>它们在电路中是相连的</li><li>但在不同模式下电流方向不同</li></ul></li><li>U7的作用：<ul><li>仅在Host模式时起作用</li><li>提供受控的5V输出</li><li>保护系统免受过流影响</li></ul></li></ul></li><li><p><strong>工作模式切换</strong>：</p><ul><li>通过ID信号识别当前模式</li><li>自动配置电源流向</li><li>U7根据模式自动使能或禁用</li></ul></li></ol><p>这种设计支持USB OTG的双向供电特性，允许设备在不同场景下灵活切换角色。看似复杂的电源路径实际上是为了实现这种灵活性。</p><style>.tuqbdhwloixf{zoom:100%;}</style><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part1/image-20241223160209612.png" class="tuqbdhwloixf"><h2 id="Page13-FREELINK"><a href="#Page13-FREELINK" class="headerlink" title="Page13 FREELINK"></a>Page13 FREELINK</h2><blockquote><p>FreeLink部分的核心组件是<code>LPC4322JET100</code>，暂时先不看它，只需要知道<code>J42</code>跳线帽会控制FreeLink的DFU模式，进入firmware重新烧写即可！ </p><p><span style="color: red; ">还有一个有意思的点，这个LPC需要外部的12MHz晶振<code>Y5</code>;</span></p><p>还有，MCU的UART1连接了电平转换芯片<code>NTS0102</code>，因此可以到PC的虚拟串口输出打印log。</p></blockquote><p>对于Power部分来说，仍然是上一节的老朋友：</p><p><code>U31</code>仍然是一个<code>NX5P3090UK</code>:</p><style>.vqkimoxmrnrb{zoom:100%;}</style><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part1/image-20241223160614690.png" class="vqkimoxmrnrb"><ol><li><strong>电源路径</strong>：<ul><li>输入：<code>P5V_SDA</code>通过U31的输入端</li><li>控制：经过U31的内部开关和保护电路</li><li>输出：通过U31的<code>VBUS1/2/3</code>引脚输出到<code>P5V_SDA_S</code></li></ul></li><li><strong>控制机制</strong>：<ul><li><code>POWER_EN</code>通过R216（1K）控制U31的使能</li><li><code>VTRG_FAULT_B</code>通过R215（10K）提供故障监测</li><li><code>5V_SDA_PSW</code>是在输出端额外引出的监测信号，可供外部使用；</li></ul></li></ol><p>那么，对于这种方式，电源路径如下：</p><blockquote><p>  <span style="color: green; font-weight: bold; ">调试器USB -&gt; VBUS -&gt; P5V_SDA -&gt; U31 -&gt; P5V_SDA_S -&gt; J1(5-6) -&gt; 5V_SYS</span></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RT1024-EVK-学习笔记Part1&quot;&gt;&lt;a href=&quot;#RT1024-EVK-学习笔记Part1&quot; class=&quot;headerlink&quot; title=&quot;RT1024 EVK 学习笔记Part1&quot;&gt;&lt;/a&gt;RT1024 EVK 学习笔记Part1&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Main Power &amp;amp; USB &amp;amp; FreeLink Debugger部分详细解释！&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1024" scheme="https://dustofstars.github.io/categories/NXP/RT1024/"/>
    
    <category term="原理图" scheme="https://dustofstars.github.io/categories/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="hardware" scheme="https://dustofstars.github.io/tags/hardware/"/>
    
    <category term="原理图" scheme="https://dustofstars.github.io/tags/%E5%8E%9F%E7%90%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>RT1060--串口edma详解(SDK)</title>
    <link href="https://dustofstars.github.io/NXP/RT1060/rt1060-%E4%B8%B2%E5%8F%A3edma%E8%AF%A6%E8%A7%A3-sdk/"/>
    <id>https://dustofstars.github.io/NXP/RT1060/rt1060-%E4%B8%B2%E5%8F%A3edma%E8%AF%A6%E8%A7%A3-sdk/</id>
    <published>2024-12-18T15:38:41.000Z</published>
    <updated>2024-12-18T15:38:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="串口edma详解"><a href="#串口edma详解" class="headerlink" title="串口edma详解"></a>串口edma详解</h1><blockquote><p>这次我们来一起看一下，基于 NXP MIMXRT1060 开发板的串口通信示例工程，学习如何使用 EDMA(增强型直接内存访问)来实现高效的串口数据传输。</p></blockquote><p>主要特点：</p><ol><li>使用 LPUART (低功耗串口)进行通信</li><li>利用 EDMA 实现数据传输，减少 CPU 干预</li><li>实现了一个回显功能 - 将接收到的数据发送回去</li></ol><span id="more"></span><h2 id="关键数据流"><a href="#关键数据流" class="headerlink" title="关键数据流"></a>关键数据流</h2><ul><li><p><span style="color: blue;"><strong>接收流程：</strong></span>串口输入 -&gt; LPUART接收寄存器 -&gt; EDMA传输 -&gt; 接收缓冲区(<code>g_rxBuffer</code>)</p></li><li><p><span style="color: blue;"><strong>发送流程：</strong></span>发送缓冲区(<code>g_txBuffer</code>) -&gt; EDMA传输 -&gt; LPUART发送寄存器 -&gt; 串口输出</p></li></ul><h2 id="lpuart-edma-transfer-c-工作流程"><a href="#lpuart-edma-transfer-c-工作流程" class="headerlink" title="lpuart_edma_transfer.c 工作流程"></a>lpuart_edma_transfer.c 工作流程</h2><ol><li>系统初始化：</li></ol><ul><li>配置 LPUART（波特率115200，使能收发）</li><li>配置 DMAMUX（设置 DMA 通道映射）</li><li>初始化 EDMA（并创建传输句柄）</li></ul><ol start="2"><li>主循环逻辑：</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* If RX is idle and g_rxBuffer is empty, start to read data to g_rxBuffer. */</span></span><br><span class="line">    <span class="keyword">if</span> ((!rxOnGoing) &amp;&amp; rxBufferEmpty)</span><br><span class="line">    {</span><br><span class="line">        rxOnGoing = <span class="literal">true</span>;</span><br><span class="line">        LPUART_ReceiveEDMA(DEMO_LPUART, &amp;g_lpuartEdmaHandle, &amp;receiveXfer);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If TX is idle and g_txBuffer is full, start to send data. */</span></span><br><span class="line">    <span class="keyword">if</span> ((!txOnGoing) &amp;&amp; txBufferFull)</span><br><span class="line">    {</span><br><span class="line">        txOnGoing = <span class="literal">true</span>;</span><br><span class="line">        LPUART_SendEDMA(DEMO_LPUART, &amp;g_lpuartEdmaHandle, &amp;sendXfer);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If g_txBuffer is empty and g_rxBuffer is full, copy g_rxBuffer to g_txBuffer. */</span></span><br><span class="line">    <span class="keyword">if</span> ((!rxBufferEmpty) &amp;&amp; (!txBufferFull))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">memcpy</span>(g_txBuffer, g_rxBuffer, ECHO_BUFFER_LENGTH);</span><br><span class="line">        rxBufferEmpty = <span class="literal">true</span>;</span><br><span class="line">        txBufferFull  = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>检查接收缓冲区状态，空闲则启动新的接收</li><li>检查发送缓冲区状态，满则启动新的发送</li><li>在接收完成且发送空闲时，将数据从接收缓冲区复制到发送缓冲区</li></ul><ol start="3"><li>状态管理：</li></ol><ul><li>使用回调函数处理传输完成事件</li><li>通过状态标志(<code>rxBufferEmpty</code>, <code>txBufferFull</code>等)协调收发过程</li></ul><h2 id="仔细分析callback机制"><a href="#仔细分析callback机制" class="headerlink" title="仔细分析callback机制"></a>仔细分析callback机制</h2><blockquote><p>首先看到几个关键的回调函数:</p><ol><li><code>LPUART_UserCallback</code> - 这是用户层的回调函数,在main中注册</li><li><code>LPUART_SendEDMACallback</code> - EDMA发送完成的回调</li><li><code>LPUART_ReceiveEDMACallback</code> - EDMA接收完成的回调</li><li><code>LPUART_TransferEdmaHandleIRQ</code> - LPUART的EDMA中断处理函数</li></ol></blockquote><p><span style="color: blue; font-weight: bold;">从代码中可以看到调用链路:</span></p><ol><li><p>在main中通过<code>LPUART_TransferCreateHandleEDMA</code>注册了用户回调:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create LPUART DMA handle. */</span></span><br><span class="line">LPUART_TransferCreateHandleEDMA(DEMO_LPUART, &amp;g_lpuartEdmaHandle, LPUART_UserCallback, <span class="literal">NULL</span>, &amp;g_lpuartTxEdmaHandle,</span><br><span class="line">                                &amp;g_lpuartRxEdmaHandle);</span><br></pre></td></tr></tbody></table></figure></li><li><p><span style="color: blue;"><strong>当EDMA传输完成时,会触发中断,调用<code>LPUART_TransferEdmaHandleIRQ()</code>;</strong></span></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Save the handle in global variables to support the double weak mechanism. */</span></span><br><span class="line">s_lpuartHandle[instance] = handle;</span><br><span class="line"><span class="comment">/* Set LPUART_TransferEdmaHandleIRQ as DMA IRQ handler */</span></span><br><span class="line">s_lpuartIsr[instance] = LPUART_TransferEdmaHandleIRQ;</span><br><span class="line"><span class="comment">/* Disable all LPUART internal interrupts */</span></span><br><span class="line">LPUART_DisableInterrupts(base, (<span class="type">uint32_t</span>)kLPUART_AllInterruptEnable);</span><br><span class="line"><span class="comment">/* Enable interrupt in NVIC. */</span></span><br><span class="line">(<span class="type">void</span>)EnableIRQ(s_lpuartIRQ[instance]);</span><br></pre></td></tr></tbody></table></figure></li><li><p>在EDMA的回调中会更新状态标志并调用用户回调:</p></li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LPUART_SendEDMACallback</span><br><span class="line">LPUART_ReceiveEDMACallback</span><br><span class="line">    --&gt; LPUART_UserCallback</span><br></pre></td></tr></tbody></table></figure><p>以下是LPUART EDMA传输的回调流程图:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[EDMA传输开始] --&gt; B[EDMA传输完成中断]</span><br><span class="line">    B --&gt; C[LPUART_TransferEdmaHandleIRQ]</span><br><span class="line">    C --&gt; D{传输类型?}</span><br><span class="line">    D --&gt;|发送完成| E[LPUART_SendEDMACallback]</span><br><span class="line">    D --&gt;|接收完成| F[LPUART_ReceiveEDMACallback]</span><br><span class="line">    E --&gt; G[LPUART_UserCallback]</span><br><span class="line">    F --&gt; G</span><br><span class="line">    G --&gt;|TX完成| H[设置txBufferFull=false&lt;br&gt;txOnGoing=false]</span><br><span class="line">    G --&gt;|RX完成| I[设置rxBufferEmpty=false&lt;br&gt;rxOnGoing=false]</span><br></pre></td></tr></tbody></table></figure><style>.iipenkojdsrs{zoom:100%;}</style><img src="/NXP/RT1060/rt1060-%E4%B8%B2%E5%8F%A3edma%E8%AF%A6%E8%A7%A3-sdk/image-20241218231344599.png" class="iipenkojdsrs"><p><span style="color: blue; font-weight: bold;">所以整个调用链是:</span></p><ol><li>EDMA完成传输</li><li>触发LPUART传输完成中断</li><li>调用<code>LPUART_TransferEdmaHandleIRQ</code></li><li><code>LPUART_TransferEdmaHandleIRQ</code>调用用户回调</li><li>用户回调更新状态标志</li></ol><p>这个机制实现了:</p><ol><li>硬件中断与软件处理的解耦</li><li>灵活的状态管理</li><li>异步操作的完成通知</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>初始化流程:</li></ol><ul><li>main函数中创建EDMA handle</li><li>注册<code>LPUART_UserCallback</code>作为用户回调</li><li>配置EDMA通道和中断</li></ul><ol start="2"><li>发送流程:</li></ol><ul><li>LPUART_SendEDMA触发发送</li><li>EDMA完成后触发中断</li><li>通过回调链更新状态标志</li></ul><ol start="3"><li>接收流程:</li></ol><ul><li>LPUART_ReceiveEDMA启动接收</li><li>EDMA完成后触发中断</li><li>通过回调链更新状态标志</li></ul><ol start="4"><li>状态管理:</li></ol><ul><li>txOnGoing/rxOnGoing表示传输进行状态</li><li>txBufferFull/rxBufferEmpty表示缓冲区状态</li><li>这些标志在回调中更新,在主循环中使用</li></ul><p>这种回调机制实现了:</p><ol><li>异步处理EDMA传输</li><li>状态管理的解耦</li><li>用户代码与底层驱动的分离</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;串口edma详解&quot;&gt;&lt;a href=&quot;#串口edma详解&quot; class=&quot;headerlink&quot; title=&quot;串口edma详解&quot;&gt;&lt;/a&gt;串口edma详解&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;这次我们来一起看一下，基于 NXP MIMXRT1060 开发板的串口通信示例工程，学习如何使用 EDMA(增强型直接内存访问)来实现高效的串口数据传输。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;主要特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 LPUART (低功耗串口)进行通信&lt;/li&gt;
&lt;li&gt;利用 EDMA 实现数据传输，减少 CPU 干预&lt;/li&gt;
&lt;li&gt;实现了一个回显功能 - 将接收到的数据发送回去&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1060" scheme="https://dustofstars.github.io/categories/NXP/RT1060/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="中断" scheme="https://dustofstars.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
    <category term="DMA" scheme="https://dustofstars.github.io/tags/DMA/"/>
    
  </entry>
  
  <entry>
    <title>RT1060--串口中断传输详解(SDK)</title>
    <link href="https://dustofstars.github.io/NXP/RT1060/rt1060-%E4%B8%B2%E5%8F%A3%E4%B8%AD%E6%96%AD%E4%BC%A0%E8%BE%93%E8%AF%A6%E8%A7%A3-sdk/"/>
    <id>https://dustofstars.github.io/NXP/RT1060/rt1060-%E4%B8%B2%E5%8F%A3%E4%B8%AD%E6%96%AD%E4%BC%A0%E8%BE%93%E8%AF%A6%E8%A7%A3-sdk/</id>
    <published>2024-12-17T09:42:42.000Z</published>
    <updated>2024-12-17T09:42:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="串口中断传输详解-SDK"><a href="#串口中断传输详解-SDK" class="headerlink" title="串口中断传输详解(SDK)"></a>串口中断传输详解(SDK)</h1><span id="more"></span><h2 id="1-evkmimxrt1060-lpuart-interrupt"><a href="#1-evkmimxrt1060-lpuart-interrupt" class="headerlink" title="1. evkmimxrt1060_lpuart_interrupt"></a>1. evkmimxrt1060_lpuart_interrupt</h2><blockquote><p>使用 NXP 的 <code>fsl_lpuart.h</code> 库，通过中断方式实现 LPUART 的数据接收和回显。</p><p>它使用了一个<code>ring buffer</code>来暂存接收到的数据，然后在主循环中将缓冲区的数据发送出去。</p></blockquote><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ol><li><p>宏定义：</p><ul><li><code>DEMO_LPUART</code>: 定义使用的 LPUART 外设为 <code>LPUART1</code>。</li><li><code>DEMO_LPUART_CLK_FREQ</code>: 定义 LPUART 的时钟频率。</li><li><code>DEMO_LPUART_IRQn</code>: 定义 LPUART 的中断号。</li><li><code>DEMO_LPUART_IRQHandler</code>: 定义 LPUART 的中断处理函数名。</li><li><code>DEMO_RING_BUFFER_SIZE</code>: 定义环形缓冲区的大小为 16 字节。</li></ul></li><li><p>全局变量：</p><ul><li><code>g_tipString</code>: 提示字符串，程序启动时发送到串口。</li><li><code>demoRingBuffer</code>: 环形缓冲区，<span style="color:green">用于存储接收到的数据</span>。</li><li><code>txIndex</code>: 发送索引，指向下一个要发送的数据在环形缓冲区中的位置。</li><li><code>rxIndex</code>: 接收索引，指向下一个要写入接收数据的环形缓冲区位置。</li></ul></li><li><p><code>DEMO_LPUART_IRQHandler()</code> 函数：</p><p> LPUART 中断处理函数：</p><ul><li>如果Rx Data 寄存器满，则：<ul><li>读取receiver register数据： (<code>LPUART_ReadByte()</code>)。</li><li>读完之后检查环形缓冲区是否已满，如果未满，则将接收到的数据写入环形缓冲区，并更新 <code>rxIndex</code>。</li></ul></li></ul></li><li><p><code>main()</code> 函数：</p><ul><li>初始化开发板和 LPUART。</li><li>发送提示字符串。</li><li>使能 LPUART 的接收满中断  (<code>kLPUART_RxDataRegFullInterruptEnable</code>)。</li><li>使能 LPUART 中断 (<code>EnableIRQ(DEMO_LPUART_IRQn)</code>)。</li><li>进入主循环：<ul><li>检查 LPUART 发送寄存器是否为空 (<code>kLPUART_TxDataRegEmptyFlag</code>)。</li><li>检查环形缓冲区是否非空。</li><li>如果发送寄存器为空且缓冲区非空，则从环形缓冲区读取数据 (<code>demoRingBuffer[txIndex]</code>)，并通过 <code>LPUART_WriteByte()</code> 发送出去，并更新 <code>txIndex</code>。</li></ul></li></ul></li></ol><h3 id="数据-中断-callback调用流程图"><a href="#数据-中断-callback调用流程图" class="headerlink" title="数据/中断/callback调用流程图"></a><strong>数据/中断/callback调用流程图</strong></h3><style>.xxjliqvpusek{zoom:100%;}</style><img src="/NXP/RT1060/rt1060-%E4%B8%B2%E5%8F%A3%E4%B8%AD%E6%96%AD%E4%BC%A0%E8%BE%93%E8%AF%A6%E8%A7%A3-sdk/image-20241217175339831.png" class="xxjliqvpusek"><p><strong>详细流程解释：</strong></p><ol><li>中断处理：<ul><li>读取接收到的数据并存入环形缓冲区 <code>demoRingBuffer</code>。</li><li>更新接收索引 <code>rxIndex</code>。</li></ul></li><li>主循环处理：<ul><li>主循环不断检查 LPUART 发送寄存器是否为空以及环形缓冲区是否非空。</li><li>如果条件满足，则从环形缓冲区读取数据，并通过 <code>LPUART_WriteByte()</code> 发送出去。</li><li>更新发送索引 <code>txIndex</code>。</li></ul></li><li><strong>数据发送：</strong> LPUART 硬件将数据发送到串口接收端。</li></ol><h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a><strong>关键点</strong></h3><ul><li><strong>环形缓冲区：</strong> 用于在中断处理函数和主循环之间传递数据，避免数据丢失。</li><li><strong>中断驱动：</strong> 使用中断来处理接收事件，提高了 CPU 效率。</li><li><strong>非阻塞发送：</strong> 主循环中轮询检查发送寄存器是否为空和ring buffer非空，用于读取数据并发送，更新<code>txIndex</code>;</li></ul><h2 id="2-evkmimxrt1060-lpuart-interrupt-transfer"><a href="#2-evkmimxrt1060-lpuart-interrupt-transfer" class="headerlink" title="2. evkmimxrt1060_lpuart_interrupt_transfer"></a>2. evkmimxrt1060_lpuart_interrupt_transfer</h2><blockquote><p>使用 LPUART 进行回显。</p><p>程序通过 LPUART 接收用户输入的 8 个字符，然后将这 8 个字符回显给用户终端。</p></blockquote><h3 id="代码解释-1"><a href="#代码解释-1" class="headerlink" title="代码解释"></a>代码解释</h3><p><strong>代码结构：</strong></p><ol><li><p><strong>宏定义</strong>：定义了一些宏和变量，例如使用的 LPUART 实例 (<code>DEMO_LPUART</code>)、时钟频率 (<code>DEMO_LPUART_CLK_FREQ</code>)、回显缓冲区长度 (<code>ECHO_BUFFER_LENGTH</code>) 。</p></li><li><p><strong>callback声明</strong>：声明了一个 LPUART 用户回调函数 <code>LPUART_UserCallback</code>。</p></li><li><p><strong>变量</strong>：定义了一些全局变量，例如用于存储句柄 (<code>g_lpuartHandle</code>)、提示信息字符串 (<code>g_tipString</code>)、发送缓冲区 (<code>g_txBuffer</code>)、接收缓冲区 (<code>g_rxBuffer</code>) 等，还有一些标志位用于指示缓冲区状态和传输状态：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> rxBufferEmpty            = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> txBufferFull             = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> txOnGoing                = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> rxOnGoing                = <span class="literal">false</span>;</span><br></pre></td></tr></tbody></table></figure></li><li><p>**LPUART 用户回调函数 (LPUART_UserCallback)**：该函数会在 LPUART 传输完成 (发送或接收) 时被调用。它更新发送和接收缓冲区的相关标志位 (txBufferFull、txOnGoing、rxBufferEmpty、rxOnGoing)。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* LPUART user callback */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LPUART_UserCallback</span><span class="params">(LPUART_Type *base, <span class="type">lpuart_handle_t</span> *handle, <span class="type">status_t</span> status, <span class="type">void</span> *userData)</span></span><br><span class="line">{</span><br><span class="line">    userData = userData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kStatus_LPUART_TxIdle == status) <span class="comment">// 实际上就是发送完成！</span></span><br><span class="line">    {</span><br><span class="line">        txBufferFull = <span class="literal">false</span>;</span><br><span class="line">        txOnGoing    = <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kStatus_LPUART_RxIdle == status) <span class="comment">// 实际上对应接收完成！</span></span><br><span class="line">    {</span><br><span class="line">        rxBufferEmpty = <span class="literal">false</span>;</span><br><span class="line">        rxOnGoing     = <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>主函数 (main)</p><ul><li><p>初始化时钟、引脚复用等。</p></li><li><p>配置 LPUART：设置波特率、启用发送和接收功能等。</p></li><li><p>创建 LPUART 传输句柄。</p><p><code>LPUART_TransferCreateHandle(DEMO_LPUART, &amp;g_lpuartHandle, LPUART_UserCallback, NULL);</code></p></li><li><p>发送提示信息字符串。</p><p><code>LPUART_TransferSendNonBlocking(DEMO_LPUART, &amp;g_lpuartHandle, &amp;xfer);</code></p></li><li><p>进入循环，实现回显功能：</p><ul><li><p>如果接收空闲且接收缓冲区为空，则启动接收数据到接收缓冲区。</p><p><code>LPUART_TransferReceiveNonBlocking(DEMO_LPUART, &amp;g_lpuartHandle, &amp;receiveXfer, NULL);</code></p></li><li><p>如果发送空闲且发送缓冲区满，则启动发送数据。</p><p><code>LPUART_TransferSendNonBlocking(DEMO_LPUART, &amp;g_lpuartHandle, &amp;sendXfer);</code></p></li><li><p>如果接收非空且发送不满，则将接收缓冲区内容复制到发送缓冲区，并更新缓冲区标志位。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(g_txBuffer, g_rxBuffer, ECHO_BUFFER_LENGTH);</span><br><span class="line">rxBufferEmpty = <span class="literal">true</span>;</span><br><span class="line">txBufferFull  = <span class="literal">true</span>;</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li></ol><p><strong>流程图：</strong></p><p><strong>数据流：</strong></p><ol><li>初始化阶段：<ul><li>配置 LPUART。</li></ul></li><li>发送提示信息：<ul><li>将提示信息字符串拷贝到发送缓冲区。</li><li>启动发送。</li></ul></li><li>回显循环：<ul><li>接收数据：<ul><li>如果接收空闲且接收缓冲区为空，则启动接收数据。</li><li>接收完成触发回调函数，更新接收缓冲区标志位。</li></ul></li><li>发送数据：<ul><li>如果发送空闲且发送缓冲区满，则启动发送数据。</li><li>发送完成触发回调函数，更新发送缓冲区标志位。</li></ul></li><li>复制数据：<ul><li>如果接收非空且发送不满，则将接收缓冲区内容复制到发送缓冲区。</li><li>更新接收和发送缓冲区标志位。</li></ul></li></ul></li></ol><p><strong>中断和回调流程：</strong></p><ol><li>当数据接收完成或发送完成后，会产生中断。</li><li>中断服务程序会将控制权转移到 LPUART 驱动程序。</li><li>驱动程序会调用用户回调函数 <code>LPUART_UserCallback</code>。</li><li>回调函数中，根据传输完成类型 (发送/接收) 更新相关的缓冲区标志位。</li></ol><p><strong>注意：</strong></p><ul><li>该代码使用非阻塞式传输，即发送或接收启动后，程序不会等待传输完成，而是继续执行其他操作。</li><li>回调函数中只更新了标志位，并没有直接操作数据缓冲区。数据处理是在主循环中进行的。</li></ul><p><strong>代码关键点</strong></p><ul><li><strong>非阻塞传输：</strong> 使用了 <code>LPUART_TransferSendNonBlocking</code> 和 <code>LPUART_TransferReceiveNonBlocking</code> 函数，这意味着发送和接收操作会在后台进行，不会阻塞主循环。</li><li><strong>回调函数：</strong> <code>LPUART_UserCallback</code> 函数用于处理传输完成事件。在这个函数中，主要任务是更新标志位，例如 <code>txOnGoing</code>、<code>txBufferFull</code>、<code>rxOnGoing</code> 和 <code>rxBufferEmpty</code>。</li><li><strong>缓冲区管理：</strong> 使用了 <code>g_txBuffer</code> 和 <code>g_rxBuffer</code> 作为发送和接收缓冲区，并通过 <code>memcpy</code> 函数在两个缓冲区之间复制数据。</li><li><strong>主循环逻辑：</strong> 主循环负责启动发送和接收操作，并在缓冲区之间复制数据。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    subgraph 初始化</span><br><span class="line">        A[初始化 LPUART] --&gt; B{发送提示信息}</span><br><span class="line">        B --&gt; C[启动发送&lt;br&gt;LPUART_TransferSendNonBlocking]</span><br><span class="line">        C --&gt; D{等待发送完成&lt;br&gt; txOnGoing }</span><br><span class="line">    end</span><br><span class="line">    D --&gt; E[回显循环]</span><br><span class="line">    subgraph 接收</span><br><span class="line">        E --&gt; F{接收空闲 &amp; 接收缓冲区为空&lt;br&gt; !rxOnGoing &amp;&amp; rxBufferEmpty }</span><br><span class="line">        F -- 是 --&gt; G[启动接收&lt;br&gt;LPUART_TransferReceiveNonBlocking]</span><br><span class="line">        G --&gt; H[LPUART 硬件接收数据&lt;br&gt;RxDataRegFullFlag 置位]</span><br><span class="line">        H --&gt; I[产生中断信号]</span><br><span class="line">        I --&gt; J[NVIC 处理中断&lt;br&gt;调用中断服务例程&lt;br&gt;LPUART_TransferHandleIRQ]</span><br><span class="line">        J --&gt; K[中断服务例程&lt;br&gt;调用 LPUART_UserCallback&lt;br&gt;kStatus_LPUART_RxIdle&lt;br&gt;rxBufferEmpty = false&lt;br&gt;rxOnGoing = false]</span><br><span class="line">    end</span><br><span class="line">    subgraph 发送</span><br><span class="line">        E --&gt; L{发送空闲 &amp; 发送缓冲区满&lt;br&gt; !txOnGoing &amp;&amp; txBufferFull }</span><br><span class="line">        L -- 是 --&gt; M[启动发送&lt;br&gt;LPUART_TransferSendNonBlocking]</span><br><span class="line">        M --&gt; N[LPUART 硬件发送数据]</span><br><span class="line">        N --&gt; O[发送完成&lt;br&gt;产生中断信号]</span><br><span class="line">        O --&gt; P[NVIC 处理中断&lt;br&gt;调用中断服务例程&lt;br&gt;LPUART_TransferHandleIRQ]</span><br><span class="line">        P --&gt; Q[中断服务例程&lt;br&gt;调用 LPUART_UserCallback&lt;br&gt;kStatus_LPUART_TxIdle&lt;br&gt;txBufferFull = false&lt;br&gt;txOnGoing = false]</span><br><span class="line">    end</span><br><span class="line">    E --&gt; R{接收缓冲区非空 &amp; 发送缓冲区未满&lt;br&gt; !rxBufferEmpty &amp;&amp; !txBufferFull}</span><br><span class="line">    R -- 是 --&gt; S[数据复制&lt;br&gt;memcpy&lt;br&gt;rxBufferEmpty = true&lt;br&gt;txBufferFull = true]</span><br><span class="line">    K --&gt; E</span><br><span class="line">    Q --&gt; E</span><br><span class="line">    S --&gt; E</span><br></pre></td></tr></tbody></table></figure><p><img src="/export.svg"></p><h3 id="代码逻辑解释："><a href="#代码逻辑解释：" class="headerlink" title="代码逻辑解释："></a><strong>代码逻辑解释：</strong></h3><ol><li><p><strong>初始化：</strong> 程序首先初始化 LPUART 外设，然后发送一个提示信息。</p></li><li><p>回显循环：</p><p> 程序进入一个无限循环，不断检查以下条件：</p><ul><li><span style="color:green"><strong>接收：</strong></span><ul><li>如果当前没有正在接收数据 (<code>!rxOnGoing</code>) 并且接收缓冲区为空 (<code>rxBufferEmpty</code>)，则启动一次非阻塞的接收操作 (<code>LPUART_TransferReceiveNonBlocking</code>)。</li><li>当 LPUART 硬件接收到数据后，<code>RxDataRegFullFlag</code> 标志位会被置位，触发中断。</li><li>NVIC 接收到中断请求后，会调用中断服务例程。在中断服务例程中，会调用用户定义的回调函数 <code>LPUART_UserCallback</code>。<ul><li>回调函数根据 <code>kStatus_LPUART_RxIdle</code> 状态将 <code>rxBufferEmpty</code> 设置为 <code>false</code>，将 <code>rxOnGoing</code> 设置为 <code>false</code>，表明接收已完成。</li></ul></li></ul></li><li><span style="color:green"><strong>发送：</strong></span><ul><li>如果当前没有正在发送数据 (<code>!txOnGoing</code>) 并且发送缓冲区已满 (<code>txBufferFull</code>)，则启动一次非阻塞的发送操作 (<code>LPUART_TransferSendNonBlocking</code>)。</li><li>LPUART 硬件发送完数据后，会产生中断。</li><li>NVIC 处理中断，并调用回调函数 <code>LPUART_UserCallback</code>。<ul><li>回调函数根据 <code>kStatus_LPUART_TxIdle</code> 状态将 <code>txBufferFull</code> 设置为 <code>false</code>，将 <code>txOnGoing</code> 设置为 <code>false</code>，表明发送已完成。</li></ul></li></ul></li><li><span style="color:green"><strong>数据复制：</strong></span>如果接收缓冲区非空 (<code>!rxBufferEmpty</code>) 并且发送缓冲区未满 (<code>!txBufferFull</code>)，则使用 <code>memcpy</code> 函数将接收缓冲区的数据复制到发送缓冲区，并将 <code>rxBufferEmpty</code> 设置为 <code>true</code>，<code>txBufferFull</code> 设置为 <code>true</code>，为下一次接收和发送做准备。</li></ul></li></ol><h3 id="关于中断和回调"><a href="#关于中断和回调" class="headerlink" title="关于中断和回调"></a>关于中断和回调</h3><p><code>LPUART_UserCallback</code> 是一个用户自定义的回调函数，它会在 LPUART 驱动程序中的中断处理函数 <code>LPUART_TransferHandleIRQ</code> 中，当特定的传输事件发生后被调用。具体来说，以下几种情况下会调用 <code>LPUART_UserCallback</code>：</p><ol><li><strong>接收完成：</strong> 当使用 <code>LPUART_TransferReceiveNonBlocking</code> 函数启动非阻塞接收，并且所有请求的数据都已接收完毕时，<code>LPUART_TransferHandleIRQ</code> 函数会在处理接收数据就绪中断时调用 <code>LPUART_UserCallback</code>，并传递状态 <code>kStatus_LPUART_RxIdle</code>。</li><li><strong>发送完成：</strong> 当使用 <code>LPUART_TransferSendNonBlocking</code> 函数启动非阻塞发送，并且所有数据都已发送完毕时，<code>LPUART_TransferHandleIRQ</code> 函数会在处理发送完成中断时调用 <code>LPUART_UserCallback</code>，并传递状态 <code>kStatus_LPUART_TxIdle</code>。</li><li><strong>接收硬件溢出：</strong> 当 LPUART 硬件发生接收溢出错误时，<code>LPUART_TransferHandleIRQ</code> 函数会在处理接收溢出中断时调用 <code>LPUART_UserCallback</code>，并传递状态 <code>kStatus_LPUART_RxHardwareOverrun</code>。这个状态表示有数据在接收之前就被覆盖了，导致数据丢失。</li></ol><h3 id="完整的接收流程和发送流程"><a href="#完整的接收流程和发送流程" class="headerlink" title="完整的接收流程和发送流程"></a>完整的接收流程和发送流程</h3><p><strong>接收流程：</strong></p><ol><li>应用程序调用 <code>LPUART_TransferReceiveNonBlocking</code> 函数启动非阻塞接收。</li><li><code>LPUART_TransferReceiveNonBlocking</code> 函数配置 LPUART 硬件，使能接收中断，并将接收请求的信息保存在 <code>lpuart_handle_t</code> 结构体中。</li><li>LPUART 硬件接收到数据后，触发中断。</li><li>CPU 响应中断，执行中断服务例程 <code>LPUART_TransferHandleIRQ</code>。</li><li><code>LPUART_TransferHandleIRQ</code> 函数检查中断状态，如果是接收数据就绪中断，则调用 <code>LPUART_TransferHandleReceiveDataFull</code> 函数。</li><li><code>LPUART_TransferHandleReceiveDataFull</code>函数将数据从LPUART接收FIFO读取到handle指定的缓冲区。</li><li><code>LPUART_TransferHandleReceiveDataFull</code>函数检查是否所有请求的数据都已接收完毕，如果是，则在<code>LPUART_TransferHandleIRQ</code>中调用<code>handle-&gt;callback</code>，即 <code>LPUART_UserCallback</code>，并传递 <code>kStatus_LPUART_RxIdle</code> 状态。</li></ol><p><strong>发送流程：</strong></p><ol><li>应用程序调用 <code>LPUART_TransferSendNonBlocking</code> 函数启动非阻塞发送。</li><li><code>LPUART_TransferSendNonBlocking</code> 函数配置 LPUART 硬件，使能发送中断，并将发送请求的信息保存在 <code>lpuart_handle_t</code> 结构体中。</li><li>当发送数据寄存器为空时，LPUART 硬件触发中断。</li><li>CPU 响应中断，执行中断服务例程 <code>LPUART_TransferHandleIRQ</code>。</li><li><code>LPUART_TransferHandleIRQ</code> 函数检查中断状态，如果是发送数据寄存器空中断，则调用 <code>LPUART_TransferHandleSendDataEmpty</code> 函数。</li><li><code>LPUART_TransferHandleSendDataEmpty</code>函数将数据从handle指定的缓冲区写入LPUART发送FIFO。</li><li><code>LPUART_TransferHandleSendDataEmpty</code>函数检查是否所有数据都已发送完毕。如果是，则当发送完成后，在<code>LPUART_TransferHandleIRQ</code>中调用 <code>handle-&gt;callback</code>，即 <code>LPUART_UserCallback</code>，并传递 <code>kStatus_LPUART_TxIdle</code> 状态。</li></ol><p><strong>总结：</strong></p><p><code>LPUART_UserCallback</code> 是一个在中断上下文中被调用的回调函数。它允许用户在 LPUART 传输完成后执行自定义的操作，例如：</p><ul><li>设置标志位，通知应用程序传输已完成。</li><li>启动下一次传输。</li><li>处理接收到的数据。</li><li>进行错误处理。</li></ul><p>通过使用回调函数，可以实现事件驱动的编程模型，提高程序的效率和响应性。用户不需要在主循环中轮询 LPUART 的状态，而是通过回调函数在传输完成后得到通知。</p><p>因此，<code>LPUART_UserCallback</code> 的调用时机取决于 LPUART 的传输状态和中断事件，主要发生在接收完成、发送完成和接收溢出等情况下。它在整个 LPUART 驱动程序中起到了连接驱动程序和用户应用程序的重要作用。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;串口中断传输详解-SDK&quot;&gt;&lt;a href=&quot;#串口中断传输详解-SDK&quot; class=&quot;headerlink&quot; title=&quot;串口中断传输详解(SDK)&quot;&gt;&lt;/a&gt;串口中断传输详解(SDK)&lt;/h1&gt;</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1060" scheme="https://dustofstars.github.io/categories/NXP/RT1060/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="中断" scheme="https://dustofstars.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
    <category term="UART" scheme="https://dustofstars.github.io/tags/UART/"/>
    
  </entry>
  
  <entry>
    <title>RT1060--串口空闲中断&amp;EDMA接收不定长数据</title>
    <link href="https://dustofstars.github.io/NXP/RT1060/rt1060-%E4%B8%B2%E5%8F%A3%E7%A9%BA%E9%97%B2%E4%B8%AD%E6%96%AD-edma%E6%8E%A5%E6%94%B6%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%95%B0%E6%8D%AE/"/>
    <id>https://dustofstars.github.io/NXP/RT1060/rt1060-%E4%B8%B2%E5%8F%A3%E7%A9%BA%E9%97%B2%E4%B8%AD%E6%96%AD-edma%E6%8E%A5%E6%94%B6%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%95%B0%E6%8D%AE/</id>
    <published>2024-12-04T06:41:42.000Z</published>
    <updated>2024-12-04T06:41:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="串口空闲中断-EDMA-接收不定长数据"><a href="#串口空闲中断-EDMA-接收不定长数据" class="headerlink" title="串口空闲中断 &amp; EDMA 接收不定长数据"></a>串口空闲中断 &amp; EDMA 接收不定长数据</h1><blockquote><p>客户有接收不定长数据的需求，但是如果采用协议适配的方法会非常繁琐。使用UART的IDLE中断+DMA的方式，即可高效的解决这一问题！</p></blockquote><p>另外，如果通过协议先接收单独的单字节，串口进中断接收在数据量大的时候效率会低很多</p><p>以RT1060EVK为例来进行这一操作！</p><span id="more"></span><h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">让我仔细分析一下这个main函数的执行流程和中断调用关系...</span><br><span class="line"></span><br><span class="line">首先看到几个关键的中断和回调:</span><br><span class="line">1. DEMO_LPUART_IRQHandler - UART的中断处理函数</span><br><span class="line">2. LPUART_UserCallback - DMA传输完成的回调函数</span><br><span class="line"></span><br><span class="line">中断触发的场景:</span><br><span class="line">1. IDLE线检测 - 接收到一帧数据后的空闲状态</span><br><span class="line">2. TC(传输完成)中断 - 发送完成后触发</span><br><span class="line">3. DMA传输完成中断 - 通过callback通知</span><br><span class="line"></span><br><span class="line">数据流转过程:</span><br><span class="line">1. 初始状态是接收模式</span><br><span class="line">2. 数据到来 -&gt; DMA自动接收到buffer</span><br><span class="line">3. 检测到空闲 -&gt; IDLE中断</span><br><span class="line">4. 处理数据 -&gt; 准备发送</span><br><span class="line">5. DMA发送 -&gt; 发送完成触发TC中断</span><br><span class="line">6. TC中断中切换回接收模式</span><br><span class="line"></span><br><span class="line">这里面有很多细节需要梳理,让我详细分析每个阶段的处理...</span><br></pre></td></tr></tbody></table></figure><p>让我详细解释main函数的逻辑和中断调用关系:</p><h3 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置:"></a><strong>初始化配置</strong>:</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置UART中断</span></span><br><span class="line">LPUART_EnableInterrupts(DEMO_LPUART, </span><br><span class="line">    kLPUART_IdleLineInterruptEnable|      <span class="comment">// 空闲线检测中断</span></span><br><span class="line">    kLPUART_RxOverrunInterruptEnable|     <span class="comment">// 接收溢出中断</span></span><br><span class="line">    kLPUART_NoiseErrorInterruptEnable|    <span class="comment">// 噪声错误中断</span></span><br><span class="line">    kLPUART_FramingErrorInterruptEnable|  <span class="comment">// 帧错误中断</span></span><br><span class="line">    kLPUART_ParityErrorInterruptEnable);  <span class="comment">// 奇偶校验错误中断</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始时禁用TC中断</span></span><br><span class="line">LPUART_DisableInterrupts(DEMO_LPUART, kLPUART_TransmissionCompleteInterruptEnable);</span><br></pre></td></tr></tbody></table></figure><h3 id="中断和DMA的调用流程"><a href="#中断和DMA的调用流程" class="headerlink" title="中断和DMA的调用流程:"></a><strong>中断和DMA的调用流程</strong>:</h3><h4 id="接收数据流程"><a href="#接收数据流程" class="headerlink" title="接收数据流程:"></a><strong>接收数据流程</strong>:</h4><ul><li>DMA持续接收数据到<code>g_rxBuffer</code></li><li>当检测到空闲线(<span style="color:red"><em><u>一段时间没有新数据</u></em></span>)时,触发IDLE中断；</li><li>在IDLE中断处理函数中:<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DEMO_LPUART_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> ((kLPUART_IdleLineFlag)&amp;stat)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 1. 获取已接收的数据长度</span></span><br><span class="line">        LPUART_TransferGetReceiveCountEDMA(...);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 复制数据到发送缓冲区</span></span><br><span class="line">        <span class="built_in">memcpy</span>(g_txBuffer, g_rxBuffer, rx_count);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 设置发送标志</span></span><br><span class="line">        reciveFrame = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 重新启动接收</span></span><br><span class="line">        LPUART_TransferAbortReceiveEDMA(...);</span><br><span class="line">        LPUART_ReceiveEDMA(...);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="发送数据流程"><a href="#发送数据流程" class="headerlink" title="发送数据流程:"></a><strong>发送数据流程</strong>:</h4><ul><li>main循环检测到<code>reciveFrame</code>为true时启动发送</li><li>DMA开始发送数据</li><li>发送完成后触发DMA完成中断,调用<code>LPUART_UserCallback</code></li><li>在callback中使能TC中断:<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LPUART_UserCallback</span><span class="params">(...)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (kStatus_LPUART_TxIdle == status)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 使能TC中断</span></span><br><span class="line">        LPUART_EnableInterrupts(DEMO_LPUART, kLPUART_TransmissionCompleteInterruptEnable);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>TC中断触发后,在中断处理函数中:<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((kLPUART_TransmissionCompleteFlag)&amp;stat)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 1. 禁用TC中断</span></span><br><span class="line">    LPUART_DisableInterrupts(DEMO_LPUART, kLPUART_TransmissionCompleteInterruptEnable);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 切换到接收模式</span></span><br><span class="line">    Set_RS485_Receive();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 重新启动接收</span></span><br><span class="line">    LPUART_TransferAbortReceiveEDMA(...);</span><br><span class="line">    LPUART_ReceiveEDMA(...);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="主循环逻辑"><a href="#主循环逻辑" class="headerlink" title="主循环逻辑:"></a><strong>主循环逻辑</strong>:</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(reciveFrame)  <span class="comment">// 检查是否收到完整数据帧</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 1. 准备发送数据</span></span><br><span class="line">        sendXfer.data = g_txBuffer;</span><br><span class="line">        sendXfer.dataSize = send_size;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 切换到发送模式</span></span><br><span class="line">        Set_RS485_Transimit();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 启动DMA发送</span></span><br><span class="line">        LPUART_SendEDMA(DEMO_LPUART, &amp;g_lpuartEdmaHandle, &amp;sendXfer);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 清除标志</span></span><br><span class="line">        reciveFrame = <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="关键点说明"><a href="#关键点说明" class="headerlink" title="关键点说明"></a>关键点说明</h2><ol><li>DMA用于实际的数据传输,不占用CPU</li><li><span style="color:red"><strong><u>IDLE中断用于检测一帧数据的接收完成</u></strong></span></li><li>TC中断用于确保最后一个字节完全发送出去</li><li>使用回调和中断机制实现自动的收发切换</li><li>主循环只负责检测标志并启动新的发送</li></ol><p>这种设计实现了高效的非阻塞式数据收发,同时正确处理了RS485半双工通信的方向切换时序。</p><h2 id="备注：详细的回调-中断实现的自动收发切换"><a href="#备注：详细的回调-中断实现的自动收发切换" class="headerlink" title="备注：详细的回调/中断实现的自动收发切换"></a>备注：详细的回调/中断实现的自动收发切换</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    A[初始状态: 接收模式] --&gt;|DMA接收数据| B[接收数据]</span><br><span class="line">    </span><br><span class="line">    B --&gt;|检测到IDLE| C[IDLE中断处理]</span><br><span class="line">    C --&gt;|1. 获取接收数据长度&lt;br&gt;2. 复制数据到TX buffer&lt;br&gt;3. 设置reciveFrame标志| D[主循环]</span><br><span class="line">    </span><br><span class="line">    D --&gt;|检测到reciveFrame| E[开始发送]</span><br><span class="line">    E --&gt;|1. 切换RS485方向&lt;br&gt;2. 启动DMA发送| F[DMA发送数据]</span><br><span class="line">    </span><br><span class="line">    F --&gt;|DMA发送完成| G[DMA完成回调&lt;br&gt;LPUART_UserCallback]</span><br><span class="line">    G --&gt;|使能TC中断| H[等待最后一个字节发送]</span><br><span class="line">    </span><br><span class="line">    H --&gt;|TC中断触发| I[TC中断处理]</span><br><span class="line">    I --&gt;|1. 禁用TC中断&lt;br&gt;2. 切换RS485方向&lt;br&gt;3. 重启DMA接收| A</span><br></pre></td></tr></tbody></table></figure><p>让我详细解释每个阶段的切换过程：</p><ol><li><p><strong>接收阶段</strong>:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始配置为接收模式</span></span><br><span class="line">Set_RS485_Receive();  <span class="comment">// GPIO设为低电平</span></span><br><span class="line">LPUART_ReceiveEDMA(...);  <span class="comment">// 启动DMA接收</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>接收完成检测</strong>:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IDLE中断处理函数中</span></span><br><span class="line"><span class="keyword">if</span> ((kLPUART_IdleLineFlag)&amp;stat)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 获取接收到的数据</span></span><br><span class="line">    LPUART_TransferGetReceiveCountEDMA(...);</span><br><span class="line">    <span class="built_in">memcpy</span>(g_txBuffer, g_rxBuffer, rx_count);</span><br><span class="line">    reciveFrame = <span class="literal">true</span>;  <span class="comment">// 设置标志通知主循环</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>切换到发送模式</strong>:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主循环中</span></span><br><span class="line"><span class="keyword">if</span>(reciveFrame)</span><br><span class="line">{</span><br><span class="line">    Set_RS485_Transimit();  <span class="comment">// GPIO设为高电平</span></span><br><span class="line">    LPUART_SendEDMA(...);   <span class="comment">// 启动DMA发送</span></span><br><span class="line">    reciveFrame = <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>发送完成处理</strong>:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DMA发送完成回调</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LPUART_UserCallback</span><span class="params">(...)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (kStatus_LPUART_TxIdle == status)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 使能TC中断，等待最后一个字节发送完成</span></span><br><span class="line">        LPUART_EnableInterrupts(DEMO_LPUART, kLPUART_TransmissionCompleteInterruptEnable);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// TC中断处理</span></span><br><span class="line"><span class="keyword">if</span>((kLPUART_TransmissionCompleteFlag)&amp;stat)</span><br><span class="line">{</span><br><span class="line">    LPUART_DisableInterrupts(DEMO_LPUART, kLPUART_TransmissionCompleteInterruptEnable);</span><br><span class="line">    Set_RS485_Receive();  <span class="comment">// 切换回接收模式</span></span><br><span class="line">    <span class="comment">// 重新启动接收</span></span><br><span class="line">    LPUART_TransferAbortReceiveEDMA(...);</span><br><span class="line">    LPUART_ReceiveEDMA(...);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><p>关键设计考虑：</p><ol><li><p><strong>为什么需要TC中断？</strong></p><ul><li>DMA完成不代表最后一个字节已经完全发送出去</li><li>TC中断确保最后一个字节完全发送后才切换方向</li><li>避免方向切换过早导致数据截断</li></ul></li><li><p><strong>方向切换时序</strong>:</p><ul><li>发送前：先切换方向，再开始发送</li><li>发送后：等待TC中断确认完全发送后，再切换回接收</li></ul></li><li><p><strong>自动化处理</strong>:</p><ul><li>使用中断和回调机制，无需主循环干预</li><li>主循环只负责启动新的发送</li><li>其他切换过程由中断自动完成</li></ul></li></ol><p>这种设计保证了RS485半双工通信的可靠性，同时通过DMA和中断机制提高了效率。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;串口空闲中断-EDMA-接收不定长数据&quot;&gt;&lt;a href=&quot;#串口空闲中断-EDMA-接收不定长数据&quot; class=&quot;headerlink&quot; title=&quot;串口空闲中断 &amp;amp; EDMA 接收不定长数据&quot;&gt;&lt;/a&gt;串口空闲中断 &amp;amp; EDMA 接收不定长数据&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;客户有接收不定长数据的需求，但是如果采用协议适配的方法会非常繁琐。使用UART的IDLE中断+DMA的方式，即可高效的解决这一问题！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外，如果通过协议先接收单独的单字节，串口进中断接收在数据量大的时候效率会低很多&lt;/p&gt;
&lt;p&gt;以RT1060EVK为例来进行这一操作！&lt;/p&gt;</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1060" scheme="https://dustofstars.github.io/categories/NXP/RT1060/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="中断" scheme="https://dustofstars.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
    <category term="DMA" scheme="https://dustofstars.github.io/tags/DMA/"/>
    
  </entry>
  
  <entry>
    <title>RT1050开发--第7节 RT1050 硬件启动模式</title>
    <link href="https://dustofstars.github.io/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dustofstars.github.io/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-12-11T06:11:12.000Z</published>
    <updated>2023-12-11T06:11:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第7节-RT1050-硬件启动模式详解"><a href="#第7节-RT1050-硬件启动模式详解" class="headerlink" title="第7节 RT1050 硬件启动模式详解"></a>第7节 RT1050 硬件启动模式详解</h1><style>.dnfxahqnxvtq{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/Snipaste_2023-12-11_14-33-24.bmp" class="dnfxahqnxvtq"><span id="more"></span><h2 id="硬件启动配置"><a href="#硬件启动配置" class="headerlink" title="硬件启动配置"></a>硬件启动配置</h2><h3 id="外部设备设备配置"><a href="#外部设备设备配置" class="headerlink" title="外部设备设备配置"></a>外部设备设备配置</h3><ol><li><p>开发板配置选项</p><style>.ajbknoawqqjn{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/Snipaste_2023-12-11_14-35-48.bmp" class="ajbknoawqqjn"></li><li><p>启动配置选项电路</p><style>.kgmkdytpmlxr{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/Snipaste_2023-12-11_14-42-44.bmp" class="kgmkdytpmlxr"></li><li><p>启动配置引脚</p><style>.tgcntbymgjvc{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/Snipaste_2023-12-11_14-51-14.bmp" class="tgcntbymgjvc"></li><li><p>启动模式选择</p><style>.nukdgbjgeokj{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/Snipaste_2023-12-11_14-52-23.bmp" class="nukdgbjgeokj"><p>启动模式选择可以有：从Fuses、从串口下载、从内部；</p></li><li><p>串行Flash配置选项</p><style>.eyftnxczdkoe{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/Snipaste_2023-12-11_14-55-01.bmp" class="eyftnxczdkoe"><p>这两位控制支持的Flash Type；</p><p><strong><u><em>即SW7的前两位确定Flash的规格，后两位确定启动的方式！</em></u></strong></p></li></ol><h2 id="Nor-Flash-启动流程"><a href="#Nor-Flash-启动流程" class="headerlink" title="Nor Flash 启动流程"></a>Nor Flash 启动流程</h2><blockquote><style>.nsjxdaxjzvrm{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/Snipaste_2023-12-11_14-59-46.bmp" class="nsjxdaxjzvrm"></blockquote><style>.ncfegmxovfpg{zoom:150%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/Snipaste_2023-12-11_16-48-41.bmp" class="ncfegmxovfpg"><p>BootRom里面的程序：</p><ol><li>配置 FlexSPI 的Pin复用功能，配置时钟频率30MHz，进行基础的读取操作；<ul><li>FlexSPI最高300MHz，这里不知道外部Flash是啥情况，<u>配置为低速时钟用来读NorFlash的头上的配置信息</u>；</li><li>获取到外部Flash的配置参数；</li></ul></li><li>读取了外部Flash的配置参数之后，RT用来配置它的外设 FlexSPI ；<ul><li>它是根据读取的外部Flash的配置参数，来配置FlexSPI；</li></ul></li><li>设置boot device 参数<ul><li>Image 地址， memory范围；</li><li>即：**<u>真正的代码段的地址和长度</u>**；</li></ul></li><li>判断Image是否直接在Flash的片上进行取址：<ol><li><u><strong>如果XIP，则从FlexSPI1的地址空间中执行Image；</strong></u></li><li><u><strong>如果非XIP，则拷贝到OCRAM中，再从OCRAM中运行Image；</strong></u></li></ol></li></ol><h3 id="Flash的配置参数"><a href="#Flash的配置参数" class="headerlink" title="Flash的配置参数"></a>Flash的配置参数</h3><style>.vgkrrjnisygc{zoom:200%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/Snipaste_2023-12-11_16-59-06.bmp" class="vgkrrjnisygc"><p>512字节的串口Nor Flash配置字段：</p><ul><li>memCfg：外部时序，时钟等；</li><li>pageSize：页大小；</li><li>sectorSize：块大小；</li><li>xxxClkFreq: 串口的时钟频率；</li></ul><p><strong><u><em>工程代码：</em></u></strong></p><style>.kdjjiqfkppfc{zoom:150%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/image-20231211170401921.png" class="kdjjiqfkppfc" alt="image-20231211170401921"><h3 id="Image的关键信息"><a href="#Image的关键信息" class="headerlink" title="Image的关键信息"></a>Image的关键信息</h3><style>.bvellpfleywt{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/image-20231211170553725.png" class="bvellpfleywt"><ul><li>Image vector table（IVT）：声明image的具体位置，即代码在 nor flash 的具体位置是多少；</li><li>Boot data：image位置和大小；</li><li>Device configuration data （DCD）：</li><li>User code and data：</li></ul><h4 id="IVT-Boot-data"><a href="#IVT-Boot-data" class="headerlink" title="IVT + Boot data"></a>IVT + Boot data</h4><ul><li><p>IVT 需要<u>放在外部Flash的固定偏移地址，供ROM读取以便让系统知道用户Image的第一条可执行指令放在哪里，以及Boot Data和DCD的存放位置</u>；</p><style>.oglwcfpjtmok{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/image-20231211171225319.png" class="oglwcfpjtmok"></li><li><p>BootData保存了完整的Image首地址和整个Image所占大小；</p><style>.yduuqlzgrlrx{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/image-20231211171319387.png" class="yduuqlzgrlrx"></li><li><p>程序代码：</p><style>.pzvqodhifejf{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/image-20231211171351373.png" class="pzvqodhifejf"></li></ul><h4 id="DCD"><a href="#DCD" class="headerlink" title="DCD"></a>DCD</h4><ul><li><p>DCD包含了一些配置命令以便在跳到用户程序入口之前，供ROM调用配置内部外设以更好的匹配外部IC，一般如果系统外挂了SDRAM的情况下需要配置好DCD；</p></li><li><p>程序代码：</p><style>.mnefwvhmkemk{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/image-20231211171607245.png" class="mnefwvhmkemk"></li></ul>]]></content>
    
    
    <summary type="html">第七节课！硬件启动模式详解！</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1050" scheme="https://dustofstars.github.io/categories/NXP/RT1050/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="RT1050" scheme="https://dustofstars.github.io/tags/RT1050/"/>
    
  </entry>
  
  <entry>
    <title>RT1050开发--第6节 RT1050 Memory Mapping</title>
    <link href="https://dustofstars.github.io/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC6%E8%8A%82-rt1050-memory-mapping/"/>
    <id>https://dustofstars.github.io/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC6%E8%8A%82-rt1050-memory-mapping/</id>
    <published>2023-12-11T05:37:29.000Z</published>
    <updated>2023-12-11T05:37:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第6节-RT1050-Memory-Mapping"><a href="#第6节-RT1050-Memory-Mapping" class="headerlink" title="第6节 RT1050 Memory Mapping"></a>第6节 RT1050 Memory Mapping</h1><style>.mfmhyjvgxtqd{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC6%E8%8A%82-rt1050-memory-mapping/Snipaste_2023-12-11_13-40-00.bmp" class="mfmhyjvgxtqd"><span id="more"></span><h2 id="RT1052结构框图"><a href="#RT1052结构框图" class="headerlink" title="RT1052结构框图"></a>RT1052结构框图</h2><style>.gxujszxlpgvo{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC6%E8%8A%82-rt1050-memory-mapping/Snipaste_2023-12-11_13-43-52.bmp" class="gxujszxlpgvo"><h2 id="Cortex-M7-存储器映射"><a href="#Cortex-M7-存储器映射" class="headerlink" title="Cortex-M7 存储器映射"></a>Cortex-M7 存储器映射</h2><style>.byeupiuwthku{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC6%E8%8A%82-rt1050-memory-mapping/Snipaste_2023-12-11_13-45-20.bmp" class="byeupiuwthku"><ul><li>如果给存储器再分配一个地址，就叫做存储器重映射；</li><li>在4GB的地址空间，ARM粗线条的平均分为7个块，每个块也规定了用途，大部分的款大小都是512MB以上，显然是很大的，芯片厂商在每个块的范围内设计外设时根本用不完；</li></ul><style>.fsiqhfxwtadq{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC6%E8%8A%82-rt1050-memory-mapping/Snipaste_2023-12-11_13-49-42.bmp" class="fsiqhfxwtadq"><h2 id="RT1052存储器功能划分"><a href="#RT1052存储器功能划分" class="headerlink" title="RT1052存储器功能划分"></a>RT1052存储器功能划分</h2><blockquote><p><mark><strong><u>重点！！！</u></strong></mark></p><p>在这上面的7个Block中，有4个非常重要。</p><ul><li>Block0 主要用于存储**<u>程序代码</u>**，一般采用FLASH存储器；</li><li>Block1 主要用于**<u>运行时内存</u>**，一般采用SRAM存储器；</li><li>Block2 用来设计成片上外设，内核通过相应的地址访问片上外设；</li><li>Block5 用于NVIC，系统定时器，系统功能控制块；</li></ul></blockquote><h3 id="Block0"><a href="#Block0" class="headerlink" title="Block0"></a>Block0</h3><style>.iwirbhmirgmz{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC6%E8%8A%82-rt1050-memory-mapping/Block0.bmp" class="iwirbhmirgmz"><p>自下往上看：</p><ol><li>ITCM：是Instruction Tightly-Coupled Memory的缩写，指的是**<u>指令紧耦合内存</u>**。<ul><li>所谓紧耦合，指的是该内存与内核紧密连接，有很高的访问速度，而“指令”，表示该内存用于缓存指令；</li><li>对于我们希望有极高执行速度的代码，可以要求内核上电后把相应的代码从外部的Flash加载至ITCM，那么在运行时，代码的执行速度就不会因为外部的Flash访问速度而存在瓶颈。</li></ul></li><li>ROCMP：**<u>这是一小段ROM空间，用于存储芯片启动时的加载代码</u><strong>，即Bootloader，</strong><u>Bootloader负载把指令从外部存储器加载到ITCM</u>**；</li><li><mark><strong>FlexSPI：和SEMC一起是RT1052中可用于控制外部并行和串行NorFlash的两个外设，此处把它们映射到这个代码空间，是歪了支持XIP功能（即指令直接在NorFlash中运行，不需要加载到内部的ITCM）。</strong></mark></li><li>SEMC：智能外部存储器控制器；</li></ol><h3 id="Block1"><a href="#Block1" class="headerlink" title="Block1"></a>Block1</h3><style>.etbkihisvccc{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC6%E8%8A%82-rt1050-memory-mapping/Block1.bmp" class="etbkihisvccc"><ol><li>DTCM：数据紧耦合内存，和ITCM类似，有着极高的访问速度，*<u><strong>不过它是专门用来存储程序数据的，即带啊吗中变量的存储位置</strong></u>*；</li><li>OCRAM：是 On-chip RAM 的缩写。即片上内存，可以完全把它理解为传统MCU内部的SRAM，它没有像ITCM和DTCM的专用限制，**<u>可以用于存储指令和数据</u>**（通用目的）。</li></ol><h3 id="注意！"><a href="#注意！" class="headerlink" title="注意！"></a>注意！</h3><p>在RT1052中，TCM只有512KB，不是分别ITCM DTCM OCRAM都有，而是它们三个共有512KB！</p><style>.hyzehpajnjbh{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC6%E8%8A%82-rt1050-memory-mapping/FlexRAM%E5%88%86%E9%85%8D.bmp" class="hyzehpajnjbh"><p>通过FUSE，有16种FlexRAM的配置！这个和后续的分散加载文件息息相关！</p><ul><li>具体来说，ITCM DTCM OCRAM三种存储器**<u>共享内部FlexRAM的空间，而这个内部的FlexRAM空间在RT1052中是512KB</u>**；</li><li>默认是第一种配置，256-128-128；</li></ul><h3 id="Block2"><a href="#Block2" class="headerlink" title="Block2"></a>Block2</h3><style>.kcdujvnmdogi{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC6%E8%8A%82-rt1050-memory-mapping/Block2.bmp" class="kcdujvnmdogi"><p>Block2 用于设计片内的外设，在RT1052中，它的外设使用4条总线与内核进行连接，AIPS 是 <code>ARM IP Bus</code> 的缩写，**<u>它一边与 AHB 总线连接，另一边与片上的各种外设连接</u><strong>，AIPS1~4 即连接了各种各样的外设，此处</strong><u>每条总线划分的地址范围是1MB，内核根据地址可以访问相应总线下的外设，达到控制目的</u>**。</p><h3 id="Block5"><a href="#Block5" class="headerlink" title="Block5"></a>Block5</h3><style>.qpssfproxyfb{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC6%E8%8A%82-rt1050-memory-mapping/Block5.bmp" class="qpssfproxyfb"><h2 id="谁影响了代码的运行速度？"><a href="#谁影响了代码的运行速度？" class="headerlink" title="谁影响了代码的运行速度？"></a>谁影响了代码的运行速度？</h2><style>.htgjsrwbovmg{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC6%E8%8A%82-rt1050-memory-mapping/Snipaste_2023-12-11_14-22-39.bmp" class="htgjsrwbovmg"><blockquote><p>订正：</p><ul><li>I-Cache/D-Cache</li></ul></blockquote><p>RT1052没有内置的Flash，那么如果像原来一样，在MCU的Flash中运行，就会受限于NorFlash的总线访问速度，无法发挥CPU速度的优势。那么，通过分散加载文件，到Cache，TCM中运行，就是一个可行的解决方案了。</p>]]></content>
    
    
    <summary type="html">第六节课！Memory Mapping！</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1050" scheme="https://dustofstars.github.io/categories/NXP/RT1050/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="RT1050" scheme="https://dustofstars.github.io/tags/RT1050/"/>
    
  </entry>
  
  <entry>
    <title>RT1050开发--第5节 RT1050 Hello World （Keil V5）</title>
    <link href="https://dustofstars.github.io/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC5%E8%8A%82-rt1050-hello-world-%EF%BC%88keil-v5%EF%BC%89/"/>
    <id>https://dustofstars.github.io/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC5%E8%8A%82-rt1050-hello-world-%EF%BC%88keil-v5%EF%BC%89/</id>
    <published>2023-12-05T14:28:25.000Z</published>
    <updated>2023-12-05T14:28:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第5节-RT1050-Hello-World-（Keil-V5）"><a href="#第5节-RT1050-Hello-World-（Keil-V5）" class="headerlink" title="第5节 RT1050 Hello World （Keil V5）"></a>第5节 RT1050 Hello World （Keil V5）</h1><style>.kjysqdjwxfib{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC5%E8%8A%82-rt1050-hello-world-%EF%BC%88keil-v5%EF%BC%89/image-20231205210519877.png" class="kjysqdjwxfib"><span id="more"></span><h2 id="HelloWorld工程介绍"><a href="#HelloWorld工程介绍" class="headerlink" title="HelloWorld工程介绍"></a>HelloWorld工程介绍</h2><h3 id="工程文件位置"><a href="#工程文件位置" class="headerlink" title="工程文件位置"></a>工程文件位置</h3><p><code>C:\Users\Gavin\Documents\RT\Keil5\rt1050 keil sdk &amp; doc\SDK_2_14_0_EVKB-IMXRT1050\boards\evkbimxrt1050\demo_apps\hello_world\</code></p><style>.kytqsferdilh{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC5%E8%8A%82-rt1050-hello-world-%EF%BC%88keil-v5%EF%BC%89/image-20231205211106693.png" class="kytqsferdilh"><h3 id="Keil工程位置"><a href="#Keil工程位置" class="headerlink" title="Keil工程位置"></a>Keil工程位置</h3><style>.qhfssbdqlpeo{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC5%E8%8A%82-rt1050-hello-world-%EF%BC%88keil-v5%EF%BC%89/image-20231205211232436.png" class="qhfssbdqlpeo"><hr><h3 id="MDK工程目录结构"><a href="#MDK工程目录结构" class="headerlink" title="MDK工程目录结构"></a>MDK工程目录结构</h3><style>.ivirtvojjjnj{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC5%E8%8A%82-rt1050-hello-world-%EF%BC%88keil-v5%EF%BC%89/image-20231205211757977.png" class="ivirtvojjjnj"><h4 id="几种工程目标"><a href="#几种工程目标" class="headerlink" title="几种工程目标"></a>几种工程目标</h4><style>.xhebxiuqshqg{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC5%E8%8A%82-rt1050-hello-world-%EF%BC%88keil-v5%EF%BC%89/image-20231205211932870.png" class="xhebxiuqshqg"><p>—&gt; <mark><strong><u>我们在这里用的是<code>flexspi_nor_debug</code>工程，代码段放在nor flash，数据段放在TCM中！</u></strong></mark></p><h4 id="工程工作组"><a href="#工程工作组" class="headerlink" title="工程工作组"></a>工程工作组</h4><style>.cxzfqofilxtf{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC5%E8%8A%82-rt1050-hello-world-%EF%BC%88keil-v5%EF%BC%89/image-20231205212708560.png" class="cxzfqofilxtf"><p><strong><u><em>关于xip的用处：</em></u></strong></p><ul><li>由于RT没有内部Flash，代码都存放在外部ROM空间，那么，在系统启动时，RT是不知道外部flash的信息的，比如：代码地址，空间大小等等；</li><li>所以，需要把这些信息先存放在外部Flash中，然后RT通过SPI通信获得了这部分信息之后，才可以到外部Flash中去取指令；</li></ul><h2 id="打造自己的HelloWorld工程"><a href="#打造自己的HelloWorld工程" class="headerlink" title="打造自己的HelloWorld工程"></a>打造自己的HelloWorld工程</h2><h3 id="SDK工程路径"><a href="#SDK工程路径" class="headerlink" title="SDK工程路径"></a>SDK工程路径</h3><style>.acutnlypqfog{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC5%E8%8A%82-rt1050-hello-world-%EF%BC%88keil-v5%EF%BC%89/image-20231205213504551.png" class="acutnlypqfog"><h3 id="创建hello-world工程"><a href="#创建hello-world工程" class="headerlink" title="创建hello_world工程"></a>创建hello_world工程</h3><ul><li>创建01-hello_world文件夹；</li><li>复制SDK的主要文件；<ul><li>根据工程包含的路径复制，得到：</li><li><style>.immpnvnfgqjo{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC5%E8%8A%82-rt1050-hello-world-%EF%BC%88keil-v5%EF%BC%89/image-20231205214932520.png" class="immpnvnfgqjo"></li></ul></li><li>打开这个新建的工程，消除找不到文件的感叹号<code>❗</code></li><li><style>.mqldqlegevey{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC5%E8%8A%82-rt1050-hello-world-%EF%BC%88keil-v5%EF%BC%89/image-20231205215148765.png" class="mqldqlegevey"></li></ul><p>—&gt; 消除方法：通过使用文本编辑器打开该Keil工程，全文搜索并替换这几个include的相对路径！</p><p>—&gt; Reload!</p><p>—&gt; 完成！</p><blockquote><style>.vozhairifubw{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC5%E8%8A%82-rt1050-hello-world-%EF%BC%88keil-v5%EF%BC%89/image-20231205221003063.png" class="vozhairifubw"></blockquote><h2 id="分析Hello-world-c"><a href="#分析Hello-world-c" class="headerlink" title="分析Hello_world.c"></a>分析Hello_world.c</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Init board hardware. 初始化开发板*/</span></span><br><span class="line">    BOARD_ConfigMPU();  <span class="comment">//配置内存保护单元</span></span><br><span class="line">    BOARD_InitBootPins();<span class="comment">//初始化开发板IO模式</span></span><br><span class="line">    BOARD_InitBootClocks();<span class="comment">//初始化开发板系统时钟</span></span><br><span class="line">    BOARD_InitDebugConsole();<span class="comment">//初始化调试控制台</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Just enable the trace clock, leave coresight initialization to IDE debugger */</span></span><br><span class="line">    SystemCoreClockUpdate();</span><br><span class="line">    CLOCK_EnableClock(kCLOCK_Trace);</span><br><span class="line"></span><br><span class="line">    PRINTF(<span class="string">"hello world.\r\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        ch = GETCHAR();</span><br><span class="line">        PUTCHAR(ch);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="烧写代码"><a href="#烧写代码" class="headerlink" title="烧写代码"></a>烧写代码</h2><blockquote><p>Keil 快捷键 F8 </p><style>.vsvjmatgbumg{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC5%E8%8A%82-rt1050-hello-world-%EF%BC%88keil-v5%EF%BC%89/image-20231205221649324.png" class="vsvjmatgbumg"></blockquote><style>.wpuwuvswmsfv{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC5%E8%8A%82-rt1050-hello-world-%EF%BC%88keil-v5%EF%BC%89/image-20231205221717414.png" class="wpuwuvswmsfv"><h3 id="实验现象"><a href="#实验现象" class="headerlink" title="实验现象"></a>实验现象</h3><style>.olcovxqskbpo{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC5%E8%8A%82-rt1050-hello-world-%EF%BC%88keil-v5%EF%BC%89/image-20231205222337955.png" class="olcovxqskbpo">]]></content>
    
    
    <summary type="html">第五节课！Keil写一个自己的工程！</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1050" scheme="https://dustofstars.github.io/categories/NXP/RT1050/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="RT1050" scheme="https://dustofstars.github.io/tags/RT1050/"/>
    
  </entry>
  
  <entry>
    <title>RT1050开发--第4节 RT1050开发环境搭建</title>
    <link href="https://dustofstars.github.io/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC4%E8%8A%82-rt1050%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://dustofstars.github.io/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC4%E8%8A%82-rt1050%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2023-12-04T14:33:36.000Z</published>
    <updated>2023-12-04T14:33:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第4节-RT1050开发环境搭建"><a href="#第4节-RT1050开发环境搭建" class="headerlink" title="第4节 RT1050开发环境搭建"></a>第4节 RT1050开发环境搭建</h1><blockquote><style>.dekxtsqanoji{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC4%E8%8A%82-rt1050%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20231205110854127.png" class="dekxtsqanoji"></blockquote><span id="more"></span><h2 id="Keil5安装"><a href="#Keil5安装" class="headerlink" title="Keil5安装"></a>Keil5安装</h2><ol><li>安装MDK-Keil5；</li><li>安装RT1052 Keil5依赖包；<ol><li>地址：<code>https://www.keil.arm.com/packs/mimxrt1052_dfp-nxp/devices/</code></li><li><style>.wxtpaykbfopi{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC4%E8%8A%82-rt1050%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20231205115624338.png" class="wxtpaykbfopi"></li></ol></li></ol><h2 id="仿真器驱动安装"><a href="#仿真器驱动安装" class="headerlink" title="仿真器驱动安装"></a>仿真器驱动安装</h2><ul><li><p>CMSIS-DAP仿真器驱动；</p></li><li><p>串口驱动；</p></li><li><blockquote><style>.ueutjtcduxlm{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC4%E8%8A%82-rt1050%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20231205115830490.png" class="ueutjtcduxlm"></blockquote></li></ul><h2 id="SDK下载"><a href="#SDK下载" class="headerlink" title="SDK下载"></a>SDK下载</h2><ol><li>下载地址：<code>https://mcuxpresso.nxp.com/en/select</code></li><li><style>.wcftwloruhtl{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC4%E8%8A%82-rt1050%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20231205120209889.png" class="wcftwloruhtl"></li></ol><h2 id="SDK介绍"><a href="#SDK介绍" class="headerlink" title="SDK介绍"></a>SDK介绍</h2><ul><li><p>SDK概述</p><style>.thpdonbxvndf{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC4%E8%8A%82-rt1050%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20231205121253428.png" class="thpdonbxvndf"></li><li><p>SDK源码目录</p><style>.setqwwlpsgpq{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC4%E8%8A%82-rt1050%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20231205121358508.png" class="setqwwlpsgpq"></li><li><p>API手册外设驱动结构</p><style>.jxfewbwbqyqh{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC4%E8%8A%82-rt1050%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20231205121447229.png" class="jxfewbwbqyqh"></li></ul><h2 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h2><style>.fvweghylvxab{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC4%E8%8A%82-rt1050%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20231205121856419.png" class="fvweghylvxab"><h2 id="数据手册"><a href="#数据手册" class="headerlink" title="数据手册"></a>数据手册</h2><style>.qylieqdtumww{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC4%E8%8A%82-rt1050%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20231205122245517.png" class="qylieqdtumww"><ul><li>MIMXRT1050 EVKB Board Hardware User’s Guide ： <code>https://www.nxp.com/webapp/sps/download/preDownload.jsp?render=true</code></li><li>DataSheet:</li><li><style>.xgaiheixihuh{zoom:150%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC4%E8%8A%82-rt1050%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20231205123621629.png" class="xgaiheixihuh" alt="image-20231205123621629"></li></ul>]]></content>
    
    
    <summary type="html">第四节课！ RT1050开发环境搭建。。不咋重要的一节。。</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1050" scheme="https://dustofstars.github.io/categories/NXP/RT1050/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="RT1050" scheme="https://dustofstars.github.io/tags/RT1050/"/>
    
  </entry>
  
  <entry>
    <title>RT1050开发--第3节 RT1050硬件平台</title>
    <link href="https://dustofstars.github.io/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC3%E8%8A%82-rt1050%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/"/>
    <id>https://dustofstars.github.io/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC3%E8%8A%82-rt1050%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/</id>
    <published>2023-12-04T14:31:32.000Z</published>
    <updated>2023-12-04T14:31:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第3节-RT1050硬件平台使用"><a href="#第3节-RT1050硬件平台使用" class="headerlink" title="第3节 RT1050硬件平台使用"></a>第3节 RT1050硬件平台使用</h1><blockquote><style>.pktgafudoywm{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC3%E8%8A%82-rt1050%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/image-20231205103223182.png" class="pktgafudoywm"></blockquote><h2 id="RT1050-EVKB开发板介绍"><a href="#RT1050-EVKB开发板介绍" class="headerlink" title="RT1050 EVKB开发板介绍"></a>RT1050 EVKB开发板介绍</h2><span id="more"></span><h3 id="EVKB硬件框图"><a href="#EVKB硬件框图" class="headerlink" title="EVKB硬件框图"></a>EVKB硬件框图</h3><ol><li>原理图</li></ol><style>.wmipvvrjahdy{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC3%E8%8A%82-rt1050%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/image-20231205103422056.png" class="wmipvvrjahdy"><ul><li><p>FlexSPI：</p><ul><li>HyperFlash –高性能高速 CYPRESS S26K</li><li>QSPI Flash</li><li>–&gt; **<u><em>用于外部扩展ROM存储器</em></u>**；</li></ul></li><li><p>SDRAM：</p><ul><li>16bit接口，<u><strong>内部控制器是<code>SEMC</code>！</strong></u></li><li>扩展RAM；</li></ul></li><li><p>SDMC：</p><ul><li>使用SD卡存储大型文件；</li></ul></li></ul><h3 id="PCB图"><a href="#PCB图" class="headerlink" title="PCB图"></a>PCB图</h3><style>.igekgtwvbpos{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC3%E8%8A%82-rt1050%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/image-20231205103953019.png" class="igekgtwvbpos"><ol><li>开发板硬件清单</li></ol><style>.pncopdgoekbt{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC3%E8%8A%82-rt1050%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/image-20231205104237835.png" class="pncopdgoekbt"><ul><li>重点看一下Mass Storage，可以看到除了SD卡外，还有64M的QSPI Flash和512M的HyperFlash；</li></ul><ol start="2"><li><p>开发板供电模式</p><style>.vncpfgjxkxny{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC3%E8%8A%82-rt1050%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/image-20231205104639064.png" class="vncpfgjxkxny"><blockquote><p>J1 放在5-6时，由OpenSDA那个USB口供电：J28；</p></blockquote></li></ol><h2 id="开发板启动模式配置"><a href="#开发板启动模式配置" class="headerlink" title="开发板启动模式配置"></a>开发板启动模式配置</h2><h3 id="启动配置引脚"><a href="#启动配置引脚" class="headerlink" title="启动配置引脚"></a>启动配置引脚</h3><style>.lssxwyzciwqo{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC3%E8%8A%82-rt1050%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/image-20231205104954445.png" class="lssxwyzciwqo"><ul><li><u><strong>最常用的是：10–Internal Boot 模式！</strong></u></li><li>SW7就是4个拨码开关：x-x-1-0  –&gt; Internal Boot！</li></ul><hr><h3 id="高级启动序列"><a href="#高级启动序列" class="headerlink" title="高级启动序列"></a>高级启动序列</h3><style>.rdjxefewztzq{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC3%E8%8A%82-rt1050%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/image-20231205105329551.png" class="rdjxefewztzq"><blockquote><p>即：Internal Boot的执行流程：</p><ul><li>最上方是低功耗的WakeUp检测；如果是WakeUp模式启动，就正常Execute Image；</li><li>如果不是，就会检测Boot的启动模式；Internal Boot or 串口下载？<ul><li>Internal Boot：<ul><li>根据GPIO引脚的配置（高低电平），选择是从SD卡还是QSPI还是HyperFlash启动；</li><li>Authenticate image；</li><li>校验通过就Execute Image；</li></ul></li><li>串口下载：*<u>暂时略过</u>*；</li></ul></li></ul></blockquote><h3 id="外部启动模式选择（通过拨码开关）"><a href="#外部启动模式选择（通过拨码开关）" class="headerlink" title="外部启动模式选择（通过拨码开关）"></a>外部启动模式选择（通过拨码开关）</h3><style>.gahcfkrqiwwo{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC3%E8%8A%82-rt1050%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/image-20231205105944436.png" class="gahcfkrqiwwo"><hr><h2 id="开发板烧写-仿真接口"><a href="#开发板烧写-仿真接口" class="headerlink" title="开发板烧写/仿真接口"></a>开发板烧写/仿真接口</h2><h3 id="OpenSDA"><a href="#OpenSDA" class="headerlink" title="OpenSDA"></a>OpenSDA</h3><blockquote><style>.ifqskmpccxtj{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC3%E8%8A%82-rt1050%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/image-20231205110133794.png" class="ifqskmpccxtj"></blockquote><style>.xdldaymdhcfl{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC3%E8%8A%82-rt1050%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/image-20231205110147365.png" class="xdldaymdhcfl"><h3 id="CMSIS-DAP接口"><a href="#CMSIS-DAP接口" class="headerlink" title="CMSIS-DAP接口"></a>CMSIS-DAP接口</h3><blockquote><style>.gcopmxmmprwl{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC3%E8%8A%82-rt1050%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/image-20231205110445636.png" class="gcopmxmmprwl"></blockquote><style>.fgltjtzyqvqx{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC3%E8%8A%82-rt1050%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/image-20231205110458191.png" class="fgltjtzyqvqx"><h3 id="使用要求"><a href="#使用要求" class="headerlink" title="使用要求"></a>使用要求</h3><style>.rkbpgvawwpqg{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC3%E8%8A%82-rt1050%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/image-20231205110606490.png" class="rkbpgvawwpqg">]]></content>
    
    
    <summary type="html">第三节课！ RT1050硬件平台EVKB板子的使用！</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1050" scheme="https://dustofstars.github.io/categories/NXP/RT1050/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="RT1050" scheme="https://dustofstars.github.io/tags/RT1050/"/>
    
  </entry>
  
  <entry>
    <title>RT1050开发--第2节 NXP RT1050系列芯片</title>
    <link href="https://dustofstars.github.io/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC2%E8%8A%82-nxp-rt1050%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87/"/>
    <id>https://dustofstars.github.io/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC2%E8%8A%82-nxp-rt1050%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87/</id>
    <published>2023-12-04T14:28:29.000Z</published>
    <updated>2023-12-04T14:28:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二节-RT1050系列芯片"><a href="#第二节-RT1050系列芯片" class="headerlink" title="第二节 RT1050系列芯片"></a>第二节 RT1050系列芯片</h1><blockquote><style>.tbblngiufzrz{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC2%E8%8A%82-nxp-rt1050%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87/image-20231204214727923.png" class="tbblngiufzrz"></blockquote><hr><span id="more"></span><h2 id="MCU与MPU开发模式"><a href="#MCU与MPU开发模式" class="headerlink" title="MCU与MPU开发模式"></a>MCU与MPU开发模式</h2><h3 id="MPU嵌入式开发流程"><a href="#MPU嵌入式开发流程" class="headerlink" title="MPU嵌入式开发流程"></a>MPU嵌入式开发流程</h3><style>.lwndxngugaaz{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC2%E8%8A%82-nxp-rt1050%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87/image-20231204214944808.png" class="lwndxngugaaz"><h3 id="MCU物联网开发流程"><a href="#MCU物联网开发流程" class="headerlink" title="MCU物联网开发流程"></a>MCU物联网开发流程</h3><style>.juwpqbwionlw{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC2%E8%8A%82-nxp-rt1050%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87/image-20231204215132544.png" class="juwpqbwionlw"><h3 id="新的需求"><a href="#新的需求" class="headerlink" title="新的需求"></a>新的需求</h3><style>.pkjbgukactyx{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC2%E8%8A%82-nxp-rt1050%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87/image-20231204215345727.png" class="pkjbgukactyx"><hr><h2 id="iMX-RT-1050跨界处理器"><a href="#iMX-RT-1050跨界处理器" class="headerlink" title="iMX.RT 1050跨界处理器"></a>iMX.RT 1050跨界处理器</h2><style>.hfeqsmsoljmb{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC2%E8%8A%82-nxp-rt1050%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87/image-20231205100755320.png" class="hfeqsmsoljmb"><h3 id="降低成本-–-无需片内闪存"><a href="#降低成本-–-无需片内闪存" class="headerlink" title="降低成本 – 无需片内闪存"></a>降低成本 – 无需片内闪存</h3><style>.gvlmgjosymht{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC2%E8%8A%82-nxp-rt1050%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87/image-20231205100923019.png" class="gvlmgjosymht"><h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><blockquote><style>.kuwfchfcpzdy{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC2%E8%8A%82-nxp-rt1050%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87/image-20231205101211113.png" class="kuwfchfcpzdy"></blockquote><style>.oqkayvowklcx{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC2%E8%8A%82-nxp-rt1050%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87/image-20231205101220140.png" class="oqkayvowklcx"><h3 id="低中断延时"><a href="#低中断延时" class="headerlink" title="低中断延时"></a>低中断延时</h3><blockquote><style>.wfcmrdurnixn{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC2%E8%8A%82-nxp-rt1050%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87/image-20231205101743111.png" class="wfcmrdurnixn"></blockquote><style>.ezunuckbjibo{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC2%E8%8A%82-nxp-rt1050%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87/image-20231205101754029.png" class="ezunuckbjibo"><h3 id="高效能"><a href="#高效能" class="headerlink" title="高效能"></a>高效能</h3><style>.uabbplogvakz{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC2%E8%8A%82-nxp-rt1050%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87/image-20231205102016092.png" class="uabbplogvakz"><blockquote><p>RT把DC-DC放到芯片里面，每MHz电流消耗降低了接近一半！</p></blockquote><hr><h2 id="RT1050特色外设"><a href="#RT1050特色外设" class="headerlink" title="RT1050特色外设"></a>RT1050特色外设</h2><h3 id="通用外设"><a href="#通用外设" class="headerlink" title="通用外设"></a>通用外设</h3><style>.gkynyspdqfmm{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC2%E8%8A%82-nxp-rt1050%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87/image-20231205102154012.png" class="gkynyspdqfmm"><h3 id="低功耗外设"><a href="#低功耗外设" class="headerlink" title="低功耗外设"></a>低功耗外设</h3><style>.twpomwcnsues{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC2%E8%8A%82-nxp-rt1050%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87/image-20231205102237384.png" class="twpomwcnsues"><h3 id="灵活外设"><a href="#灵活外设" class="headerlink" title="灵活外设"></a>灵活外设</h3><blockquote> <style>.bavtvfgrpdcf{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC2%E8%8A%82-nxp-rt1050%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87/image-20231205102336054.png" class="bavtvfgrpdcf"></blockquote><blockquote><p>**<u>FlexSPI</u>**重点，覆盖了所有的SPI接口，并且速度更快，接近200M；</p><p><mark><strong><u>FlexRAM</u></strong></mark>：DTCM、ITCM，但是RT内核只提供了一个512K的RAM，但是它可以灵活的分配为DTCM、ITCM等；</p></blockquote><h3 id="高级外设"><a href="#高级外设" class="headerlink" title="高级外设"></a>高级外设</h3><style>.onmiqgyeytwi{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC2%E8%8A%82-nxp-rt1050%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87/image-20231205102806831.png" class="onmiqgyeytwi"><p>SEMC:<u><em><strong>安全外部存储器控制器，之前提到的SDRAM、NOR NAND都可以通过这个接口接入</strong></em></u>；</p>]]></content>
    
    
    <summary type="html">第二节课！RT1050系列芯片跨界处理器的特色！</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1050" scheme="https://dustofstars.github.io/categories/NXP/RT1050/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="RT1050" scheme="https://dustofstars.github.io/tags/RT1050/"/>
    
  </entry>
  
  <entry>
    <title>RT1050开发--第1节 ARM Cortex-M7体系结构</title>
    <link href="https://dustofstars.github.io/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>https://dustofstars.github.io/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</id>
    <published>2023-12-04T14:26:22.000Z</published>
    <updated>2023-12-04T14:26:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一节-ARM-Cortex-M7体系结构"><a href="#第一节-ARM-Cortex-M7体系结构" class="headerlink" title="第一节 ARM Cortex-M7体系结构"></a>第一节 ARM Cortex-M7体系结构</h1><span id="more"></span><blockquote><style>.cfvrgfppkjzk{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204205936163.png" class="cfvrgfppkjzk"></blockquote><hr><h2 id="认识ARM"><a href="#认识ARM" class="headerlink" title="认识ARM"></a>认识ARM</h2><style>.wvtatisepmpl{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204210036757.png" class="wvtatisepmpl"><h3 id="A系列-–-移动的王者"><a href="#A系列-–-移动的王者" class="headerlink" title="A系列 – 移动的王者"></a>A系列 – 移动的王者</h3><style>.njewvhtldngd{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204210232296.png" class="njewvhtldngd"><h2 id="M系列-–-无处不在"><a href="#M系列-–-无处不在" class="headerlink" title="M系列 – 无处不在"></a>M系列 – 无处不在</h2><style>.fpcsqoutnehs{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204210508859.png" class="fpcsqoutnehs"><style>.pdyxgybhoqug{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204210629438.png" class="pdyxgybhoqug"><style>.cwcwoqnaposp{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204210816730.png" class="cwcwoqnaposp"><hr><h2 id="Cortex-M7介绍"><a href="#Cortex-M7介绍" class="headerlink" title="Cortex-M7介绍"></a>Cortex-M7介绍</h2><style>.tqxbiqpetnyy{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204210956321.png" class="tqxbiqpetnyy"><h3 id="规格特点"><a href="#规格特点" class="headerlink" title="规格特点"></a>规格特点</h3><style>.bijqhfcrxjmm{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204211218436.png" class="bijqhfcrxjmm"><h3 id="对外接口"><a href="#对外接口" class="headerlink" title="对外接口"></a>对外接口</h3><style>.cfegfkucoabt{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204211325476.png" class="cfegfkucoabt"><hr><h2 id="Cortex-M7-编程模型"><a href="#Cortex-M7-编程模型" class="headerlink" title="Cortex-M7 编程模型"></a>Cortex-M7 编程模型</h2><h3 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h3><style>.tpxhsphwuisl{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204211548215.png" class="tpxhsphwuisl"><blockquote><p>所有M系列都是这两个模式：线程模式 + 处理模式（中断模式）</p><p>即：主程序都是在线程模式，中断处理函数都是处理模式，处理模式下拥有特权；</p></blockquote><hr><h3 id="操作状态"><a href="#操作状态" class="headerlink" title="操作状态"></a>操作状态</h3><style>.smwxusuoccag{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204211740877.png" class="smwxusuoccag"><blockquote><p>即：一个运行，一个调试；</p></blockquote><h3 id="特权访问和非特权访问"><a href="#特权访问和非特权访问" class="headerlink" title="特权访问和非特权访问"></a>特权访问和非特权访问</h3><style>.tfyixwivqdnr{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204211828379.png" class="tfyixwivqdnr"><blockquote><p>特权访问：即可以触碰到CPU所有的资源；非特权访问有些资源碰不到！</p><p><mark><strong><u>线程模式一般就是非特权的，处理模式都是特权的！</u></strong></mark></p></blockquote><hr><h3 id="系统的地址映射"><a href="#系统的地址映射" class="headerlink" title="系统的地址映射"></a>系统的地址映射</h3><blockquote><style>.duxytgqiclrp{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204212206094.png" class="duxytgqiclrp"></blockquote><style>.vjfjxgtdquim{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204212237605.png" class="vjfjxgtdquim"><blockquote><p>0x0000_0000 ~ 0xFFFF_FFFF  一共 4GB；</p><p>Code ： 即 ROM；</p><p>SRAM：即数据；</p><p>Peripheral：放外设，M7把代码、数据、外设 都映射到同一片地址空间；</p><p>External RAM： 外部存储器！</p><p>External device：外部设备</p><p>内部私有外设总线；</p><p>外部私有外设总线；–》 M7内核的；</p></blockquote><h3 id="处理器的核心寄存器"><a href="#处理器的核心寄存器" class="headerlink" title="处理器的核心寄存器"></a>处理器的核心寄存器</h3><blockquote><style>.xltgoxpsotpt{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204212830460.png" class="xltgoxpsotpt"></blockquote><style>.ujzoqqniuitt{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204212848276.png" class="ujzoqqniuitt"><p>R13栈指针一个寄存器映射两个区域：<mark><strong><code>MSP</code></strong> 和 **<code>PSP</code>**；</mark></p><blockquote><p><strong><u><em>纯裸机编程时，只有一个栈，所以只有MSP主栈指针；</em></u></strong></p><p>FreeRTOS才会用到PSP进程栈指针；</p></blockquote><hr><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><style>.jfhjswgigelb{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204213402264.png" class="jfhjswgigelb"><style>.rqmhnsjfdmmq{zoom:100%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204213423024.png" class="rqmhnsjfdmmq"><p><strong><mark><u>ARM的异常处理流程：</u></mark></strong></p><ul><li>1– 保存当前程序的上下文，即：xPSR、PC、LR、R0-R3,R12;<ul><li>通过MSP或者PSP读取地址，把这些寄存器全都入栈，就保存了下来；</li></ul></li><li>2– 把当前要返回的地址放在LR链接寄存器中；</li><li>3a– 切换模式，从线程模式切换到处理模式；</li><li>3b– 指针指向新的栈顶；</li><li>4– 找到该中断的向量地址，赋值给PC指针，执行中断处理函数；</li></ul>]]></content>
    
    
    <summary type="html">第一节课！介绍ARM的体系结构！</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1050" scheme="https://dustofstars.github.io/categories/NXP/RT1050/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="RT1050" scheme="https://dustofstars.github.io/tags/RT1050/"/>
    
  </entry>
  
  <entry>
    <title>野火RT1052开发板1创建环境</title>
    <link href="https://dustofstars.github.io/NXP/RT1050/%E9%87%8E%E7%81%AB/%E9%87%8E%E7%81%ABrt1052%E5%BC%80%E5%8F%91%E6%9D%BF1%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83/"/>
    <id>https://dustofstars.github.io/NXP/RT1050/%E9%87%8E%E7%81%AB/%E9%87%8E%E7%81%ABrt1052%E5%BC%80%E5%8F%91%E6%9D%BF1%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83/</id>
    <published>2023-11-30T13:32:20.000Z</published>
    <updated>2023-11-30T13:32:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="野火RT1052开发板1-–-NXP-MCU-Link-Pro-Keil-V5-编译环境创建"><a href="#野火RT1052开发板1-–-NXP-MCU-Link-Pro-Keil-V5-编译环境创建" class="headerlink" title="野火RT1052开发板1 – NXP MCU-Link Pro + Keil V5 编译环境创建"></a>野火RT1052开发板1 – NXP MCU-Link Pro + Keil V5 编译环境创建</h1><blockquote><p>野火i.MX RT1052 EVK Pro是个很好的学习工具，野火不仅做了汉化，另外，把所有的Pin脚都做了引出，虽然是个老产品，但是一通百通所以这个系列准备使用野火的板子来入门，具体要更几篇待定…，但是尽量每一篇都有真东西，这是第一篇：使用NXP MCU-Link Pro + Keil V5，创建编译环境运行第一个demo。</p></blockquote><span id="more"></span><style>.smkijslyknqt{zoom:100%;}</style><img src="/NXP/RT1050/%E9%87%8E%E7%81%AB/%E9%87%8E%E7%81%ABrt1052%E5%BC%80%E5%8F%91%E6%9D%BF1%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83/image-20231130220915920.png" class="smkijslyknqt"><ul><li>芯片Part Number： <strong>196pin</strong> 的工业级的 <code>MIMXRT1052CVL5B</code></li></ul><h2 id="安装Keil-V5"><a href="#安装Keil-V5" class="headerlink" title="安装Keil V5"></a>安装Keil V5</h2><blockquote><p>参考这个视频： <a href="https://www.bilibili.com/video/av544829324/?vd_source=e742ab928a70238934780b04b84d177d">https://www.bilibili.com/video/av544829324/?vd_source=e742ab928a70238934780b04b84d177d</a></p></blockquote><h3 id="安装芯片包"><a href="#安装芯片包" class="headerlink" title="安装芯片包"></a>安装芯片包</h3><ul><li>KEIL5 需要自己安装对应芯片的芯片包。直接去 keil 的官网下载：<a href="http://www.keil.com/dd2/pack/">http://www.keil.com/dd2/pack/</a></li><li>下载之后双击安装即可！</li></ul><style>.fhownhcwgiak{zoom:100%;}</style><img src="/NXP/RT1050/%E9%87%8E%E7%81%AB/%E9%87%8E%E7%81%ABrt1052%E5%BC%80%E5%8F%91%E6%9D%BF1%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83/image-20231130221413145.png" class="fhownhcwgiak"><h3 id="更换编译器"><a href="#更换编译器" class="headerlink" title="更换编译器"></a>更换编译器</h3><p>Keil的新版本不再提供ARM Compiler V5，因此需要自己下载，去百度这个关键词：**<u><em>ARMCompiler_506_Windows_x86_b960.zip</em></u>** 找到的就是最后一个V5编译器，下载并安装。</p><ul><li>安装地址推荐：**<u><em>C:\Keil_v5\ARM\ARMCC</em></u>** (新建一个ARMCC文件夹，安装到这个文件夹)</li></ul><p>然后，需要在project中手动增加这个编译器：</p><ol><li><p>Add another Arm Compiler Version to List：</p><style>.lhwtskwgcepm{zoom:100%;}</style><img src="/NXP/RT1050/%E9%87%8E%E7%81%AB/%E9%87%8E%E7%81%ABrt1052%E5%BC%80%E5%8F%91%E6%9D%BF1%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83/image-20231130222156941.png" class="lhwtskwgcepm"></li><li><p>在项目中改为这个编译器：</p></li></ol><style>.rxkesrvlkhnd{zoom:100%;}</style><img src="/NXP/RT1050/%E9%87%8E%E7%81%AB/%E9%87%8E%E7%81%ABrt1052%E5%BC%80%E5%8F%91%E6%9D%BF1%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83/image-20231130222240551.png" class="rxkesrvlkhnd"><h3 id="更换Flash下载算法"><a href="#更换Flash下载算法" class="headerlink" title="更换Flash下载算法"></a>更换Flash下载算法</h3><p>i.MX RT 系列芯片内部不具备 FLASH 存储器，即其程序代码需要存储在外部的存储器中，使用时需要自己提供对应 FLASH 的下载算法给 KEIL 软件，野火 i.MX RT1052 系 列开发板使用 32MB 的 SPI-NorFlash 芯片存储程序。野火提供了自己的Flash下载算法，有两个版本，寄存器版本和库函数版本：</p><ul><li>iMXRT1052_W25Q256JV_CFG_By_Fire.FLM(寄存器版本工程使用)</li><li>Embedfire_RT1052_QSPI_R1.FLM（库函数版本工程使用）</li></ul><p>需要把这两个文件复制到Keil的安装目录下：**<u><em>C:\Keil_v5\ARM\Flash</em></u>**</p><p><u><strong>====&gt; 到此为止，编译所需的软件基本整理完毕！==</strong></u></p><h2 id="硬件连接"><a href="#硬件连接" class="headerlink" title="硬件连接"></a>硬件连接</h2><p>先把载板丢一边，看看这个核心板，核心板有一个供电口，一个SWD debug口，还有一个三线的UART接口。</p><style>.osobhczqiwfy{zoom:100%;}</style><img src="/NXP/RT1050/%E9%87%8E%E7%81%AB/%E9%87%8E%E7%81%ABrt1052%E5%BC%80%E5%8F%91%E6%9D%BF1%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83/image-20231130223734281.png" class="osobhczqiwfy"><style>.qznjtpvuwqlb{zoom:100%;}</style><img src="/NXP/RT1050/%E9%87%8E%E7%81%AB/%E9%87%8E%E7%81%ABrt1052%E5%BC%80%E5%8F%91%E6%9D%BF1%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83/image-20231130223748254.png" class="qznjtpvuwqlb"><p>原装的DAP下载器不见了，刚好试试NXP更为强大的MCU-Link Pro ! 小试牛刀！</p><h3 id="MCU-Link-Pro"><a href="#MCU-Link-Pro" class="headerlink" title="MCU-Link Pro"></a>MCU-Link Pro</h3><p>MCU-Link Pro的官方主页在这：<a href="https://www.nxp.com.cn/design/software/development-software/mcuxpresso-software-and-tools-/mcu-link-pro-debug-probe:MCU-LINK-PRO">MCU-Link Pro硬件调试器 | NXP 半导体</a></p><p>支持很多NXP产品的调试，而且可以方便的烧录CMSIS-DAP和JLink的固件，虽然贵点，但是相当于一颗更比两颗强，值了！</p><style>.pjalumnpgwvx{zoom:100%;}</style><img src="/NXP/RT1050/%E9%87%8E%E7%81%AB/%E9%87%8E%E7%81%ABrt1052%E5%BC%80%E5%8F%91%E6%9D%BF1%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83/image-20231130224325691.png" class="pjalumnpgwvx"><p>看一下这里对它的总体介绍：</p><blockquote><p>MCU-Link Pro基于恩智浦的MCU-Link架构，可以在MCU-Link低成本硬件调试器和板载评估板中找到，所有这些版本都运行相同的固件。除了基本MCU-Link中的SWD调试、SWO分析和USB到UART桥接功能(VCOM)之外，MCU-LinkPro型号还增加了J-Link LITE固件选项、能量测量、模拟信号监视器、USB转SPI和I2C桥接功能，以及外设仿真的板载LPC804。MCU-Link Pro基于Arm® Cortex-M33®双核LPC55S69微控制器，并具有高速USB接口，提供低成本、高性能的调试。</p></blockquote><style>.uflrdqjnxzym{zoom:100%;}</style><img src="/NXP/RT1050/%E9%87%8E%E7%81%AB/%E9%87%8E%E7%81%ABrt1052%E5%BC%80%E5%8F%91%E6%9D%BF1%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83/image-20231130225008405.png" class="uflrdqjnxzym"><p>在这个用法中，我们主要用到J7连接板子，J19中的UART信号接出来到板子上：RX &lt;—&gt; TX  TX &lt;—&gt; RX</p><style>.btlokjcjicxk{zoom:100%;}</style><img src="/NXP/RT1050/%E9%87%8E%E7%81%AB/%E9%87%8E%E7%81%ABrt1052%E5%BC%80%E5%8F%91%E6%9D%BF1%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83/image-20231130225346948.png" class="btlokjcjicxk"><h3 id="JTAG接口转接"><a href="#JTAG接口转接" class="headerlink" title="JTAG接口转接"></a>JTAG接口转接</h3><p>由于配备的cable是个小口，还需要一个小转大的转接板，因此，需要找个20PinJTAG口的定义，查阅这个链接：<a href="https://blog.csdn.net/chenhuanqiangnihao/article/details/113835905">JTAG各类接口针脚定义、含义以及SWD接线方式_jtag接口定义_学海无涯_come on的博客-CSDN博客</a></p><style>.xggkcfvblhog{zoom:100%;}</style><img src="/NXP/RT1050/%E9%87%8E%E7%81%AB/%E9%87%8E%E7%81%ABrt1052%E5%BC%80%E5%8F%91%E6%9D%BF1%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83/image-20231130225730949.png" class="xggkcfvblhog"><p>注意，方形焊盘都是1号Pin脚；</p><style>.uohnxhlqmplo{zoom:100%;}</style><img src="/NXP/RT1050/%E9%87%8E%E7%81%AB/%E9%87%8E%E7%81%ABrt1052%E5%BC%80%E5%8F%91%E6%9D%BF1%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83/image-20231130225915289.png" class="uohnxhlqmplo"><p><strong>==—》至此，硬件连接部分搞定！==</strong></p><h2 id="跑Demo！"><a href="#跑Demo！" class="headerlink" title="跑Demo！"></a>跑Demo！</h2><h3 id="先展示一下硬件连接"><a href="#先展示一下硬件连接" class="headerlink" title="先展示一下硬件连接"></a>先展示一下硬件连接</h3><style>.ojxbcqydqmbm{zoom:100%;}</style><img src="/NXP/RT1050/%E9%87%8E%E7%81%AB/%E9%87%8E%E7%81%ABrt1052%E5%BC%80%E5%8F%91%E6%9D%BF1%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83/%E7%A1%AC%E4%BB%B6%E8%BF%9E%E6%8E%A5.jpg" class="ojxbcqydqmbm"><hr><p>注意：</p><ul><li>一定要先给板子上电，再给debugger上电，不然有可能通信失败！</li></ul><h3 id="运行自带的验证程序"><a href="#运行自带的验证程序" class="headerlink" title="运行自带的验证程序"></a>运行自带的验证程序</h3><blockquote><p>1052-H1核心板测试代码\1052-H1测试程序</p></blockquote><p>先编译看看：</p><style>.ceteqlmrdwqf{zoom:100%;}</style><img src="/NXP/RT1050/%E9%87%8E%E7%81%AB/%E9%87%8E%E7%81%ABrt1052%E5%BC%80%E5%8F%91%E6%9D%BF1%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83/image-20231130232535899.png" class="ceteqlmrdwqf"><p>🆗！</p><p>再烧录进来：</p><style>.qaogmqxkxvse{zoom:100%;}</style><img src="/NXP/RT1050/%E9%87%8E%E7%81%AB/%E9%87%8E%E7%81%ABrt1052%E5%BC%80%E5%8F%91%E6%9D%BF1%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83/image-20231130232615101.png" class="qaogmqxkxvse"><p>看看使用VCOM的串口输出：</p><style>.bkolsflyxhkl{zoom:100%;}</style><img src="/NXP/RT1050/%E9%87%8E%E7%81%AB/%E9%87%8E%E7%81%ABrt1052%E5%BC%80%E5%8F%91%E6%9D%BF1%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83/shot.png" class="bkolsflyxhkl"><hr><p>完美运行按键检测的demo~</p><p>后续可以看一下按键中断是如何实现的，以及，继续看一下RT库开发手册！</p><p>— 2023/11/30</p>]]></content>
    
    
    <summary type="html">第一部分，野火RT1052开发板为例，环境创建先跑起来再说</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1050" scheme="https://dustofstars.github.io/categories/NXP/RT1050/"/>
    
    <category term="野火" scheme="https://dustofstars.github.io/categories/NXP/RT1050/%E9%87%8E%E7%81%AB/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="RT1050" scheme="https://dustofstars.github.io/tags/RT1050/"/>
    
  </entry>
  
</feed>
