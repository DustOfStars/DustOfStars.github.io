<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DustOfStars</title>
  
  <subtitle>--jxw</subtitle>
  <link href="https://dustofstars.github.io/atom.xml" rel="self"/>
  
  <link href="https://dustofstars.github.io/"/>
  <updated>2025-05-28T14:32:01.000Z</updated>
  <id>https://dustofstars.github.io/</id>
  
  <author>
    <name>Gavin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RT1060 evkmimxrt1060_sai_edma_record_playback 详解</title>
    <link href="https://dustofstars.github.io/NXP/RT1060/SAI/rt1060-evkmimxrt1060-sai-edma-record-playback-%E8%AF%A6%E8%A7%A3/"/>
    <id>https://dustofstars.github.io/NXP/RT1060/SAI/rt1060-evkmimxrt1060-sai-edma-record-playback-%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-05-28T14:32:01.000Z</published>
    <updated>2025-05-28T14:32:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="evkmimxrt1060-sai-edma-record-playback"><a href="#evkmimxrt1060-sai-edma-record-playback" class="headerlink" title="evkmimxrt1060_sai_edma_record_playback"></a>evkmimxrt1060_sai_edma_record_playback</h1><blockquote><p>详细解析 evkmimxrt1060_sai_edma_record_playback</p><ul><li>硬件：RT1060-EVK</li><li>IDE：MCUXpresso</li><li>SDK：2.16.000</li></ul></blockquote><span id="more"></span><h2 id="0-工程用到的外设拆解"><a href="#0-工程用到的外设拆解" class="headerlink" title="0. 工程用到的外设拆解"></a>0. 工程用到的外设拆解</h2><style>.kbncvuwxnvah{zoom:100%;}</style><img src="/NXP/RT1060/SAI/rt1060-evkmimxrt1060-sai-edma-record-playback-%E8%AF%A6%E8%A7%A3/image-20250528224056154.png" class="kbncvuwxnvah" alt="image-20250528224056154"><ol><li>UART</li><li>I2C</li><li>SAI: 在这个例子中，SAI是master，会向codec输出MCLK。</li><li>Codec:</li><li>DMAMUX</li><li>eDMA</li></ol><h2 id="1-main函数主逻辑"><a href="#1-main函数主逻辑" class="headerlink" title="1. main函数主逻辑"></a>1. main函数主逻辑</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">sai_transfer_t</span> xfer; <span class="comment">// 用于定义一次SAI传输的数据缓冲区和大小</span></span><br><span class="line">    <span class="type">sai_transceiver_t</span> saiConfig; <span class="comment">// 用于配置SAI收发器，比如工作模式、数据格式等</span></span><br><span class="line"></span><br><span class="line">    BOARD_ConfigMPU(); <span class="comment">// 配置内存保护单元 (MPU)，通常用于设置内存区域的访问权限等，保证系统稳定性</span></span><br><span class="line">    BOARD_InitBootPins(); <span class="comment">// 初始化开发板的引脚，将特定引脚配置为SAI、I2C、UART等外设的功能</span></span><br><span class="line">    BOARD_InitBootClocks(); <span class="comment">// 初始化系统时钟，包括CPU核心时钟、外设时钟等</span></span><br><span class="line">    CLOCK_InitAudioPll(&amp;audioPllConfig); <span class="comment">// 初始化音频PLL (锁相环)，这个PLL通常用来为SAI提供高精度的音频主时钟</span></span><br><span class="line">    BOARD_InitDebugConsole(); <span class="comment">// 初始化调试控制台，通常是配置UART，用于通过串口打印信息（比如 "SAI example started!"）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Clock setting for LPI2C*/</span></span><br><span class="line">    CLOCK_SetMux(kCLOCK_Lpi2cMux, DEMO_LPI2C_CLOCK_SOURCE_SELECT); <span class="comment">// 选择LPI2C的时钟源</span></span><br><span class="line">    CLOCK_SetDiv(kCLOCK_Lpi2cDiv, DEMO_LPI2C_CLOCK_SOURCE_DIVIDER); <span class="comment">// 设置LPI2C时钟的分频器，确定其工作频率</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Clock setting for SAI1*/</span></span><br><span class="line">    CLOCK_SetMux(kCLOCK_Sai1Mux, DEMO_SAI1_CLOCK_SOURCE_SELECT); <span class="comment">// 选择SAI1的时钟源</span></span><br><span class="line">    CLOCK_SetDiv(kCLOCK_Sai1PreDiv, DEMO_SAI1_CLOCK_SOURCE_PRE_DIVIDER); <span class="comment">// 设置SAI1时钟的预分频器</span></span><br><span class="line">    CLOCK_SetDiv(kCLOCK_Sai1Div, DEMO_SAI1_CLOCK_SOURCE_DIVIDER); <span class="comment">// 设置SAI1时钟的分频器，共同决定 SAI的工作频率和MCLK频率</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Enable MCLK clock*/</span></span><br><span class="line">    BOARD_EnableSaiMclkOutput(<span class="literal">true</span>); <span class="comment">// 使能SAI的主时钟(MCLK)输出。在这个例子中，SAI是master，会向codec输出MCLK。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Init DMAMUX */</span></span><br><span class="line">    DMAMUX_Init(DEMO_DMAMUX); <span class="comment">// 初始化DMA多路复用器，它负责将外设请求（如SAI的Tx/Rx完成）路由到特定的EDMA通道</span></span><br><span class="line">    DMAMUX_SetSource(DEMO_DMAMUX, DEMO_TX_EDMA_CHANNEL, (<span class="type">uint8_t</span>)DEMO_SAI_TX_SOURCE); <span class="comment">// 将SAI Tx的数据请求路由到EDMA的某个通道</span></span><br><span class="line">    DMAMUX_EnableChannel(DEMO_DMAMUX, DEMO_TX_EDMA_CHANNEL); <span class="comment">// 使能该EDMA通道的DMAMUX请求</span></span><br><span class="line">    DMAMUX_SetSource(DEMO_DMAMUX, DEMO_RX_EDMA_CHANNEL, (<span class="type">uint8_t</span>)DEMO_SAI_RX_SOURCE); <span class="comment">// 将SAI Rx的数据请求路由到EDMA的另一个通道</span></span><br><span class="line">    DMAMUX_EnableChannel(DEMO_DMAMUX, DEMO_RX_EDMA_CHANNEL); <span class="comment">// 使能该EDMA通道的DMAMUX请求</span></span><br><span class="line"></span><br><span class="line">    PRINTF(<span class="string">"SAI example started!\n\r"</span>); <span class="comment">// 打印启动信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Init DMA and create handle for DMA */</span></span><br><span class="line">    EDMA_GetDefaultConfig(&amp;dmaConfig); <span class="comment">// 获取EDMA默认配置</span></span><br><span class="line">    EDMA_Init(DEMO_DMA, &amp;dmaConfig); <span class="comment">// 初始化EDMA控制器</span></span><br><span class="line">    EDMA_CreateHandle(&amp;dmaTxHandle, DEMO_DMA, DEMO_TX_EDMA_CHANNEL); <span class="comment">// 为SAI Tx创建一个EDMA句柄</span></span><br><span class="line">    EDMA_CreateHandle(&amp;dmaRxHandle, DEMO_DMA, DEMO_RX_EDMA_CHANNEL); <span class="comment">// 为SAI Rx创建一个EDMA句柄</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* SAI init */</span></span><br><span class="line">    SAI_Init(DEMO_SAI); <span class="comment">// 初始化SAI外设模块本身</span></span><br><span class="line">    SAI_TransferTxCreateHandleEDMA(DEMO_SAI, &amp;txHandle, tx_callback, <span class="literal">NULL</span>, &amp;dmaTxHandle); <span class="comment">// 为SAI Tx创建EDMA传输句柄，关联SAI模块、EDMA句柄和Tx完成回调函数</span></span><br><span class="line">    SAI_TransferRxCreateHandleEDMA(DEMO_SAI, &amp;rxHandle, rx_callback, <span class="literal">NULL</span>, &amp;dmaRxHandle); <span class="comment">// 为SAI Rx创建EDMA传输句柄，关联SAI模块、EDMA句柄和Rx完成回调函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* I2S mode configurations */</span></span><br><span class="line">    SAI_GetClassicI2SConfig(&amp;saiConfig, DEMO_AUDIO_BIT_WIDTH, kSAI_Stereo, <span class="number">1U</span> &lt;&lt; DEMO_SAI_CHANNEL); <span class="comment">// 获取标准的I2S模式配置，比如位宽、声道等</span></span><br><span class="line">    saiConfig.syncMode              = DEMO_SAI_TX_SYNC_MODE; <span class="comment">// 设置Tx同步模式（这里是异步）</span></span><br><span class="line">    saiConfig.bitClock.bclkPolarity = DEMO_SAI_TX_BIT_CLOCK_POLARITY; <span class="comment">// 设置位时钟极性</span></span><br><span class="line">    saiConfig.masterSlave           = DEMO_SAI_MASTER_SLAVE; <span class="comment">// // 设置SAI模块在BCLK和LRCLK方面是Slave</span></span><br><span class="line">    SAI_TransferTxSetConfigEDMA(DEMO_SAI, &amp;txHandle, &amp;saiConfig); <span class="comment">// 将配置应用到SAI Tx EDMA句柄</span></span><br><span class="line">    saiConfig.syncMode = DEMO_SAI_RX_SYNC_MODE; <span class="comment">// 设置Rx同步模式（这里是同步，与Tx异步工作）</span></span><br><span class="line">    SAI_TransferRxSetConfigEDMA(DEMO_SAI, &amp;rxHandle, &amp;saiConfig); <span class="comment">// 将配置应用到SAI Rx EDMA句柄</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set bit clock divider */</span></span><br><span class="line">    SAI_TxSetBitClockRate(DEMO_SAI, DEMO_AUDIO_MASTER_CLOCK, DEMO_AUDIO_SAMPLE_RATE, DEMO_AUDIO_BIT_WIDTH,</span><br><span class="line">                          DEMO_AUDIO_DATA_CHANNEL); <span class="comment">// 设置SAI Tx的位时钟速率，基于MCLK、采样率、位宽和通道数计算</span></span><br><span class="line">    SAI_RxSetBitClockRate(DEMO_SAI, DEMO_AUDIO_MASTER_CLOCK, DEMO_AUDIO_SAMPLE_RATE, DEMO_AUDIO_BIT_WIDTH,</span><br><span class="line">                          DEMO_AUDIO_DATA_CHANNEL); <span class="comment">// 设置SAI Rx的位时钟速率</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* master clock configurations */</span></span><br><span class="line">    BOARD_MASTER_CLOCK_CONFIG(); <span class="comment">// 这是一个宏，可能包含额外的MCLK配置，根据实际板级定义来确定具体功能</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Use default setting to init codec */</span></span><br><span class="line">    <span class="keyword">if</span> (CODEC_Init(&amp;codecHandle, &amp;boardCodecConfig) != kStatus_Success) <span class="comment">// 初始化音频编解码器(codec)，这里是WM8960</span></span><br><span class="line">    {</span><br><span class="line">        assert(<span class="literal">false</span>); <span class="comment">// 如果初始化失败，停止程序</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (CODEC_SetVolume(&amp;codecHandle, kCODEC_PlayChannelHeadphoneLeft | kCODEC_PlayChannelHeadphoneRight,</span><br><span class="line">                        DEMO_CODEC_VOLUME) != kStatus_Success) <span class="comment">// 设置耳机输出音量</span></span><br><span class="line">    {</span><br><span class="line">        assert(<span class="literal">false</span>); <span class="comment">// 如果设置音量失败，停止程序</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 主循环：音频录制和播放的实时处理 ---</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 录制部分 (RX)</span></span><br><span class="line">        <span class="keyword">if</span> (emptyBlock &gt; <span class="number">0</span>) <span class="comment">// 检查是否有空的缓冲区可以用于接收（录制）音频数据</span></span><br><span class="line">        {</span><br><span class="line">            xfer.data     = Buffer + rx_index * BUFFER_SIZE; <span class="comment">// 设置本次EDMA接收传输的目标地址为当前可用的缓冲区</span></span><br><span class="line">            xfer.dataSize = BUFFER_SIZE; <span class="comment">// 设置本次传输的数据大小（缓冲区大小）</span></span><br><span class="line">            <span class="keyword">if</span> (kStatus_Success == SAI_TransferReceiveEDMA(DEMO_SAI, &amp;rxHandle, &amp;xfer)) <span class="comment">// 启动一次SAI通过EDMA的接收传输</span></span><br><span class="line">            {</span><br><span class="line">                rx_index++; <span class="comment">// 接收缓冲区索引递增，指向下一个缓冲区</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (rx_index == BUFFER_NUMBER) <span class="comment">// 如果索引达到缓冲区总数，循环回到第一个缓冲区</span></span><br><span class="line">            {</span><br><span class="line">                rx_index = <span class="number">0U</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 播放部分 (TX)</span></span><br><span class="line">        <span class="keyword">if</span> (emptyBlock &lt; BUFFER_NUMBER) <span class="comment">// 检查是否有已填充（录制完成）的缓冲区可以用于发送（播放）音频数据</span></span><br><span class="line">        {</span><br><span class="line">            xfer.data     = Buffer + tx_index * BUFFER_SIZE; <span class="comment">// 设置本次EDMA发送传输的数据源地址为当前待播放的缓冲区</span></span><br><span class="line">            xfer.dataSize = BUFFER_SIZE; <span class="comment">// 设置本次传输的数据大小</span></span><br><span class="line">            <span class="keyword">if</span> (kStatus_Success == SAI_TransferSendEDMA(DEMO_SAI, &amp;txHandle, &amp;xfer)) <span class="comment">// 启动一次SAI通过EDMA的发送传输</span></span><br><span class="line">            {</span><br><span class="line">                tx_index++; <span class="comment">// 发送缓冲区索引递增，指向下一个待播放的缓冲区</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (tx_index == BUFFER_NUMBER) <span class="comment">// 如果索引达到缓冲区总数，循环回到第一个缓冲区</span></span><br><span class="line">            {</span><br><span class="line">                tx_index = <span class="number">0U</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// emptyBlock 变量在这里是关键：</span></span><br><span class="line">        <span class="comment">// - 当 EDMA 完成一次 RX (录制) 传输时，`rx_callback` 会被调用，将 `emptyBlock` 减一，表示一个缓冲区被数据填满，不再是空的。</span></span><br><span class="line">        <span class="comment">// - 当 EDMA 完成一次 TX (播放) 传输时，`tx_callback` 会被调用，将 `emptyBlock` 加一，表示一个缓冲区的数据被发送完，变为空闲状态。</span></span><br><span class="line">        <span class="comment">// - 通过判断 `emptyBlock` 的值，主循环知道哪些缓冲区可以用来录制 (emptyBlock &gt; 0)，哪些缓冲区有数据可以播放 (emptyBlock &lt; BUFFER_NUMBER)。</span></span><br><span class="line">        <span class="comment">// - 这里的逻辑实现了一个简单的“乒乓”缓冲或者循环缓冲机制，确保录制和播放能够连续进行。</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>工作流程和逻辑总结：</p><ol><li>初始化阶段：</li></ol><ul><li><p>系统、引脚、时钟等基础硬件被配置。</p></li><li><p>**<u>音频PLL被设置</u>**，为SAI提供精确时钟。</p></li><li><p><strong><u>用于codec控制的I2C</u></strong> 和 <strong><u>用于音频数据传输的SAI</u></strong> 的时钟被配置。</p></li><li><p><span style="color: blue; font-weight: bold;">SAI的MCLK输出被使能，为外部codec提供工作时钟。</span></p></li><li><p>DMAMUX被配置，将SAI的Tx和Rx请求连接到指定的EDMA通道。</p></li><li><p>EDMA控制器被初始化，并为SAI的Tx和Rx创建了EDMA句柄，准备好进行数据传输。</p></li><li><p>SAI外设本身被初始化。</p></li><li><p>为SAI的Tx和Rx功能创建了EDMA传输句柄，这些句柄关联了SAI模块、对应的EDMA句柄以及传输完成后的回调函数 (<code>tx_callback</code> 和 <code>rx_callback</code>)。</p></li><li><p>**<u>SAI被配置为I2S模式</u>**，设置了位宽、声道、同步模式（Rx同步于Tx位时钟，Tx异步）、主从模式等参数。</p><blockquote><p>此时，Codec是master，SAI是slave。</p></blockquote></li><li><p>计算并设置了SAI的 <strong>位时钟速率</strong>。</p></li><li><p>音频codec (WM8960) 通过I2C接口被初始化和配置（包括音量设置）。</p></li></ul><hr><ol start="2"><li>数据传输阶段 (主循环 while(1))：</li></ol><ul><li><p>工程使用了多个（<code>BUFFER_NUMBER</code>，这里是4个）大小为 <code>BUFFER_SIZE</code> (这里是1024字节) 的缓冲区 (Buffer 数组)。</p></li><li><p><code>emptyBlock</code> 变量跟踪当前有多少个缓冲区是空的。初始时，所有缓冲区都是空的，<code>emptyBlock</code> 等于 <code>BUFFER_NUMBER</code>。</p></li><li><p><code>rx_index</code> 指向下一个用于接收（录制）数据的缓冲区。</p></li><li><p><code>tx_index</code> 指向下一个用于发送（播放）数据的缓冲区。</p></li><li><p>录制逻辑： </p><blockquote><p>如果 <code>emptyBlock &gt; 0</code> (有空缓冲区)，意味着可以启动一次新的接收传输。工程设置下一个 空缓冲区 为目标，启动一个EDMA接收任务。EDMA会自动将SAI接收到的数据传输到指定的缓冲区中。传输完成后，会触发 <code>rx_callback</code>，将 <code>emptyBlock</code> 减一，并更新 <code>rx_index</code>。</p></blockquote></li><li><p>播放逻辑： </p><blockquote><p>如果 <code>emptyBlock</code> &lt; <code>BUFFER_NUMBER</code> (有非空缓冲区)，意味着有数据可以播放。工程设置下一个 待播放的缓冲区 为 数据源，启动一个EDMA发送任务。</p><p>EDMA会自动将缓冲区中的数据传输到SAI，SAI再发送给codec进行播放。传输完成后，会触发 <code>tx_callback</code>，将 <code>emptyBlock</code> 加一，并更新 <code>tx_index</code>。</p></blockquote></li><li><p><code>rx_index</code> 和 <code>tx_index</code> 在达到缓冲区末尾时会循环回0，形成一个循环缓冲队列。</p></li><li><p><span style="color: red; font-weight: bold;">通过这种方式，当录制EDMA完成一个缓冲区时，<code>emptyBlock</code> 减少，主循环就可以尽快启动播放该缓冲区；当播放EDMA完成一个缓冲区时，<code>emptyBlock</code> 增加，主循环就可以尽快将该缓冲区再次用于录制。这实现了音频数据的实时“录放”（Capture-Playback）。</span></p></li></ul><ol start="3"><li>回调函数 (<code>rx_callback</code> 和 <code>tx_callback</code>)：</li></ol><ul><li><p>这两个函数在对应的EDMA传输完成时由SAI EDMA驱动调用。</p></li><li><p>它们的主要作用是更新 <code>emptyBlock</code> 的计数器。<code>rx_callback</code> (接收完成) 减少 <code>emptyBlock</code>，<code>tx_callback</code> (发送完成) 增加 <code>emptyBlock</code>。</p></li><li><p>它们也包含基本的错误处理（虽然这里的实现只是检查状态而没有具体处理）。</p></li></ul><p>总的来说，这个工程通过配置SAI和EDMA，建立了一个高效的音频数据通道。数据通过EDMA从SAI Rx（录音输入）传输到内存缓冲区，然后再通过EDMA从内存缓冲区传输到SAI Tx（播放输出）。main 函数中的 while(1) 循环负责检查缓冲区的状态 (emptyBlock) 并不断启动新的EDMA传输任务，从而实现连续的音频录制和播放功能。回调函数是这个EDMA驱动模型的关键部分，它们在外设事件（传输完成）发生时被调用，通知主程序更新状态并安排下一个任务。</p><h2 id="2-几个时钟的区分"><a href="#2-几个时钟的区分" class="headerlink" title="2. 几个时钟的区分"></a>2. 几个时钟的区分</h2><p>在I2S（或其他类似的串行音频接口）通信中，有几种不同的时钟信号：</p><ul><li><p><code>MCLK</code> (Master Clock / System Clock): 通常是频率最高的时钟，用于驱动Codec的内部电路和PLL。</p></li><li><p><code>BCLK</code> (Bit Clock): 位时钟，每个音频数据位对应一个BCLK周期。</p></li><li><p><code>LRCLK</code> (Left/Right Clock / Frame Sync): 左右时钟或帧同步信号，指示当前传输的是左声道还是右声道数据，并同步一个音频帧的开始。（也是字选择信号）</p></li></ul><p>时钟的主从关系主要体现在 <code>BCLK</code> 和 <code>LRCLK</code> 上。配置为 I2S Master 的设备会 生成并输出 BCLK 和 LRCLK；配置为 I2S Slave 的设备会 接收 BCLK 和 LRCLK。</p><p>然而，MCLK 的主从关系是相对独立的。在一个典型的系统中，通常有一个设备负责产生高频的MCLK来驱动整个音频链路。这个设备可以是由主控芯片（MCU）通过其某个时钟生成单元产生，也可以由外部的Codec自己产生（这种情况较少见）。</p><p>在工程中，<code>BOARD_EnableSaiMclkOutput(true)</code> 函数的作用是配置MIMXRT1060芯片上SAI1模块的MCLK引脚，使其作为 输出 引脚。这意味着芯片正在 产生并输出 MCLK。这个MCLK通常是由芯片内部的音频PLL (<code>CLOCK_InitAudioPll</code>) 产生，然后通过SAI模块的MCLK引脚输出到外部的WM8960 Codec。</p><h2 id="3-位时钟是怎么产生的"><a href="#3-位时钟是怎么产生的" class="headerlink" title="3. 位时钟是怎么产生的"></a>3. 位时钟是怎么产生的</h2><p>来仔细看 <code>SAI_TxSetBitClockRate</code> 和 <code>SAI_RxSetBitClockRate</code> 这两个函数及其实现的逻辑。它们的核心功能是根据期望的音频参数（<strong>采样率、位宽、通道数</strong>）来计算并配置SAI模块的 <strong>位时钟 (BCLK)</strong> 相关的寄存器设置。</p><p><strong>1. <code>SAI_TxSetBitClockRate</code> 函数 (配置发送功能的位时钟速率)</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * brief Transmitter bit clock rate configurations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * param base SAI base pointer. // SAI模块的基地址，指向具体的SAI实例（比如SAI1）</span></span><br><span class="line"><span class="comment"> * param sourceClockHz, bit clock source frequency. // 位时钟的源频率，通常是MCLK或者其他的SAI时钟源频率</span></span><br><span class="line"><span class="comment"> * param sampleRate audio data sample rate. // 音频采样率 (Hz)，比如 16000 Hz (16KHz)</span></span><br><span class="line"><span class="comment"> * param bitWidth, audio data bitWidth. // 音频数据位宽 (bits)，比如 16 bits</span></span><br><span class="line"><span class="comment"> * param channelNumbers, audio channel numbers. // 音频通道数，比如 2 (立体声)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SAI_TxSetBitClockRate</span><span class="params">(</span></span><br><span class="line"><span class="params">    I2S_Type *base, <span class="type">uint32_t</span> sourceClockHz, <span class="type">uint32_t</span> sampleRate, <span class="type">uint32_t</span> bitWidth, <span class="type">uint32_t</span> channelNumbers)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint32_t</span> tcr2         = base-&gt;TCR2; <span class="comment">// 读取SAI发送配置寄存器2 (TCR2) 的当前值</span></span><br><span class="line">    <span class="type">uint32_t</span> bitClockDiv  = <span class="number">0</span>; <span class="comment">// 用于存储计算出的位时钟分频值</span></span><br><span class="line">    <span class="type">uint32_t</span> bitClockFreq = sampleRate * bitWidth * channelNumbers; <span class="comment">// 计算目标位时钟频率： 采样率 * 位宽 * 通道数 = 每秒传输的总位数 = BCLK频率</span></span><br><span class="line"></span><br><span class="line">    assert(sourceClockHz &gt;= bitClockFreq); <span class="comment">// 断言：源时钟频率必须大于等于目标位时钟频率，否则无法通过分频得到</span></span><br><span class="line"></span><br><span class="line">    tcr2 &amp;= ~I2S_TCR2_DIV_MASK; <span class="comment">// 清除TCR2寄存器中位时钟分频器 (DIV) 字段的当前值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* need to check the divided bclk, if bigger than target, then divider need to re-calculate. */</span></span><br><span class="line">    bitClockDiv = sourceClockHz / bitClockFreq; <span class="comment">// 初步计算分频值： 源频率 / 目标频率</span></span><br><span class="line">    <span class="comment">/* for the condition where the source clock is smaller than target bclk */</span></span><br><span class="line">    <span class="keyword">if</span> (bitClockDiv == <span class="number">0U</span>) <span class="comment">// 如果源频率小于目标频率（理论上不应该发生，但为了安全检查），分频值至少设为1</span></span><br><span class="line">    {</span><br><span class="line">        bitClockDiv++;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/* recheck the divider if properly or not, to make sure output blck not bigger than target*/</span></span><br><span class="line">    <span class="comment">// 重新检查计算出的分频值是否合适，确保分频后的位时钟频率不会高于目标频率。</span></span><br><span class="line">    <span class="comment">// 这里的逻辑是通过 integer division 的特性来确保分频值是足够大的整数。</span></span><br><span class="line">    <span class="comment">// 如果 `sourceClockHz / bitClockDiv` 仍然大于 `bitClockFreq`，说明 `bitClockDiv` 偏小，需要再加1。</span></span><br><span class="line">    <span class="keyword">if</span> ((sourceClockHz / bitClockDiv) &gt; bitClockFreq)</span><br><span class="line">    {</span><br><span class="line">        bitClockDiv++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 设置TCR2寄存器的DIV字段。</span></span><br><span class="line">        <span class="comment">// 注意这里的 `bitClockDiv / 2U - 1UL`：</span></span><br><span class="line">        <span class="comment">// 大多数恩智浦微控制器的SAI模块的DIV字段配置的是 (分频值 / 2) - 1。</span></span><br><span class="line">        <span class="comment">// 例如，如果需要分频64，DIV寄存器需要设置为 (64 / 2) - 1 = 31。</span></span><br><span class="line">        <span class="comment">// 这里的代码就是根据计算出的总分频值 `bitClockDiv` 来得到寄存器实际需要写入的值。</span></span><br><span class="line">        tcr2 |= I2S_TCR2_DIV(bitClockDiv / <span class="number">2U</span> - <span class="number">1UL</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    base-&gt;TCR2 = tcr2; <span class="comment">// 将修改后的TCR2值写回寄存器，应用配置</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>核心逻辑 (SAI_TxSetBitClockRate):</strong></p><ol><li>计算目标位时钟频率 (<code>bitClockFreq</code>)：这是由音频格式（采样率、位宽、通道数）决定的，表示每秒需要传输的总位数。</li><li>计算所需的时钟源到目标位时钟频率的总分频比 (<code>bitClockDiv</code>)： <code>源时钟频率 / 目标位时钟频率</code>。</li><li>对计算出的分频比进行调整，确保分频结果不会高于目标频率。</li><li>根据计算出的分频比和硬件寄存器的编码方式（除以2减1）计算要写入寄存器的值。</li><li>将计算出的分频值写入SAI发送配置寄存器2 (<code>TCR2</code>) 的相应位字段 (<code>DIV</code>)。</li></ol><p><strong>2. <code>SAI_RxSetBitClockRate</code> 函数 (配置接收功能的位时钟速率)</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * brief Receiver bit clock rate configurations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * param base SAI base pointer. // SAI模块的基地址</span></span><br><span class="line"><span class="comment"> * param sourceClockHz, bit clock source frequency. // 位时钟的源频率</span></span><br><span class="line"><span class="comment"> * param sampleRate audio data sample rate. // 音频采样率</span></span><br><span class="line"><span class="comment"> * param bitWidth, audio data bitWidth. // 音频数据位宽</span></span><br><span class="line"><span class="comment"> * param channelNumbers, audio channel numbers. // 音频通道数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SAI_RxSetBitClockRate</span><span class="params">(</span></span><br><span class="line"><span class="params">    I2S_Type *base, <span class="type">uint32_t</span> sourceClockHz, <span class="type">uint32_t</span> sampleRate, <span class="type">uint32_t</span> bitWidth, <span class="type">uint32_t</span> channelNumbers)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint32_t</span> rcr2         = base-&gt;RCR2; <span class="comment">// 读取SAI接收配置寄存器2 (RCR2) 的当前值</span></span><br><span class="line">    <span class="type">uint32_t</span> bitClockDiv  = <span class="number">0</span>; <span class="comment">// 用于存储计算出的位时钟分频值</span></span><br><span class="line">    <span class="type">uint32_t</span> bitClockFreq = sampleRate * bitWidth * channelNumbers; <span class="comment">// 计算目标位时钟频率，与发送功能相同</span></span><br><span class="line"></span><br><span class="line">    assert(sourceClockHz &gt;= bitClockFreq); <span class="comment">// 断言：源时钟频率必须大于等于目标位时钟频率</span></span><br><span class="line"></span><br><span class="line">    rcr2 &amp;= ~I2S_RCR2_DIV_MASK; <span class="comment">// 清除RCR2寄存器中位时钟分频器 (DIV) 字段的当前值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* need to check the divided bclk, if bigger than target, then divider need to re-calculate. */</span></span><br><span class="line">    bitClockDiv = sourceClockHz / bitClockFreq; <span class="comment">// 初步计算分频值</span></span><br><span class="line">    <span class="comment">/* for the condition where the source clock is smaller than target bclk */</span></span><br><span class="line">    <span class="keyword">if</span> (bitClockDiv == <span class="number">0U</span>) <span class="comment">// 检查分频值是否为0</span></span><br><span class="line">    {</span><br><span class="line">        bitClockDiv++;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/* recheck the divider if properly or not, to make sure output blck not bigger than target*/</span></span><br><span class="line">    <span class="comment">// 重新检查分频值，确保分频后的位时钟不高于目标频率</span></span><br><span class="line">    <span class="keyword">if</span> ((sourceClockHz / bitClockDiv) &gt; bitClockFreq)</span><br><span class="line">    {</span><br><span class="line">        bitClockDiv++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 设置RCR2寄存器的DIV字段，同样是除以2减1的编码方式</span></span><br><span class="line">        rcr2 |= I2S_RCR2_DIV(bitClockDiv / <span class="number">2U</span> - <span class="number">1UL</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    base-&gt;RCR2 = rcr2; <span class="comment">// 将修改后的RCR2值写回寄存器，应用配置</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>核心逻辑 (SAI_RxSetBitClockRate):</strong></p><p>这个函数与 <code>SAI_TxSetBitClockRate</code> 的逻辑完全相同。唯一的区别在于，它操作的是SAI接收配置寄存器2 (<code>RCR2</code>) 的 <code>DIV</code> 位字段 (<code>I2S_RCR2_DIV_MASK</code>)。</p><p><strong>为什么在 Slave 模式下也调用这些函数？</strong></p><p>在这个工程中，SAI 被配置为 BCLK/LRCLK 的 Slave。在 Slave 模式下，SAI 不会通过其内部的分频器生成 BCLK，而是从外部设备（Codec Master）接收 BCLK。</p><p>在具体工程中，由于 SAI 被明确配置为 Slave (<code>kSAI_Slave</code>)，最重要的时钟（BCLK 和 LRCLK）实际上是由 Codec Master 产生的。MCU SAI 模块通过接收这些外部时钟来同步数据的发送和接收。因此，虽然代码中调用了 <code>SetBitClockRate</code> 函数，其主要作用可能不是用于配置时钟生成硬件（因为是 Slave 模式），而是计算分频并写入寄存器，方便后面使用。</p><p>来深入分析一下 Codec (WM8960) 如何在主模式下计算和产生 BCLK，以及代码中哪里体现了这一点。</p><p>当我们说 Codec 工作在 I2S 主模式 (Master) 时，这意味着它负责根据音频格式（采样率、位宽、通道数）来生成并输出 位时钟 (BCLK) 和 帧同步信号 (LRCLK)。它通常依赖于一个主时钟 (MCLK) 来驱动其内部时钟生成电路（如 PLL 和分频器）。</p><p>在这个工程中：</p><ol><li><p>MCLK 源： 微控制器 (MIMXRT1060) 通过 SAI 的 MCLK 输出引脚提供 MCLK 给 WM8960 Codec。我们在 main.c 中配置并使能了这个输出 (BOARD_EnableSaiMclkOutput(true))。MCLK 的频率是根据音频 PLL 和 SAI 的时钟分频器设置得出的，main.c 中通过 DEMO_SAI_CLK_FREQ 宏定义来表示这个频率。</p></li><li><p>音频格式信息： Codec 需要知道要传输的音频数据的格式，才能计算出正确的 BCLK 频率。这些信息在 wm8960Config 结构体中进行了配置，并在初始化 Codec 时通过 CODEC_Init 函数传递给了 WM8960 驱动：</p></li></ol><ul><li><p><code>.format.sampleRate = kWM8960_AudioSampleRate16KHz</code>: 设定采样率为 16KHz。</p></li><li><p><code>.format.bitWidth = kWM8960_AudioBitWidth16bit</code>: 设定数据位宽为 16 bit。</p></li><li><p><code>.bus = kWM8960_BusI2S</code>: 设定使用标准的 I2S 格式。标准 I2S 格式下，一个立体声采样周期需要传输 <code>2 * bitWidth</code> 的数据位（对于 16bit stereo 就是 32 位）。</p></li><li><p><code>.format.mclk_HZ = 6144000U * 2</code>: 设定 Codec 接收到的 MCLK 频率。这里计算出来是 12.288 MHz。这与 <code>DEMO_SAI_CLK_FREQ</code> 理论上应该匹配。</p></li></ul><ol start="3"><li>Codec 如何计算 BCLK： Codec 内部有专门的时钟生成硬件。当 Codec 被配置为 I2S Master 并接收到 MCLK 后，它会根据接收到的 MCLK 频率 (format.mclk_HZ) 和配置的音频格式（采样率、位宽、总线格式）来计算并生成 BCLK 和 LRCLK。</li></ol><ul><li><p>对于标准的 I2S 格式，所需的 BCLK 频率通常是 采样率 * 每帧总位数。对于 16 位立体声，每帧是 32 位（16位左声道 + 16位右声道）。所以理论上 BCLK 频率应为 16KHz * 32 = 512 KHz。</p></li><li><p>Codec 内部的 PLL 和分频器会利用 MCLK (12.288 MHz) 来尝试生成这个 512 KHz 的 BCLK。例如，12.288 MHz / 512 KHz = 24。所以 Codec 内部可能需要将 MCLK 分频 24 倍来得到 BCLK。</p></li><li><p>LRCLK 的频率就是采样率，即 16 KHz。LRCLK 通常是 BCLK 的一个分频（对于 16 位立体声 I2S，LRCLK 频率是 BCLK 频率的 1/32）。</p></li></ul><ol start="4"><li>代码中的体现：</li></ol><ul><li><p>wm8960Config 结构体中的 <code>.master_slave = true</code> 指明了 Codec 是 Master。</p></li><li><p>wm8960Config.format 中的 <code>.sampleRate</code> 和 <code>.bitWidth</code> 提供了 Codec 计算 BCLK 所需的音频格式信息。</p></li><li><p>wm8960Config.format.mclk_HZ 告知 Codec 它接收到的 MCLK 频率是多少，这是它进行内部时钟生成的输入。</p></li><li><p>Codec 驱动 (fsl_wm8960.c) 的作用： 虽然我们没有直接看到 WM8960 驱动中计算 BCLK 的 C 代码（因为时钟生成是 Codec 硬件的功能，驱动主要通过 I2C 配置 Codec 寄存器），但 <code>CODEC_Init</code> (在 fsl_codec_adapter.c 中调用 WM8960 驱动的初始化函数) 会读取 wm8960Config 中的这些参数，并通过 I2C 接口将它们写入 WM8960 Codec 的内部配置寄存器。</p></li><li><p>WM8960 Datasheet/Reference Manual： Codec 如何根据这些配置计算 BCLK 的具体细节（如内部 PLL 配置、分频器寄存器设置等）通常会在 WM8960 的数据手册或参考手册中详细说明。驱动程序 fsl_wm8960.c 就是根据这个手册来实现通过 I2C 配置 Codec 寄存器的逻辑。驱动会解析 wm8960Config 中的参数，并翻译成 Codec 寄存器中对应的位域值。</p></li></ul><p>总结：</p><p>当 SAI 是 Slave 时，BCLK 是由 Codec (WM8960) 产生的。CodeC 作为 I2S Master，利用从微控制器接收到的 MCLK，并根据通过 I2C 接口由 Codec 驱动 (fsl_wm8960.c) 写入其内部寄存器的音频格式配置（采样率、位宽、总线格式等），通过其内部的时钟生成电路（PLL 和分频器）计算并生成所需的 BCLK 和 LRCLK。微控制器的 SAI 驱动代码通过 wm8960Config 和 CODEC_Init 将音频格式和 MCLK 频率信息传递给 Codec 驱动，由 Codec 驱动负责通过 I2C 将这些配置应用到 WM8960 硬件，CodeC 硬件本身负责根据这些配置生成 BCLK。</p><h2 id="4-时钟总结"><a href="#4-时钟总结" class="headerlink" title="4. 时钟总结"></a>4. 时钟总结</h2><p>好的，没问题。根据我们之前的讨论，我为你绘制一个简单的文本图，希望能帮助你更清晰地理解整个系统中各个外设的作用、连接关系以及时钟和数据流。</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">+----------------------------------------------------------------+</span><br><span class="line">|                    微控制器 (MIMXRT1060)                       |</span><br><span class="line">|                                                                |</span><br><span class="line">| +---------------------------+                                  |</span><br><span class="line">| | Audio PLL &amp; 时钟生成单元  | -- MCLK (主时钟输出) --&gt; +-----+ |</span><br><span class="line">| +---------------------------+                        |     | |</span><br><span class="line">|                                                      |     | |</span><br><span class="line">| +---------------------------+                        |     | |</span><br><span class="line">| | LPI2C1 (I2C控制器)        | -- I2C总线 (配置信息) -&gt; |     | |</span><br><span class="line">| +---------------------------+                        |     | |</span><br><span class="line">|                                                      |     | |</span><br><span class="line">| +---------------------------+ &lt;- BCLK (位时钟输入) ----+     | |</span><br><span class="line">| | SAI1 (串行音频接口)        | &lt;- LRCLK (帧同步输入) --+ WM8960 Codec |</span><br><span class="line">| |   (BCLK/LRCLK 从设备)     |                          |     | |</span><br><span class="line">| |                           |                          |  (BCLK/LRCLK|</span><br><span class="line">| | +---------------------+   | &lt;--- 数字音频数据 (RX) ---+  主设备,   |</span><br><span class="line">| | | SAI1 RX FIFO (接收) |&lt;--+                          |   MCLK 输入)|</span><br><span class="line">| | +---------------------+   | EDMA传输请求(RX)         |     | |</span><br><span class="line">| |        |                  +------------------------+-----+ |</span><br><span class="line">| |        |                                                  |</span><br><span class="line">| | +---------------------+   | ---&gt; 数字音频数据 (TX) ---&gt; +-----+</span><br><span class="line">| | | SAI1 TX FIFO (发送) |--&gt;+ Codec (通过其DAC输出模拟音频)--&gt;+耳机/扬声器|</span><br><span class="line">| | +---------------------+   | EDMA传输请求(TX)         +-----+-------+</span><br><span class="line">| |        ^                  +------------------------+</span><br><span class="line">| +---------------------------+                                  |</span><br><span class="line">|            |                                                   |</span><br><span class="line">| +---------------------------+                                  |</span><br><span class="line">| | DMAMUX (DMA多路复用器)    | -- 路由EDMA请求 --&gt; +-----------+ |</span><br><span class="line">| |        ^                  |                     |  麦克风   | |</span><br><span class="line">| +---------------------------+                     +-----------+ |</span><br><span class="line">|            | EDMA请求                                         |</span><br><span class="line">| +---------------------------+                                  |</span><br><span class="line">| | EDMA (增强型DMA控制器)    |                                  |</span><br><span class="line">| |   (通道 RX 和 TX)         | &lt;--- EDMA传输 (数据)             |</span><br><span class="line">| |        |                  |                                  |</span><br><span class="line">| | +---------------------+   | ---&gt; EDMA传输 (数据) --&gt; +-------------+ |</span><br><span class="line">| | | EDMA Channel RX     | --+                         | 内存缓冲区  | |</span><br><span class="line">| | +---------------------+   |                         +-------------+ |</span><br><span class="line">| | +---------------------+   | &lt;--- EDMA传输 (数据)             |</span><br><span class="line">| | | EDMA Channel TX     | &lt;--+                                  |</span><br><span class="line">| | +---------------------+                                  |</span><br><span class="line">| +---------------------------+                                  |</span><br><span class="line">+----------------------------------------------------------------+</span><br></pre></td></tr></tbody></table></figure><p><strong>图解说明：</strong></p><ol><li><p><strong>MIMXRT1060:</strong> 整个系统的核心。</p><ul><li><strong>Audio PLL &amp; 时钟生成单元:</strong> 产生高频的音频主时钟 (MCLK)，并通过 SAI1 模块输出给 Codec。</li><li><strong>LPI2C1:</strong> 作为 I2C 主设备，用于通过 I2C 总线向 WM8960 Codec 发送配置命令（如设置采样率、音量、主从模式等）。</li><li><strong>SAI1:</strong> 串行音频接口，配置为 **BCLK/LRCLK 的从设备 (Slave)**。它接收来自 Codec 的 BCLK 和 LRCLK 来同步数据传输，并通过数据引脚接收录音数据 (RX) 并发送播放数据 (TX)。<ul><li><strong>SAI1 RX FIFO:</strong> 接收来自 Codec 的数字音频数据，并将数据暂存起来。当 FIFO 达到一定阈值时，会触发 EDMA 传输请求。</li><li><strong>SAI1 TX FIFO:</strong> 接收来自 EDMA 的播放数据，并通过 SAI 接口发送给 Codec。当 FIFO 需要数据时，会触发 EDMA 传输请求。</li></ul></li><li><strong>DMAMUX:</strong> 将 SAI1 模块的 RX/TX EDMA 传输请求路由到特定的 EDMA 通道。</li><li><strong>EDMA:</strong> 增强型 DMA 控制器，负责在 SAI 的 FIFO 和内存缓冲区之间高效地传输音频数据，无需 CPU 干预。</li><li><strong>内存缓冲区:</strong> 位于微控制器 RAM 中的一块区域，用于临时存储录制到的音频数据，以及存放等待播放的音频数据。</li></ul></li><li><p><strong>外部设备:</strong></p><ul><li><strong>WM8960 Codec:</strong> 音频编解码器。<ul><li>接收微控制器提供的 MCLK。</li><li>接收微控制器通过 I2C 发送的配置命令。</li><li>作为 **BCLK/LRCLK 的主设备 (Master)**，根据 MCLK 和配置信息，内部生成并输出 BCLK 和 LRCLK 给 SAI1。</li><li>将来自麦克风的模拟音频转换为数字音频 (ADC)，并通过数字音频输出引脚发送给 SAI1 RX FIFO。</li><li>将来自 SAI1 TX FIFO 的数字音频数据转换为模拟音频 (DAC)，并通过模拟音频输出引脚发送给耳机/扬声器。</li></ul></li><li><strong>麦克风:</strong> 提供模拟音频输入。</li><li><strong>耳机/扬声器:</strong> 输出模拟音频。</li></ul></li></ol><p><strong>时钟和数据流：</strong></p><ul><li><strong>时钟流：</strong> <code>MCLK</code> 从 MCU 流向 Codec；<code>BCLK</code> 和 <code>LRCLK</code> 从 Codec 流向 MCU (SAI1)。</li><li><strong>配置流：</strong> I2C 命令从 MCU 流向 Codec。</li><li><strong>数据流 (录音 - RX):</strong> 麦克风 (模拟) -&gt; Codec (ADC -&gt; 数字) -&gt; Codec 数字输出 -&gt; SAI1 RX FIFO -&gt; EDMA Channel RX -&gt; 内存缓冲区。这个过程由 Codec 生成的 BCLK 和 LRCLK 同步。</li><li><strong>数据流 (播放 - TX):</strong> 内存缓冲区 -&gt; EDMA Channel TX -&gt; SAI1 TX FIFO -&gt; SAI1 数字输出 -&gt; Codec (DAC -&gt; 模拟) -&gt; Codec 模拟输出 -&gt; 耳机/扬声器。这个过程也由 Codec 生成的 BCLK 和 LRCLK 同步。</li></ul><p>这个图和说明应该能清晰地展示出系统中各个组件的角色分工、连接方式以及音频数据和时钟的流动路径。</p><style>.oecchcmodgbs{zoom:100%;}</style><img src="/NXP/RT1060/SAI/rt1060-evkmimxrt1060-sai-edma-record-playback-%E8%AF%A6%E8%A7%A3/RT1060_SAI_edma.png" class="oecchcmodgbs"><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    subgraph MCU [MCU MIMXRT1060]</span><br><span class="line">        Clock(音频PLL 时钟)</span><br><span class="line">        I2C(LPI2C1 I2C Master)</span><br><span class="line">        SAI[SAI1 BCLK_LRCLK Slave]</span><br><span class="line">        DMAMUX[DMAMUX]</span><br><span class="line">        EDMA[EDMA Channel RX TX]</span><br><span class="line">        Memory[内存缓冲区]</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    Codec[WM8960 Codec&lt;br&gt;BCLK_LRCLK Master&lt;br&gt;MCLK Input]</span><br><span class="line">    Mic[麦克风]</span><br><span class="line">    Headphones[耳机 扬声器]</span><br><span class="line"></span><br><span class="line">    %% Clock Flow</span><br><span class="line">    Clock --&gt; Codec</span><br><span class="line"></span><br><span class="line">    %% Configuration Flow</span><br><span class="line">    I2C --&gt; Codec</span><br><span class="line"></span><br><span class="line">    %% Data and Clock Flow (Playback - TX)</span><br><span class="line">    Memory --&gt; EDMA</span><br><span class="line">    EDMA --&gt; SAI</span><br><span class="line">    SAI --&gt; Codec</span><br><span class="line">    SAI &lt;-- Codec</span><br><span class="line">    Codec --&gt; Headphones</span><br><span class="line"></span><br><span class="line">    %% Data Flow (Recording - RX)</span><br><span class="line">    Mic --&gt; Codec</span><br><span class="line">    Codec --&gt; SAI</span><br><span class="line">    SAI --&gt; DMAMUX</span><br><span class="line">    DMAMUX --&gt; EDMA</span><br><span class="line">    EDMA --&gt; Memory</span><br><span class="line"></span><br><span class="line">    %% Note on EDMA Trigger: SAI FIFOs trigger EDMA requests via DMAMUX</span><br><span class="line">    SAI --&gt; DMAMUX</span><br><span class="line">    DMAMUX --&gt; EDMA</span><br><span class="line">style Codec stroke:#FF0000</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;evkmimxrt1060-sai-edma-record-playback&quot;&gt;&lt;a href=&quot;#evkmimxrt1060-sai-edma-record-playback&quot; class=&quot;headerlink&quot; title=&quot;evkmimxrt1060_sai_edma_record_playback&quot;&gt;&lt;/a&gt;evkmimxrt1060_sai_edma_record_playback&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;详细解析 evkmimxrt1060_sai_edma_record_playback&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;硬件：RT1060-EVK&lt;/li&gt;
&lt;li&gt;IDE：MCUXpresso&lt;/li&gt;
&lt;li&gt;SDK：2.16.000&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1060" scheme="https://dustofstars.github.io/categories/NXP/RT1060/"/>
    
    <category term="SAI" scheme="https://dustofstars.github.io/categories/NXP/RT1060/SAI/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="SAI" scheme="https://dustofstars.github.io/tags/SAI/"/>
    
    <category term="eDMA" scheme="https://dustofstars.github.io/tags/eDMA/"/>
    
  </entry>
  
  <entry>
    <title>RT1060 eDMA 详解 (3)</title>
    <link href="https://dustofstars.github.io/NXP/RT1060/eDMA/rt1060-edma-%E8%AF%A6%E8%A7%A3-3/"/>
    <id>https://dustofstars.github.io/NXP/RT1060/eDMA/rt1060-edma-%E8%AF%A6%E8%A7%A3-3/</id>
    <published>2025-05-24T07:49:03.000Z</published>
    <updated>2025-05-24T07:49:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RT1060-eDMA-Part3-初始化-应用"><a href="#RT1060-eDMA-Part3-初始化-应用" class="headerlink" title="RT1060 eDMA Part3 初始化 &amp; 应用"></a>RT1060 eDMA Part3 初始化 &amp; 应用</h1><blockquote><p>第 6 章 增强型直接内存访问（eDMA） 初始化 &amp; 应用</p><p>要点：</p><p>？？？</p></blockquote><span id="more"></span><h2 id="6-4-初始化-应用信息"><a href="#6-4-初始化-应用信息" class="headerlink" title="6.4 初始化 / 应用信息"></a>6.4 初始化 / 应用信息</h2><p>以下部分讨论 eDMA 的初始化和编程注意事项。</p><h3 id="6-4-1-eDMA-初始化"><a href="#6-4-1-eDMA-初始化" class="headerlink" title="6.4.1 eDMA 初始化"></a>6.4.1 eDMA 初始化</h3><p>初始化 eDMA 的步骤如下：</p><ol><li>如果需要默认配置以外的设置，请写入控制寄存器（CR）。</li><li>如果需要默认优先级以外的配置，请将通道优先级级别写入 DCHPRIn 寄存器。</li><li>如果需要，在 EEI 寄存器中启用错误中断。</li><li>为每个可能请求服务的通道写入 32 字节的传输控制描述符（TCD）。</li><li>通过 ERQ 寄存器启用任何硬件服务请求。</li><li>通过以下方式请求通道服务：・软件方式：设置 TCDn_CSR [START] 位・硬件方式：从设备断言其 eDMA 外设请求信号</li></ol><p>任何通道请求服务后，将根据编程模型中的仲裁和优先级级别选择一个通道执行。eDMA 引擎会将所选通道的整个 TCD（包括 TCD 控制和状态字段，如表 6-6 所示）读取到其内部地址路径模块中。表 6-6 TCD 控制和状态字段</p><table><thead><tr><th>TCD n_CSR 字段名称</th><th>描述</th></tr></thead><tbody><tr><td>START</td><td>使用软件启动的 DMA 服务时，显式启动通道的控制位（硬件自动清除）</td></tr><tr><td>ACTIVE</td><td>状态位，指示通道当前正在执行</td></tr><tr><td>DONE</td><td>状态位，指示主循环完成（使用软件启动的 DMA 服务时由软件清除）</td></tr><tr><td>DREQ</td><td>使用硬件启动的 DMA 服务时，在主循环完成结束时禁用 DMA 请求的控制位</td></tr><tr><td>BWC</td><td>用于限制通道带宽控制的控制位</td></tr><tr><td>ESG</td><td>启用分散 / 聚集功能的控制位</td></tr><tr><td>INTHALF</td><td>主循环完成一半时启用中断的控制位</td></tr><tr><td>INTMAJOR</td><td>主循环完成时启用中断的控制位</td></tr></tbody></table><p>读取 TCD 时，除非检测到配置错误，否则会在系统总线上启动第一次传输。从 TCDn_SADDR 定义的源地址到 TCDn_DADDR 定义的目标地址的传输将持续进行，直到传输完 TCDn_NBYTES 指定的字节数。</p><p>传输完成后，eDMA 引擎会将本地的 TCDn_SADDR、TCDn_DADDR 和 TCDn_CITER 写回主 TCD 内存，并执行任何已启用的微循环通道链接（如果已启用）。如果主循环耗尽，将执行进一步的后处理，例如中断、主循环通道链接和分散 / 聚集操作（如果已启用）。</p><p>下图显示了每个 DMA 请求如何在无需 CPU 干预的情况下启动一次微循环传输或迭代。每次微循环后可能发生 DMA 仲裁，并且允许一级微循环 DMA 抢占。主循环中的微循环次数由起始迭代计数（BITER）指定。图 6-5 多重循环迭代示例</p><table><thead><tr><th></th><th>源或目标内存</th><th></th><th></th><th>当前主循环迭代计数（CITER）</th></tr></thead><tbody><tr><td>DMA 请求</td><td></td><td></td><td></td><td></td></tr><tr><td>•</td><td>微循环</td><td></td><td>3</td><td></td></tr><tr><td>• •</td><td></td><td></td><td></td><td></td></tr><tr><td>DMA 请求</td><td></td><td></td><td></td><td></td></tr><tr><td>•</td><td>微循环</td><td>主循环</td><td>2</td><td></td></tr><tr><td>•</td><td></td><td></td><td></td><td></td></tr><tr><td>•</td><td></td><td></td><td></td><td></td></tr><tr><td>DMA 请求</td><td></td><td></td><td></td><td></td></tr><tr><td>•</td><td>微循环</td><td></td><td>1</td><td></td></tr><tr><td>•</td><td></td><td></td><td></td><td></td></tr><tr><td>•</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>下图列出了内存数组术语以及 TCD 设置的相互关系。图 6-6 内存数组术语</p><table><thead><tr><th>xADDR:（起始地址）</th><th>xSIZE:（一次数据传输的大小）</th><th>微循环（微循环中的 NBYTES，通常与 xSIZE 值相同）</th><th></th></tr></thead><tbody><tr><td></td><td>• • •</td><td>偏移量（xOFF）：每次传输后添加到当前地址的字节数（通常与 xSIZE 相同）</td><td></td></tr><tr><td>• • • • • •</td><td>• • • • • •</td><td>每个 DMA 源（S）和目标（D）都有自己的：地址（xADDR）、大小（xSIZE）、偏移量（xOFF）、模（xMOD）、最后地址调整（xLAST），其中 x = S 或 D</td><td></td></tr><tr><td></td><td>• • •</td><td>最后一次微循环</td><td>外设队列的大小和偏移量通常等于 NBYTES</td></tr><tr><td>xLAST: 主循环后添加到当前地址的字节数（通常用于循环回退）</td><td></td><td></td><td></td></tr></tbody></table><h3 id="6-4-2-编程错误"><a href="#6-4-2-编程错误" class="headerlink" title="6.4.2 编程错误"></a>6.4.2 编程错误</h3><p>eDMA 会对传输控制描述符执行各种测试，以验证描述符数据的一致性。除通道优先级错误（ES [CPE]）外，大多数编程错误都会按通道报告。</p><p>对于组错误或通道优先级错误以外的所有错误类型，导致错误的通道号会记录在错误状态寄存器（DMAx_ES）中。如果在问题通道下次激活之前未清除错误源，该错误将被再次检测和记录。</p><p>通道优先级错误在某个组被选为活动组后在该组内识别。例如：</p><ol><li>eDMA 配置为固定组和固定通道仲裁模式。</li><li>组 1 是最高优先级，且该组中的所有通道优先级唯一。</li><li>组 0 是次高优先级，包含两个具有相同优先级的通道。</li><li>如果组 1 有任何服务请求，这些请求将被执行。</li><li>组 1 的请求全部完成后，组 0 将成为下一个活动组。</li><li>如果组 0 有服务请求，则会选择组 0 中的一个未定义通道，并发生通道优先级错误。</li><li>这种情况会持续，直到组 0 的所有请求被移除或更高优先级的组 1 请求进入。</li></ol><p>在这个序列中，对于第 2 项，仅当选定的通道通过 eDMA 外设请求信号请求服务时，eDMA 确认线才会断言。如果为所有通道启用了中断，用户将收到错误中断，但 ERR 寄存器的通道号和错误中断请求线可能错误，因为它们反映的是所选通道。组优先级错误是全局的，任何组中的请求都会导致组优先级错误。</p><p>如果优先级级别不唯一，当任何通道请求服务时，将报告通道优先级错误。具有活动请求的最高通道 / 组优先级被选中，但仲裁会选择该优先级中编号最小的通道，并由 eDMA 引擎执行。硬件服务请求握手信号、错误中断和错误报告与所选通道相关联。</p><h3 id="6-4-3-仲裁模式注意事项"><a href="#6-4-3-仲裁模式注意事项" class="headerlink" title="6.4.3 仲裁模式注意事项"></a>6.4.3 仲裁模式注意事项</h3><p>本节讨论 eDMA 的仲裁注意事项。</p><h4 id="6-4-3-1-固定组仲裁，固定通道仲裁"><a href="#6-4-3-1-固定组仲裁，固定通道仲裁" class="headerlink" title="6.4.3.1 固定组仲裁，固定通道仲裁"></a>6.4.3.1 固定组仲裁，固定通道仲裁</h4><p>在这种模式下，选择最高优先级组中最高优先级通道的服务请求进行执行。如果 eDMA 编程为某组内的通道使用 “固定” 优先级，并且该组被分配为所有组中的最高 “固定” 优先级，则该组可以占用 eDMA 控制器的所有带宽。也就是说，如果控制器仲裁下一个 DMA 请求时，最高优先级组中至少有一个 DMA 请求挂起，其他组将不会被服务。这种情况的优点是需要快速服务的通道的延迟可以很小。抢占仅在这种情况下可用。</p><h4 id="6-4-3-2-固定组仲裁，循环通道仲裁"><a href="#6-4-3-2-固定组仲裁，循环通道仲裁" class="headerlink" title="6.4.3.2 固定组仲裁，循环通道仲裁"></a>6.4.3.2 固定组仲裁，循环通道仲裁</h4><p>有请求的最高优先级组将被服务。如果更高优先级组中没有挂起的请求，则服务低优先级组。</p><p>在每个组内，通道服务从最高通道号开始，循环到最低通道号，而不考虑组内分配的通道优先级级别。</p><p>这种情况可能导致与 “固定组仲裁，固定通道仲裁” 中提到的相同带宽消耗问题，但最高优先级组中的所有通道都将被服务。最高优先级组的服务延迟较短，但随着组优先级降低，延迟可能会显著增加。</p><h3 id="6-4-4-DMA-传输示例"><a href="#6-4-4-DMA-传输示例" class="headerlink" title="6.4.4 DMA 传输示例"></a>6.4.4 DMA 传输示例</h3><p>本节介绍如何使用 eDMA 执行 DMA 传输的示例。</p><h4 id="6-4-4-1-单次请求"><a href="#6-4-4-1-单次请求" class="headerlink" title="6.4.4.1 单次请求"></a>6.4.4.1 单次请求</h4><p>要通过一次激活执行 n 字节数据的简单传输，将主循环设置为 1（TCDn_CITER = TCDn_BITER = 1）。通道服务请求被确认并选择通道执行后，数据传输开始。传输完成后，TCDn_CSR [DONE] 位被设置，如果启用了中断，则会生成中断。</p><p>例如，以下 TCD 条目配置为传输 16 字节数据。eDMA 被编程为主循环一次迭代，每次迭代传输 16 字节。源内存有一个位于 0x1000 的 8 位内存端口，目标内存有一个位于 0x2000 的 32 位端口。地址偏移量按增量编程以匹配传输大小：源为 1 字节，目标为 4 字节。最终的源和目标地址被调整为返回其初始值。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TCDn_CITER = TCDn_BITER = 1  </span><br><span class="line">TCDn_NBYTES = 16  </span><br><span class="line">TCDn_SADDR = 0x1000  </span><br><span class="line">TCDn_SOFF = 1  </span><br><span class="line">TCDn_ATTR[SSIZE] = 0  </span><br><span class="line">TCDn_SLAST = -16  </span><br><span class="line">TCDn_DADDR = 0x2000  </span><br><span class="line">TCDn_DOFF = 4  </span><br><span class="line">TCDn_ATTR[DSIZE] = 2  </span><br><span class="line">TCDn_DLAST_SGA = –16  </span><br><span class="line">TCDn_CSR[INTMAJOR] = 1  </span><br><span class="line">TCDn_CSR[START] = 1（应在初始化所有其他字段后最后写入）  </span><br><span class="line">所有其他TCDn字段 = 0  </span><br></pre></td></tr></tbody></table></figure><p>这将生成以下事件序列：</p><ol><li>用户写入 TCDn_CSR [START] 位请求通道服务。</li><li>通过仲裁选择通道进行服务。</li><li>eDMA 引擎写入：TCDn_CSR [DONE] = 0，TCDn_CSR [START] = 0，TCDn_CSR [ACTIVE] = 1。</li><li>eDMA 引擎从本地内存读取通道 TCD 数据到内部寄存器文件。</li><li>源到目标的传输执行如下：a. 从地址 0x1000 读取字节，从 0x1001 读取字节，从 0x1002 读取字节，从 0x1003 读取字节。b. 向地址 0x2000 写入 32 位 ￫ 微循环第一次迭代。c. 从地址 0x1004 读取字节，从 0x1005 读取字节，从 0x1006 读取字节，从 0x1007 读取字节。d. 向地址 0x2004 写入 32 位 ￫ 微循环第二次迭代。e. 从地址 0x1008 读取字节，从 0x1009 读取字节，从 0x100A 读取字节，从 0x100B 读取字节。f. 向地址 0x2008 写入 32 位 ￫ 微循环第三次迭代。g. 从地址 0x100C 读取字节，从 0x100D 读取字节，从 0x100E 读取字节，从 0x100F 读取字节。h. 向地址 0x200C 写入 32 位 ￫ 微循环最后一次迭代 ￫ 主循环完成。</li><li>eDMA 引擎写入：TCDn_SADDR = 0x1000，TCDn_DADDR = 0x2000，TCDn_CITER = 1（TCDn_BITER）。</li><li>eDMA 引擎写入：TCDn_CSR [ACTIVE] = 0，TCDn_CSR [DONE] = 1，INT [n] = 1。</li><li>通道退出，eDMA 进入空闲状态或服务下一个通道。</li></ol><h4 id="6-4-4-2-多次请求"><a href="#6-4-4-2-多次请求" class="headerlink" title="6.4.4.2 多次请求"></a>6.4.4.2 多次请求</h4><p>以下示例通过两次硬件请求传输 32 字节数据，其他方面与前一个示例相同。唯一变化的字段是主循环迭代计数和最终地址偏移量。eDMA 被编程为主循环两次迭代，每次迭代传输 16 字节。在 ERQ 寄存器中启用通道的硬件请求后，从设备发起通道服务请求。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TCDn_CITER = TCDn_BITER = 2  </span><br><span class="line">TCDn_SLAST = –32  </span><br><span class="line">TCDn_DLAST_SGA = –32  </span><br></pre></td></tr></tbody></table></figure><p>这将生成以下事件序列：</p><ol><li>第一次硬件（即 eDMA 外设）请求通道服务。</li><li>通过仲裁选择通道进行服务。</li><li>eDMA 引擎写入：TCD_CSR [DONE] = 0，TCDn_CSR [START] = 0，TCDn_CSR [ACTIVE] = 1。</li><li>eDMA 引擎从本地内存读取通道 TCDn 数据到内部寄存器文件。</li><li>源到目标的传输执行如下：a. 从地址 0x1000 读取字节，从 0x1001 读取字节，从 0x1002 读取字节，从 0x1003 读取字节。b. 向地址 0x2000 写入 32 位 ￫ 微循环第一次迭代。c. 从地址 0x1004 读取字节，从 0x1005 读取字节，从 0x1006 读取字节，从 0x1007 读取字节。d. 向地址 0x2004 写入 32 位 ￫ 微循环第二次迭代。e. 从地址 0x1008 读取字节，从 0x1009 读取字节，从 0x100A 读取字节，从 0x100B 读取字节。f. 向地址 0x2008 写入 32 位 ￫ 微循环第三次迭代。g. 从地址 0x100C 读取字节，从 0x100D 读取字节，从 0x100E 读取字节，从 0x100F 读取字节。h. 向地址 0x200C 写入 32 位 ￫ 微循环最后一次迭代。</li><li>eDMA 引擎写入：TCDn_SADDR = 0x1010，TCDn_DADDR = 0x2010，TCDn_CITER = 1。</li><li>eDMA 引擎写入：TCDn_CSR [ACTIVE] = 0。</li><li>通道退出 ￫ 主循环一次迭代。eDMA 进入空闲状态或服务下一个通道。</li><li>第二次硬件（即 eDMA 外设）请求通道服务。</li><li>通过仲裁选择通道进行服务。</li><li>eDMA 引擎写入：TCDn_CSR [DONE] = 0，TCDn_CSR [START] = 0，TCDn_CSR [ACTIVE] = 1。</li><li>eDMA 引擎从本地内存读取通道 TCD 数据到内部寄存器文件。</li><li>源到目标的传输执行如下：a. 从地址 0x1010 读取字节，从 0x1011 读取字节，从 0x1012 读取字节，从 0x1013 读取字节。b. 向地址 0x2010 写入 32 位 ￫ 微循环第一次迭代。c. 从地址 0x1014 读取字节，从 0x1015 读取字节，从 0x1016 读取字节，从 0x1017 读取字节。d. 向地址 0x2014 写入 32 位 ￫ 微循环第二次迭代。e. 从地址 0x1018 读取字节，从 0x1019 读取字节，从 0x101A 读取字节，从 0x101B 读取字节。f. 向地址 0x2018 写入 32 位 ￫ 微循环第三次迭代。g. 从地址 0x101C 读取字节，从 0x101D 读取字节，从 0x101E 读取字节，从 0x101F 读取字节。h. 向地址 0x201C 写入 32 位 ￫ 微循环最后一次迭代 ￫ 主循环完成。</li><li>eDMA 引擎写入：TCDn_SADDR = 0x1000，TCDn_DADDR = 0x2000，TCDn_CITER = 2（TCDn_BITER）。</li><li>eDMA 引擎写入：TCDn_CSR [ACTIVE] = 0，TCDn_CSR [DONE] = 1，INT [n] = 1。</li><li>通道退出 ￫ 主循环完成。eDMA 进入空闲状态或服务下一个通道。</li></ol><h4 id="6-4-4-3-使用模运算功能"><a href="#6-4-4-3-使用模运算功能" class="headerlink" title="6.4.4.3 使用模运算功能"></a>6.4.4.3 使用模运算功能</h4><p>eDMA 的模运算功能支持实现循环数据队列，其中队列大小为 2 的幂。TCD 中源和目标的 MOD 是一个 5 位字段，用于指定地址 + 偏移量计算后，哪些低位地址位会递增，而所有高位地址位保持原值。该字段设置为 0 时将禁用模运算功能。</p><p>下表展示了如何根据 MOD 字段的设置指定传输地址。在此示例中，创建了一个循环缓冲区，地址会回绕到初始值，同时 28 个高位地址位（0x1234567x）保持原值。假设源地址设置为 0x12345670，偏移量设置为 4 字节，MOD 字段设置为 4，从而支持一个 2⁴字节（16 字节）大小的队列。表 6-7 模运算示例（续表见下页）</p><table><thead><tr><th>传输次数</th><th>地址</th></tr></thead><tbody><tr><td>1</td><td>0x12345670</td></tr><tr><td>2</td><td>0x12345674</td></tr><tr><td>3</td><td>0x12345678</td></tr><tr><td>4</td><td>0x1234567C</td></tr><tr><td>5</td><td>0x12345670</td></tr><tr><td>6</td><td>0x12345674</td></tr></tbody></table><h3 id="6-4-5-监控传输描述符状态"><a href="#6-4-5-监控传输描述符状态" class="headerlink" title="6.4.5 监控传输描述符状态"></a>6.4.5 监控传输描述符状态</h3><p>本节讨论如何监控 eDMA 状态。</p><h4 id="6-4-5-1-测试微循环完成情况"><a href="#6-4-5-1-测试微循环完成情况" class="headerlink" title="6.4.5.1 测试微循环完成情况"></a>6.4.5.1 测试微循环完成情况</h4><p>使用软件启动的服务请求时，有两种方法可测试微循环是否完成。第一种方法是读取 TCDn_CITER 字段并检测其变化。另一种方法可从以下序列中推导：通过测试 TCDn_CSR [START] 和 TCDn_CSR [ACTIVE] 位的状态。当 TCDn_CSR [START] 位被设置后，若这两个位均读为 0，则表示微循环完成。轮询 TCDn_CSR [ACTIVE] 位可能不可靠，因为如果通道执行时间较短，可能会错过活动状态。</p><p>对于软件激活的通道，TCD 状态位按以下序列变化：</p><table><thead><tr><th>阶段</th><th>TCDn_CSR 位状态</th><th></th><th></th><th>状态</th></tr></thead><tbody><tr><td>START</td><td>ACTIVE</td><td>DONE</td><td></td><td></td></tr><tr><td>1</td><td>1</td><td>0</td><td>0</td><td>通过软件请求通道服务</td></tr><tr><td>2</td><td>0</td><td>1</td><td>0</td><td>通道正在执行</td></tr><tr><td>3a</td><td>0</td><td>0</td><td>0</td><td>通道已完成微循环并进入空闲状态</td></tr><tr><td>3b</td><td>0</td><td>0</td><td>1</td><td>通道已完成主循环并进入空闲状态</td></tr></tbody></table><p>使用硬件（外设）启动的服务请求时，测试微循环完成的最佳方法是读取 TCDn_CITER 字段并检测其变化。硬件请求和确认握手信号在编程模型中不可见。</p><p>对于硬件激活的通道，TCD 状态位按以下序列变化：</p><table><thead><tr><th>阶段</th><th>TCDn_CSR 位状态</th><th></th><th></th><th>状态</th></tr></thead><tbody><tr><td>START</td><td>ACTIVE</td><td>DONE</td><td></td><td></td></tr><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>通过硬件请求通道服务（外设请求有效）</td></tr><tr><td>2</td><td>0</td><td>1</td><td>0</td><td>通道正在执行</td></tr><tr><td>3a</td><td>0</td><td>0</td><td>0</td><td>通道已完成微循环并进入空闲状态</td></tr><tr><td>3b</td><td>0</td><td>0</td><td>1</td><td>通道已完成主循环并进入空闲状态</td></tr></tbody></table><p>对于两种激活类型，主循环完成状态均通过 TCDn_CSR [DONE] 位明确指示。无论通道如何激活，TCDn_CSR [START] 位在通道开始执行时自动清除。</p><h4 id="6-4-5-2-读取活动通道的传输描述符"><a href="#6-4-5-2-读取活动通道的传输描述符" class="headerlink" title="6.4.5.2 读取活动通道的传输描述符"></a>6.4.5.2 读取活动通道的传输描述符</h4><p>当通道执行时，读取 TCDn_SADDR、TCDn_DADDR 和 TCDn_NBYTES 字段将返回真实值。这些真实值是 eDMA 引擎当前在内部寄存器文件中使用的值，而非该通道 TCD 本地内存中的值。随着传输进行而递减至 0 的地址（SADDR、DADDR）和字节数（NBYTES）可指示传输进度。所有其他值从 TCD 本地内存读取。</p><h4 id="6-4-5-3-检查通道抢占状态"><a href="#6-4-5-3-检查通道抢占状态" class="headerlink" title="6.4.5.3 检查通道抢占状态"></a>6.4.5.3 检查通道抢占状态</h4><p>仅当同时为组仲裁和通道仲裁选择固定仲裁模式时，才支持抢占功能。抢占场景发生在以下情况：已启用抢占的通道正在运行时，更高优先级请求变为有效。当 eDMA 引擎未运行在固定组 + 固定通道仲裁模式下时，当前运行通道与待处理请求的相对优先级无法确定。选择循环仲裁模式时，通道和 / 或组优先级被视为相等（即持续轮换）。</p><p>被抢占通道的 TCDn_CSR [ACTIVE] 位在整个抢占期间保持有效。被抢占通道会暂时挂起，直至抢占通道完成一次主循环迭代。如果全局 TCD 映射中同时设置了两个 TCDn_CSR [ACTIVE] 位，则表示高优先级通道正在主动抢占低优先级通道。</p><h3 id="6-4-6-通道链接"><a href="#6-4-6-通道链接" class="headerlink" title="6.4.6 通道链接"></a>6.4.6 通道链接</h3><p>通道链接（或链式传输）是一种机制，其中一个通道设置另一个通道（或自身）的 TCDn_CSR [START] 位，从而为该通道发起服务请求。启用后，eDMA 引擎会在主循环或微循环完成时自动执行此操作。</p><p>微循环通道链接在微循环完成（或主循环的一次迭代）时触发。TCDn_CITER [ELINK] 字段决定是否请求微循环链接。启用后，除最后一次迭代外，每次主循环迭代完成后都会进行通道链接。当主循环耗尽时，仅使用主循环通道链接字段来决定是否进行通道链接。例如，初始字段设置为：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TCDn_CITER[ELINK] = 1  </span><br><span class="line">TCDn_CITER[LINKCH] = 0xC  </span><br><span class="line">TCDn_CITER[CITER] = 0x4  </span><br><span class="line">TCDn_CSR[MAJOR_ELINK] = 1  </span><br><span class="line">TCDn_CSR[MAJOR_LINKCH] = 0x3  </span><br></pre></td></tr></tbody></table></figure><p>执行流程如下：</p><ol><li>微循环完成 → 设置 TCD2_CSR [START] 位。</li><li>微循环完成 → 设置 TCD2_CSR [START] 位。</li><li>微循环完成 → 设置 TCD2_CSR [START] 位。</li><li>微循环完成且主循环完成 → 设置 TCD3_CSR [START] 位。</li></ol><p>启用微循环链接（TCDn_CITER [ELINK] = 1）时，TCDn_CITER [CITER] 字段使用 9 位向量构成当前迭代计数。禁用微循环链接（TCDn_CITER [ELINK] = 0）时，TCDn_CITER [CITER] 字段使用 15 位向量构成当前迭代计数。与 TCDn_CITER [LINKCH] 字段相关的位会连接到 CITER 值，以扩展 CITER 的范围。</p><p>注意：TCDn_CITER [ELINK] 位和 TCDn_BITER [ELINK] 位必须相等，否则会报告配置错误。CITER 和 BITER 的向量宽度必须相等，以计算主循环中途完成的中断点。</p><p>下表总结了 DMA 通道如何在循环结束时链接到另一个 DMA 通道（即使用另一个通道的 TCD）。表 6-8 通道链接参数</p><table><thead><tr><th>期望的链接行为</th><th>TCD 控制字段名称</th><th>描述</th></tr></thead><tbody><tr><td>微循环结束时链接</td><td>CITER[ELINK]</td><td>启用微循环完成时的通道间链接（当前迭代）</td></tr><tr><td>CITER[LINKCH]</td><td>微循环结束时链接的目标通道号（当前迭代）</td><td></td></tr><tr><td>主循环结束时链接</td><td>CSR[MAJOR_ELINK]</td><td>启用主循环完成时的通道间链接</td></tr><tr><td>CSR[MAJOR_LINKCH]</td><td>主循环结束时链接的目标通道号</td><td></td></tr></tbody></table><h3 id="6-4-7-动态编程"><a href="#6-4-7-动态编程" class="headerlink" title="6.4.7 动态编程"></a>6.4.7 动态编程</h3><p>本节提供在通道执行期间更改编程模型的推荐方法。</p><h4 id="6-4-7-1-动态更改通道优先级"><a href="#6-4-7-1-动态更改通道优先级" class="headerlink" title="6.4.7.1 动态更改通道优先级"></a>6.4.7.1 动态更改通道优先级</h4><p>动态更改通道优先级级别的推荐方法有以下两种：</p><ol><li>切换到循环通道仲裁模式，更改通道优先级，然后切换回固定仲裁模式。</li><li>禁用所有通道，更改通道优先级，然后启用相应的通道。</li></ol><h4 id="6-4-7-2-动态通道链接"><a href="#6-4-7-2-动态通道链接" class="headerlink" title="6.4.7.2 动态通道链接"></a>6.4.7.2 动态通道链接</h4><p>动态通道链接是指在通道执行期间设置 TCDn_CSR [MAJORELINK] 位（参见 TCD 结构示意图）。该字段在通道执行结束时从 TCD 本地内存读取，因此允许在通道执行期间启用该功能。</p><p>由于可以在执行期间更改配置，因此需要一致性模型。例如，当尝试通过启用 TCDn_CSR [MAJORELINK] 位执行动态通道链接时，若同时 eDMA 引擎正在退出该通道，则编程模型中 TCDn_CSR [MAJORELINK] 位会被设置，但无法确定在通道退出前是否实际完成了链接。</p><p>执行动态通道链接请求时，推荐以下一致性模型：</p><ol><li>向 TCDn_CSR [MAJORELINK] 写入 1。</li><li>读回 TCDn_CSR [MAJORELINK]。</li><li>测试 TCDn_CSR [MAJORELINK] 请求状态：・若 TCDn_CSR [MAJORELINK] = 1，表示动态链接尝试成功。・若 TCDn_CSR [MAJORELINK] = 0，表示动态链接尝试失败（通道已在退出中）。</li></ol><p>对于此请求，一旦通道的 TCD.done 位设置（表示主循环完成），TCD 本地内存控制器会强制将任何写入通道 TCD.word7 的 TCDn_CSR [MAJORELINK] 位清零。</p><p>注意：必须在写入 TCDn_CSR [MAJORELINK] 之前清除 TCDn_CSR [DONE] 位。eDMA 引擎在通道开始执行后会自动清除 TCDn_CSR [DONE] 位。</p><h4 id="6-4-7-3-动态分散-聚集"><a href="#6-4-7-3-动态分散-聚集" class="headerlink" title="6.4.7.3 动态分散 / 聚集"></a>6.4.7.3 动态分散 / 聚集</h4><p>分散 / 聚集是指自动将新 TCD 加载到通道中的过程。它使 DMA 通道能够使用多个 TCD，从而支持将 DMA 数据分散到多个目标或从多个源聚集数据。启用分散 / 聚集功能且通道完成主循环后，会从系统内存中获取新 TCD 并加载到 eDMA 编程模型中的该通道描述符位置，替换当前描述符。</p><p>由于可以在执行期间更改配置，因此需要一致性模型。例如，当尝试通过启用 TCDn_CSR [ESG] 位执行动态分散 / 聚集操作时，若同时 eDMA 引擎正在退出该通道，则编程模型中 ESG 位会被设置，但无法确定在通道退出前是否实际处理了分散 / 聚集请求。</p><p>以下子节介绍两种一致性模型方法。方法 1 的优点是可以通过一次读取同时获取 MAJORLINKCH 字段和 ESG 位。对于动态通道链接和分散 / 聚集请求，一旦通道的 TCD [DONE] 位设置（表示主循环完成），TCD 本地内存控制器会强制将任何写入通道 TCD word7 的 TCD MAJOR [ELINK] 和 ESG 位清零。</p><p>注意：用户必须在写入 MAJORELINK 或 ESG 位之前清除 TCDn_CSR [DONE] 位。eDMA 引擎在通道开始执行后会自动清除 TCDn_CSR [DONE] 位。</p><h5 id="6-4-7-3-1-方法-1（不使用主循环通道链接的通道）"><a href="#6-4-7-3-1-方法-1（不使用主循环通道链接的通道）" class="headerlink" title="6.4.7.3.1 方法 1（不使用主循环通道链接的通道）"></a>6.4.7.3.1 方法 1（不使用主循环通道链接的通道）</h5><p>对于不使用主循环通道链接的通道，此一致性模型可用于动态分散 / 聚集请求。</p><p>当 TCDn_CSR [MAJORELINK] = 0 时，eDMA 不使用 TCDn_CSR [MAJORLINKCH] 字段。此时，MAJORLINKCH 可用于其他用途。此方法将 MAJORLINKCH 字段用作 TCD 标识（ID）。</p><ol><li>构建描述符时，为每个使用动态分散 / 聚集的通道对应的 TCD，在 TCDn_CSR [MAJORLINKCH] 中写入唯一的 TCD ID。</li><li>向 TCDn_CSR [DREQ] 写入 1。若动态分散 / 聚集尝试失败，设置 DREQ 位可防止通道未来通过硬件激活。这将避免通道使用基于分散 / 聚集地址（在下一步写入）计算的目标地址（DADDR）执行，而非使用 DLAST_SGA 最终偏移量值。</li><li>向 TCDn_DLASTSGA 寄存器写入分散 / 聚集地址。</li><li>向 TCDn_CSR [ESG] 写入 1。</li><li>读回 16 位 TCD 控制 / 状态字段。</li><li>测试 TCDn_CSR 寄存器中的 ESG 请求状态和 MAJORLINKCH 值：<ul><li>若 ESG = 1，表示动态链接尝试成功。</li><li>若 ESG = 0 且 MAJORLINKCH（ID）未改变，表示动态链接尝试失败（通道已在退出中）。</li><li>若 ESG = 0 且 MAJORLINKCH（ID）改变，表示动态链接尝试成功（新 TCD 的 ESG 值清除了 ESG 位）。</li></ul></li></ol><h5 id="6-4-7-3-2-方法-2（使用主循环通道链接的通道）"><a href="#6-4-7-3-2-方法-2（使用主循环通道链接的通道）" class="headerlink" title="6.4.7.3.2 方法 2（使用主循环通道链接的通道）"></a>6.4.7.3.2 方法 2（使用主循环通道链接的通道）</h5><p>对于使用主循环通道链接的通道，此一致性模型可用于动态分散 / 聚集请求。此方法将 TCD [DLAST_SGA] 字段用作 TCD 标识（ID）。</p><ol><li>向 TCDn_CSR [DREQ] 写入 1。若动态分散 / 聚集尝试失败，设置 TCDn_CSR [DREQ] 位可防止通道未来通过硬件激活。这将避免通道使用基于分散 / 聚集地址（在下一步写入）计算的目标地址（DADDR）执行，而非使用 DLAST_SGA 最终偏移量值。</li><li>向 TCDn_DLAST_SGA 寄存器写入分散 / 聚集地址。</li><li>向 TCDn_CSR [ESG] 写入 1。</li><li>读回 TCDn_CSR [ESG]。</li><li>测试 ESG 请求状态：<ul><li>若 ESG = 1，表示动态链接尝试成功。</li><li>若 ESG = 0，读取 32 位 TCDn_DLAST_SGA 字段：<ul><li>若 ESG = 0 且 TCDn_DLAST_SGA 未改变，表示动态链接尝试失败（通道已在退出中）。</li><li>若 ESG = 0 且 TCDn_DLAST_SGA 改变，表示动态链接尝试成功（新 TCD 的 ESG 值清除了 ESG 位）。</li></ul></li></ul></li></ol><h3 id="6-4-8-挂起-恢复具有活动硬件服务请求的-DMA-通道"><a href="#6-4-8-挂起-恢复具有活动硬件服务请求的-DMA-通道" class="headerlink" title="6.4.8 挂起 / 恢复具有活动硬件服务请求的 DMA 通道"></a>6.4.8 挂起 / 恢复具有活动硬件服务请求的 DMA 通道</h3><p>DMA 允许在无需 CPU 干预的情况下将数据从内存或外设寄存器传输到内存或外设寄存器的另一位置。配置并激活 DMA 和外设后，动态挂起外设服务请求的情况较为罕见。在此类场景中，禁用 DMA 硬件服务请求有特定限制。为确保一致性，必须遵循特定流程。本节提供当 DMA 由从模块（如串行外设接口（SPI）、ADC 或其他模块）触发时，如何一致地挂起和恢复 DMA 通道的指导。</p><h4 id="6-4-8-1-挂起活动-DMA-通道"><a href="#6-4-8-1-挂起活动-DMA-通道" class="headerlink" title="6.4.8.1 挂起活动 DMA 通道"></a>6.4.8.1 挂起活动 DMA 通道</h4><p>挂起活动 DMA 通道的步骤如下：</p><ol><li>首先在外设端停止 DMA 服务请求。通过读取外设的相应寄存器，确认请求已禁用。</li><li>检查 DMA 的硬件请求状态寄存器（DMA_HRSn），确保待挂起的 DMA 通道无服务请求。然后通过清除相应 DMA 通道的 ERQ 位，禁用硬件服务请求。</li></ol><h4 id="6-4-8-2-恢复-DMA-通道"><a href="#6-4-8-2-恢复-DMA-通道" class="headerlink" title="6.4.8.2 恢复 DMA 通道"></a>6.4.8.2 恢复 DMA 通道</h4><p>恢复 DMA 通道的步骤如下：</p><ol><li>通过设置相应的 ERQ 位，启用目标通道的 DMA 服务请求。</li><li>在外设端启用 DMA 服务请求。</li></ol><p>例如，假设 SPI 被配置为主设备，当 SPI_TXFIFO 出现空槽时通过 DMA 服务请求传输数据。DMA 会在请求时将下一条命令和数据传输到 TXFIFO。若需挂起 DMA/SPI 传输循环并执行恢复操作，步骤如下：</p><ol><li>向 SPI_RSER [TFFF_RE] 写入 0，禁用源端的 DMA 服务请求。确认 SPI_RSER [TFFF_RE] 为 0。</li><li>验证对应通道的 DMA_HRS [HRSn] 为 0，确保 SPI 未发起 DMA 服务请求。若不存在服务请求，通过清除通道的 ERQ 位禁用 DMA 通道；若存在服务请求，等待请求处理完成且 HRS 位读为 0。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RT1060-eDMA-Part3-初始化-应用&quot;&gt;&lt;a href=&quot;#RT1060-eDMA-Part3-初始化-应用&quot; class=&quot;headerlink&quot; title=&quot;RT1060 eDMA Part3 初始化 &amp;amp; 应用&quot;&gt;&lt;/a&gt;RT1060 eDMA Part3 初始化 &amp;amp; 应用&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;第 6 章 增强型直接内存访问（eDMA） 初始化 &amp;amp; 应用&lt;/p&gt;
&lt;p&gt;要点：&lt;/p&gt;
&lt;p&gt;？？？&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1060" scheme="https://dustofstars.github.io/categories/NXP/RT1060/"/>
    
    <category term="eDMA" scheme="https://dustofstars.github.io/categories/NXP/RT1060/eDMA/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="eDMA" scheme="https://dustofstars.github.io/tags/eDMA/"/>
    
  </entry>
  
  <entry>
    <title>RT1060 eDMA 详解 (2)</title>
    <link href="https://dustofstars.github.io/NXP/RT1060/eDMA/rt1060-edma-%E8%AF%A6%E8%A7%A3-2/"/>
    <id>https://dustofstars.github.io/NXP/RT1060/eDMA/rt1060-edma-%E8%AF%A6%E8%A7%A3-2/</id>
    <published>2025-05-24T07:10:02.000Z</published>
    <updated>2025-05-24T07:10:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RT1060-eDMA-Part2-功能描述"><a href="#RT1060-eDMA-Part2-功能描述" class="headerlink" title="RT1060 eDMA Part2 功能描述"></a>RT1060 eDMA Part2 功能描述</h1><blockquote><p>第 6 章 增强型直接内存访问（eDMA） Functional Description</p><p>要点：</p><p>？？？</p></blockquote><span id="more"></span><h2 id="6-3-功能描述"><a href="#6-3-功能描述" class="headerlink" title="6.3 功能描述"></a>6.3 功能描述</h2><p>eDMA 的操作在以下小节中描述。</p><h3 id="6-3-1-操作模式"><a href="#6-3-1-操作模式" class="headerlink" title="6.3.1 操作模式"></a>6.3.1 操作模式</h3><p>eDMA 工作在以下模式：<strong>表 6-4. 操作模式</strong></p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>Normal</td><td>在正常模式下，eDMA 将数据 从源传输到目标。源和目标可以是内存块或能够与 eDMA 协同工作的 I/O 块。<br>服务请求 启动传输 TCD 中指定的<strong>特定字节数</strong>（<code>NBYTES</code>）。 <br>- 小循环（minor loop）是为服务请求传输 <code>NBYTES</code> 数据的读写操作序列。<br>- 每个服务请求 **<u>执行一次主循环迭代</u>**（<code>major loop iteration</code>），传输 NBYTES 数据。</td></tr><tr><td>Debug</td><td>DMA 操作可通过寄存器 Control（CR）在调试模式下配置：<br>- 若 <code>CR[EDBG]=0</code>，芯片处于调试模式时 eDMA 继续正常运行。<br>- 若 <code>CR [EDBG]=1</code>，芯片进入调试模式时 eDMA 停止传输数据。<span style="color: blue; font-weight: bold; ">若进入调试模式时某通道处于活动状态，eDMA 会继续操作直至该通道退出。</span></td></tr><tr><td><strong>Wait</strong></td><td>进入等待模式前，eDMA 会尝试完成任何正在进行的传输。<br>传输完成后，芯片进入等待模式。</td></tr></tbody></table><h3 id="6-3-2-eDMA-基本数据流"><a href="#6-3-2-eDMA-基本数据流" class="headerlink" title="6.3.2 eDMA 基本数据流"></a>6.3.2 eDMA 基本数据流</h3><p>数据传输的基本流程可分为三个阶段。如下图所示，第一阶段涉及通道激活：</p><style>.nkdwbekoshnd{zoom:100%;}</style><img src="/NXP/RT1060/eDMA/rt1060-edma-%E8%AF%A6%E8%A7%A3-2/image-20250524151836491.png" class="nkdwbekoshnd" alt="image-20250524151836491"><p><strong>图 6-2. eDMA operation, part 1</strong></p><p>此示例使用 eDMA 外设请求信号的断言来为通道 n 请求服务。通过软件和 <code>TCDn_CSR[START]</code> 位激活通道的基本流程与外设请求相同。eDMA 请求输入信号在内部注册，然后路由通过 eDMA 引擎：</p><ul><li>首先经过<strong>控制模块</strong>，然后进入<strong>编程模型和通道仲裁模块</strong>。</li><li>在下一个周期，通道仲裁执行，使用固定优先级或循环算法。</li><li>仲裁完成后，<strong>激活的通道号通过地址路径发送</strong>，并转换为 访问 <code>TCDn</code> 本地内存所需的地址。</li><li>接下来，访问 TCD 内存，<span style="color: red; font-weight: bold; ">从本地内存读取所需的描述符并加载到 eDMA 引擎的内部寄存器文件中。</span><strong><u>TCD 内存宽度为 64 位，以最小化获取激活通道描述符并将其加载到内部寄存器文件所需的时间。</u></strong></li></ul><p>下图说明了基本数据流的第二部分：</p><style>.sswgnkfwcgih{zoom:100%;}</style><img src="/NXP/RT1060/eDMA/rt1060-edma-%E8%AF%A6%E8%A7%A3-2/image-20250524152522740.png" class="sswgnkfwcgih" alt="image-20250524152522740"><p><strong>图 6-3. eDMA operation, part 2</strong></p><p>与数据传输相关的模块（地址路径、数据路径和控制模块)按顺序执行所需的 源读取 和 目标写入 以<strong>执行数据移动</strong>。启动源读取，<span style="color: red;">获取的数据临时存储在数据路径模块中，直到在目标写入期间被选通到内部总线上。这种源读取 / 目标写入处理持续进行，直到 <code>minor byte count</code> 完成传输。</span></p><p>小字节计数传输完成后，执行基本数据流的最后阶段。在此阶段，<span style="color: red; font-weight: bold; ">地址路径逻辑对相应 TCD 中的某些字段进行所需的更新，例如 SADDR、DADDR、CITER。</span>如果主迭代计数用尽，则执行附加操作。这些操作包括最终地址调整和将 <code>BITER</code> 字段重新加载到 <code>CITER</code> 中。此时还会触发可选的中断请求，并可能使用描述符中包含的<code>分散 / 聚集地址指针</code>（如果启用了<code>scatter/gather</code>）从内存中获取新的 TCD。TCD 内存的更新和中断请求的触发如下图所示：</p><style>.duphnycmxmgt{zoom:100%;}</style><img src="/NXP/RT1060/eDMA/rt1060-edma-%E8%AF%A6%E8%A7%A3-2/image-20250524153040151.png" class="duphnycmxmgt" alt="image-20250524153040151"><p><strong>图 6-4. eDMA operation, part 3</strong></p><h3 id="6-3-3-故障报告和处理"><a href="#6-3-3-故障报告和处理" class="headerlink" title="6.3.3 故障报告和处理"></a>6.3.3 故障报告和处理</h3><p>通道错误在错误状态寄存器（<code>DMAx_ES</code>）中报告，可能由以下原因引起：</p><ul><li>配置错误，即传输控制描述符中的非法设置或固定仲裁模式下的非法优先级寄存器设置，或</li><li>总线主设备读或写周期的错误终止</li></ul><p><span style="color: red; font-weight: bold; ">当起始源地址或目标地址、源或目标偏移量、小循环字节计数或传输大小表示不一致状态时，报告配置错误。</span>以下详细说明了每种可能的原因：</p><ul><li>地址和偏移量必须以 0 模传输大小边界对齐。</li><li><span style="color: red;">小循环字节计数必须是源和目标传输大小的倍数。</span></li><li>所有源读取和目标写入必须分别配置为已编程传输大小的自然边界。</li><li>在固定仲裁模式下，任何两个通道优先级相等都会导致配置错误。启用固定仲裁模式后，所有通道优先级必须是唯一的。</li></ul><blockquote><p><strong>注</strong>：当两个通道具有相同优先级时，存在通道优先级错误，并在错误状态寄存器中报告。但是，错误状态寄存器中不报告通道号。当组内所有通道优先级不唯一时，仲裁选择的通道号不确定。为帮助调试通道优先级错误（<code>CPE</code>），请在 DMA 的控制寄存器中设置错误暂停位。</p><p>如果组内所有通道优先级不唯一，DMA 在记录 <code>CPE</code> 错误后暂停。DMA 保持暂停状态，不处理任何通道服务请求。将所有通道优先级设置为唯一编号后，可通过清除 HALT 位重新启用 DMA。</p></blockquote><ul><li>如果在通道完成时启用了分散 / 聚集操作，当分散 / 聚集地址（<code>DLAST_SGA</code>）未按 32 字节边界对齐时，报告配置错误。</li><li>如果在通道完成时启用了小循环通道链接，当尝试链接时 <code>TCDn_CITER[ELINK]</code> 位不等于 <code>TCDn_BITER[ELINK]</code> 位，报告配置错误。</li></ul><p>如果已启用，除分散 / 聚集和小循环链接错误外，所有配置错误条件都会在通道激活时报告并触发错误中断请求。分散 / 聚集配置错误在正确启用时，在主循环完成且分散 / 聚集操作开始时报告。小循环通道链接配置错误在小循环完成且链接操作被处理时报告。</p><p>如果系统总线读或写因错误而终止，数据传输将停止，并设置相应的总线错误标志。在这种情况下，eDMA 引擎会用故障点处的当前源地址、目标地址和当前迭代计数更新通道的传输控制描述符状态。发生系统总线错误时，通道在下一次传输后终止。由于流水线效应，eDMA 收到总线错误时，下一次传输已在进行中。如果在开始写入序列之前的最后一次读取时发生总线错误，将使用总线错误期间捕获的数据执行写入。如果在切换到下一个读取序列之前的最后一次写入时发生总线错误，在通道因目标总线错误终止之前，将执行读取序列。</p><p>可以通过软件使用 <code>CR[CX]</code> 位取消传输。当识别到取消传输请求时，DMA 引擎停止处理该通道。允许当前读写序列完成。如果取消发生在主循环或小循环的最后一个读写序列，取消请求将被丢弃，通道正常退出。</p><p>错误取消传输与取消传输相同，不同之处在于错误状态寄存器（<code>DMAx_ES</code>）会更新已取消的通道号并设置 <code>ECX</code>。已取消通道的 TCD 包含最后一次传输的源地址和目标地址，保存在 TCD 中。如果需要重新启动通道，必须重新初始化 TCD，因为上述字段不再代表原始参数。当通过错误取消传输机制取消传输时，通道号会加载到 <code>DMA_ES[ERRCHN]</code> 中，并设置 ECX 和 VLD。此外，如果已启用，可能会生成错误中断。</p><blockquote><p><strong>注</strong>：取消传输请求使您能够在不再需要完整数据传输时停止大型数据传输。取消传输位不会中止通道，它只是停止数据传输，然后通过正常关闭序列退出通道。应用程序软件必须管理取消的上下文。如果需要（或不需要）中断，则应在取消请求之前启用（或禁用）中断。由于未完成完整传输，应用程序软件必须清理传输控制描述符。</p></blockquote><p>任何错误的发生都会导致 eDMA 引擎立即停止活动通道的正常处理（进入错误处理状态，而到系统总线的事务仍有流水线效应），并断言 eDMA 错误寄存器中的相应通道位。同时，错误条件的详细信息会加载到错误状态寄存器（<code>DMAx_ES</code>）中。检测到错误时，主循环完成指示符、设置传输控制描述符 DONE 标志以及可能的中断请求断言不受影响。更新错误状态后，eDMA 引擎通过处理下一个适当的通道继续运行。发生错误条件的通道不会自动禁用。如果某个通道因错误而终止，并且在错误修复之前发出另一个服务请求，该通道将执行并以相同的错误条件终止。</p><h3 id="6-3-4-通道抢占"><a href="#6-3-4-通道抢占" class="headerlink" title="6.3.4 通道抢占"></a>6.3.4 通道抢占</h3><p>通过设置 <code>DCHPRIn[ECP]</code> 位，可在每个通道的基础上启用通道抢占功能。<span style="color: red; font-weight: bold; ">通道抢占允许正在执行的数据传输暂时挂起，以便启动更高优先级的通道。</span>抢占通道完成其微循环数据传输后，被抢占的通道将恢复执行。恢复后的通道完成一次读 / 写序列后，可再次被抢占。如果有任何更高优先级的通道请求服务，恢复后的通道将被挂起，优先处理高优先级通道。<span style="color: red; font-weight: bold; ">不支持嵌套抢占</span>，即试图抢占一个正在执行抢占的通道。抢占通道一旦开始执行，便不能被抢占。<span style="color: red; font-weight: bold; ">抢占功能仅在选择固定仲裁时可用。</span></p><p>通过设置 <code>DCHPRIn[DPA]</code> 位，<span style="color: red; font-weight: bold; ">可以禁用某个通道的抢占能力。</span>当一个通道的抢占能力被禁用时，无论低优先级通道的 <code>ECP</code> 设置如何，该通道都不能挂起低优先级通道的数据传输。<span style="color: red; font-weight: bold; ">这使得可以定义一组低优先级、大数据传输的通道。这些低优先级通道可配置为不相互抢占，从而避免低优先级通道占用通常为真正高优先级通道保留的抢占槽。</span></p><h3 id="6-3-5-时钟"><a href="#6-3-5-时钟" class="headerlink" title="6.3.5 时钟"></a>6.3.5 时钟</h3><p>下表描述了 eDMA 的时钟源。有关时钟设置、配置和门控信息，请参见时钟控制器模块（CCM）。表 6-5 eDMA 时钟</p><table><thead><tr><th>时钟名称</th><th>描述</th></tr></thead><tbody><tr><td><code>edma_hclk</code></td><td>模块时钟</td></tr><tr><td><code>ipg_clk</code></td><td>外设时钟</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RT1060-eDMA-Part2-功能描述&quot;&gt;&lt;a href=&quot;#RT1060-eDMA-Part2-功能描述&quot; class=&quot;headerlink&quot; title=&quot;RT1060 eDMA Part2 功能描述&quot;&gt;&lt;/a&gt;RT1060 eDMA Part2 功能描述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;第 6 章 增强型直接内存访问（eDMA） Functional Description&lt;/p&gt;
&lt;p&gt;要点：&lt;/p&gt;
&lt;p&gt;？？？&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1060" scheme="https://dustofstars.github.io/categories/NXP/RT1060/"/>
    
    <category term="eDMA" scheme="https://dustofstars.github.io/categories/NXP/RT1060/eDMA/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="eDMA" scheme="https://dustofstars.github.io/tags/eDMA/"/>
    
  </entry>
  
  <entry>
    <title>RT1060 eDMA 详解 (1)</title>
    <link href="https://dustofstars.github.io/NXP/RT1060/eDMA/rt1060-edma-%E8%AF%A6%E8%A7%A3-1/"/>
    <id>https://dustofstars.github.io/NXP/RT1060/eDMA/rt1060-edma-%E8%AF%A6%E8%A7%A3-1/</id>
    <published>2025-05-24T06:22:01.000Z</published>
    <updated>2025-05-24T06:22:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RT1060-eDMA-Part1-Overview"><a href="#RT1060-eDMA-Part1-Overview" class="headerlink" title="RT1060 eDMA Part1 Overview"></a>RT1060 eDMA Part1 Overview</h1><blockquote><p>第 6 章 增强型直接内存访问（eDMA） Overview</p><p>要点：</p><ol><li>32通道；</li><li>每个TCD 32字节；</li></ol><p><span style="color: red; font-weight: bold; ">TCD 支持两层深度的嵌套传输操作:</span></p><ul><li>每个通道在本地内存中存储 <span style="color: red; font-weight: bold; ">32 字节的 TCD</span></li><li>由小字节传输计数（<code>minor dyte transfer count</code>）定义的<strong>内部数据传输循环</strong></li><li>由主迭代计数（<code>major iteration count</code>）定义的<strong>外部数据传输循环</strong></li></ul></blockquote><span id="more"></span><h2 id="6-1-芯片特定的-eDMA-信息"><a href="#6-1-芯片特定的-eDMA-信息" class="headerlink" title="6.1 芯片特定的 eDMA 信息"></a>6.1 芯片特定的 eDMA 信息</h2><p>表 6-1. 相关信息的参考链接</p><table><thead><tr><th>主题</th><th>相关模块</th><th>参考资料</th></tr></thead><tbody><tr><td>系统内存映射</td><td>-</td><td>系统内存映射</td></tr><tr><td>时钟</td><td><code>CCM</code></td><td>时钟管理<br>时钟控制模块（CCM）</td></tr><tr><td>电源管理</td><td><code>PMU</code> 电源管理单元</td><td>电源管理<br>电源管理单元</td></tr><tr><td>信号多路复用</td><td><code>IOMUX</code></td><td>外部信号和引脚多路复用<br>IOMUX</td></tr><tr><td>中断、DMA 事件和 XBAR 分配</td><td>-</td><td>中断、DMA 事件和 XBAR 分配</td></tr></tbody></table><h2 id="6-2-概述"><a href="#6-2-概述" class="headerlink" title="6.2 概述"></a>6.2 概述</h2><p>增强型直接内存访问（eDMA）控制器是第二代模块，能够在主机处理器干预最少的情况下执行复杂的数据传输。其硬件微体系结构包括：</p><ul><li>一个 DMA 引擎，用于执行：<ul><li>源地址和目标地址计算</li><li>数据移动操作</li></ul></li><li>本地内存，<span style="color: blue; font-weight: bold;">包含 32 个通道中每个通道的传输控制描述符（TCD）</span></li></ul><h3 id="6-2-1-框图"><a href="#6-2-1-框图" class="headerlink" title="6.2.1 框图"></a>6.2.1 框图</h3><p>下图展示了 eDMA 系统的组件，包括 eDMA 模块（“引擎”）。</p><style>.njztjrbsqwmo{zoom: 80%;}</style><img src="/NXP/RT1060/eDMA/rt1060-edma-%E8%AF%A6%E8%A7%A3-1/image-20250524113333289.png" class="njztjrbsqwmo" alt="image-20250524113333289"><blockquote><p>图 6-1 展示了 eDMA 系统的核心组件及其交互关系，主要包括以下部分：</p><ol><li>eDMA 引擎<ul><li>包含<strong>地址路径</strong>（Address path）、<strong>数据路径</strong>（Data path）、<strong>编程模型 / 通道仲裁</strong>（Program model/channel arbitration）和<strong>控制模块</strong>（Control），是数据传输的执行核心。</li></ul></li><li><span style="color: blue; font-weight: bold;">传输控制描述符（TCD）</span><ul><li>存储于本地内存中，<span style="color: red; font-weight: bold;">每个通道对应一个 TCD，包含源地址、目标地址、传输大小等关键参数。</span></li></ul></li><li>内部外设总线（<code>Internal peripheral bus</code>）<ul><li>连接 eDMA 引擎与芯片内部其他模块（如交叉开关），用于传输地址、数据和控制信号。</li></ul></li><li>交叉开关（<code>Crossbar switch</code>）<ul><li>作为总线主控枢纽，负责在 eDMA 引擎与系统内存、外设之间建立数据传输路径。</li></ul></li><li>输入 / 输出信号<ul><li><strong>请求信号（eDMA peripheral request）</strong>：*<u>外部设备（如外设）触发 eDMA 传输的请求信号。</u>*</li><li><strong>完成信号（eDMA done）</strong>：eDMA 引擎向外部反馈传输完成的信号。</li><li><strong>读写数据总线（Read/Write data）</strong>：用于传输实际数据。</li><li><strong>地址总线（Address）</strong>：传输源地址和目标地址。</li></ul></li></ol><h4 id="二、数据传输全流程解析"><a href="#二、数据传输全流程解析" class="headerlink" title="二、数据传输全流程解析"></a>二、数据传输全流程解析</h4><p>eDMA 的工作流程可分为<strong>初始化配置</strong>、<strong>传输执行</strong>和<strong>完成处理</strong>三个阶段，结合框图信号流向说明如下：</p><h5 id="阶段-1：初始化配置"><a href="#阶段-1：初始化配置" class="headerlink" title="阶段 1：初始化配置"></a><strong>阶段 1：初始化配置</strong></h5><ol><li><strong>软件配置 TCD</strong></li></ol><ul><li><p>通过内部外设总线，主机处理器向 eDMA 引擎的编程模型寄存器写入每个通道的 TCD 参数，包括：</p><ul><li>源地址（<code>SADDR</code>）、目标地址（<code>DADDR</code>）</li><li>传输大小（<code>SSIZE</code>/<code>DSIZE</code>，如 8/16/32 位）</li><li>小循环字节计数（<code>NBYTES</code>，<span style="color: red; font-weight: bold; ">单次循环传输量</span>）</li><li>主迭代计数（<code>CITER</code>，循环次数）</li><li>优先级、中断使能等控制位。</li></ul></li><li><p>TCD 存储于<strong>本地内存阵列</strong>中，供 eDMA 引擎调用。</p></li></ul><ol start="2"><li><strong>通道激活触发</strong></li></ol><ul><li>激活方式可选：<ul><li><strong>软件触发</strong>：主机通过寄存器直接启动通道。</li><li><strong>硬件触发</strong>：外设通过<strong>eDMA peripheral request</strong>信号触发（如 ADC 完成转换后请求 DMA 传输）。</li><li><strong>通道链触发</strong>：前一通道传输完成后自动启动下一通道（连续传输场景）。</li></ul></li></ul><h5 id="阶段-2：传输执行（核心流程）"><a href="#阶段-2：传输执行（核心流程）" class="headerlink" title="阶段 2：传输执行（核心流程）"></a><strong>阶段 2：传输执行（核心流程）</strong></h5><ol><li><strong>地址路径处理（第一阶段流水线）</strong><ul><li>eDMA 引擎从本地内存读取目标通道的 <code>TCD</code>，加载到<strong>地址路径寄存器</strong>。</li></ul></li></ol><ul><li><strong>地址计算</strong>：根据 TCD 中的参数生成源地址和目标地址，支持递增、递减、固定地址等模式。</li><li><strong>优先级仲裁</strong>：若多个通道同时请求，通过<strong>固定优先级</strong>或<strong>循环仲裁逻辑</strong>（Program model/channel arbitration 模块）选择高优先级通道执行。</li><li><strong>抢占机制</strong>：若高优先级通道请求介入，当前通道在完成一个读写序列后暂停，TCD 状态保存到<strong>通道 y 寄存器</strong>，高优先级通道优先执行。</li></ul><ol start="2"><li><strong>数据路径处理（第二阶段流水线）</strong><ul><li><strong>读取数据</strong>：通过交叉开关从源地址（如内存或外设）经<strong>内部读取数据总线</strong>获取数据，存入<strong>内部数据缓冲区</strong>。</li><li><strong>数据对齐与转换</strong>：若源和目标数据大小不等，通过多路复用逻辑（Data path 模块）组合数据（如两次 16 位读取合并为一次 32 位写入）。</li><li><strong>写入数据</strong>：通过交叉开关将缓冲区数据经<strong>内部写入数据总线</strong>写入目标地址，完成一次小循环传输。</li><li><strong>循环控制</strong>：小循环（<code>NBYTES</code>）完成后，地址路径自动更新 SADDR/DADDR 和剩余字节数，直至主迭代计数（<code>CITER</code>）完成。</li></ul></li></ol><h5 id="阶段-3：完成处理与反馈"><a href="#阶段-3：完成处理与反馈" class="headerlink" title="阶段 3：完成处理与反馈"></a><strong>阶段 3：完成处理与反馈</strong></h5><ol><li><strong>传输结束判断</strong></li></ol><ul><li><span style="color: red; font-weight: bold; ">当主迭代计数完成</span>或发生错误时，eDMA 引擎执行以下操作：<ul><li>更新 TCD 中的最终地址和状态（如写入本地内存）。</li><li><span style="color: red; font-weight: bold; ">若启用<strong>分散 / 聚集模式</strong>，加载下一个 TCD（需提前配置内存中的 TCD 链表）。</span></li></ul></li></ul><ol start="2"><li><p><strong>中断通知</strong></p><ul><li><p>通过 编程模型 / 通道仲裁模块 向中断控制器发送信号：</p></li><li><p><strong>正常完成中断</strong>：每个通道独立生成中断（如主迭代结束）。</p></li><li><p><strong>错误中断</strong>：若传输过程中发生错误（如总线超时），所有通道的错误状态逻辑或后触发全局错误中断。</p></li></ul></li><li><p><strong>信号反馈</strong></p></li></ol><ul><li>通过<strong>eDMA done 信号</strong>向外部设备（如触发传输的外设）反馈传输完成，设备可据此启动后续操作。</li></ul><h4 id="四、典型应用场景"><a href="#四、典型应用场景" class="headerlink" title="四、典型应用场景"></a>四、典型应用场景</h4><ul><li><strong>外设数据搬运</strong>：如 ADC 采样数据从外设寄存器批量传输至内存，无需 CPU 干预。</li><li><strong>内存到内存拷贝</strong>：固件升级时的代码搬移，或图像处理中的缓冲区数据复制。</li><li><strong>分散 / 聚集传输</strong>：<span style="color: red; font-weight: bold; ">从多个非连续地址读取数据并合并写入（如网络数据包组装）。</span></li></ul><p>通过上述流程，eDMA 实现了高效、低功耗的数据传输，显著减轻了 CPU 负载，尤其适用于需要高吞吐量和实时响应的嵌入式系统。</p></blockquote><h3 id="6-2-2-模块组成"><a href="#6-2-2-模块组成" class="headerlink" title="6.2.2 模块组成"></a>6.2.2 模块组成</h3><p>eDMA 模块包含两个主要模块：<code>eDMA 引擎</code> 和 <code>传输控制描述符本地内存</code>。</p><p>表 6-2. eDMA 引擎子模块</p><table><thead><tr><th>子模块</th><th>功能</th></tr></thead><tbody><tr><td>Address Path</td><td>地址路径模块：<br>- 提供两个通道（TCD）的寄存器版本<br>- 通道 x（正常启动）和通道 y（抢占启动）<br>- 管理所有主总线地址计算</td></tr><tr><td></td><td>所有通道提供相同的功能。<span style="color: red; font-weight: bold; ">这种结构允许在活动通道的读写序列完成后，若 eDMA 引擎断言更高优先级的通道激活，则抢占与该活动通道相关的数据传输。</span><br>eDMA 激活通道后，它会运行直到小循环完成，除非被更高优先级的通道抢占。这提供了一种机制（由 <code>DCHPRIn[ECP]</code> 启用），其中 eDMA 引擎可以抢占大型数据移动操作，以最小化另一个通道停滞的时间。<br><br>当 eDMA 引擎选择一个通道执行时，它会从本地内存读取该通道 TCD 的内容，并将其加载到以下其中一个中：<br>1. 地址路径 通道 x 寄存器（正常启动）<br>2. 地址路径 通道 y 寄存器（抢占启动） <br><br>小循环执行完成后，地址路径硬件会将 <code>TCDn_{SADDR, DADDR, CITER}</code> 的新值写回本地内存。<span style="color: red; font-weight: bold; ">如果主迭代计数完成，eDMA 引擎会执行额外的处理</span>，包括：<br>1. 最终地址指针更新<br>2. 重新加载 <code>TCDn_CITER</code> 字段 <br>3. 作为分散 / 聚集操作的一部分，可能从内存中获取下一个 <code>TCDn</code></td></tr><tr><td>Data Path</td><td>数据路径模块 实现总线主设备的读 / 写数据路径。<br>它包括一个<code>数据缓冲区</code>和必要的<code>多路复用逻辑</code>，<strong>以支持任何所需的数据对齐</strong>。<br>内部读取数据总线是主要输入，内部写入数据总线是主要输出。地址和数据路径模块直接支持两级流水线内部总线。<br><span style="color: red; font-weight: bold; ">地址路径模块代表总线流水线的第一阶段（地址阶段）。数据路径模块实现流水线的第二阶段（数据阶段）</span></td></tr><tr><td>编程模型 / 通道仲裁</td><td>该模块实现： <br>- eDMA 编程模型的第一部分 <br>- 通道仲裁逻辑 <br><br><span style="color: red; font-weight: bold; ">编程模型寄存器连接到芯片的内部外设总线。</span>eDMA 外设请求输入和中断请求输出也连接到该模块（通过控制逻辑）</td></tr><tr><td>Control</td><td>控制模块为 eDMA 引擎提供所有控制功能。<br>1. <span style="color: red; font-weight: bold; ">对于源大小（<code>SSIZE</code>）和目标大小（<code>DSIZE</code>）相等的数据传输，eDMA 引擎会执行一系列 源读取 / 目标写入 操作，直到传输了小循环字节计数（<code>NBYTES</code>）中指定的字节数。</span><br><br>2. <span style="color: red; font-weight: bold; ">对于源和目标大小不相等的 TCD，eDMA 引擎会为每个较大尺寸的引用执行多次较小尺寸数据的访问。</span>例如，如果源大小（<code>SSIZE</code>）引用 16 位数据，而目标大小（<code>DSIZE</code>）是 32 位数据，eDMA 会执行两次读取，然后一次 32 位写入</td></tr></tbody></table><p>下面 表 6-3 解释了 TCD 本地内存的分区。<strong>表 6-3. 传输控制描述符内存</strong></p><table><thead><tr><th>子模块</th><th>描述</th></tr></thead><tbody><tr><td>Memory Controller</td><td>内存控制器逻辑实现所需的双端口控制器，管理来自 eDMA 引擎的访问以及来自内部外设总线的引用。<br>如果发生同时访问，eDMA 引擎获得优先级，外设事务暂停</td></tr><tr><td>Memory Array</td><td>内存阵列为每个通道的传输配置文件提供 TCD 存储</td></tr></tbody></table><h3 id="6-2-3-Features"><a href="#6-2-3-Features" class="headerlink" title="6.2.3 Features"></a>6.2.3 Features</h3><p>eDMA 模块是一个高度可编程的数据传输引擎，经过优化，可最大限度减少对主机处理器的干预。<span style="color: red; font-weight: bold; ">它适用于静态已知要传输的数据大小，且不在传输的数据本身中定义大小的应用。</span>eDMA 模块具有以下特性：</p><ul><li>通过双地址传输进行所有数据移动：<u><strong>1. 从源读取，2. 写入目标</strong></u><ul><li>可编程的<strong>源地址</strong>和<strong>目标地址</strong>以及<strong>传输大小</strong></li><li>支持增强寻址模式</li></ul></li><li><span style="color: red; font-weight: bold; "><u>32 通道实现</u></span>，可在主机处理器干预最少的情况下执行复杂的数据传输<ul><li>内部数据缓冲区，用作临时存储以**<u>支持 16 字节和 32 字节传输</u>**</li><li>连接到交叉开关（AXBS），用于数据移动的总线主控</li></ul></li><li><span style="color: red; font-weight: bold; ">TCD 支持两层深度的嵌套传输操作</span><ul><li>每个通道在本地内存中存储 <span style="color: red; font-weight: bold; ">32 字节的 TCD</span></li><li>由小字节传输计数（<code>minor dyte transfer count</code>）定义的<strong>内部数据传输循环</strong></li><li>由主迭代计数（<code>major iteration count</code>）定义的<strong>外部数据传输循环</strong></li></ul></li><li>通道激活通过以下三种方法之一：<ul><li>显式软件启动</li><li><span style="color: red; font-weight: bold; ">通过通道到通道链接机制启动，用于连续传输</span></li><li><strong><u>每个通道一个的外设硬件请求</u></strong></li></ul></li><li>固定优先级和循环通道仲裁</li><li>通过可编程中断请求进行通道完成通知<ul><li><span style="color: red; font-weight: bold; ">每个通道一个中断。当主迭代计数完成时，eDMA 引擎可以生成一个中断</span></li><li>每个通道可编程错误终止，并逻辑求和以形成一个错误中断到中断控制器</li></ul></li><li>支持可编程的 <strong><u>分散 / 聚集 DMA 处理</u></strong></li><li>支持复杂数据结构</li></ul><blockquote><p> <strong>注</strong>：在本模块的讨论中，n 为通道号。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RT1060-eDMA-Part1-Overview&quot;&gt;&lt;a href=&quot;#RT1060-eDMA-Part1-Overview&quot; class=&quot;headerlink&quot; title=&quot;RT1060 eDMA Part1 Overview&quot;&gt;&lt;/a&gt;RT1060 eDMA Part1 Overview&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;第 6 章 增强型直接内存访问（eDMA） Overview&lt;/p&gt;
&lt;p&gt;要点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;32通道；&lt;/li&gt;
&lt;li&gt;每个TCD 32字节；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span style=&quot;color: red; font-weight: bold; &quot;&gt;TCD 支持两层深度的嵌套传输操作:&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个通道在本地内存中存储 &lt;span style=&quot;color: red; font-weight: bold; &quot;&gt;32 字节的 TCD&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;由小字节传输计数（&lt;code&gt;minor dyte transfer count&lt;/code&gt;）定义的&lt;strong&gt;内部数据传输循环&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;由主迭代计数（&lt;code&gt;major iteration count&lt;/code&gt;）定义的&lt;strong&gt;外部数据传输循环&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1060" scheme="https://dustofstars.github.io/categories/NXP/RT1060/"/>
    
    <category term="eDMA" scheme="https://dustofstars.github.io/categories/NXP/RT1060/eDMA/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="eDMA" scheme="https://dustofstars.github.io/tags/eDMA/"/>
    
  </entry>
  
  <entry>
    <title>RT600 BootROM RM解析 (7)</title>
    <link href="https://dustofstars.github.io/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-7/"/>
    <id>https://dustofstars.github.io/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-7/</id>
    <published>2025-05-20T08:55:29.000Z</published>
    <updated>2025-05-20T08:55:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RT600-RM-CH41：RT6xx-非安全BootROM-7"><a href="#RT600-RM-CH41：RT6xx-非安全BootROM-7" class="headerlink" title="RT600 RM CH41：RT6xx 非安全BootROM (7)"></a>RT600 RM CH41：RT6xx 非安全BootROM (7)</h1><blockquote><p>如何通过runBootloader调用ROM API！</p></blockquote><span id="more"></span><h2 id="41-11-调用-ROM-的-API"><a href="#41-11-调用-ROM-的-API" class="headerlink" title="41.11 调用 ROM 的 API"></a>41.11 调用 ROM 的 API</h2><p>ROM 提供了一个 <code>runBootloader</code> API，用户应用程序可通过该 API 使用指定的boot参数调用 ROM。<code>runBootloader</code> API 的 ROM 地址如图 231 所示。</p><style>.levrorviyzdu{zoom:100%;}</style><img src="/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-7/image-20250520165817569.png" class="levrorviyzdu"><p><code>runBootloader</code> 的原型如下。用户应用程序可传递一个包含引导模式选项的参数：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">runBootloader</span> <span class="params">(<span class="type">void</span> *arg)</span>  </span><br></pre></td></tr></tbody></table></figure><p>用户应用程序boot模式选项的定义如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">user_app_boot_invoke_option</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>{</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        {</span></span><br><span class="line">            <span class="type">uint32_t</span> reserved : <span class="number">8</span>;  </span><br><span class="line"><span class="type">uint32_t</span> boot_image_index : <span class="number">4</span>;  </span><br><span class="line"><span class="type">uint32_t</span> instance : <span class="number">4</span>;  </span><br><span class="line"><span class="type">uint32_t</span> boot_interface : <span class="number">4</span>;  </span><br><span class="line"><span class="type">uint32_t</span> mode : <span class="number">4</span>;  </span><br><span class="line"><span class="type">uint32_t</span> tag : <span class="number">8</span>; </span><br><span class="line">        }B;</span><br><span class="line"><span class="type">uint32_t</span> U;  </span><br><span class="line">}option;  </span><br><span class="line">} <span class="type">user_app_boot_invoke_option_t</span>;  </span><br></pre></td></tr></tbody></table></figure><p><code>user_app_boot_invoke_option_t</code> 的描述如下表 1105 所示。</p><p><strong>表 1105. 用户应用程序引导选项</strong></p><table><thead><tr><th>偏移字段</th><th>[31:24] TAG</th><th>描述</th></tr></thead><tbody><tr><td>[31:24]</td><td>TAG</td><td>必须为 ‘0xEB’</td></tr><tr><td>[23:20]</td><td>引导模式</td><td>0：主引导模式 <br>1：ISP 引导</td></tr><tr><td>[19:16]</td><td>引导接口</td><td>0：USART <br>1：I2C <br>2：SPI <br>3：USB HID <br>4：FlexSPI <br>7：SD <br>8：MMC</td></tr><tr><td>[15:12]</td><td>引导实例</td><td>0 或 1；仅当引导接口为 SD 或 MMC 时使用该实例，其他接口忽略</td></tr><tr><td>[11:08]</td><td>FlexSPI 引导镜像索引</td><td>适用于 FlexSPI NOR 闪存的 FlexSPI 引导镜像索引</td></tr><tr><td>[07:00]</td><td>保留</td><td>保留</td></tr></tbody></table><p>用户应用程序可使用的详细引导选项组合如下表 1106 所示。</p><p><strong>表 1106. 用户应用程序可使用的详细引导选项</strong></p><table><thead><tr><th>Tag [31:24]</th><th>引导模式 [23:20]</th><th>接口 [19:16]</th><th>实例 [15:12]</th><th>FlexSPI 引导镜像索引</th><th>保留 [07:00]</th><th>组合</th><th>引导操作</th></tr></thead><tbody><tr><td>0xEB</td><td>0</td><td>0</td><td>X</td><td>X</td><td>X</td><td>0xEB00XXXX</td><td>串行主引导：USART</td></tr><tr><td>0xEB</td><td>1</td><td>1</td><td>X</td><td>X</td><td>X</td><td>0xEB01XXXX</td><td>串行主引导：I2C</td></tr><tr><td>0xEB</td><td>1</td><td>2</td><td>X</td><td>X</td><td>X</td><td>0xEB02XXXX</td><td>串行主引导：SPI</td></tr><tr><td>0xEB</td><td>1</td><td>3</td><td>X</td><td>X</td><td>X</td><td>0xEB03XXXX</td><td>串行主引导：USB HID</td></tr><tr><td>0xEB</td><td>0</td><td>4</td><td>0</td><td>X</td><td>X</td><td>0xEB04X0XX</td><td>主引导：FlexSPI：引导镜像 0</td></tr><tr><td>0xEB</td><td>0</td><td>4</td><td>1</td><td>X</td><td>X</td><td>0xEB04X1XX</td><td>主引导：FlexSPI：引导镜像 1</td></tr><tr><td>0xEB</td><td>0</td><td>7</td><td>0</td><td>X</td><td>X</td><td>0xEB070XXX</td><td>主引导：SD（实例 0）</td></tr><tr><td>0xEB</td><td>0</td><td>7</td><td>1</td><td>X</td><td>X</td><td>0xEB071XXX</td><td>主引导：SD（实例 1）</td></tr><tr><td>0xEB</td><td>0</td><td>8</td><td>0</td><td>X</td><td>X</td><td>0xEB080XXX</td><td>主引导：MMC（实例 0）</td></tr><tr><td>0xEB</td><td>0</td><td>8</td><td>1</td><td>X</td><td>X</td><td>0xEB081XXX</td><td>主引导：MMC（实例 1）</td></tr><tr><td>0xEB</td><td>1</td><td>0</td><td>X</td><td>X</td><td>X</td><td>0xEB10XXXX</td><td>ISP 引导：USART</td></tr><tr><td>0xEB</td><td>1</td><td>1</td><td>X</td><td>X</td><td>X</td><td>0xEB11XXXX</td><td>ISP 引导：I2C</td></tr><tr><td>0xEB</td><td>1</td><td>2</td><td>X</td><td>X</td><td>X</td><td>0xEB12XXXX</td><td>ISP 引导：SPI</td></tr><tr><td>0xEB</td><td>1</td><td>3</td><td>X</td><td>X</td><td>X</td><td>0xEB13XXXX</td><td>ISP 引导：HID</td></tr></tbody></table><p>以下示例展示了用户应用程序如何使用该 API 调用 ROM。<strong>示例 1：</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">user_app_boot_invoke_option_t</span> boot_options = {<span class="number">0</span>};  </span><br><span class="line">boot_options.option.B.tag = <span class="number">0xeb</span>;  </span><br><span class="line">boot_options.option.B.mode = <span class="number">0x1</span>;  </span><br><span class="line">boot_options.option.B.boot_interface = <span class="number">0x2</span>;  </span><br><span class="line">runBootloader((<span class="type">void</span>*)&amp;boot_options); <span class="comment">// 调用此函数后，系统将复位并以SPI接口进入ISP模式运行  </span></span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">user_app_boot_invoke_option_t</span> boot_options = {<span class="number">0</span>};  </span><br><span class="line">boot_options.option.B.tag = <span class="number">0xeb</span>;  </span><br><span class="line">boot_options.option.B.mode = <span class="number">0x0</span>;  </span><br><span class="line">boot_options.option.B.boot_interface = <span class="number">0x4</span>;  </span><br><span class="line">boot_options.option.B.boot_image_index = <span class="number">0x0</span>;  </span><br><span class="line">runBootloader((<span class="type">void</span>*)&amp;boot_options); <span class="comment">// 调用此函数后，系统将复位并通过FLEXSPI接口引导镜像0  </span></span><br></pre></td></tr></tbody></table></figure><h2 id="41-12-附录"><a href="#41-12-附录" class="headerlink" title="41.12 附录"></a>41.12 附录</h2><p>本章引用的补充信息。<strong>表 1107. Get property</strong></p><table><thead><tr><th>属性标签</th><th>标签详细信息</th></tr></thead><tbody><tr><td>kPropertyTag_BootloaderVersion = 0x01</td><td>引导程序版本</td></tr><tr><td>kPropertyTag_AvailablePeripherals = 0x02</td><td>ISP 模式可用外设</td></tr><tr><td>kPropertyTag_AvailableCommands = 0x07</td><td>ISP 模式可用命令</td></tr><tr><td>kPropertyTag_MaxPacketSize = 0x0B</td><td>每次传输的 ISP 最大数据包大小</td></tr><tr><td>kPropertyTag_RAMSizeInBytes = 0x0F</td><td>设备 RAM 大小（字节）</td></tr><tr><td>kPropertyTag_SystemDeviceId = 0x10</td><td>设备系统设备 ID</td></tr><tr><td>kPropertyTag_SecurityState = 0x11</td><td>设备安全状态</td></tr><tr><td>kPropertyTag_UniqueDeviceId = 0x12</td><td>唯一设备 ID</td></tr><tr><td>kPropertyTag_TargetVersion = 0x18</td><td>目标版本号，返回芯片版本和 ROM 版本，该属性的描述见下文注释</td></tr><tr><td>kPropertyTag_ExternalMemoryAttributes = 0x19</td><td>外部存储器属性</td></tr></tbody></table><blockquote><p>注释：目标版本属性：针对属性 ID <code>0x18</code>，ROM 引导程序返回的目标版本号由三个字段组成，以 “.” 分隔，目标版本以字母 “T” 为前缀，格式为 T &lt; 主版本。次版本。修订版 &gt;；</p><p>例如 T2.0.2。主版本和次版本对应芯片版本的主值和次值，修订版字段对应引导 ROM 的修订版。如果芯片未应用 ROM 补丁，则 ROM 在修订版字段返回 “0”，否则返回有效的 ROM 补丁版本。</p></blockquote><p><strong>表 1108. Set property</strong></p><table><thead><tr><th>属性标签</th><th>标签详细信息</th></tr></thead><tbody><tr><td>kPropertyTag_IrqNotifierPin = 0x1C</td><td>进入 ISP 模式中断服务程序时设置引脚通知器</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RT600-RM-CH41：RT6xx-非安全BootROM-7&quot;&gt;&lt;a href=&quot;#RT600-RM-CH41：RT6xx-非安全BootROM-7&quot; class=&quot;headerlink&quot; title=&quot;RT600 RM CH41：RT6xx 非安全BootROM (7)&quot;&gt;&lt;/a&gt;RT600 RM CH41：RT6xx 非安全BootROM (7)&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;如何通过runBootloader调用ROM API！&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT600" scheme="https://dustofstars.github.io/categories/NXP/RT600/"/>
    
    <category term="BootROM" scheme="https://dustofstars.github.io/categories/NXP/RT600/BootROM/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="RT600" scheme="https://dustofstars.github.io/tags/RT600/"/>
    
    <category term="BootROM" scheme="https://dustofstars.github.io/tags/BootROM/"/>
    
  </entry>
  
  <entry>
    <title>RT600 BootROM RM解析 (6)</title>
    <link href="https://dustofstars.github.io/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-6/"/>
    <id>https://dustofstars.github.io/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-6/</id>
    <published>2025-05-20T08:01:27.000Z</published>
    <updated>2025-05-20T08:01:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RT600-RM-CH41：RT6xx-非安全BootROM-6"><a href="#RT600-RM-CH41：RT6xx-非安全BootROM-6" class="headerlink" title="RT600 RM CH41：RT6xx 非安全BootROM (6)"></a>RT600 RM CH41：RT6xx 非安全BootROM (6)</h1><blockquote><p>FlexSPI Driver的API详解！</p></blockquote><span id="more"></span><h2 id="41-10-FlexSPI-闪存驱动-API"><a href="#41-10-FlexSPI-闪存驱动-API" class="headerlink" title="41.10 FlexSPI 闪存驱动 API"></a>41.10 FlexSPI 闪存驱动 API</h2><h3 id="41-10-1-如何阅读本节"><a href="#41-10-1-如何阅读本节" class="headerlink" title="41.10.1 如何阅读本节"></a>41.10.1 如何阅读本节</h3><p>所有器件均提供基于 ROM 的 FlexSPI 闪存驱动 API。</p><h3 id="41-10-2-功能"><a href="#41-10-2-功能" class="headerlink" title="41.10.2 功能"></a>41.10.2 功能</h3><ul><li>用于识别外部串行闪存设备的 API</li><li>用于向外部串行闪存设备编程数据或从中读取数据的 API</li><li>用于部分或完全擦除外部串行闪存设备的 API</li></ul><h3 id="41-10-3-概述"><a href="#41-10-3-概述" class="headerlink" title="41.10.3 概述"></a>41.10.3 概述</h3><p>基于 ROM 的 FlexSPI 闪存驱动 API 集包含多个独立 API，以减少在 RT6xx 器件上启用外部闪存支持的工作量。借助这些 API，支持市场上大多数串行 NOR 闪存设备，包括但不限于：</p><ul><li>支持 JESD216 标准或更高版本的串行 NOR 闪存设备</li><li>HyperFLASH 设备</li><li>Micron Xcella Flash 设备</li><li>Macronix OctaFlash 设备</li><li>Adesto EcoXiP Flash 设备</li></ul><p><strong>注意</strong></p><ul><li>HyperFLASH 是 Cypress 或 ISSI 的符合 HyperBus 标准的闪存设备。</li><li>Xcella 是 Xcella 联盟的商标。</li><li>OctaFlash 是 Macronix Octal Flash 的商标。</li><li>EcoXiP 是 Adesto Octal Flash 的商标。</li></ul><h4 id="41-10-3-1-FlexSPI-驱动-API-位置"><a href="#41-10-3-1-FlexSPI-驱动-API-位置" class="headerlink" title="41.10.3.1 FlexSPI 驱动 API 位置"></a>41.10.3.1 FlexSPI 驱动 API 位置</h4><p>FlexSPI 驱动 API 的位置见图 231。</p><style>.nrmycoomdagk{zoom:150%;}</style><img src="/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-6/image-20250520161048274.png" class="nrmycoomdagk" alt="image-20250520161048274"><h4 id="41-10-4-FlexSPI-闪存驱动-API"><a href="#41-10-4-FlexSPI-闪存驱动-API" class="headerlink" title="41.10.4 FlexSPI 闪存驱动 API"></a>41.10.4 FlexSPI 闪存驱动 API</h4><p>FlexSPI 闪存驱动 API 提供简化用户应用中闪存编程工作的功能。ROM API 的详细信息见下一节。</p><p><strong>表 1088. FlexSPI 闪存驱动 API 列表</strong></p><table><thead><tr><th>函数原型</th><th>API 描述</th><th>章节</th></tr></thead><tbody><tr><td>status_t <code>flexspi_nor_flash_init</code>(uint32_t instance, flexspi_nor_config_t *config);</td><td>初始化 FlexSPI 控制器</td><td>41.10.4.1</td></tr><tr><td>status_t <code>flexspi_nor_flash_page_program</code>(uint32_t instance, flexspi_nor_config_t *config, uint32_t dstAddr, const uint32_t *src);</td><td>向指定闪存地址编程数据</td><td>41.10.4.2</td></tr><tr><td>status_t <code>flexspi_nor_flash_erase_all</code>(uint32_t instance, flexspi_nor_config_t *config);</td><td>擦除整个闪存</td><td>41.10.4.3</td></tr><tr><td>status_t <code>flexspi_nor_flash_erase</code>(uint32_t instance, flexspi_nor_config_t *config, uint32_t start, uint32_t length);</td><td>擦除指定闪存区域</td><td>41.10.4.4</td></tr></tbody></table><p><strong>表 1088. FlexSPI 闪存驱动 API 列表（续）</strong></p><table><thead><tr><th>函数原型</th><th>API 描述</th><th>章节</th></tr></thead><tbody><tr><td>status_t <code>flexspi_nor_flash_erase_sector</code>(uint32_t instance, flexspi_nor_config_t *config, uint32_t address);</td><td>擦除指定闪存扇区</td><td>41.10.4.5</td></tr><tr><td>status_t <code>flexspi_nor_flash_erase_block</code>(uint32_t instance, flexspi_nor_config_t *config, uint32_t address);</td><td>擦除指定闪存块</td><td>41.10.4.6</td></tr><tr><td>status_t <code>flexspi_nor_flash_read</code>(uint32_t instance, flexspi_nor_config_t *config, uint32_t *dst, uint32_t start, uint32_t bytes);</td><td>从指定起始地址读取固定长度的数据</td><td>41.10.4.7</td></tr><tr><td>void <code>flexspi_clock_config</code>(uint32_t instance, uint32_t freqOption, uint32_t sampleClkMode);</td><td>配置 FlexSPI 时钟频率和数据采样模式</td><td>41.10.4.8</td></tr><tr><td>status_t <code>flexspi_nor_set_clock_source</code>(uint32_t clockSource);</td><td>选择 FlexSPI 时钟源</td><td>41.10.4.9</td></tr><tr><td>status_t <code>flexspi_nor_get_config</code>(uint32_t instance, flexspi_nor_config_t *config, serial_nor_config_option_t *option);</td><td>从外部闪存获取闪存配置</td><td>41.10.4.10</td></tr><tr><td>status_t <code>flexspi_command_xfer</code> (uint32_t instance, flexspi_xfer_t *xfer)</td><td>传输 FlexSPI 命令</td><td>41.10.4.11</td></tr><tr><td>status_t <code>flexspi_update_lut</code> (uint32_t instance, uint32_t seqIndex, const uint32_t *lutBase, uint32_t seqNumber)</td><td>更新 FlexSPI 查找表</td><td>41.10.4.12</td></tr></tbody></table><h5 id="41-10-4-1-flexspi-nor-flash-init"><a href="#41-10-4-1-flexspi-nor-flash-init" class="headerlink" title="41.10.4.1 flexspi_nor_flash_init"></a>41.10.4.1 flexspi_nor_flash_init</h5><p>此例程根据参数 0 和参数 1 中指定的参数初始化 FlexSPI 控制器。</p><p><strong>表 1089. flexspi_nor_flash_init API</strong></p><table><thead><tr><th>例程</th><th>flexspi_nor_flash_init</th></tr></thead><tbody><tr><td>原型</td><td>status_t <code>flexspi_nor_flash_init</code>(uint32_t instance, flexspi_nor_config_t *config);</td></tr><tr><td>输入参数</td><td>参数 0：FlexSPI 控制器实例，仅支持 0 <br>参数 1：闪存配置块FCB</td></tr><tr><td>结果</td><td>错误代码：0 = 无错误。参见表 1104 “闪存 API 的返回和错误代码”。</td></tr><tr><td>描述</td><td>使用参数 1 指向的参数配置 FlexSPI 控制器。</td></tr></tbody></table><h6 id="41-10-4-1-1-参数-0：FlexSPI-控制器实例"><a href="#41-10-4-1-1-参数-0：FlexSPI-控制器实例" class="headerlink" title="41.10.4.1.1 参数 0：FlexSPI 控制器实例"></a>41.10.4.1.1 参数 0：FlexSPI 控制器实例</h6><p>这是 FlexSPI 的实例号，仅支持 0。</p><h6 id="41-10-4-1-2-参数-1：闪存配置块缓冲区"><a href="#41-10-4-1-2-参数-1：闪存配置块缓冲区" class="headerlink" title="41.10.4.1.2 参数 1：闪存配置块缓冲区"></a>41.10.4.1.2 参数 1：闪存配置块缓冲区</h6><p>该参数指向闪存配置块 (FCB)，其中包含与外部闪存设备相关的参数，例如闪存大小、页大小、扇区大小。<code>flexspi_nor_config_t</code> 的详细信息见 <strong>表 1001</strong>。</p><h5 id="41-10-4-2-flexspi-nor-flash-page-program"><a href="#41-10-4-2-flexspi-nor-flash-page-program" class="headerlink" title="41.10.4.2 flexspi_nor_flash_page_program"></a>41.10.4.2 flexspi_nor_flash_page_program</h5><p><strong>表 1090. flexspi_nor_flash_page_program API</strong></p><table><thead><tr><th>例程</th><th>flexspi_nor_flash_page_program</th></tr></thead><tbody><tr><td>原型</td><td>status_t <code>flexspi_nor_flash_page_program</code>(uint32_t instance, flexspi_nor_config_t *config, uint32_t dstAddr, const uint32_t *src);</td></tr><tr><td>输入参数</td><td>参数 0：FlexSPI 控制器实例 <br>参数 1：闪存配置块 <br>参数 2：要编程的目标地址 <br>参数 3：要编程的数据。<strong>注意</strong>：该参数必须指向字对齐的地址。</td></tr><tr><td>结果</td><td>错误代码：0 = 无错误。参见表 1104 “闪存 API 的返回和错误代码”。</td></tr><tr><td>描述</td><td>向指定的目标地址编程数据</td></tr></tbody></table><h5 id="41-10-4-3-flexspi-nor-flash-erase-all"><a href="#41-10-4-3-flexspi-nor-flash-erase-all" class="headerlink" title="41.10.4.3 flexspi_nor_flash_erase_all"></a>41.10.4.3 flexspi_nor_flash_erase_all</h5><p><strong>表 1091. flexspi_nor_flash_erase_all API</strong></p><table><thead><tr><th>例程</th><th>flexspi_nor_flash_erase_all</th></tr></thead><tbody><tr><td>原型</td><td>status_t <code>flexspi_nor_flash_erase_all</code>(uint32_t instance, flexspi_nor_config_t *config);</td></tr><tr><td>输入参数</td><td>参数 0：FlexSPI 控制器实例，仅支持 0 <br>参数 1：闪存配置块</td></tr><tr><td>结果</td><td>错误代码：0 = 无错误。参见表 1104 “闪存 API 的返回和错误代码”。</td></tr><tr><td>描述</td><td>擦除整个外部闪存</td></tr></tbody></table><h5 id="41-10-4-4-flexspi-nor-flash-erase"><a href="#41-10-4-4-flexspi-nor-flash-erase" class="headerlink" title="41.10.4.4 flexspi_nor_flash_erase"></a>41.10.4.4 flexspi_nor_flash_erase</h5><p><strong>表 1092. flexspi_nor_flash_erase API</strong></p><table><thead><tr><th>例程</th><th>flexspi_nor_flash_erase API</th></tr></thead><tbody><tr><td>原型</td><td>status_t <code>flexspi_nor_flash_erase</code>(uint32_t instance, flexspi_nor_config_t *config, uint32_t start, uint32_t length);</td></tr><tr><td>输入参数</td><td>参数 0：FlexSPI 控制器实例，仅支持 0 <br>参数 1：闪存配置块 <br>参数 2：要擦除的起始地址 <br>参数 3：要擦除的长度</td></tr><tr><td>结果</td><td>错误代码：0 = 无错误。参见表 1104 “闪存 API 的返回和错误代码”。</td></tr><tr><td>描述</td><td>擦除指定的闪存区域</td></tr></tbody></table><h5 id="41-10-4-5-flexspi-nor-flash-erase-sector"><a href="#41-10-4-5-flexspi-nor-flash-erase-sector" class="headerlink" title="41.10.4.5 flexspi_nor_flash_erase_sector"></a>41.10.4.5 flexspi_nor_flash_erase_sector</h5><p><strong>表 1093. flexspi_nor_flash_erase_sector API</strong></p><table><thead><tr><th>例程</th><th>flexspi_nor_flash_erase_sector API</th></tr></thead><tbody><tr><td>原型</td><td>status_t <code>flexspi_nor_flash_erase_sector</code>(uint32_t instance, flexspi_nor_config_t *config, uint32_t address);</td></tr><tr><td>输入参数</td><td>参数 0：FlexSPI 控制器实例，仅支持 0 <br>参数 1：闪存配置块 <br>参数 2：要擦除的扇区地址</td></tr><tr><td>结果</td><td>错误代码：0 = 无错误。参见表 1104 “闪存 API 的返回和错误代码”。</td></tr><tr><td>描述</td><td>擦除一个指定扇区</td></tr></tbody></table><h5 id="41-10-4-6-flexspi-nor-flash-erase-block"><a href="#41-10-4-6-flexspi-nor-flash-erase-block" class="headerlink" title="41.10.4.6 flexspi_nor_flash_erase_block"></a>41.10.4.6 flexspi_nor_flash_erase_block</h5><p>表 1094. flexspi_nor_flash_erase_block</p><table><thead><tr><th>例程</th><th>flexspi_nor_flash_erase_block</th></tr></thead><tbody><tr><td>原型</td><td>status_t <code>flexspi_nor_flash_erase_block</code>(uint32_t instance, flexspi_nor_config_t *config, uint32_t address);</td></tr><tr><td>输入参数</td><td>参数 0：FlexSPI 控制器实例，仅支持 0 <br>参数 1：闪存配置块 <br>参数 2：要擦除的块地址</td></tr><tr><td>结果</td><td>错误代码：0 = 无错误。参见表 1104 “闪存 API 的返回和错误代码”。</td></tr><tr><td>描述</td><td>擦除一个指定块</td></tr></tbody></table><h5 id="41-10-4-7-flexspi-nor-flash-read"><a href="#41-10-4-7-flexspi-nor-flash-read" class="headerlink" title="41.10.4.7 flexspi_nor_flash_read"></a>41.10.4.7 flexspi_nor_flash_read</h5><p><strong>表 1095. flexspi_nor_flash_read</strong></p><table><thead><tr><th>例程</th><th>flexspi_nor_flash_read</th></tr></thead><tbody><tr><td>原型</td><td>status_t <code>flexspi_nor_flash_read</code>(uint32_t instance, flexspi_nor_config_t *config, uint32_t *dst, uint32_t start, uint32_t bytes)</td></tr><tr><td>输入参数</td><td>参数 0：FlexSPI 控制器实例，仅支持 0 <br>参数 1：闪存配置块 <br>参数 2：用于存储读取数据的缓冲区地址 <br>参数 3：读取地址 <br>参数 4：读取大小</td></tr><tr><td>结果</td><td>错误代码：0 = 无错误。参见表 1104 “闪存 API 的返回和错误代码”。</td></tr><tr><td>描述</td><td>用于从 FlexSPI NOR 闪存读取数据</td></tr></tbody></table><h5 id="41-10-4-8-flexspi-clock-config"><a href="#41-10-4-8-flexspi-clock-config" class="headerlink" title="41.10.4.8 flexspi_clock_config"></a>41.10.4.8 flexspi_clock_config</h5><p><strong>表 1096. flexspi_clock_config</strong></p><table><thead><tr><th>例程</th><th>flexspi_clock_config</th></tr></thead><tbody><tr><td>原型</td><td>void <code>flexspi_clock_config</code>(uint32_t instance, uint32_t freqOption, uint32_t sampleClkMode)</td></tr><tr><td>输入参数</td><td>参数 0：FlexSPI 控制器实例，仅支持 0 <br>参数 1：FlexSPI 接口时钟频率选择 <br>参数 2：FlexSPI 控制器数据采样模式</td></tr><tr><td>结果</td><td>错误代码：0 = 无错误。参见表 1104 “闪存 API 的返回和错误代码”。</td></tr><tr><td>描述</td><td>用于配置 FlexSPI 接口的时钟频率和数据采样模式</td></tr></tbody></table><h6 id="41-10-4-8-1-参数-0：FlexSPI-控制器实例"><a href="#41-10-4-8-1-参数-0：FlexSPI-控制器实例" class="headerlink" title="41.10.4.8.1 参数 0：FlexSPI 控制器实例"></a>41.10.4.8.1 参数 0：FlexSPI 控制器实例</h6><p>这是 FlexSPI 的实例号，仅支持 0。</p><h6 id="41-10-4-8-2-参数-1：FlexSPI-接口时钟频率选择"><a href="#41-10-4-8-2-参数-1：FlexSPI-接口时钟频率选择" class="headerlink" title="41.10.4.8.2 参数 1：FlexSPI 接口时钟频率选择"></a>41.10.4.8.2 参数 1：FlexSPI 接口时钟频率选择</h6><p>用于选择 FlexSPI SPI 工作时钟，可能的选项如下：</p><ul><li>kFlexSpiSerialClk_30MHz = 1, </li><li>kFlexSpiSerialClk_50MHz = 2, </li><li>kFlexSpiSerialClk_60MHz = 3,</li><li>kFlexSpiSerialClk_80MHz = 4, </li><li>kFlexSpiSerialClk_100MHz = 5, </li><li>kFlexSpiSerialClk_120MHz = 6,</li><li>kFlexSpiSerialClk_133MHz = 7, </li><li>kFlexSpiSerialClk_166MHz = 8, </li><li>kFlexSpiSerialClk_200MHz = 9</li></ul><h6 id="41-10-4-8-3-参数-2：FlexSPI-控制器数据采样模式"><a href="#41-10-4-8-3-参数-2：FlexSPI-控制器数据采样模式" class="headerlink" title="41.10.4.8.3 参数 2：FlexSPI 控制器数据采样模式"></a>41.10.4.8.3 参数 2：FlexSPI 控制器数据采样模式</h6><p>用于选择 FlexSPI 接口数据采样模式，可能的选项如下：</p><ul><li>kFlexSpiClk_SDR, //!&lt;单数据速率 (SDR) 模式的时钟配置</li><li>kFlexSpiClk_DDR, //!&lt;双倍数据速率 (DDR) 模式的时钟配置</li></ul><h5 id="41-10-4-9-flexspi-nor-set-clock-source"><a href="#41-10-4-9-flexspi-nor-set-clock-source" class="headerlink" title="41.10.4.9 flexspi_nor_set_clock_source"></a>41.10.4.9 flexspi_nor_set_clock_source</h5><p><strong>表 1097. flexspi_nor_set_clock_source</strong></p><table><thead><tr><th>例程</th><th>flexspi_nor_set_clock_source</th></tr></thead><tbody><tr><td>原型</td><td>status_t <code>flexspi_nor_set_clock_source</code>(uint32_t clockSource)</td></tr><tr><td>输入参数</td><td>参数 0：FlexSPI 接口的时钟源</td></tr><tr><td>结果</td><td>错误代码：0 = 无错误。参见表 1104 “闪存 API 的返回和错误代码”。</td></tr><tr><td>描述</td><td>仅用于选择 FlexSPI 接口的时钟源，不进行其他配置</td></tr></tbody></table><h6 id="41-10-4-9-1-参数-0：FlexSPI-接口时钟源选择"><a href="#41-10-4-9-1-参数-0：FlexSPI-接口时钟源选择" class="headerlink" title="41.10.4.9.1 参数 0：FlexSPI 接口时钟源选择"></a>41.10.4.9.1 参数 0：FlexSPI 接口时钟源选择</h6><p>FlexSPI 接口的时钟源选择如下：</p><ul><li>kFlexspiClockSrc_MainClk = 0（主时钟）、</li><li>kFlexspiClockSrc_MainPllClk（主 PLL 时钟）、</li><li>kFlexspiClockSrc_Aux0PllClk（辅助 0 PLL 时钟）、</li><li>kFlexspiClockSrc_48M_Clk（48MHz 时钟）、</li><li>kFlexspiClockSrc_Aux1PllClk（辅助 1 PLL 时钟）</li></ul><h5 id="41-10-4-10-flexspi-nor-get-config"><a href="#41-10-4-10-flexspi-nor-get-config" class="headerlink" title="41.10.4.10 flexspi_nor_get_config"></a>41.10.4.10 flexspi_nor_get_config</h5><p><strong>表 1098. flexspi_nor_get_config</strong></p><table><thead><tr><th>例程</th><th>flexspi_nor_get_config</th></tr></thead><tbody><tr><td>原型</td><td>status_t <code>flexspi_nor_get_config</code>(uint32_t instance, flexspi_nor_config_t *config, serial_nor_config_option_t *option);</td></tr><tr><td>输入参数</td><td>参数 0：FlexSPI 控制器实例，仅支持 0 <br>参数 1：闪存配置块 <br><span style="color: red; font-weight: bold; ">参数 2：闪存配置选项块</span></td></tr><tr><td>结果</td><td>错误代码：0 = 无错误。参见表 1104 “闪存 API 的返回和错误代码”。</td></tr><tr><td>描述</td><td>探测闪存设备是否存在，并根据从闪存设备读取的参数生成闪存配置块。</td></tr></tbody></table><h6 id="41-10-4-10-1-参数-0：FlexSPI-控制器实例"><a href="#41-10-4-10-1-参数-0：FlexSPI-控制器实例" class="headerlink" title="41.10.4.10.1 参数 0：FlexSPI 控制器实例"></a>41.10.4.10.1 参数 0：FlexSPI 控制器实例</h6><p>这是 FlexSPI 的实例号，仅支持 0。</p><h6 id="41-10-4-10-2-参数-1：闪存配置块"><a href="#41-10-4-10-2-参数-1：闪存配置块" class="headerlink" title="41.10.4.10.2 参数 1：闪存配置块"></a>41.10.4.10.2 参数 1：闪存配置块</h6><p>该参数指向闪存配置块 (FCB)，其中包含与外部闪存设备相关的参数，例如闪存大小、页大小、扇区大小。flexspi_nor_config_t 的详细信息见表 1001。</p><h6 id="41-10-4-10-3-参数-2：闪存配置选项块"><a href="#41-10-4-10-3-参数-2：闪存配置选项块" class="headerlink" title="41.10.4.10.3 参数 2：闪存配置选项块"></a>41.10.4.10.3 参数 2：闪存配置选项块</h6><p>该参数为 FlexSPI 驱动提供了一种简化选项，用于探测闪存并后续获取闪存参数。该块的定义如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">serial_nor_config_option</span> {</span>  </span><br><span class="line">    <span class="class"><span class="keyword">union</span> {</span>  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> {</span>  </span><br><span class="line">            <span class="type">uint32_t</span> misc_mode : <span class="number">4</span>;     <span class="comment">//!&lt; 杂项模式  </span></span><br><span class="line">            <span class="type">uint32_t</span> quad_mode_setting : <span class="number">4</span>; <span class="comment">//!&lt; 四线模式设置  </span></span><br><span class="line">            <span class="type">uint32_t</span> cmd_pads : <span class="number">4</span>;      <span class="comment">//!&lt; 命令引脚数  </span></span><br><span class="line">            <span class="type">uint32_t</span> query_pads : <span class="number">4</span>;    <span class="comment">//!&lt; SFDP读取引脚数  </span></span><br><span class="line">            <span class="type">uint32_t</span> max_freq : <span class="number">4</span>;      <span class="comment">//!&lt; 最大支持频率  </span></span><br><span class="line">            <span class="type">uint32_t</span> device_type : <span class="number">4</span>;   <span class="comment">//!&lt; 设备类型  </span></span><br><span class="line">            <span class="type">uint32_t</span> option_size : <span class="number">4</span>;   <span class="comment">//!&lt; 选项大小（以uint32_t为单位，大小=(option_size + 1)）  </span></span><br><span class="line">            <span class="type">uint32_t</span> tag : <span class="number">4</span>;           <span class="comment">//!&lt; 标签，必须为0x0C  </span></span><br><span class="line">        } B;  </span><br><span class="line">        <span class="type">uint32_t</span> U;  </span><br><span class="line">    } option0;  </span><br><span class="line">    <span class="type">uint32_t</span> dummy_cycles:<span class="number">8</span>;  </span><br><span class="line">    <span class="class"><span class="keyword">union</span> {</span>  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> {</span>  </span><br><span class="line">            <span class="type">uint32_t</span> status_override : <span class="number">8</span>; <span class="comment">//!&lt; 设备模式配置期间覆盖状态寄存器值  </span></span><br><span class="line">            <span class="type">uint32_t</span> dummy_cycles : <span class="number">8</span>;   <span class="comment">//!&lt; 读取前的哑周期数  </span></span><br><span class="line">            <span class="type">uint32_t</span> pinmux_group : <span class="number">4</span>;   <span class="comment">//!&lt; 引脚复用组选择  </span></span><br><span class="line">            <span class="type">uint32_t</span> dqs_pinmux_group : <span class="number">4</span>; <span class="comment">//!&lt; DQS引脚复用组选择  </span></span><br><span class="line">            <span class="type">uint32_t</span> drive_strength : <span class="number">4</span>; <span class="comment">//!&lt; FlexSPI引脚驱动强度  </span></span><br><span class="line">            <span class="type">uint32_t</span> flash_connection : <span class="number">4</span>; <span class="comment">//!&lt; 闪存连接选项：0-单闪存连接到端口A，1-并行模式，2-单闪存连接到端口B  </span></span><br><span class="line">        } B;  </span><br><span class="line">        <span class="type">uint32_t</span> U;  </span><br><span class="line">    } option1;  </span><br><span class="line">} <span class="type">serial_nor_config_option_t</span>;  </span><br></pre></td></tr></tbody></table></figure><p><code>serial_nor_config_option_t</code> 结构体的详细信息如下表所示。</p><p><strong>表 1099. serial_nor_config_option_t 定义</strong></p><table><thead><tr><th>偏移量</th><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>option0</td><td>详见 option0 定义</td></tr><tr><td>4</td><td>option1</td><td>可选，<span style="color: red; font-weight: bold; ">仅当 option0 中的 option_size 字段非零时有效</span>。详见 option1 定义</td></tr></tbody></table><p><strong>表 1100. option0 定义</strong></p><table><thead><tr><th>字段</th><th>位范围</th><th>描述</th></tr></thead><tbody><tr><td>tag</td><td>31:28</td><td>配置选项的标签，固定为 0x0C</td></tr><tr><td>option_size</td><td>27:24</td><td>大小（字节）=(Option Size + 1) × 4 若仅需要 option0，则为 0</td></tr><tr><td>device_type</td><td>23:20</td><td>设备检测类型： <br>0 - 读取 SFDP 用于 SDR 命令 <br>1 - 读取 SFDP 用于 DDR 读取命令 <br>2 - HyperFLASH 1V8 <br>3 - HyperFLASH 3V <br>4 - Macronix Octal DDR <br>6 - Micron Octal DDR <br>8 - Adesto EcoXiP DDR</td></tr><tr><td>query_pads</td><td>19:16</td><td>查询命令（读取 SFDP 或 MID）期间的数据引脚数： <br>0 - 1 引脚 <br>1 - 2 引脚 <br>2 - 4 引脚 <br>3 - 8 引脚</td></tr><tr><td>cmd_pads</td><td>15:12</td><td>闪存访问命令期间的命令引脚数： <br>0 - 1 引脚 <br>1 - 2 引脚 <br>2 - 4 引脚 <br>3 - 8 引脚</td></tr><tr><td><code>quad_mode_setting</code></td><td>11:8</td><td>四线模式使能设置： <br>0 - 未配置 <br>1 - 在状态寄存器 1 中设置位 6 <br>2 - 在状态寄存器 2 中设置位 1 <br>3 - 在状态寄存器 2 中设置位 7 <br>4 - 通过 0x31 命令在状态寄存器 2 中设置位 1 <br><strong>注意：该字段仅在设备符合 JESD216 标准（9 长字 SFDP 表）时有效</strong></td></tr><tr><td>misc_mode</td><td>7:4</td><td>杂项模式： <br>0 - 未启用 <br>1 - 启用 0-4-4 模式以提高随机读取性能 <br>3 - 数据顺序交换模式（仅适用于 MXIC OctaFlash） <br>5 - 选择 FlexSPI 数据采样源为内部环回（详见 FlexSPI 使用说明） <br>6 - 配置 FlexSPI NOR 闪存运行于标准 SPI 模式 <br><strong>注意：实验性特性，产品中请勿使用，保持为 0</strong></td></tr><tr><td>max_freq</td><td>3:0</td><td>闪存最大工作速度： <br>0 - 不更改 FlexSPI 时钟设置 <br>其他值 - 参见 FlexSPI 时钟设置熔丝图</td></tr></tbody></table><p>表 1101. option1 定义</p><table><thead><tr><th>字段</th><th>位范围</th><th>描述</th></tr></thead><tbody><tr><td>flash_connection</td><td>31:28</td><td>闪存连接选项： <br>0 - 单闪存连接到端口 A <br>1 - 并行模式 <br>2 - 单闪存连接到端口 B</td></tr><tr><td>drive_strength</td><td>27:24</td><td>FlexSPI 引脚的驱动强度</td></tr><tr><td>dqs_pinmux_group</td><td>23:20</td><td>DQS 引脚复用组选择</td></tr><tr><td>pinmux_group</td><td>19:16</td><td>引脚复用组选择</td></tr><tr><td>status_override</td><td>15:8</td><td>设备模式配置期间覆盖状态寄存器值</td></tr><tr><td>dummy_cycles</td><td>7:0</td><td>读取命令的哑周期数： <br>0 - 使用检测到的哑周期数 <br>其他值 - 闪存数据表中提供的哑周期数</td></tr></tbody></table><p>典型选项配置如下：</p><ul><li>四线 NOR - 四线 SDR 读取：option0 = <code>0xc0000004</code>（80 MHz）</li><li>四线 NOR - 四线 DDR 读取：option0 = <code>0xc0100003</code>（60 MHz）</li><li>HyperFLASH 1V8：option0 = <code>0xc0233004</code>（80 MHz）</li><li>HyperFLASH 3V0：option0 = 0xc0333004（80 MHz）</li><li>MXIC OPI DDR（默认启用 OPI DDR）：option=0xc0433004（80 MHz）</li><li>Micron Octal DDR：option0=0xc0600004（80 MHz）</li><li>Micron OPI DDR：option0=0xc0603004（80 MHz，SPI-&gt;OPI DDR）</li><li>Micron OPI DDR（默认启用 DDR 读取）：option0 = 0xc0633004（80 MHz）</li><li>Adesto OPI DDR：option0=<code>0xc0803004</code>（80 MHz）</li></ul><h5 id="41-10-4-11-flexspi-command-xfer"><a href="#41-10-4-11-flexspi-command-xfer" class="headerlink" title="41.10.4.11 flexspi_command_xfer"></a>41.10.4.11 <span style="color: red; font-weight: bold; ">flexspi_command_xfer</span></h5><p><strong>表 1102. flexspi_command_xfer</strong></p><table><thead><tr><th>例程</th><th>flexspi_command_xfer</th></tr></thead><tbody><tr><td>原型</td><td>status_t <code>flexspi_command_xfer</code> (uint32_t instance, flexspi_xfer_t *xfer)</td></tr><tr><td>输入参数</td><td>参数 0：FlexSPI 控制器实例，仅支持 0 <br>参数 1：FlexSPI 传输上下文</td></tr><tr><td>结果</td><td>错误代码：0 = 无错误。参见表 1104 “闪存 API 的返回和错误代码”。</td></tr><tr><td>描述</td><td>通过 FlexSPI 接口发送在 FlexSPI 传输上下文中配置的命令。</td></tr></tbody></table><h6 id="41-10-4-11-1-参数-0：FlexSPI-控制器实例"><a href="#41-10-4-11-1-参数-0：FlexSPI-控制器实例" class="headerlink" title="41.10.4.11.1 参数 0：FlexSPI 控制器实例"></a>41.10.4.11.1 参数 0：FlexSPI 控制器实例</h6><p>这是 FlexSPI 的实例号，仅支持 0。</p><h6 id="41-10-4-11-2-参数-1：FlexSPI-传输上下文"><a href="#41-10-4-11-2-参数-1：FlexSPI-传输上下文" class="headerlink" title="41.10.4.11.2 参数 1：FlexSPI 传输上下文"></a>41.10.4.11.2 参数 1：<span style="color: red; font-weight: bold; ">FlexSPI 传输上下文</span></h6><p>定义如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">FlexSPIOperationType</span> {</span>  </span><br><span class="line">    kFlexSpiOperation_Command, <span class="comment">//!&lt; FlexSPI操作：仅命令，忽略TX和RX缓冲区  </span></span><br><span class="line">    kFlexSpiOperation_Config,  <span class="comment">//!&lt; FlexSPI操作：配置设备模式，TX FIFO大小在LUT中固定  </span></span><br><span class="line">    kFlexSpiOperation_Write,   <span class="comment">//!&lt; FlexSPI操作：写，仅TX缓冲区有效  </span></span><br><span class="line">    kFlexSpiOperation_Read,    <span class="comment">//!&lt; FlexSPI操作：读，仅RX缓冲区有效  </span></span><br><span class="line">    kFlexSpiOperation_End = kFlexSpiOperation_Read,  </span><br><span class="line">} <span class="type">flexspi_operation_t</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//!@brief FlexSPI传输上下文  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">FlexSpiXfer</span> {</span>  </span><br><span class="line">    <span class="type">flexspi_operation_t</span> operation; <span class="comment">//!&lt; FlexSPI操作类型  </span></span><br><span class="line">    <span class="type">uint32_t</span> baseAddress;          <span class="comment">//!&lt; FlexSPI操作基地址  </span></span><br><span class="line">    <span class="type">uint32_t</span> segId;                <span class="comment">//!&lt; 段ID  </span></span><br><span class="line">    <span class="type">uint32_t</span> seqId;                <span class="comment">//!&lt; 序列ID  </span></span><br><span class="line">    <span class="type">uint32_t</span> seqNum;               <span class="comment">//!&lt; 序列编号  </span></span><br><span class="line">    <span class="type">bool</span> isParallelModeEnable;     <span class="comment">//!&lt; 是否启用并行传输  </span></span><br><span class="line">    <span class="type">uint32_t</span> *txBuffer;            <span class="comment">//!&lt; TX缓冲区  </span></span><br><span class="line">    <span class="type">uint32_t</span> txSize;               <span class="comment">//!&lt; TX大小（字节）  </span></span><br><span class="line">    <span class="type">uint32_t</span> *rxBuffer;            <span class="comment">//!&lt; RX缓冲区  </span></span><br><span class="line">    <span class="type">uint32_t</span> rxSize;               <span class="comment">//!&lt; RX大小（字节）  </span></span><br><span class="line">} <span class="type">flexspi_xfer_t</span>;  </span><br></pre></td></tr></tbody></table></figure><h5 id="41-10-4-12-flexspi-update-lut"><a href="#41-10-4-12-flexspi-update-lut" class="headerlink" title="41.10.4.12 flexspi_update_lut"></a>41.10.4.12 <span style="color: red; font-weight: bold; ">flexspi_update_lut</span></h5><p><strong>表 1093. flexspi_update_lut</strong></p><table><thead><tr><th>例程</th><th>flexspi_update_lut</th></tr></thead><tbody><tr><td>原型</td><td>status_t <code>flexspi_update_lut</code> (uint32_t instance, uint32_t seqIndex, const uint32_t *lutBase, uint32_t seqNumber)</td></tr><tr><td>输入参数</td><td>参数 0：FlexSPI 控制器实例，仅支持 0 <br>参数 1：要更新的 FlexSPI 查找表序列起始索引 <br>参数 2：命令序列存储指针 <br>参数 3：要更新的命令序列数量 <br><span style="color: red; font-weight: bold; ">注意：有关命令序列的信息，请参见 33.4.7 节 “查找表”。</span></td></tr><tr><td>结果</td><td>错误代码：0 = 无错误。参见表 1104 “闪存 API 的返回和错误代码”。</td></tr><tr><td>描述</td><td>通过 FlexSPI 接口发送在 FlexSPI 传输上下文中配置的命令。</td></tr></tbody></table><h6 id="41-10-4-12-1-参数-0：FlexSPI-控制器实例"><a href="#41-10-4-12-1-参数-0：FlexSPI-控制器实例" class="headerlink" title="41.10.4.12.1 参数 0：FlexSPI 控制器实例"></a>41.10.4.12.1 参数 0：FlexSPI 控制器实例</h6><p>这是 FlexSPI 的实例号，仅支持 0。</p><h6 id="41-10-4-12-2-参数-1：要更新的-FlexSPI-查找表序列起始索引"><a href="#41-10-4-12-2-参数-1：要更新的-FlexSPI-查找表序列起始索引" class="headerlink" title="41.10.4.12.2 参数 1：要更新的 FlexSPI 查找表序列起始索引"></a>41.10.4.12.2 参数 1：要更新的 FlexSPI 查找表序列起始索引</h6><ul><li>seqIndex 范围：0~15</li><li>参数 3 的 seqNumber 范围：0~15</li><li><span style="color: red; font-weight: bold; ">seqIndex + seqNumber 应 ≤ 16</span></li></ul><h6 id="41-10-4-12-3-参数-2：命令序列存储指针"><a href="#41-10-4-12-3-参数-2：命令序列存储指针" class="headerlink" title="41.10.4.12.3 参数 2：命令序列存储指针"></a>41.10.4.12.3 参数 2：命令序列存储指针</h6><p>存储要更新的命令序列的缓冲区。</p><h6 id="41-10-4-12-4-参数-3：要更新的命令序列数量"><a href="#41-10-4-12-4-参数-3：要更新的命令序列数量" class="headerlink" title="41.10.4.12.4 参数 3：要更新的命令序列数量"></a>41.10.4.12.4 参数 3：要更新的命令序列数量</h6><ul><li>seqIndex 范围：0~15</li><li>参数 3 的 seqNumber 范围：0~15</li><li>seqIndex + seqNumber 应 ≤ 16</li></ul><h6 id="41-10-4-13-闪存驱动-API-的可能返回和错误代码"><a href="#41-10-4-13-闪存驱动-API-的可能返回和错误代码" class="headerlink" title="41.10.4.13 闪存驱动 API 的可能返回和错误代码"></a>41.10.4.13 闪存驱动 API 的可能返回和错误代码</h6><p><strong>表 1104. 闪存 API 的返回和错误代码</strong></p><table><thead><tr><th>返回代码</th><th>错误代码</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>kStatus_Success</td><td>操作成功</td></tr><tr><td>1</td><td>kStatus_Fail</td><td>操作失败</td></tr><tr><td>4</td><td>kStatus_Invalidargument</td><td>参数 0 或参数 0 指向的 FCB 中的数据无效</td></tr><tr><td>6000</td><td>kStatus_FLEXSPI_SequenceExecutionTimeout</td><td>FlexSPI 序列执行超时</td></tr><tr><td>6001</td><td>kStatus_FLEXSPI_InvalidSequence</td><td>FlexSPI LUT 序列无效</td></tr><tr><td>6002</td><td>kStatus_FLEXSPI_DeviceTimeout</td><td>FlexSPI 设备超时</td></tr><tr><td>20100</td><td>kStatus_FLEXSPINOR_ProgramFail</td><td>页编程失败</td></tr><tr><td>20101</td><td>kStatus_FLEXSPINOR_EraseSectorFail</td><td>扇区擦除失败</td></tr></tbody></table><p><strong>表 1104.Flash API 返回和错误代码（续）</strong></p><table><thead><tr><th>返回代码</th><th>错误代码</th><th>描述</th></tr></thead><tbody><tr><td>20102</td><td>kStatus_FLEXSPINOR_EraseAllFail</td><td>芯片擦除失败</td></tr><tr><td>20103</td><td>kStatus_FLEXSPINOR_WaitTimeout</td><td>执行超时</td></tr><tr><td>20104</td><td>kStatus_FlexSPINOR_NotSupported</td><td>页面大小溢出</td></tr><tr><td>20105</td><td>kStatus_FlexSPINOR_WriteAlignmentError</td><td>地址对齐错误</td></tr><tr><td>20106</td><td>kStatus_FlexSPINOR_CommandFailure</td><td>擦除 / 编程验证错误</td></tr><tr><td>20107</td><td>kStatus_FlexSPINOR_SFDP_NotFound</td><td>API 调用期间发生超时</td></tr><tr><td>20108</td><td>kStatus_FLEXSPINOR_Unsupported_SFDP_Version</td><td>不识别的 SFDP 版本</td></tr><tr><td>20109</td><td>kStatus_FLEXSPINOR_Flash_NotFound</td><td>闪存检测失败</td></tr><tr><td>20110</td><td>kStatus_FLEXSPINOR_DTRRead_DummyProbeFailed</td><td>DDR 读取虚拟探测失败</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RT600-RM-CH41：RT6xx-非安全BootROM-6&quot;&gt;&lt;a href=&quot;#RT600-RM-CH41：RT6xx-非安全BootROM-6&quot; class=&quot;headerlink&quot; title=&quot;RT600 RM CH41：RT6xx 非安全BootROM (6)&quot;&gt;&lt;/a&gt;RT600 RM CH41：RT6xx 非安全BootROM (6)&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;FlexSPI Driver的API详解！&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT600" scheme="https://dustofstars.github.io/categories/NXP/RT600/"/>
    
    <category term="BootROM" scheme="https://dustofstars.github.io/categories/NXP/RT600/BootROM/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="RT600" scheme="https://dustofstars.github.io/tags/RT600/"/>
    
    <category term="BootROM" scheme="https://dustofstars.github.io/tags/BootROM/"/>
    
  </entry>
  
  <entry>
    <title>RT600 BootROM RM解析 (5)</title>
    <link href="https://dustofstars.github.io/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-5/"/>
    <id>https://dustofstars.github.io/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-5/</id>
    <published>2025-05-20T07:17:24.000Z</published>
    <updated>2025-05-20T07:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RT600-RM-CH41：RT6xx-非安全BootROM-5"><a href="#RT600-RM-CH41：RT6xx-非安全BootROM-5" class="headerlink" title="RT600 RM CH41：RT6xx 非安全BootROM (5)"></a>RT600 RM CH41：RT6xx 非安全BootROM (5)</h1><blockquote><p>OTP 驱动的 API 解析…</p><p>也涉及到ROM API的大概。</p></blockquote><span id="more"></span><h2 id="41-9-OTP-Driver-APIs"><a href="#41-9-OTP-Driver-APIs" class="headerlink" title="41.9 OTP Driver APIs"></a>41.9 OTP Driver APIs</h2><h3 id="41-9-1-How-to-read-this-section"><a href="#41-9-1-How-to-read-this-section" class="headerlink" title="41.9.1 How to read this section"></a>41.9.1 How to read this section</h3><p>This ROM based OTP Driver APIs are available on all parts.</p><h3 id="41-9-2-功能"><a href="#41-9-2-功能" class="headerlink" title="41.9.2 功能"></a>41.9.2 功能</h3><ul><li>用于对 OTP 块进行word 编程 / 读取的 API</li><li>用于计算和校验 OTP CRC 校验和的 API</li></ul><h3 id="41-9-3-概述"><a href="#41-9-3-概述" class="headerlink" title="41.9.3 概述"></a>41.9.3 概述</h3><p><span style="color: green; font-weight: bold; ">BootROM包含一组 OTP API，用于简化开发或生产周期中的 OTP 编程。</span></p><h4 id="41-9-3-1-ROM-API-布局"><a href="#41-9-3-1-ROM-API-布局" class="headerlink" title="41.9.3.1 ROM API 布局"></a>41.9.3.1 ROM API 布局</h4><style>.bjemnsrppkkn{zoom:150%;}</style><img src="/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-5/image-20250520154845928.png" class="bjemnsrppkkn" alt="image-20250520154845928"><p>图 231 展示了 ROM API 布局的详细信息。</p><h4 id="41-9-3-2-OTP-API-位置"><a href="#41-9-3-2-OTP-API-位置" class="headerlink" title="41.9.3.2 OTP API 位置"></a>41.9.3.2 OTP API 位置</h4><p>OTP API 位置的详细信息见<strong>图 231</strong>。</p><p><span style="color: green; "><strong>注意</strong>：执行任何 OTP 功能时，若 <code>LDO_ENABLE</code> 外部接地或接高电平，<code>VDDCORE</code> 必须设置为 0.9V 或更高。</span></p><h3 id="41-9-4-API-说明"><a href="#41-9-4-API-说明" class="headerlink" title="41.9.4 API 说明"></a>41.9.4 API 说明</h3><p>OTP API 提供对 OTP 块进行编程、读取、重新加载影子寄存器的功能，还支持计算和验证指定 OTP 区域的 CRC 校验和。</p><p><strong>表 1073. OTP API 调用</strong></p><table><thead><tr><th>函数原型</th><th>API 说明</th><th>章节</th></tr></thead><tbody><tr><td>status_t <code>otp_init</code>(uint32_t src_clk_freq);</td><td>基于源时钟频率初始化 OTP 块</td><td>41.9.4.1</td></tr><tr><td>status_t <code>otp_deinit</code>(void);</td><td>反初始化 OTP 块</td><td>41.9.4.2</td></tr><tr><td>status_t <code>otp_fuse_read</code>(uint32_t addr, uint32_t *data);</td><td>从指定的 OTP 字索引读取 OTP 熔丝值</td><td>41.9.4.3</td></tr><tr><td>status_t <code>opt_fuse_program</code>(uint32_t addr, uint32_t data, bool lock);</td><td>向指定的 OTP 字索引写入数据，若 lock 参数为 true 则锁定该位置</td><td>41.9.4.4</td></tr><tr><td>status_t <code>otp_crc_calc</code>(uint32_t *src, uint32_t numberOfWords, uint32_t *crcChecksum);</td><td>基于指定的 OTP 区域计算 CRC 校验和</td><td>41.9.4.5</td></tr><tr><td>status_t <code>otp_shadow_register_reload</code>(void);</td><td>从 OTP 熔丝块重新加载所有影子寄存器</td><td>41.9.4.6</td></tr><tr><td>status_t <code>otp_crc_check</code>(uint32_t start_addr, uint32_t end_addr, uint32_t crc_addr);</td><td>基于提供的 OTP 熔丝区域执行 CRC 校验</td><td>41.9.4.7</td></tr></tbody></table><h4 id="41-9-4-1-otp-init"><a href="#41-9-4-1-otp-init" class="headerlink" title="41.9.4.1 otp_init"></a>41.9.4.1 otp_init</h4><p>该例程根据指定的源时钟频率配置 OTP 控制器。</p><p><strong>表 1074. otp_init</strong></p><table><thead><tr><th>例程</th><th>otp_init</th></tr></thead><tbody><tr><td>原型</td><td>status_t <code>otp_init</code>(uint32_t <code>src_clk_freq</code>);</td></tr><tr><td>输入参数</td><td>参数 0：目标源时钟频率</td></tr><tr><td>结果</td><td>错误码：0 = 无错误。参见表 1104 “Flash API 返回码和错误码”。</td></tr><tr><td>说明</td><td>基于 OTP 控制器的源时钟频率配置 OTP 控制器</td></tr></tbody></table><h5 id="41-9-4-1-1-参数-0：目标源时钟频率"><a href="#41-9-4-1-1-参数-0：目标源时钟频率" class="headerlink" title="41.9.4.1.1 参数 0：目标源时钟频率"></a>41.9.4.1.1 参数 0：目标源时钟频率</h5><p>该频率是 CPU 访问 OTP 控制器时使用的时钟速率。</p><h5 id="41-9-4-1-2-错误或返回码"><a href="#41-9-4-1-2-错误或返回码" class="headerlink" title="41.9.4.1.2 错误或返回码"></a>41.9.4.1.2 错误或返回码</h5><p><strong>表 1075. 错误或返回码</strong></p><table><thead><tr><th>返回码</th><th>错误码</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>kStatus_Success</td><td>操作成功</td></tr></tbody></table><h4 id="41-9-4-2-otp-deinit"><a href="#41-9-4-2-otp-deinit" class="headerlink" title="41.9.4.2 otp_deinit"></a>41.9.4.2 otp_deinit</h4><p>该例程关闭 OTP 控制器。</p><p><strong>表 1076. otp_deinit</strong></p><table><thead><tr><th>例程</th><th>otp_deinit</th></tr></thead><tbody><tr><td>原型</td><td>status_t <code>otp_deinit</code>(void);</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>结果</td><td>错误码：0 = 无错误。参见表 1104 “Flash API 返回码和错误码”。</td></tr><tr><td>说明</td><td>关闭 OTP 控制器</td></tr></tbody></table><h4 id="41-9-4-3-otp-fuse-read"><a href="#41-9-4-3-otp-fuse-read" class="headerlink" title="41.9.4.3 otp_fuse_read"></a>41.9.4.3 otp_fuse_read</h4><p><strong>表 1078. otp_fuse_read</strong></p><table><thead><tr><th>例程</th><th>otp_fuse_read</th></tr></thead><tbody><tr><td>原型</td><td>status_t <code>otp_fuse_read</code>(uint32_t addr, uint32_t *data);</td></tr><tr><td>输入参数</td><td>参数 0：OTP 字索引 参数 1：用于存储 OTP 控制器返回值的数据缓冲区</td></tr><tr><td>结果</td><td>错误码：0 = 无错误。参见表 1104 “Flash API 返回码和错误码”。</td></tr><tr><td>说明</td><td>从指定的 OTP 字索引读取熔丝值</td></tr></tbody></table><h5 id="41-9-4-3-1-参数-0：OTP-字索引"><a href="#41-9-4-3-1-参数-0：OTP-字索引" class="headerlink" title="41.9.4.3.1 参数 0：OTP 字索引"></a>41.9.4.3.1 参数 0：OTP 字索引</h5><p>该参数指定要读出的 OTP 熔丝字。</p><h5 id="41-9-4-3-2-参数-1：数据缓冲区"><a href="#41-9-4-3-2-参数-1：数据缓冲区" class="headerlink" title="41.9.4.3.2 参数 1：数据缓冲区"></a>41.9.4.3.2 参数 1：数据缓冲区</h5><p>若 API 调用成功，该参数提供的地址将存储 OTP 控制器的返回值。</p><h5 id="41-9-4-3-3-错误或返回码"><a href="#41-9-4-3-3-错误或返回码" class="headerlink" title="41.9.4.3.3 错误或返回码"></a>41.9.4.3.3 错误或返回码</h5><p>表 1079. 错误或返回码</p><table><thead><tr><th>返回码</th><th>错误码</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>kStatus_Success</td><td>操作成功</td></tr><tr><td>4</td><td>kStatus_InvalidArgument</td><td>参数 1 无效</td></tr><tr><td>21001</td><td>kStatus_OTP_InvalidAddress</td><td>OTP 字索引无效</td></tr><tr><td>21004</td><td>kSatus_OTP_Error</td><td>OTP 操作期间发生错误</td></tr><tr><td>21005</td><td>kStatus_OTP_EccCheckFail</td><td>操作期间 OTP ECC 校验失败</td></tr><tr><td>21006</td><td>kStatus_OTP_Locked</td><td>OTP 字已锁定</td></tr></tbody></table><h4 id="41-9-4-4-otp-fuse-program"><a href="#41-9-4-4-otp-fuse-program" class="headerlink" title="41.9.4.4 otp_fuse_program"></a>41.9.4.4 otp_fuse_program</h4><p>表 1080. otp_fuse_program</p><table><thead><tr><th>例程</th><th>otp_fuse_program</th></tr></thead><tbody><tr><td>原型</td><td>status_t <code>opt_fuse_program</code>(uint32_t addr, uint32_t data, bool lock);</td></tr><tr><td>输入参数</td><td>参数 0：OTP 字索引 <br>参数 1：要编程的数据 <br>参数 2：锁定标志</td></tr><tr><td>结果</td><td>错误码：0 = 无错误。参见表 1104 “Flash API 返回码和错误码”。</td></tr><tr><td>说明</td><td>向指定的 OTP 字索引写入数据，并根据请求锁定该位置</td></tr></tbody></table><h5 id="41-9-4-4-1-参数-0：OTP-字索引"><a href="#41-9-4-4-1-参数-0：OTP-字索引" class="headerlink" title="41.9.4.4.1 参数 0：OTP 字索引"></a>41.9.4.4.1 参数 0：OTP 字索引</h5><p>该参数指定要编程的 OTP 字索引。</p><h5 id="41-9-4-4-2-参数-1：要编程的数据"><a href="#41-9-4-4-2-参数-1：要编程的数据" class="headerlink" title="41.9.4.4.2 参数 1：要编程的数据"></a>41.9.4.4.2 参数 1：要编程的数据</h5><p>该参数指定要写入的数据。</p><h5 id="41-9-4-4-3-参数-2：锁定标志"><a href="#41-9-4-4-3-参数-2：锁定标志" class="headerlink" title="41.9.4.4.3 参数 2：锁定标志"></a>41.9.4.4.3 参数 2：锁定标志</h5><p><strong>该参数决定编程后是否锁定 OTP 字索引</strong>。有效值：true（1）或 false（0）。</p><h5 id="41-9-4-4-4-错误或返回码"><a href="#41-9-4-4-4-错误或返回码" class="headerlink" title="41.9.4.4.4 错误或返回码"></a>41.9.4.4.4 错误或返回码</h5><p>表 1081. 错误或返回码</p><table><thead><tr><th>返回码</th><th>错误码</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>kStatus_Success</td><td>操作成功</td></tr><tr><td>4</td><td>kStatus_InvalidArgument</td><td>参数 1 无效</td></tr><tr><td>21001</td><td>kStatus_OTP_InvalidAddress</td><td>OTP 地址无效</td></tr><tr><td>21002</td><td>kStatus_OTP_ProgramFail</td><td>OTP 编程失败</td></tr><tr><td>21004</td><td>kSatus_OTP_Error</td><td>OTP 操作期间发生错误</td></tr><tr><td>21005</td><td>kStatus_OTP_EccCheckFail</td><td>操作期间 OTP ECC 校验失败</td></tr><tr><td>21006</td><td>kStatus_OTP_Locked</td><td>OTP 字已锁定</td></tr></tbody></table><h4 id="41-9-4-5-otp-crc-calc"><a href="#41-9-4-5-otp-crc-calc" class="headerlink" title="41.9.4.5 otp_crc_calc"></a>41.9.4.5 otp_crc_calc</h4><p>表 1082. otp_crc_calc</p><table><thead><tr><th>例程</th><th>otp_crc_calc</th></tr></thead><tbody><tr><td>原型</td><td>status_t otp_crc_calc(uint32_t *src, uint32_t numberOfWords, uint32_t *crcChecksum);</td></tr><tr><td>输入参数</td><td>参数 0：存储源数据的缓冲区 <br>参数 1：用于 CRC 计算的字数 <br>参数 2：存储校验和结果的缓冲区</td></tr><tr><td>结果</td><td>错误码：0 = 无错误。参见表 1104 “Flash API 返回码和错误码”。</td></tr><tr><td>说明</td><td>计算指定缓冲区的校验和，并将数据存储到输出缓冲区</td></tr></tbody></table><h5 id="41-9-4-5-1-参数-0：存储源数据的缓冲区"><a href="#41-9-4-5-1-参数-0：存储源数据的缓冲区" class="headerlink" title="41.9.4.5.1 参数 0：存储源数据的缓冲区"></a>41.9.4.5.1 参数 0：存储源数据的缓冲区</h5><p>该参数提供用于 CRC 校验和计算的源数据缓冲区，指针地址必须 32 位对齐。</p><h5 id="41-9-4-5-2-参数-1：用于-CRC-计算的字数"><a href="#41-9-4-5-2-参数-1：用于-CRC-计算的字数" class="headerlink" title="41.9.4.5.2 参数 1：用于 CRC 计算的字数"></a>41.9.4.5.2 参数 1：用于 CRC 计算的字数</h5><p>该参数指定 CRC 计算的字数。</p><h5 id="41-9-4-5-3-参数-2：存储校验和结果的缓冲区"><a href="#41-9-4-5-3-参数-2：存储校验和结果的缓冲区" class="headerlink" title="41.9.4.5.3 参数 2：存储校验和结果的缓冲区"></a>41.9.4.5.3 参数 2：存储校验和结果的缓冲区</h5><p>若操作成功，该参数指向的缓冲区将存储 CRC 结果。</p><h5 id="41-9-4-5-4-错误或返回码"><a href="#41-9-4-5-4-错误或返回码" class="headerlink" title="41.9.4.5.4 错误或返回码"></a>41.9.4.5.4 错误或返回码</h5><p>表 1083. 错误或返回码</p><table><thead><tr><th>返回码</th><th>错误码</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>kStatus_Success</td><td>操作成功</td></tr><tr><td>4</td><td>kStatus_InvalidArgument</td><td>参数 1 或 3 无效</td></tr></tbody></table><h5 id="41-9-4-6-otp-shadow-register-reload"><a href="#41-9-4-6-otp-shadow-register-reload" class="headerlink" title="41.9.4.6 otp_shadow_register_reload"></a>41.9.4.6 otp_shadow_register_reload</h5><p>表 1084. otp_shadow_register_reload</p><table><thead><tr><th>例程</th><th>otp_shadow_register_reload</th></tr></thead><tbody><tr><td>原型</td><td>status_t otp_shadow_register_reload(void);</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>结果</td><td>错误码：0 = 无错误。参见表 1104 “Flash API 返回码和错误码”。</td></tr><tr><td>说明</td><td>从 OTP 熔丝块重新加载所有影子寄存器</td></tr></tbody></table><h5 id="41-9-4-6-1-错误或返回码"><a href="#41-9-4-6-1-错误或返回码" class="headerlink" title="41.9.4.6.1 错误或返回码"></a>41.9.4.6.1 错误或返回码</h5><p>表 1085. 错误或返回码</p><table><thead><tr><th>返回码</th><th>错误码</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>kStatus_Success</td><td>操作成功</td></tr><tr><td>21004</td><td>kSatus_OTP_Error</td><td>OTP 操作期间发生错误</td></tr><tr><td>21005</td><td>kStatus_OTP_EccCheckPass</td><td>操作期间 OTP ECC 校验失败</td></tr></tbody></table><h5 id="41-9-4-7-otp-crc-check"><a href="#41-9-4-7-otp-crc-check" class="headerlink" title="41.9.4.7 otp_crc_check"></a>41.9.4.7 otp_crc_check</h5><p>表 1086. otp_crc_check</p><table><thead><tr><th>例程</th><th>otp_crc_check</th></tr></thead><tbody><tr><td>原型</td><td>status_t otp_crc_check(uint32_t start_addr, uint32_t end_addr, uint32_t crc_addr);</td></tr><tr><td>输入参数</td><td>参数 0：CRC 校验的起始 OTP 字索引 <br>参数 1：CRC 校验的结束 OTP 字索引 <br>参数 2：存储预期校验和的 OTP 字</td></tr><tr><td>结果</td><td>错误码：0 = 无错误。参见表 1104 “Flash API 返回码和错误码”。</td></tr><tr><td>说明</td><td>计算指定 OTP 范围内的 CRC 校验和，并与存储预期校验和的 OTP 字进行比较</td></tr></tbody></table><h5 id="41-9-4-7-1-参数-0：CRC-校验的起始-OTP-字索引"><a href="#41-9-4-7-1-参数-0：CRC-校验的起始-OTP-字索引" class="headerlink" title="41.9.4.7.1 参数 0：CRC 校验的起始 OTP 字索引"></a>41.9.4.7.1 参数 0：CRC 校验的起始 OTP 字索引</h5><p>该参数指定 CRC 校验的起始 OTP 字索引。</p><h5 id="41-9-4-7-2-参数-1：CRC-校验的结束-OTP-字索引"><a href="#41-9-4-7-2-参数-1：CRC-校验的结束-OTP-字索引" class="headerlink" title="41.9.4.7.2 参数 1：CRC 校验的结束 OTP 字索引"></a>41.9.4.7.2 参数 1：CRC 校验的结束 OTP 字索引</h5><p>该参数指定 CRC 校验的结束 OTP 字索引。</p><h5 id="41-9-4-7-3-参数-2：存储预期校验和的-OTP-字"><a href="#41-9-4-7-3-参数-2：存储预期校验和的-OTP-字" class="headerlink" title="41.9.4.7.3 参数 2：存储预期校验和的 OTP 字"></a>41.9.4.7.3 参数 2：存储预期校验和的 OTP 字</h5><p>该参数指向存储预期 CRC 校验和的 OTP 字，由于编程时已锁定，可能无法通过 <code>otp_fuse_read</code> API 访问。</p><h5 id="41-9-4-7-4-错误或返回码"><a href="#41-9-4-7-4-错误或返回码" class="headerlink" title="41.9.4.7.4 错误或返回码"></a>41.9.4.7.4 错误或返回码</h5><p>表 1087. 错误或返回码</p><table><thead><tr><th>返回码</th><th>错误码</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>kStatus_Success</td><td>操作成功</td></tr><tr><td>21001</td><td>kStatus_OTP_InvalidAddress</td><td>OTP 地址无效</td></tr><tr><td>21004</td><td>kSatus_OTP_Error</td><td>OTP 操作期间发生错误</td></tr><tr><td>21008</td><td>kStatus_OTP_CrcCheckPass</td><td>OTP CRC 校验通过</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RT600-RM-CH41：RT6xx-非安全BootROM-5&quot;&gt;&lt;a href=&quot;#RT600-RM-CH41：RT6xx-非安全BootROM-5&quot; class=&quot;headerlink&quot; title=&quot;RT600 RM CH41：RT6xx 非安全BootROM (5)&quot;&gt;&lt;/a&gt;RT600 RM CH41：RT6xx 非安全BootROM (5)&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;OTP 驱动的 API 解析…&lt;/p&gt;
&lt;p&gt;也涉及到ROM API的大概。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT600" scheme="https://dustofstars.github.io/categories/NXP/RT600/"/>
    
    <category term="BootROM" scheme="https://dustofstars.github.io/categories/NXP/RT600/BootROM/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="RT600" scheme="https://dustofstars.github.io/tags/RT600/"/>
    
    <category term="BootROM" scheme="https://dustofstars.github.io/tags/BootROM/"/>
    
  </entry>
  
  <entry>
    <title>RT600 BootROM RM解析 (4)</title>
    <link href="https://dustofstars.github.io/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-4/"/>
    <id>https://dustofstars.github.io/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-4/</id>
    <published>2025-05-20T07:07:14.000Z</published>
    <updated>2025-05-20T07:07:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RT600-RM-CH41：RT6xx-非安全BootROM-4"><a href="#RT600-RM-CH41：RT6xx-非安全BootROM-4" class="headerlink" title="RT600 RM CH41：RT6xx 非安全BootROM (4)"></a>RT600 RM CH41：RT6xx 非安全BootROM (4)</h1><blockquote><p>Recovery Boot Mode 和 Serial Boot Mode</p></blockquote><span id="more"></span><h2 id="41-6-Recovery-boot-模式"><a href="#41-6-Recovery-boot-模式" class="headerlink" title="41.6 Recovery boot 模式"></a>41.6 Recovery boot 模式</h2><p>BootROM支持恢复引导 —— 当主引导镜像因异常（例如镜像升级过程中破坏引导镜像的错误）而损坏时，可将设备恢复到特定状态的选项。</p><p>在 RT6xx 中，<span style="color: green;">SPI NOR/EEPROM 设备支持作为恢复介质，并且可以指定 SPI0-SPI7 中的一个作为连接 SPI NOR/EEPROM 设备的接口。</span>参见表 996 中的 SPI 外设引脚列表。</p><p>当主引导失败且启用恢复引导时，BootROM进入恢复引导模式。恢复引导过程开始时，<span style="color: red; font-weight: bold; ">BootROM使用来自 <code>IRC48M</code> 的 24 MHz 时钟，通过检查制造商 ID（MID）来探测 SPI NOR/EEPROM 设备的存在。</span>一旦检测到设备，BootROM会使用 24 MHz 时钟将恢复镜像从 SPI NOR/EEPROM 设备加载到片上 SRAM，然后对镜像进行完整性检查 / 镜像认证。</p><p>如果完整性检查 / 认证通过，BootROM将跳转到恢复引导镜像；否则，如果允许，将进入 ISP 模式。如果禁用 ISP 引导，BootROM将锁定设备。</p><h3 id="41-6-1-恢复引导-OTP-设置"><a href="#41-6-1-恢复引导-OTP-设置" class="headerlink" title="41.6.1 恢复引导 OTP 设置"></a>41.6.1 恢复引导 OTP 设置</h3><p>恢复引导字段位于 <code>BOOT_CFG0</code> OTP 字中，从偏移量 17 开始，宽度为 3 位。详情见表 1014。</p><p><strong>表 1014. 恢复引导 OTP 字段</strong></p><table><thead><tr><th></th><th><code>RECOVERY_SPI_PORT</code> 用于冗余 SPI 闪存引导的 FlexComm 端口</th><th>值</th></tr></thead><tbody><tr><td>FC0</td><td>使用 Flexcomm0 引脚 PIO0_0（SCK）、PIO0_1（MISO）、PIO0_2（MOSI）、PIO0_3（SSEL）</td><td>3’b000</td></tr><tr><td>FC1</td><td>使用 Flexcomm1 引脚 PIO0_7（SCK）、PIO0_8（MISO）、PIO0_9（MOSI）、PIO0_10（SSEL）</td><td>3’b001</td></tr><tr><td>FC2</td><td>使用 Flexcomm2 引脚 PIO0_14（SCK）、PIO0_15（MISO）、PIO0_16（MOSI）、PIO0_17（SSEL）</td><td>3’b010</td></tr><tr><td>FC3</td><td>使用 Flexcomm3 引脚 PIO0_21（SCK）、PIO0_22（MISO）、PIO0_23（MOSI）、PIO0_24（SSEL）</td><td>3’b011</td></tr><tr><td>FC4</td><td>使用 Flexcomm4 引脚 PIO0_28（SCK）、PIO0_29（MISO）、PIO0_30（MOSI）、PIO0_31（SSEL）</td><td>3’b100</td></tr><tr><td>FC5</td><td>使用 Flexcomm5 引脚 PIO1_3（SCK）、PIO1_4（MISO）、PIO1_5（MOSI）、PIO1_6（SSEL）</td><td>3’b101</td></tr><tr><td>FC6</td><td>使用 Flexcomm6 引脚 PIO3_25（SCK）、PIO3_26（MISO）、PIO3_27（MOSI）、PIO3_28（SSEL）</td><td>3’b110</td></tr></tbody></table><h3 id="41-6-2-恢复引导流程"><a href="#41-6-2-恢复引导流程" class="headerlink" title="41.6.2 恢复引导流程"></a>41.6.2 恢复引导流程</h3><style>.odumbwvgjuft{zoom:100%;}</style><img src="/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-4/image-20250520144643285.png" class="odumbwvgjuft"><p><strong>图 203. 恢复引导流程</strong></p><h2 id="41-7-Serial-Boot模式"><a href="#41-7-Serial-Boot模式" class="headerlink" title="41.7 Serial Boot模式"></a>41.7 Serial Boot模式</h2><h3 id="41-7-1-简介"><a href="#41-7-1-简介" class="headerlink" title="41.7.1 简介"></a>41.7.1 简介</h3><p>BootROM支持通过串行接口（例如 SPI 从机、UART）将镜像加载到片上 SRAM，然后引导至该镜像。支持的串行引导外设如下：</p><ul><li>UART</li><li>SPI 从机</li><li>I2C</li><li>USB HID</li></ul><p><span style="color: red; font-weight: bold; ">串行引导复用了 ISP 引导的相同数据包格式和简化命令集。</span>支持的命令如下：</p><ul><li><code>Get-Property</code></li><li><code>Set-Property</code></li><li><code>Write-Memory</code></li></ul><p>更多详细信息请参见第 41.8 节。</p><h3 id="41-7-2-串行引导流程"><a href="#41-7-2-串行引导流程" class="headerlink" title="41.7.2 串行引导流程"></a>41.7.2 串行引导流程</h3><style>.jtluwarmckhm{zoom:100%;}</style><img src="/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-4/image-20250520145208912.png" class="jtluwarmckhm" alt="image-20250520145208912"><p><strong>图 204. 串行引导流程</strong></p><h3 id="41-7-3-通过-UART-的串行引导"><a href="#41-7-3-通过-UART-的串行引导" class="headerlink" title="41.7.3 通过 UART 的串行引导"></a>41.7.3 通过 UART 的串行引导</h3><p>当选择 UART 接口作为串行引导接口时，BootROM使用 8-N-1 模式通过 UART 接口读取引导镜像。此模式涉及的命令如下：</p><ul><li><code>Ping</code>（用于自动波特率检测）</li><li><code>Get-Property</code>（可选，用于主机工具获取最大有效载荷大小，主机可跳过此命令并直接使用 512 字节有效载荷大小对镜像进行打包）</li><li><code>Write-memory</code></li></ul><p>有关 Ping 和 Write-Memory 命令的详细信息，请参见第 41.8.5 节，Write-Memory 命令中的最大有效载荷大小为 512 字节。</p><h3 id="41-7-4-通过-SPI-的串行引导"><a href="#41-7-4-通过-SPI-的串行引导" class="headerlink" title="41.7.4 通过 SPI 的串行引导"></a>41.7.4 通过 SPI 的串行引导</h3><p>BootROM支持通过 SPI 接口加载引导镜像，其中 <span style="color: red; font-weight: bold; ">SPI 工作在 SPI 从机模式 3 和 8 位数据模式下。</span></p><p>BootROM在配置的 SPI 接口上响应主机系统。一旦 <code>SSEL</code> 变为低电平，传输即开始。<span style="color: green;">出厂设置下的默认最大 SPI 速度为 24 MHz，当内核以高速引导模式运行时，速度可高达 50 MHz。</span></p><p>此模式涉及的命令如下：</p><ul><li><code>Set-Property</code></li><li><code>Get-Property</code>（可选，用于主机工具获取最大有效载荷大小，主机可跳过此命令并直接使用 512 字节有效载荷大小对镜像进行打包）</li><li><code>Write-memory</code></li></ul><p>有关 Set-Property 和 Write-Memory 命令的详细信息，请参见第 41.8.5 节，Write-Memory 命令中的最大有效载荷大小为 512 字节。</p><h3 id="41-7-5-通过-I2C-的串行引导"><a href="#41-7-5-通过-I2C-的串行引导" class="headerlink" title="41.7.5 通过 I2C 的串行引导"></a>41.7.5 通过 I2C 的串行引导</h3><p>BootROM可通过 I2C 接口加载引导镜像，其中 I2C 工作在从机模式，<span style="color: red; font-weight: bold; ">7 位地址为 <code>0x10</code>。</span>此引导模式使用的命令为：</p><ul><li><code>Get-Property</code>（可选，用于主机工具获取最大有效载荷大小，主机可跳过此命令并直接使用 512 字节有效载荷大小对镜像进行打包）</li><li><code>Write-Memory</code>有关 Write-Memory 命令的详细信息，请参见第 41.8.5 节，Write-Memory 命令中的最大有效载荷大小为 512 字节。</li></ul><h3 id="41-7-6-通过-USB-HID-的串行引导"><a href="#41-7-6-通过-USB-HID-的串行引导" class="headerlink" title="41.7.6 通过 USB HID 的串行引导"></a>41.7.6 通过 USB HID 的串行引导</h3><p>BootROM可通过 USB 加载引导镜像并引导至该镜像，<span style="color: red; font-weight: bold; ">其中 USB 工作在 HID 模式下。</span></p><p>选择引导模式为 HID 模式并确保 HID 成功模拟后，<span style="color: green;">使用以下命令将引导镜像加载到 RAM 中运行。</span></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blhost.exe -u 0x1fc9, 0x0020 write-memory 0x1c000 image.bin</span><br></pre></td></tr></tbody></table></figure><p>有关 Write-Memory 命令的详细信息，请参见第 41.8.5 节，Write-Memory 命令中的最大有效载荷大小为 512 字节。</p><blockquote><ul><li>0x1FC9, 0x0020 is PID,VID of the HID device.</li><li>image.bin is the boot image</li></ul><p>Note: USB boot requires the use of an <code>external 24 MHz crystal</code> on the main crystal oscillator.</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RT600-RM-CH41：RT6xx-非安全BootROM-4&quot;&gt;&lt;a href=&quot;#RT600-RM-CH41：RT6xx-非安全BootROM-4&quot; class=&quot;headerlink&quot; title=&quot;RT600 RM CH41：RT6xx 非安全BootROM (4)&quot;&gt;&lt;/a&gt;RT600 RM CH41：RT6xx 非安全BootROM (4)&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Recovery Boot Mode 和 Serial Boot Mode&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT600" scheme="https://dustofstars.github.io/categories/NXP/RT600/"/>
    
    <category term="BootROM" scheme="https://dustofstars.github.io/categories/NXP/RT600/BootROM/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="RT600" scheme="https://dustofstars.github.io/tags/RT600/"/>
    
    <category term="BootROM" scheme="https://dustofstars.github.io/tags/BootROM/"/>
    
  </entry>
  
  <entry>
    <title>RT600 BootROM RM解析 (3)</title>
    <link href="https://dustofstars.github.io/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-3/"/>
    <id>https://dustofstars.github.io/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-3/</id>
    <published>2025-05-19T09:11:04.000Z</published>
    <updated>2025-05-19T09:11:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RT600-RM-CH41：RT6xx-非安全BootROM-3"><a href="#RT600-RM-CH41：RT6xx-非安全BootROM-3" class="headerlink" title="RT600 RM CH41：RT6xx 非安全BootROM (3)"></a>RT600 RM CH41：RT6xx 非安全BootROM (3)</h1><h2 id="41-4-引导模式"><a href="#41-4-引导模式" class="headerlink" title="41.4 引导模式"></a>41.4 引导模式</h2><p>ROM 引导加载程序支持以下引导模式：</p><ul><li>Master Boot 模式</li><li>Recovery Boot 模式</li><li>Serial Boot 模式</li><li>ISP Boot 模式</li></ul><span id="more"></span><h2 id="41-5-主引导模式"><a href="#41-5-主引导模式" class="headerlink" title="41.5 主引导模式"></a>41.5 主引导模式</h2><p>主引导模式支持以下引导设备：</p><ul><li>FlexSPI 引导</li><li>SD 引导</li><li>eMMC 引导</li><li>SPI NOR 引导</li></ul><p>引导加载程序从引导介质上的指定偏移量查找引导镜像。详情见表 1000。</p><p><strong>表 1000. 不同引导介质上的镜像偏移量</strong></p><table><thead><tr><th>引导介质</th><th>镜像偏移量</th></tr></thead><tbody><tr><td>FlexSPI 引导（串行 NOR 闪存设备）</td><td>0x1000</td></tr><tr><td>SD 引导（SD 卡）</td><td>0x1000</td></tr><tr><td>eMMC 引导（eMMC 存储器）</td><td>0x1000</td></tr><tr><td>SPI 1 位 NOR 引导</td><td>0x1000</td></tr></tbody></table><h3 id="41-5-1-FlexSPI-引导"><a href="#41-5-1-FlexSPI-引导" class="headerlink" title="41.5.1 FlexSPI 引导"></a>41.5.1 FlexSPI 引导</h3><p>引导加载程序通过 FlexSPI 接口，使用位于闪存设备偏移量 <code>0x400</code> 处的闪存配置块（FCB）<span style="color: green;">或 OTP 中指定的闪存自动探测功能</span>，支持访问各种厂商的不同 Quad/Octal SPI NOR 闪存设备，可使用 1 位、2 位（双）、4 位（四）或 8 位（八）模式。FCB 的详细信息见表 1001。</p><ul><li>若 <code>FLEXSPI_AUTO_PROBE_EN</code> 已熔断，引导加载程序将使用 <code>FLEXSPI_FLASH_PROBE_TYPE</code> 字段（定义闪存自动探测类型）、<code>FLEXSPI_FLASH_TYPE</code> 字段（定义闪存类型）和 <code>FLEXSPI_FLASH_BOOT_FREQ</code> 字段（定义闪存访问速度）中熔断的参数执行闪存自动探测序列。</li><li>若未熔断，引导加载程序将查看闪存设备上的偏移量 <code>0x400</code>。若偏移量 <code>0x400</code> 处的数据等于 <code>0x42464346</code>，引导加载程序将<span style="color: red; font-weight: bold; ">把整个 512 字节的 FCB 读入片上 SRAM，并使用该 FCB 相应地配置 FlexSPI 控制器。</span></li></ul><p>上述操作完成后，引导加载程序开始执行正常引导流程。更多细节见 图 187。</p><p><strong>表 1001. FlexSPI 闪存配置块</strong></p><table><thead><tr><th>字段</th><th>偏移量</th><th>大小（字节）</th><th>描述</th></tr></thead><tbody><tr><td>tag</td><td>0x000</td><td>4</td><td>配置块标签，必须为 <code>0x42464346</code>。</td></tr><tr><td>version</td><td>0x004</td><td>4</td><td>配置块版本，供引导 ROM 内部使用，固定为 <code>0x56020000</code>。</td></tr><tr><td>reserved</td><td>0x008</td><td>4</td><td>保留。</td></tr><tr><td><code>readSampleClkSrc</code></td><td>0x00C</td><td>1</td><td><span style="color: red; font-weight: bold; ">读取采样时钟源选项：</span> <br>0 - 内部环回 <br>1 - 来自 DQS 焊盘的环回 <br>2 - 来自 SCK 焊盘的环回 <br>3 - 外部 DQS 信号</td></tr><tr><td>csHoldTime</td><td>0x00D</td><td>1</td><td>CS 保持时间（以闪存时钟周期为单位），推荐值为 3。</td></tr><tr><td>csSetupTime</td><td>0x00E</td><td>1</td><td>CS 建立时间（以闪存时钟周期为单位），推荐值为 3。</td></tr><tr><td>columnAddressWidth</td><td>0x00F</td><td>1</td><td>列地址宽度： <span style="color: red; ">HyperFLASH 设为 3 其他闪存设备设为 0</span></td></tr><tr><td>deviceModeCfgEnable</td><td>0x010</td><td>1</td><td>启用 Device Mode Configuration 序列。</td></tr><tr><td>reserved</td><td>0x011</td><td>1</td><td>保留。</td></tr><tr><td>deviceModeSeq</td><td>0x014</td><td>4</td><td>设备模式配置序列： <br>字节 0：所需序列数 <br>字节 1：序列索引</td></tr><tr><td>deviceModeArg</td><td>0x018</td><td>4</td><td>设备模式配置参数（<span style="color: red;">如某些 QSPI 闪存设备状态寄存器 2 中的 QE 设置</span>）。</td></tr><tr><td>configCmdEnable</td><td>0x01C</td><td>1</td><td>配置命令使能： <br>0 - 忽略配置命令 <br>1 - 启用配置命令</td></tr><tr><td>configModeType</td><td>0x01D</td><td>3</td><td>配置命令类型，支持最多 3 种类型，每种类型与一个配置命令序列组合。</td></tr><tr><td>configCmdSeqs</td><td>0x020</td><td>12</td><td>配置命令序列，支持最多 3 个序列。</td></tr><tr><td>reserved</td><td>0x02C</td><td>4</td><td>保留。</td></tr><tr><td>configCmdArgs</td><td>0x030</td><td>12</td><td>配置命令参数，支持最多 3 个参数。</td></tr><tr><td>reserved</td><td>0x03C</td><td>4</td><td>保留。</td></tr></tbody></table><p><strong>表 1001. FlexSPI 闪存配置块（续）</strong></p><table><thead><tr><th>字段</th><th>偏移量</th><th>大小（字节）</th><th>描述</th></tr></thead><tbody><tr><td>controllerMiscOption</td><td>0x040</td><td>4</td><td>控制器杂项配置选项： <br>位 0 - 差分时钟使能，HyperFLASH 1V8 设备设为 1，其他设备设为 0 <br>位 3 - 字地址使能，HyperFLASH 设为 1，其他设备设为 0 <br>位 4 - 安全配置频率使能，若期望用安全频率配置设备则设为 1 <br>位 6 - DDR 模式使能，若需要 DDR 读取则设为 1 <br>其他位 - 保留，设为 0</td></tr><tr><td>deviceType</td><td>0x044</td><td>1</td><td>设备类型： 1 - 串行 NOR</td></tr><tr><td>sflashPadType</td><td>0x045</td><td>1</td><td>读取命令中使用的数据焊盘： <br>1 - 单焊盘 <br>2 - 双焊盘 <br>4 - 四焊盘 <br>8 - 八焊盘</td></tr><tr><td>serialClkFreq</td><td>0x046</td><td>1</td><td>Flash Frequency. <br>In Normal boot mode BOOT_CFG[0]:bit7=0 <br>- SDR 模式：1 - 24 MHz，2 - 48 MHz <br>- DDR 模式：1 - 12 MHz <br>高速引导模式 BOOT_CFG [0]:bit7=1：  <br>SDR 模式：1-30 MHz，2-50 MHz，3-60 MHz，4-80 MHz，5-100 MHz，6-120 MHz，7-133 MHz，8-166 MHz，9-200 MHz  <br>DDR 模式：1-30 MHz，2-50 MHz，3-60 MHz，4-80 MHz，5-100 MHz，6-120 MHz，7-133 MHz，8-166 MHz，9-200 MHz</td></tr><tr><td>lutCustomSeqEnable</td><td>0x047</td><td>1</td><td><span style="color: red; ">LUT 自定义使能：若编程 / 擦除无法在 SDR 模式下用 1 个 LUT 序列完成，则需要此功能（当前仅适用于 HyperFLASH）</span> <br></td></tr><tr><td>reserved</td><td>0x048</td><td>8</td><td>保留，供未来使用。</td></tr><tr><td>sflashA1Size</td><td>0x050</td><td>4</td><td>连接到 A1 的闪存大小。</td></tr><tr><td>sflashA2Size</td><td>0x054</td><td>4</td><td>连接到 A2 的闪存大小。</td></tr><tr><td>sflashB1Size</td><td>0x058</td><td>4</td><td>连接到 B1 的闪存大小。</td></tr><tr><td>sflashB2Size</td><td>0x05C</td><td>4</td><td>连接到 B2 的闪存大小。</td></tr></tbody></table><p><strong>表 1001. FlexSPI 闪存配置块（续）</strong></p><table><thead><tr><th>字段</th><th>偏移量</th><th>大小（字节）</th><th>描述</th></tr></thead><tbody><tr><td>csPadSettingOverride</td><td>0x060</td><td>4</td><td>CS 引脚的焊盘覆盖值。若非零，则使用此值配置 CS 引脚；否则使用默认 ROM 设置。</td></tr><tr><td>sclkPadSettingOverride</td><td>0x064</td><td>4</td><td>SCK 焊盘设置覆盖值。</td></tr><tr><td>dataPadSettingOverride</td><td>0x068</td><td>4</td><td>数据焊盘设置覆盖值。</td></tr><tr><td>dqsPadSettingOverride</td><td>0x06C</td><td>4</td><td>DQS 焊盘设置覆盖值。</td></tr><tr><td>timeoutInMs</td><td>0x070</td><td>4</td><td>终止忙检查的超时值（以毫秒为单位）。</td></tr><tr><td>commandInterval</td><td>0x074</td><td>4</td><td>两个命令之间的 CS 取消选择间隔。</td></tr><tr><td>dataValidTime</td><td>0x078</td><td>4</td><td>端口 A 和端口 B 的时钟边沿到数据有效时间。</td></tr><tr><td>busyOffset</td><td>0x07C</td><td>2</td><td>忙标志偏移量，有效值：0-31。</td></tr><tr><td>busyBitPolarity</td><td>0x07E</td><td>2</td><td>忙标志极性： 0 - 闪存设备忙时忙标志为 1 1 - 闪存设备忙时忙标志为 0</td></tr><tr><td>lookupTable</td><td>0x080</td><td>256</td><td><span style="color: red; font-weight: bold; ">16 个 LUT 序列，每个序列由 4 个字组成。更多细节见第 33 章 “RT6xx FlexSPI 闪存接口”。</span></td></tr><tr><td><code>lutCustomSeq</code></td><td>0x180</td><td>48</td><td>可自定义的 LUT 序列。</td></tr><tr><td>reserved</td><td>0x1B0</td><td>16</td><td>保留，供未来使用。</td></tr><tr><td>pageSize</td><td>0x1C0</td><td>4</td><td>闪存页大小。</td></tr><tr><td>sectorSize</td><td>0x1C4</td><td>4</td><td>闪存扇区大小。</td></tr><tr><td>ipcmdSerialClkFreq</td><td>0x1C8</td><td>1</td><td>IP 命令的串行时钟频率： <br>0 - 与读取命令相同 <br>其他值 - 与 serialClkFreq 定义相同</td></tr><tr><td>isUniformBlockSize</td><td>0x1C9</td><td>1</td><td>扇区大小是否与块大小相同。</td></tr><tr><td><code>isDataOrderSwapped</code></td><td>0x1CA</td><td>1</td><td>数据顺序（D0, D1, D2, D3）是否交换为（D1, D0, D3, D2）： <br>0 - 否 <br>1 - 是</td></tr><tr><td>reserved</td><td>0x1CB</td><td>1</td><td>保留，供未来使用。</td></tr><tr><td>serialNorType</td><td>0x1CC</td><td>1</td><td>串行 NOR 闪存类型： <br>0 - 标准 SPI <br>1 - HyperBus <br>2 - XPI <br>3 - NoCmd</td></tr><tr><td>needExitNoCmdMode</td><td>0x1CD</td><td>1</td><td>执行其他 IP 命令前是否需要退出 NoCmd 模式。</td></tr><tr><td>halfClkForNonReadCmd</td><td>0x1CE</td><td>1</td><td>非读取命令是否使用半速串行时钟：是 / 否。</td></tr><tr><td>needRestoreNoCmdMode</td><td>0x1CF</td><td>1</td><td>IP 命令执行后是否需要恢复 NoCmd 模式。</td></tr><tr><td>blockSize</td><td>0x1D0</td><td>4</td><td>闪存块大小。</td></tr><tr><td>flashStateCtx</td><td>0x1D4</td><td>4</td><td>闪存状态上下文，用于将闪存恢复为默认状态。</td></tr><tr><td>reserved</td><td>0x1D8</td><td>40</td><td>保留，供未来使用。</td></tr></tbody></table><h4 id="41-5-1-1-FlexSPI-闪存复位"><a href="#41-5-1-1-FlexSPI-闪存复位" class="headerlink" title="41.5.1.1 FlexSPI 闪存复位"></a>41.5.1.1 FlexSPI 闪存复位</h4><p>在 FlexSPI 引导期间，引导过程要求 FlexSPI 闪存设备处于特定模式（如 1 位 SPI 兼容模式）。上电复位（POR）后，闪存设备自然会进入此模式，因为上电序列会将其与 RT6xx 设备一起复位。然而，若闪存设备在非 POR 复位（如看门狗定时器或外部引脚复位）时被配置为 DPI 模式、QPI 模式或八进制模式，则不会处于 1 位 SPI 兼容模式。在这种情况下，引导过程需要进行特殊处理，以在继续访问闪存设备之前将其恢复为 1 位 SPI 兼容模式。通常，这可以通过使用 GPIO 断言闪存设备上的复位引脚来实现。</p><p>如果 <code>FLEXSPI_RESET_PIN_EN</code> 已熔断，引导加载程序可以使用 <code>FLEXSPI_RESET_PIN_PORT</code> 和 <code>FLEXSPI_RESET_PIN_GPIO</code> 组合指定的 GPIO 执行复位过程，将闪存设备复位为 1 位 SPI 兼容模式。</p><h5 id="41-5-1-1-1-闪存掉电"><a href="#41-5-1-1-1-闪存掉电" class="headerlink" title="41.5.1.1.1 闪存掉电"></a>41.5.1.1.1 闪存掉电</h5><p>闪存设备可配置为Power-Down模式以降低待机电流。对于 FlexSPI 引导，RT6xx 引导代码访问闪存之前，必须先将闪存从掉电模式中释放。<span style="color: red; font-weight: bold; ">在这种情况下，<code>FLEXSPI_RESET_PIN</code> 可用于在引导过程中切换闪存上的复位引脚，以将闪存从掉电模式中释放。</span></p><p>如果闪存不支持复位引脚，可以设计专用电路为闪存提供 VCC。<code>FLEXSPI_RESET_PIN</code> 可用于控制电路在引导时为闪存上电 / 断电，以将闪存恢复为初始状态。</p><h4 id="41-5-1-2-FlexSPI-引导在-OTP-中的配置"><a href="#41-5-1-2-FlexSPI-引导在-OTP-中的配置" class="headerlink" title="41.5.1.2 FlexSPI 引导在 OTP 中的配置"></a>41.5.1.2 FlexSPI 引导在 OTP 中的配置</h4><p>与 FlexSPI 引导相关的配置分配在 <code>BOOT_CFG1</code> OTP 字中，分配详情见 表 1002。</p><p><strong>表 1002. OTP 中的 FlexSPI 引导配置</strong></p><table><thead><tr><th>字段名称</th><th>枚举名称</th><th>描述</th><th>偏移量</th><th>宽度</th><th>值</th></tr></thead><tbody><tr><td><code>FLEXSPI_AUTO_PROBE_EN</code></td><td>-</td><td>Quad/Octal-SPI 闪存自动探测功能使能。</td><td>0</td><td>1</td><td>-</td></tr><tr><td>FLEXSPI_PROBE_TYPE</td><td>-</td><td>Quad/Octal-SPI 闪存探测类型： 000b - QSPI NOR <br>001b - Macronix Octal Flash<br>010b - Micron Octal Flash <br>011b - Adesto Octal Flash <br>100b-111b - 保留</td><td>1</td><td>3</td><td>-</td></tr><tr><td>FLEXSPI_FLASH_TYPE</td><td>-</td><td>定义典型串行 NOR 闪存类型： <br>000b - 设备默认支持 3B 读取 <br>010b - HyperFlash 1V8 <br>011b - HyperFlash 3V3 <br>100b - MXIC Octal DDR <br>101b - Micron Octal DDR <br>其他值 - 保留</td><td>4</td><td>3</td><td>-</td></tr><tr><td>FLEXSPI_DUMMY_CYCLES</td><td>-</td><td>读取命令的 Quad/Octal-SPI 哑周期： 0000b - 自动探测哑周期 <br>其他值 - 指定哑周期数</td><td>7</td><td>4</td><td>-</td></tr><tr><td>FLEXSPI_FREQUENCY</td><td>-</td><td>Quad/Octal-SPI 闪存接口频率： 000b - 100 MHz 001b - 120 MHz 010b - 133 MHz 011b - 166 MHz 100b - 200 MHz 101b - 80 MHz 110b - 60 MHz 111b - 50 MHz</td><td>11</td><td>3</td><td>-</td></tr><tr><td>FLEXSPI_RESET_PIN_ENABLE</td><td>-</td><td>使用 <code>FLEXSPI_RESET_PIN</code> 复位闪存设备： <br>0 - 未连接或不可用（NO_RESET） <br>1 - 连接到 GPIO（EN_RESET）</td><td>14</td><td>1</td><td>-</td></tr><tr><td>FLEXSPI_RESET_PIN</td><td>-</td><td>用于 Quad/Octal SPI 复位功能的 GPIO 端口和引脚号： <br>位 0-2：GPIO 端口 <br>位 3-7：GPIO 引脚号</td><td>15</td><td>8</td><td>-</td></tr><tr><td>FLEXSPI_HOLD_TIME</td><td>-</td><td>访问串行闪存前的等待时间： 00b - 500 微秒 01b - 1 毫秒 10b - 3 毫秒 11b - 10 毫秒</td><td>23</td><td>2</td><td>-</td></tr></tbody></table><p><strong>表 1002. OTP 中的 FlexSPI 引导配置（续）</strong></p><table><thead><tr><th>字段名称</th><th>枚举名称</th><th>描述</th><th>偏移量</th><th>宽度</th><th>值</th></tr></thead><tbody><tr><td>FLEXSPI_PWR_HOLD_TIME</td><td>-</td><td>除 FLEXSPI_HOLD_TIME 字段定义的延迟外，上电后访问 Quad/Octal-SPI 闪存设备前的延迟： 0000b - 无延迟 0001b - 额外等待 100 微秒 0010b - 额外等待 500 微秒 0011b - 额外等待 1 毫秒 0100b - 额外等待 10 毫秒 其他值 - 更多延迟（详见文档）</td><td>25</td><td>4</td><td>-</td></tr><tr><td>RESERVED</td><td>-</td><td>保留</td><td>29</td><td>3</td><td>-</td></tr></tbody></table><h4 id="41-5-1-3-FlexSPI-引导流程"><a href="#41-5-1-3-FlexSPI-引导流程" class="headerlink" title="41.5.1.3 FlexSPI 引导流程"></a>41.5.1.3 FlexSPI 引导流程</h4><p>下图说明了简要的 FlexSPI 引导流程。<code>Keyblob</code> 的详细信息见第 42 章 “RT6xx 安全引导 ROM”。正常镜像加载和认证流程的详细信息见图 188。</p><style>.wrgxjhzzwskr{zoom:80%;}</style><img src="/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-3/FlexSPI_Flash_boot_flow.png" class="wrgxjhzzwskr"><p><strong>图 188. FlexSPI 闪存引导流程</strong></p><h4 id="41-5-1-4-FlexSPI-双镜像乒乓引导"><a href="#41-5-1-4-FlexSPI-双镜像乒乓引导" class="headerlink" title="41.5.1.4 FlexSPI 双镜像乒乓引导"></a>41.5.1.4 FlexSPI 双镜像乒乓引导</h4><p><span style="color: red; font-weight: bold; ">FlexSPI 控制器支持重映射功能，<u>可将串行 NOR 闪存的 AHB 访问地址重映射到另一个带偏移量的地址</u>，从而在第一个镜像引导失败时支持第二个镜像引导。</span></p><h5 id="41-5-1-4-1-FlexSPI-重映射的基本功能"><a href="#41-5-1-4-1-FlexSPI-重映射的基本功能" class="headerlink" title="41.5.1.4.1 FlexSPI 重映射的基本功能"></a>41.5.1.4.1 FlexSPI 重映射的基本功能</h5><p>下图是 FlexSPI 重映射功能的简单示意图</p><style>.bykkusbdpvzi{zoom:30%;}</style><p><strong>图 189. FlexSPI 镜像重映射（偏移量 = 0x200000）</strong></p><blockquote><p><span style="color: blue;"><em>也就是说，有Remap功能的MCU的FlexSPI可以有两个image，一个在0x8000_0000,一个在0x8000_2000。它们可以有不同的FCB和KeyBlob。</em></span></p></blockquote><p>设置重映射偏移量后，FlexSPI 内存访问将按如下方式更改访问地址：<strong>添加偏移量</strong>。例如，当偏移量设置为 2MB（0x200000）时，通过 FlexSPI 对 0x08000000 的访问将重映射到 0x08200000。<span style="color: blue; font-weight: bold; ">通过这种方式，可以使用两个镜像实现双镜像引导。偏移量和镜像1的大小由用户通过 OTP 熔丝设置。</span></p><h5 id="41-5-1-4-2-OTP-中的-FlexSPI-重映射大小和引导镜像-1-偏移量配置"><a href="#41-5-1-4-2-OTP-中的-FlexSPI-重映射大小和引导镜像-1-偏移量配置" class="headerlink" title="41.5.1.4.2 OTP 中的 FlexSPI 重映射大小和引导镜像 1 偏移量配置"></a>41.5.1.4.2 OTP 中的 FlexSPI 重映射大小和引导镜像 1 偏移量配置</h5><p>FlexSPI 双镜像引导相关配置分配在 <code>BOOT_CFG2</code> 和 <code>BOOT_CFG3</code> OTP 字中，更多细节见表 1003 和表 1004。</p><p><strong>表 1003. 引导镜像 1 偏移量（<code>BOOT_CFG3</code>）</strong></p><table><thead><tr><th>字段名称</th><th>偏移量</th><th>宽度</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>image1的偏移量</td><td>22</td><td>10</td><td>x</td><td>x * 256 KB</td></tr></tbody></table><blockquote><p>Note：<strong>image1是第二镜像，从image0开始！！</strong></p></blockquote><p><strong>表 1004. 从 <code>0x08001000</code> 开始的 FlexSPI 重映射大小</strong></p><table><thead><tr><th>字段名称</th><th>偏移量</th><th>宽度</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>FlexSPI 重映射大小 [1]</td><td>28</td><td>4</td><td></td><td>0：与第二镜像偏移量大小相同 <br>13 - 256 KB <br>14 - 512 KB <br>15 - 768 KB <br>x  - x * 1 MB</td></tr></tbody></table><blockquote><p>[1]：注意：FlexSPI 重映射大小不能超过 引导镜像1的起始地址。</p></blockquote><h4 id="41-5-1-4-3-双镜像乒乓引导"><a href="#41-5-1-4-3-双镜像乒乓引导" class="headerlink" title="41.5.1.4.3 双镜像乒乓引导"></a><strong>41.5.1.4.3 双镜像乒乓引导</strong></h4><p>对于双镜像乒乓引导，每个引导镜像都有自己的镜像版本，ROM 使用该版本<span style="color: red;">首先选择最新的引导镜像。如果最新镜像引导失败，将尝试使用旧镜像引导。</span></p><p><strong>乒乓引导流程</strong>对于 FlexSPI 引导，ROM 始终尝试查找最新的引导镜像并引导。如果引导失败，ROM 将尝试查找旧的引导镜像。如果旧镜像引导仍失败，则 ROM 将进入 ISP Boot 模式。下图是乒乓引导流程图。</p><style>.emzfyiufderh{zoom:80%;}</style><img src="/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-3/image-20250520120724007.png" class="emzfyiufderh" alt="FlexSPI_boot_image_selection"><p><strong>图 190. FlexSPI 引导镜像选择</strong></p><style>.gbwcvbunzqoy{zoom:80%;}</style><img src="/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-3/image-20250520120922630.png" class="gbwcvbunzqoy"><p><strong>图 191. FlexSPI 乒乓引导流程</strong></p><h4 id="41-5-1-4-4-Boot-image-版本"><a href="#41-5-1-4-4-Boot-image-版本" class="headerlink" title="41.5.1.4.4 Boot image 版本"></a>41.5.1.4.4 Boot image 版本</h4><p>每个引导镜像版本位于 FlexSPI 引导设备的偏移量 <code>0x600</code> 处（如图 189 所示）。<span style="color: red; font-weight: bold; ">镜像版本用 4 字节定义，低 2 字节为实际镜像版本号，高 2 字节为低 2 字节版本号的取反值。</span>不遵循此规则的任何其他值都将被视为无效值。如果引导镜像版本无效，ROM 将完全不引导该镜像。</p><p>但如果镜像版本为全 <code>0xFFFFFFFF</code>（用户未编程镜像版本的情况），也将被视为有效值。<span style="color: red; font-weight: bold; ">当一个镜像版本为 0xFFFFFFFF，另一个为有效版本时，ROM 始终优先引导有效版本的镜像，而非 0xFFFFFFFF 的镜像。如果两个镜像版本均为 0xFFFFFFFF，ROM 始终引导 FlexSPI NOR 闪存设备中低地址的第一个镜像。</span></p><p>以下是引导镜像版本的一些示例：</p><ul><li><strong>0xFFFE0001</strong>：有效引导镜像版本，版本号为 1。</li><li><strong>0xFFFD0002</strong>：有效引导镜像版本，版本号为 2。</li><li><strong>0x00000003</strong>：无效引导镜像版本，不遵循版本规则。</li><li><strong>0xFFFFFFFF</strong>：有效镜像版本，但引导顺序较低。</li><li><strong>0x0000FFFF</strong>：有效镜像版本，版本号为最大 0xFFFF。</li></ul><h4 id="41-5-1-5-为-RT6xx-设备配置-FlexSPI-NOR-设备"><a href="#41-5-1-5-为-RT6xx-设备配置-FlexSPI-NOR-设备" class="headerlink" title="41.5.1.5 为 RT6xx 设备配置 FlexSPI NOR 设备"></a>41.5.1.5 为 RT6xx 设备配置 FlexSPI NOR 设备</h4><p>ROM 支持从外部 FlexSPI NOR 闪存设备引导镜像。本节介绍如何使用 <code>blhost</code> 工具将镜像编程到外部非易失性存储器中以进行引导。更多细节请参考第 41.8.16 节 “外部存储器支持”。blhost 工具通过 ROM ISP 模式使用 UART、SPI、I2C、USB HID 与 ROM 代码通信，RT6xx 上的引脚连接见表 1005。</p><p><strong>表 1005. blhost 工具通信的引脚分配</strong></p><table><thead><tr><th>外设</th><th>端口</th><th>引脚</th></tr></thead><tbody><tr><td>USB</td><td>-</td><td>USB1_VBUS <br>USB1_VDD1V8 <br>USB1_VDD3V3 <br>USB1_DM <br>USB1_DP</td></tr><tr><td>SPI 从机</td><td>PIO1_11</td><td>HS_SPI_SCK (FC14)</td></tr><tr><td></td><td>PIO1_12</td><td>HS_SPI_MISO (FC14)</td></tr><tr><td></td><td>PIO1_13</td><td>HS_SPI_MOSI (FC14)</td></tr><tr><td></td><td>PIO1_14</td><td>HS_SPI_SSELN0 (FC14)</td></tr><tr><td>I2C 从机</td><td>PIO0_15</td><td>FC2_TXD_SCL_MISO</td></tr><tr><td></td><td>PIO0_16</td><td>FC2_RXD_SDA_MOSI</td></tr><tr><td>UART</td><td>PIO0_1</td><td>FC0_TXD_SCL_MISO</td></tr><tr><td></td><td>PIO0_2</td><td>FC0_RXD_SDA_MOSI</td></tr></tbody></table><h5 id="41-5-1-5-1-FlexSPI-NOR-闪存引导镜像编程"><a href="#41-5-1-5-1-FlexSPI-NOR-闪存引导镜像编程" class="headerlink" title="41.5.1.5.1 FlexSPI NOR 闪存引导镜像编程"></a>41.5.1.5.1 FlexSPI NOR 闪存引导镜像编程</h5><p>RT6xx ROM 支持从不同类型的 NOR 闪存（如连接到 FlexSPI 引脚的 Quad Flash、Octal Flash、Hyper Flash）引导，FlexSPI 引脚分配见表 1006。对于 FlexSPI NOR 引导，FCB 应编程在偏移量 <code>0x08000400</code> 处，引导镜像应编程在偏移量 <code>0x08001000</code> 处。以下部分将介绍如何为 5 种常见 NOR 闪存类型配置和编程引导镜像。</p><p><strong>表 1006. NOR 闪存连接的 FlexSPI 引脚分配</strong></p><table><thead><tr><th>外设</th><th>端口</th><th>引脚</th></tr></thead><tbody><tr><td>FlexSPI0 端口 A</td><td>PIO1_18</td><td>FLEXSPI0A_SCLK</td></tr><tr><td></td><td>PIO1_19</td><td><code>FLEXSPI0A_SS0_N</code></td></tr><tr><td></td><td>PIO1_20</td><td>FLEXSPI0A_DATA0</td></tr><tr><td></td><td>PIO1_21</td><td>FLEXSPI0A_DATA1</td></tr><tr><td></td><td>PIO1_22</td><td>FLEXSPI0A_DATA2</td></tr><tr><td></td><td>PIO1_23</td><td>FLEXSPI0A_DATA3</td></tr><tr><td></td><td>PIO1_24</td><td>FLEXSPI0A_DATA4</td></tr><tr><td></td><td>PIO1_25</td><td>FLEXSPI0A_DATA5</td></tr><tr><td></td><td>PIO1_26</td><td>FLEXSPI0A_DATA6</td></tr><tr><td></td><td>PIO1_27</td><td>FLEXSPI0A_DATA7</td></tr><tr><td></td><td>PIO1_28</td><td><code>FLEXSPI0A_DQS</code></td></tr><tr><td></td><td>PIO1_29</td><td><code>FLEXSPI0A_SS1_N</code></td></tr><tr><td>FlexSPI0 端口 B</td><td>PIO1_29</td><td>FLEXSPI0B_SCLK</td></tr><tr><td></td><td>PIO2_19</td><td><code>FLEXSPI0B_SS0_N</code></td></tr><tr><td></td><td>PIO1_11</td><td>FLEXSPI0B_DATA0</td></tr><tr><td></td><td>PIO1_12</td><td>FLEXSPI0B_DATA1</td></tr><tr><td></td><td>PIO1_13</td><td>FLEXSPI0B_DATA2</td></tr><tr><td></td><td>PIO1_14</td><td>FLEXSPI0B_DATA3</td></tr><tr><td></td><td>PIO2_17</td><td>FLEXSPI0B_DATA4</td></tr><tr><td></td><td>PIO2_18</td><td>FLEXSPI0B_DATA5</td></tr><tr><td></td><td>PIO2_22</td><td>FLEXSPI0B_DATA6</td></tr><tr><td></td><td>PIO2_23</td><td>FLEXSPI0B_DATA7</td></tr><tr><td></td><td>PIO2_21</td><td><code>FLEXSPI0B_SS1_N</code></td></tr></tbody></table><h5 id="41-5-1-5-2-FlexSPI-NOR-闪存配置参数"><a href="#41-5-1-5-2-FlexSPI-NOR-闪存配置参数" class="headerlink" title="41.5.1.5.2 FlexSPI NOR 闪存配置参数"></a>41.5.1.5.2 FlexSPI NOR 闪存配置参数</h5><p>不同 NOR 闪存需要不同的配置参数来启用和编程。以下是 NOR 闪存的配置参数定义。<code>serial_nor_config_option_t</code> 结构体的详细信息见表 1007、表 1008 和表 1009。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">serial_nor_config_option</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">            <span class="type">uint32_t</span> max_freq : <span class="number">4</span>;     <span class="comment">//!&lt; 最大支持频率</span></span><br><span class="line">            <span class="type">uint32_t</span> misc_mode : <span class="number">4</span>;    <span class="comment">//!&lt; 杂项模式</span></span><br><span class="line">            <span class="type">uint32_t</span> quad_mode_setting : <span class="number">4</span>; <span class="comment">//!&lt; 四线模式设置</span></span><br><span class="line">            <span class="type">uint32_t</span> cmd_pads : <span class="number">4</span>;     <span class="comment">//!&lt; 命令焊盘</span></span><br><span class="line">            <span class="type">uint32_t</span> query_pads : <span class="number">4</span>;   <span class="comment">//!&lt; SFDP读取焊盘</span></span><br><span class="line">            <span class="type">uint32_t</span> device_type : <span class="number">4</span>;  <span class="comment">//!&lt; 设备类型</span></span><br><span class="line">            <span class="type">uint32_t</span> option_size : <span class="number">4</span>;  <span class="comment">//!&lt; 选项大小（以uint32_t为单位，大小=(option_size + 1)）</span></span><br><span class="line">            <span class="type">uint32_t</span> tag : <span class="number">4</span>;          <span class="comment">//!&lt; 标签，必须为0x0C</span></span><br><span class="line">        } B;</span><br><span class="line">        <span class="type">uint32_t</span> U;</span><br><span class="line">    } option0;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">            <span class="type">uint32_t</span> dummy_cycles : <span class="number">8</span>;    <span class="comment">//!&lt; 读取前的哑周期</span></span><br><span class="line">            <span class="type">uint32_t</span> status_override : <span class="number">8</span>; <span class="comment">//!&lt; 设备模式配置期间覆盖状态寄存器值</span></span><br><span class="line">            <span class="type">uint32_t</span> pinmux_group : <span class="number">4</span>;    <span class="comment">//!&lt; 引脚复用组选择</span></span><br><span class="line">            <span class="type">uint32_t</span> dqs_pinmux_group : <span class="number">4</span>;<span class="comment">//!&lt; DQS引脚复用组选择</span></span><br><span class="line">            <span class="type">uint32_t</span> drive_strength : <span class="number">4</span>;   <span class="comment">//!&lt; FlexSPI焊盘驱动强度</span></span><br><span class="line">            <span class="type">uint32_t</span> flash_connection : <span class="number">4</span>; <span class="comment">//!&lt; 闪存连接选项：0-单闪存连接到端口A，1-并行模式，2-单闪存连接到端口B</span></span><br><span class="line">        } B;</span><br><span class="line">        <span class="type">uint32_t</span> U;</span><br><span class="line">    } option1;</span><br><span class="line">} <span class="type">serial_nor_config_option_t</span>;</span><br></pre></td></tr></tbody></table></figure><p><strong>表 1007. serial_nor_config_option_t 定义</strong></p><table><thead><tr><th>偏移量</th><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>Option0</td><td>详见 option0 定义。</td></tr><tr><td>4</td><td>Option1</td><td>可选，仅当 Option0 中的 <code>option_size</code> 字段非零时有效。详见 option1 定义。</td></tr></tbody></table><p><strong>表 1008. Option0 定义</strong></p><table><thead><tr><th>字段</th><th>位</th><th>描述</th></tr></thead><tbody><tr><td>tag</td><td>31:28</td><td>配置选项标签，固定为 <code>0x0C</code>。</td></tr><tr><td>option_size</td><td>27:24</td><td>大小（字节）=(Option Size + 1) × 4。<span style="color: red; font-weight: bold; ">若仅需要 option0，则为 0</span>。<br>– 实际就是4字节或者8字节两个选项！</td></tr><tr><td>device_type</td><td>23:20</td><td>设备检测类型： <br>0 - 读取 SFDP 用于 SDR 命令 <br>1 - 读取 SFDP 用于 DDR 读取命令 <br>2 - HyperFLASH 1V8 3 - HyperFLASH 3V 4 - Macronix Octal DDR <br>5 - Macronix Octal SDR <br>6 - Micron Octal DDR <br>7 - Micron Octal SDR <br>8 - Adesto EcoXiP DDR <br>9 - Adesto EcoXiP SDR</td></tr><tr><td>query_pad</td><td>19:16</td><td>查询命令（读取 SFDP 或 MID）期间的数据焊盘： <br>0 - 1 位 <br>2 - 4 位 <br>3 - 8 位</td></tr><tr><td>cmd_pad</td><td>15:12</td><td>闪存访问命令期间的数据焊盘： <br>0 - 1 位 <br>2 - 4 位 <br>3 - 8 位</td></tr></tbody></table><p><strong>表 1008. Option0 定义（续）</strong></p><table><thead><tr><th>字段</th><th>位</th><th>描述</th></tr></thead><tbody><tr><td><code>quad_mode_setting</code></td><td>11:8</td><td>四线模式使能设置： <br>0 - 未配置 <br>1 - 设置状态寄存器1的 bit 6 <br>2 - 设置状态寄存器 2 的位 1 <br>3 - 设置状态寄存器 2 的位 7 <br>4 - 通过 0x31 命令设置状态寄存器 2 的位 1 <br><span style="color: red; font-weight: bold; ">（此设置将闪存配置为 QPI 模式，用户代码必须将闪存重置为 SPI 模式，ROM 不会自动执行此操作。 注意：此字段仅适用于符合 JESD216 的设备（9 长字 SFDP 表））</span></td></tr><tr><td>misc_mode</td><td>7:4</td><td>杂项模式： <br>0 - 未启用 <br>1 - 启用 0-4-4 模式以提高随机读取性能 <br>3 - 数据顺序交换模式（仅适用于 MXIC OctaFlash） <br>5 - 选择 FlexSPI 数据采样源为内部环回（详见 FlexSPI 使用说明） <br>6 - 配置 FlexSPI NOR 闪存以标准 SPI 模式运行 （注意：实验性功能，产品中请勿使用，保持为 0。）</td></tr><tr><td>max_freq</td><td>3:0</td><td>最大闪存操作速度： <br>0 - 不更改 FlexSPI 时钟设置 <br>其他值 - 见 FlexSPI 时钟设置熔丝图</td></tr></tbody></table><p><strong>表 1009. Option1 定义</strong></p><table><thead><tr><th>字段</th><th>位</th><th>描述</th></tr></thead><tbody><tr><td><code>flash_connection</code></td><td>31:28</td><td>闪存连接选项： <br>0 - 单闪存连接到端口 A <br>1 - 并行模式 <br>2 - 单闪存连接到端口 B</td></tr><tr><td>drive_strength</td><td>27:24</td><td>FlexSPI 焊盘驱动强度。</td></tr><tr><td>dqs_pinmux_group</td><td>23:20</td><td>DQS 引脚复用组选择。</td></tr><tr><td>pinmux_group</td><td>19:16</td><td>引脚复用组选择。</td></tr><tr><td>status_override</td><td>15:8</td><td>设备模式配置期间覆盖状态寄存器值。</td></tr><tr><td>dummy_cycles</td><td>7:0</td><td>读取命令的哑周期： <br>0 - 使用检测到的哑周期 <br>其他值 - 闪存数据表中提供的哑周期数</td></tr></tbody></table><h5 id="41-5-1-5-3-NOR-闪存配置、擦除和编程"><a href="#41-5-1-5-3-NOR-闪存配置、擦除和编程" class="headerlink" title="41.5.1.5.3 NOR 闪存配置、擦除和编程"></a>41.5.1.5.3 NOR 闪存配置、擦除和编程</h5><p>以连接到 FlexSPI 端口A 的 Macronix MX25L25645G 为例：</p><ol><li><p><strong>配置参数存储到 RAM</strong>：首先将配置参数存储在 RAM 中，供下一步配置 FlexSPI 使用。如图 192 所示，FlexSPI 的配置参数为 0xc0000002，该参数根据闪存类型选择。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\blhost\blhost&gt;blhost.exe -p com3 fill-memory 0x1c0004 0xc0000002</span><br><span class="line"><span class="comment"># 响应：成功注入命令，状态0（成功）</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>使用 RAM 中的参数配置 FlexSPI</strong>：如图 193 所示，配置完成后可读取、擦除、编程闪存。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\blhost\blhost&gt;blhost.exe -p com3 configure-memory 0x9 0x1c000</span><br><span class="line"><span class="comment"># 响应：成功配置内存，状态0（成功）</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>读取闪存</strong>：如图 194 所示，使用 blhost 工具读取闪存数据。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\blhost\blhost&gt;blhost.exe -p com3 read-memory 0x08000400 0x100</span><br><span class="line"><span class="comment"># 响应：读取256字节，状态0（成功）</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>擦除闪存</strong>：如图 195 所示，擦除指定区域。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\blhost\blhost&gt;blhost.exe -p com3 flash-erase-region 0x08000400 0x200</span><br><span class="line"><span class="comment"># 响应：成功擦除，状态0（成功）</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>编程引导镜像</strong>：如图 196 所示，将引导镜像写入闪存。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\blhost\blhost&gt;blhost.exe -p com3 write-memory 0x08001000 boot_image.bin</span><br><span class="line"><span class="comment"># 响应：写入5796字节，状态0（成功）</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>验证读取</strong>：如图 197 所示，读取已编程的镜像数据。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\blhost\blhost&gt;blhost.exe -p com3 read-memory 0x08001000 0x100</span><br><span class="line">   <span class="comment"># 响应：读取256字节，显示镜像数据，状态0（成功）</span></span><br></pre></td></tr></tbody></table></figure></li></ol><p><strong>生成并编程 FlexSPI NOR FCB 到闪存</strong></p><p>对于 FlexSPI 启动，需要在偏移量 <code>0x08000400</code> 处放置 FCB（闪存配置块），该 FCB 用于从外部 NOR 闪存通过 FlexSPI 接口引导镜像时配置 FlexSPI 接口。<span style="color: red; font-weight: bold; ">FCB 将根据之前的 FlexSPI 配置参数（如 <code>0xc0000002</code>）生成。</span></p><ol><li><p><strong>存储 FCB 生成参数到 RAM</strong>：如图 198 所示，将参数存入 RAM。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\blhost\blhost&gt;blhost.exe -p com3 fill-memory 0x1d0004 0xf000000f</span><br><span class="line"><span class="comment"># 响应：成功注入命令，状态0（成功）</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>生成并编程 FCB 到闪存</strong>：如图 199 所示，ROM 自动生成 FCB 并编程到偏移量 <code>0x08000400</code> 处。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\blhost\blhost&gt;blhost.exe -p com3 configure-memory 0x9 0x1d000</span><br><span class="line"><span class="comment"># 响应：成功配置，状态0（成功）</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>验证 FCB</strong>：如图 200 所示，读取 FCB 数据验证。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\blhost\blhost&gt;blhost.exe -p com3 read-memory 0x08000400 0x100</span><br><span class="line">   <span class="comment"># 响应：读取FCB数据（如标签0x42464346等），状态0（成功）</span></span><br></pre></td></tr></tbody></table></figure></li></ol><blockquote><p><span style="color: red; font-weight: bold; ">这里有个误区，为什么执行了两次？</span></p><p>讲解：</p><p>Step1：只是写入不含FCB的image到0x1000,写入时使用了RAM中存储的FlexSPI配置参数，但这是一次性的写入，并没有固化FCB；</p><p>Step2：写入自动生成的FCB到0x400，这是固化FCB的过程。而生成FCB是blhost和ROM一起完成的！</p></blockquote><h5 id="41-5-1-5-4-典型-NOR-闪存配置参数"><a href="#41-5-1-5-4-典型-NOR-闪存配置参数" class="headerlink" title="41.5.1.5.4 典型 NOR 闪存配置参数"></a>41.5.1.5.4 典型 NOR 闪存配置参数</h5><p>不同 NOR 闪存类型需要不同的配置参数，下表显示了一些典型闪存的配置参数。</p><p><strong>表 1010. 典型 NOR 闪存配置参数<span style="color: red; font-weight: bold; ">（闪存连接到 FlexSPI 端口A）</span></strong></p><table><thead><tr><th>设备厂商</th><th>设备类型</th><th>闪存类型</th><th>配置参数</th><th>闪存模式</th><th>备注</th></tr></thead><tbody><tr><td>Aesto</td><td>Octal Flash</td><td>ATXP032</td><td>0xC0803006</td><td>DDR</td><td>ATXP032 有 3 个版本（REVA/B/C）。<br>对于 REV A 版本，ROM 仅支持自动探测引导， OTP 熔丝字 BOOT_CFG [0] 应设为 0x7，且无需配置 FCB。</td></tr><tr><td>Spansion</td><td>Hyper Flash</td><td>S26KS512S</td><td>0xC0233006</td><td>DDR</td><td>对于 Hyper Flash 引导，引导前 BOOT_CFG [0] 应设为 <code>0x20</code>。</td></tr><tr><td>Macronix</td><td>Quad Flash</td><td>MX25L25645G</td><td>0xC0000002</td><td>SDR</td><td>-</td></tr><tr><td>Macronix</td><td>Quad Flash</td><td>MX25L25645G</td><td>0xC0100002</td><td>DDR</td><td>-</td></tr><tr><td>Macronix</td><td>Octal Flash</td><td>MX25UM51345G</td><td>0xC0403006</td><td>DDR</td><td>-</td></tr><tr><td>Micron</td><td>Octal Flash</td><td>MT35XL512ABA</td><td>0xC0603006</td><td>DDR</td><td>-</td></tr></tbody></table><h5 id="41-5-1-5-5-连接到-FlexSPI-端口-B-的典型-NOR-闪存配置参数"><a href="#41-5-1-5-5-连接到-FlexSPI-端口-B-的典型-NOR-闪存配置参数" class="headerlink" title="41.5.1.5.5 连接到 FlexSPI 端口 B 的典型 NOR 闪存配置参数"></a>41.5.1.5.5 连接到 FlexSPI 端口 B 的典型 NOR 闪存配置参数</h5><p>对于连接到 FlexSPI 端口 B 的闪存设备，<span style="color: red; font-weight: bold; "><u>配置时用户需指定参数以告知 ROM 闪存连接到端口 B。由于 FlexSPI 端口 B 没有 DQS 引脚，用户需根据闪存数据表为连接的闪存配置dummy cycle，参数存储在 Option1 中</u></span>（见表 1009）。以下是配置连接到 FlexSPI 端口 B 的 MX25UM51345G 闪存的示例。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">• blhost.exe -p com3 – fill-memory 0x1c000 4 0xC1503051 //配置option0</span><br><span class="line">• blhost.exe -p com3 – fill-memory 0x1c004 4 0x20000014  //option1</span><br><span class="line">• blhost.exe -p com3 – configure-memory 0x9 0x1c000  // 应用配置参数</span><br></pre></td></tr></tbody></table></figure><p><strong>表 1011. 典型 NOR 闪存配置参数（闪存连接到 FlexSPI 端口 B）</strong></p><table><thead><tr><th>设备厂商</th><th>设备类型</th><th>闪存类型</th><th>配置参数</th><th>闪存模式</th><th>备注</th></tr></thead><tbody><tr><td>Adesto</td><td>Octal Flash</td><td>ATXP032</td><td>0xC1903001 0x20000008</td><td>SDR</td><td>ATXP032 有 REVA/B/C 三个版本，REV A 仅支持自动探测引导，BOOT_CFG [0] 需设为 0x7，无需配置 FCB。</td></tr><tr><td>Macronix</td><td>Quad Flash</td><td>MX25L25645G</td><td>0xC1000001 0x20000008</td><td>SDR</td><td>-</td></tr><tr><td>Macronix</td><td>Octal Flash</td><td>MX25UM513(2)45G</td><td>0xC1503051 0x20000014</td><td>SDR</td><td>-</td></tr><tr><td>Micron</td><td>Octal Flash</td><td>MT35XL512ABA</td><td>0xC1703001 0x20000018</td><td>SDR</td><td>-</td></tr></tbody></table><hr><h5 id="41-5-1-6-为-PortB-连接的闪存启用-Octal-DDR-模式"><a href="#41-5-1-6-为-PortB-连接的闪存启用-Octal-DDR-模式" class="headerlink" title="41.5.1.6 为 PortB 连接的闪存启用 Octal DDR 模式"></a>41.5.1.6 为 PortB 连接的闪存启用 Octal DDR 模式</h5><p>考虑到 FlexSPI 性能和易用性，<span style="color: red; font-weight: bold; ">ROM 假定八进制闪存在 DDR 模式下始终使用 DQS 引脚。</span></p><ul><li>若支持外部 DQS 焊盘，FlexSPI IP 可自动检测dummy cycle数。</li><li>使用配置选项Option0/1配置设备时，不支持自定义Octal DDR Read的Dummy Cycle数，必须使用 DQS 焊盘。</li><li><span style="color: red; font-weight: bold; ">然而，RT6xx 系列的 FlexSPI PortB 没有 DQS 引脚。要在端口 B 上启用Octal DDR Read支持，用户必须准备完整的 FCB（闪存配置块）并在 LUT 中配置适当的Dummy Cycle。</span></li></ul><p><strong>以 MX25UM51345G 为例</strong>：以下是用于在 FlexSPI 端口 B 上启用 DDR 模式的 FCB 二进制文件示例。请注意 FCB 中的两个字段需特别处理：</p><ul><li><strong><code>sflashA1Size</code></strong> 应设为 <code>0x0</code>，**<code>sflashB1Size</code>** 应设为外部闪存大小。</li><li><strong>FlexSPI LUT 表</strong> ：需使用读取命令的正确Dummy Cycle更新。</li></ul><style>.kiqtlyvdfrwx{zoom:80%;}</style><img src="/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-3/image-20250520131728026.png" class="kiqtlyvdfrwx" alt="image-20250520131728026"><p><strong>图 201. PortB 连接的闪存启用Octal DDR 模式示例</strong></p><p>FCB 准备就绪后，使用以下命令将闪存启用到 DDR 模式–&gt;</p><p><strong>操作步骤</strong>：</p><ol><li><p>写入 FCB 二进制文件到 RAM：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blhost.exe -p comxx write-memory 0x1c000 MX25UM51345G_DDR_FCB.bin</span><br></pre></td></tr></tbody></table></figure></li><li><p>配置 FlexSPI 以应用 FCB：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blhost.exe -p comxx configure-memory 0x9 0x1c000</span><br></pre></td></tr></tbody></table></figure></li></ol><hr><h4 id="41-5-2-SD-eMMC-启动"><a href="#41-5-2-SD-eMMC-启动" class="headerlink" title="41.5.2 SD/eMMC 启动"></a>41.5.2 SD/eMMC 启动</h4><p>BootROM支持将镜像从 SD/eMMC 加载到片上 SRAM，然后从片上 SRAM 引导。</p><h5 id="41-5-2-1-SD-eMMC-引导特性"><a href="#41-5-2-1-SD-eMMC-引导特性" class="headerlink" title="41.5.2.1 SD/eMMC 引导特性"></a>41.5.2.1 SD/eMMC 引导特性</h5><p>SD/eMMC 引导可通过 uSDHC 端口执行。BootROM支持以下标准卡类型（其他类型卡不保证支持）：</p><ul><li>eMMC 5.0 或更早版本</li><li>MMC 4.4 或更早版本</li><li>SD 3.0 或更早版本</li></ul><p>支持的标准模式：</p><ul><li>eMMC/MMC：4 位 / 8 位；<span style="color: red; font-weight: bold; ">全速率 SDR（26 MHz），高速 SDR/DDR（52 MHz）；</span></li><li>eMMC 4.4 或更高版本：支持快速引导。</li><li>SD：1 位 / 4 位；<span style="color: red; font-weight: bold; ">SDR12、SDR25、SDR50 和 SDR104。</span></li></ul><p>BootROM从 SD/eMMC 的<strong>固定地址</strong>加载用户应用镜像。<span style="color: red; font-weight: bold; ">为避免主引导记录（MBR）与用户应用镜像冲突，BootROM从 SD/eMMC 地址 4096（字节地址，块索引 8）加载镜像。</span></p><h5 id="41-5-2-2-OTP-中的-SD-eMMC-引导配置"><a href="#41-5-2-2-OTP-中的-SD-eMMC-引导配置" class="headerlink" title="41.5.2.2 OTP 中的 SD/eMMC 引导配置"></a>41.5.2.2 OTP 中的 SD/eMMC 引导配置</h5><p>与 SD/eMMC 引导相关的配置分配在 <code>BOOT_CFG2</code> 和 <code>BOOT_CFG3</code> OTP 字中，分配详情见表 1002。</p><p><strong>表 1012. BOOT_CFG2 引导配置</strong></p><table><thead><tr><th>字段名称</th><th>枚举名称</th><th>描述</th><th>偏移量</th><th>宽度</th><th>值</th></tr></thead><tbody><tr><td>SDHC_DEVICE_TYPE</td><td><code>eMMC_DEV</code><br><code>SD_DEV</code></td><td>连接到 SDHC 端口的设备类型： <br>0b - eMMC 设备 <br>1b - SD 卡设备</td><td>0</td><td>1</td><td></td></tr><tr><td>SDHC_BUS_WIDTH</td><td>-</td><td>连接到 SDHC 的设备总线宽度： <br>00b - SD 卡使用 1 位数据总线，eMMC 使用 4 位 <br>01b - SD 卡使用 4 位，eMMC 使用 8 位<br> 10b - eMMC 使用 4 位 DDR 模式（需 <code>SDHC_SPEED</code>=HIGH） <br>11b - eMMC 使用 8 位 DDR 模式（需 <code>SDHC_SPEED</code>=HIGH）</td><td>1</td><td>2</td><td></td></tr><tr><td>SDHC_SPEED</td><td>-</td><td>eMMC 设备和 SD 卡的速度等级： <br>00b - 正常速度（eMMC）/SDR12（SD） <br>01b - 高速（eMMC）/SDR25（SD） <br>10b - SDR50（SD，需 <code>SDHC_BUS_WIDTH</code>=<code>SD_4B_MMC_8B</code>）<br> 11b - SDR104（SD，需 <code>SDHC_BUS_WIDTH</code>=<code>SD_4B_MMC_8B</code>）</td><td>3</td><td>2</td><td></td></tr><tr><td>SDHC_PWR_CYCLE_EN</td><td>-</td><td>通过 <code>USDHC_RST</code> 焊盘启用 SDHC 电源循环： <br>0b - 禁用 <br>1b - 启用</td><td>5</td><td>1</td><td></td></tr><tr><td>SDHC0_PWR_POL</td><td>-</td><td>SDHC0 端口电源使能信号极性： <br>0b - 高有效 <br>1b - 低有效</td><td>6</td><td>1</td><td>-</td></tr><tr><td>SDHC1_PWR_POL</td><td>-</td><td>SDHC1 端口电源使能信号极性： <br>0b - 高有效 <br>1b - 低有效</td><td>7</td><td>1</td><td>-</td></tr></tbody></table><p><strong>表 1012. BOOT_CFG2 引导配置（续）</strong></p><table><thead><tr><th>字段名称</th><th>枚举名称</th><th>描述</th><th>偏移量</th><th>宽度</th><th>值</th></tr></thead><tbody><tr><td>SDHC_PWR_CYCLE_WAIT</td><td>-</td><td>关闭 SDHC 设备电源后的等待时间： <br>00b - 20 毫秒 <br>01b - 10 毫秒 <br>10b - 5 毫秒 <br>11b - 2.5 毫秒</td><td>8</td><td>2</td><td>-</td></tr><tr><td>SDHC_PWR_STABLE_WAIT</td><td>-</td><td>启用 SDHC 设备电源后电源稳定等待时间： <br>0b - 5 毫秒 <br>1b - 2.5 毫秒</td><td>10</td><td>1</td><td>-</td></tr><tr><td>SDHC0_CARD_VOLTAGE</td><td>-</td><td><span style="color: red; font-weight: bold; ">通过 <code>USDHC_VSELECT</code> 选择 SDHC0 电压：</span><br>0b - 3.3V <br>1b - 1.8V</td><td>11</td><td>1</td><td>-</td></tr><tr><td>SDHC1_CARD_VOLTAGE</td><td>-</td><td>通过 <code>USDHC_VSELECT</code> 选择 SDHC1 电压： <br>0b - 3.3V <br>1b - 1.8V</td><td>12</td><td>1</td><td>-</td></tr><tr><td>MMC_RESET_PRE_IDLE_STATE</td><td>-</td><td>启动引导模式前将 MMC 复位到预空闲状态： <br>0b - 复位到预空闲状态 <br>1b - 不复位</td><td>13</td><td>1</td><td>-</td></tr><tr><td>SDHC_FASTBOOT_MODE</td><td>-</td><td>启用 eMMC 快速引导模式： <br>0b - 正常模式（传输模式） <br>1b - 引导模式</td><td>14</td><td>1</td><td>-</td></tr><tr><td>SDHC_FASTBOOT_ACK_EN</td><td>-</td><td>eMMC 快速引导确认功能： <br>0b - 禁用引导模式确认 <br>1b - 启用引导模式确认</td><td>15</td><td>1</td><td>-</td></tr><tr><td>SDHC_PAD</td><td>-</td><td>SDHC 焊盘设置： <br>0b - 默认 <code>SDIOPADCTL</code> <br>1b - SDIOPADCTL=val（val 为自定义值）</td><td>16</td><td>1</td><td>-</td></tr></tbody></table><p><strong>表 1013. BOOT_CFG3 引导配置</strong></p><table><thead><tr><th>字段名称</th><th>枚举名称</th><th>描述</th><th>偏移量</th><th>宽度</th><th>值</th></tr></thead><tbody><tr><td>SDHC_DLL_TUNING_OVERRIDE_ENABLE</td><td>-</td><td>DLL 延迟调整覆盖使能： <br>0 - 默认（DLL 延迟起始 10，步长 2） <br>1 - 通过 <code>SDHC_DLL_TUNING_START</code> 和 <code>SDHC_DLL_TUNING_STEP</code> 覆盖</td><td>7</td><td>1</td><td>-</td></tr><tr><td>SDHC_DLL_TUNING_START</td><td>-</td><td>DLL 延迟起始值（需 <code>SDHC_DLL_TUNING_OVERRIDE_ENABLE</code>=1）</td><td>8</td><td>8</td><td>-</td></tr><tr><td>SDHC_DLL_TUNING_STEP</td><td>-</td><td>DLL 延迟步长值（需 <code>SDHC_DLL_TUNING_OVERRIDE_ENABLE</code>=1）： 0 - 步长 = 1 <br>非 0 - 步长 = val</td><td>16</td><td>3</td><td>-</td></tr></tbody></table><h5 id="41-5-2-3-SD-eMMC-引导流程"><a href="#41-5-2-3-SD-eMMC-引导流程" class="headerlink" title="41.5.2.3 SD/eMMC 引导流程"></a>41.5.2.3 SD/eMMC 引导流程</h5><p>图 202 说明了 SD/eMMC 的简要引导流程。</p><style>.erfymxodchqu{zoom:100%;}</style><img src="/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-3/image-20250520143743354.png" class="erfymxodchqu"><p><strong>图 202. SD/eMMC 引导流程</strong></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RT600-RM-CH41：RT6xx-非安全BootROM-3&quot;&gt;&lt;a href=&quot;#RT600-RM-CH41：RT6xx-非安全BootROM-3&quot; class=&quot;headerlink&quot; title=&quot;RT600 RM CH41：RT6xx 非安全BootROM (3)&quot;&gt;&lt;/a&gt;RT600 RM CH41：RT6xx 非安全BootROM (3)&lt;/h1&gt;&lt;h2 id=&quot;41-4-引导模式&quot;&gt;&lt;a href=&quot;#41-4-引导模式&quot; class=&quot;headerlink&quot; title=&quot;41.4 引导模式&quot;&gt;&lt;/a&gt;41.4 引导模式&lt;/h2&gt;&lt;p&gt;ROM 引导加载程序支持以下引导模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Master Boot 模式&lt;/li&gt;
&lt;li&gt;Recovery Boot 模式&lt;/li&gt;
&lt;li&gt;Serial Boot 模式&lt;/li&gt;
&lt;li&gt;ISP Boot 模式&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT600" scheme="https://dustofstars.github.io/categories/NXP/RT600/"/>
    
    <category term="BootROM" scheme="https://dustofstars.github.io/categories/NXP/RT600/BootROM/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="RT600" scheme="https://dustofstars.github.io/tags/RT600/"/>
    
    <category term="BootROM" scheme="https://dustofstars.github.io/tags/BootROM/"/>
    
  </entry>
  
  <entry>
    <title>RT600 BootROM RM解析 (2)</title>
    <link href="https://dustofstars.github.io/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-2/"/>
    <id>https://dustofstars.github.io/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-2/</id>
    <published>2025-05-19T09:10:09.000Z</published>
    <updated>2025-05-19T09:10:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RT600-RM-CH41：RT6xx-非安全启动-ROM-2"><a href="#RT600-RM-CH41：RT6xx-非安全启动-ROM-2" class="headerlink" title="RT600 RM CH41：RT6xx 非安全启动 ROM(2)"></a>RT600 RM CH41：RT6xx 非安全启动 ROM(2)</h1><h2 id="41-3-概述"><a href="#41-3-概述" class="headerlink" title="41.3 概述"></a>41.3 概述</h2><p>内部 ROM 存储器用于存储启动代码。复位后，ARM 处理器从该存储器开始执行代码。每次器件上电或复位时，都会执行BootROM代码。</p><p>由于 RT6xx 没有用于代码和数据存储的内部 Flash，因此必须将image存储在其他位置，以便在复位时下载，或者 CPU 可以从外部存储器（XIP）执行。image可以从外部 Flash 加载到片上 SRAM 中，也可以通过串行端口（UART、SPI、I2C、USB）下载。然后对代码进行验证，引导 ROM 会将向量指向片上 SRAM。</p><p><span style="color: red; font-weight: bold; ">引导加载程序根据 OTP 位和 ISP 引脚的值，以及image header类型定义，决定是将代码下载到片上 SRAM 中还是从外部存储器运行。</span></p><ul><li>BootROM 首先检查 OTP 位设置，然后检查 ISP 引脚。</li><li><span style="color: green;"><u>如果 OTP 字 BOOT_CFG [0] 中的位 [3:0] 未编程（4b’0000），则引导源由 ISP 引导引脚（PIO1_15、PIO1_16 和 PIO1_17）的状态决定</u></span>，见表 994。</li></ul><span id="more"></span><p><strong>表 994. 基于 BOOT_CFG [0] 中 PRIMARY_BOOT_SRC 位的主引导源</strong></p><table><thead><tr><th>引导模式字段</th><th>字段</th><th>主引导源（又称主引导源）</th></tr></thead><tbody><tr><td>ISP_PIN_BOOT</td><td>b’0000</td><td><span style="color: red;">ISP 引脚将决定引导源。</span></td></tr><tr><td>FLEXSPI_BOOT_PORT_A</td><td>b’0001</td><td>从 FlexSPI0 端口 A 的八 / 四路 SPI 闪存设备引导。</td></tr><tr><td>SDHC0_BOOT</td><td>b’0010</td><td>从连接到 SDHC0 端口的 eMMC 设备或 SD 卡引导。</td></tr><tr><td>SDHC1_BOOT</td><td>b’0011</td><td>从连接到 SDHC1 端口的 eMMC 设备或 SD 卡引导。</td></tr><tr><td>SPI_SLV_BOOT</td><td>b’0100</td><td>通过使用主引导模式的 SPI 从接口引导。</td></tr><tr><td>FLEXSPI_BOOT_PORT_B</td><td>b’0101</td><td>从 FlexSPI0 端口 B 的八 / 四路 SPI 闪存设备引导。</td></tr><tr><td>UART_BOOT</td><td>b’0110</td><td>通过使用主引导模式的 UART 接口引导。</td></tr><tr><td>SPI_FLASH_BOOT</td><td>b’0111</td><td>通过 SPI 接口从 1 位 NOR 闪存引导。使用的 SPI 实例由熔丝字 0x60 的位 17 到 19 选择，更多细节请参考熔丝图。</td></tr><tr><td>USB_HID</td><td>b’1000</td><td>通过使用主引导模式的 USB HID 接口引导。</td></tr><tr><td>ISP_BOOT</td><td>b’0101</td><td>进入 ISP 模式，熔丝字 0x60 的位 4 到 6 决定 ISP 模式使用的外设，更多细节请参考熔丝图。</td></tr><tr><td>–</td><td>b’1010</td><td>保留</td></tr><tr><td>FLEXSPI_REC_BOOT_PORT_B</td><td>b’1011</td><td>从 FlexSPI0 端口 B 的八 / 四路 SPI 闪存设备引导；如果未找到image，则通过 FlexComm 使用 SPI 闪存设备检查恢复引导。使用的 FlexComm 实例由熔丝字 0x60 的位 17 到 19 选择，更多细节请参考熔丝图。</td></tr><tr><td>FLEXSPI_REC_BOOT_PORT_A</td><td>b’1100</td><td>从 FlexSPI0 端口 A 的八 / 四路 SPI 闪存设备引导；如果未找到image，则通过 FlexComm 使用 SPI 闪存设备检查恢复引导。使用的 FlexComm 实例由熔丝字 0x60 的位 17 到 19 选择，更多细节请参考熔丝图。</td></tr><tr><td>SDHC0_REC_BOOT</td><td>b’1101</td><td>从 SDHC0 端口设备引导。如果未找到image，则通过 FlexComm 使用 SPI 闪存设备检查恢复引导。使用的 FlexComm 实例由熔丝字 0x60 的位 17 到 19 选择，更多细节请参考熔丝图。</td></tr><tr><td>SDHC1_REC_BOOT</td><td>b’1110</td><td>从 SDHC1 端口设备引导。如果未找到image，则通过 FlexComm 使用 SPI 闪存设备检查恢复引导。使用的 FlexComm 实例由熔丝字 0x60 的位 17 到 19 选择，更多细节请参考熔丝图。</td></tr><tr><td>–</td><td>b’1111</td><td>保留</td></tr></tbody></table><p>如果未设置 <code>PRIMARY_BOOT_SRC</code> 位，RT6xx 将读取 ISP 引脚的状态以确定引导源。见表 995。</p><p><strong>表 995. 基于 ISP 引脚的引导模式和 ISP 下载器模式</strong></p><table><thead><tr><th>引导模式</th><th>ISP2 引脚<br>PIO1_17</th><th>ISP1 引脚<br>PIO1_16</th><th>ISP0 引脚<br>PIO1_15</th><th>描述</th></tr></thead><tbody><tr><td>-</td><td>低</td><td>低</td><td>低</td><td>保留</td></tr><tr><td>SDIO0（SD 卡）</td><td>低</td><td>低</td><td>高</td><td><span style="color: red;">从连接到 SDIO 1 接口的 SD 卡设备引导。</span>RT6xx 将在 SD 卡设备中查找有效image。如果未找到有效image，RT6xx 将根据表 1114“BOOT_CFG [0] 位字段” 中定义的 OTP DEFAULT_ISP_MODE 位（6:4，BOOT_CFG [0]）进入 ISP 引导模式。</td></tr><tr><td>FlexSPI 从端口 B 引导</td><td>低</td><td>高</td><td>低</td><td>从连接到 FlexSPI 接口 0 端口 B 的四路或八路 SPI 闪存设备引导。RT6xx 将在外部四路 / 八路 SPI 闪存设备中查找有效image。如果未找到有效image，RT6xx 将进入恢复引导或 ISP 引导模式。</td></tr><tr><td>FlexSPI 从端口 A 引导</td><td>低</td><td>高</td><td>高</td><td>从连接到 FlexSPI 接口 0 端口 A 的四路或八路 SPI 闪存设备引导。RT6xx 将在外部四路 / 八路 SPI 闪存设备中查找有效image。如果未找到有效image，RT6xx 将进入恢复引导或 ISP 引导模式。</td></tr><tr><td>SDIO 0（eMMC）</td><td>高</td><td>低</td><td>低</td><td><span style="color: red; ">从连接到 SDIO 0 接口的 eMMC 设备引导</span>。RT6xx 将在 eMMC 设备中查找有效image。如果未找到有效image，RT6xx 将根据表 1114“BOOT_CFG [0] 位字段” 中定义的 OTP DEFAULT_ISP_MODE 位（6:4，BOOT_CFG [0]）的值进入 ISP 引导模式。</td></tr><tr><td>-</td><td>高</td><td>低</td><td>高</td><td>保留</td></tr><tr><td>串行 ISP（UART、SPI、I2C、USB-HID）</td><td>高</td><td>高</td><td>低</td><td>串行接口（UART、SPI 和 I2C、USB-HID）用于对 OTP、外部 Flash、SD 或 eMMC 设备进行编程。</td></tr><tr><td>111</td><td>高</td><td>高</td><td>高</td><td>串行主引导（SPI 从机、I2C 从机或 UART、USB-HID）用于通过串行接口（SPI 从机、I2C 从机或 UART、USB-HID）下载引导image。</td></tr></tbody></table><p>表 996 列出了 ISP 引脚分配，这些是 ROM 代码使用的默认引脚分配，无法更改。</p><p><strong>表 996. ISP 引脚分配</strong></p><table><thead><tr><th>引导接口</th><th>引脚 (s)</th><th>功能 / 注释</th></tr></thead><tbody><tr><td><strong>FlexSPI0 端口 A</strong></td><td>PIO1_18</td><td>FLEXSPI0A_SCLK</td></tr><tr><td></td><td>PIO1_19</td><td>FLEXSPI0A_SS0_N</td></tr><tr><td></td><td>PIO1_20</td><td>FLEXSPI0A_DATA0</td></tr><tr><td></td><td>PIO1_21</td><td>FLEXSPI0A_DATA1</td></tr><tr><td></td><td>PIO1_22</td><td>FLEXSPI0A_DATA2</td></tr><tr><td></td><td>PIO1_23</td><td>FLEXSPI0A_DATA3</td></tr><tr><td></td><td>PIO1_24</td><td>FLEXSPI0A_DATA4</td></tr><tr><td></td><td>PIO1_25</td><td>FLEXSPI0A_DATA5</td></tr><tr><td></td><td>PIO1_26</td><td>FLEXSPI0A_DATA6</td></tr><tr><td></td><td>PIO1_27</td><td>FLEXSPI0A_DATA7</td></tr><tr><td></td><td>PIO1_28</td><td>FLEXSPI0A_DQS</td></tr><tr><td></td><td>PIO1_29</td><td>FLEXSPI0A_SS1_N</td></tr><tr><td><strong>FlexSPI0 端口 B</strong></td><td>PIO1_29</td><td>FLEXSPI0B_SCLK</td></tr><tr><td></td><td>PIO2_19</td><td>FLEXSPI0B_SS0_N</td></tr><tr><td></td><td>PIO1_11</td><td>FLEXSPI0B_DATA0</td></tr><tr><td></td><td>PIO1_12</td><td>FLEXSPI0B_DATA1</td></tr><tr><td></td><td>PIO1_13</td><td>FLEXSPI0B_DATA2</td></tr><tr><td></td><td>PIO1_14</td><td>FLEXSPI0B_DATA3</td></tr><tr><td></td><td>PIO2_17</td><td>FLEXSPI0B_DATA4</td></tr><tr><td></td><td>PIO2_18</td><td>FLEXSPI0B_DATA5</td></tr><tr><td></td><td>PIO2_22</td><td>FLEXSPI0B_DATA6</td></tr><tr><td></td><td>PIO2_23</td><td>FLEXSPI0B_DATA7</td></tr><tr><td></td><td>PIO2_21</td><td>FLEXSPI0B_SS1_N</td></tr><tr><td><strong>USB</strong></td><td>USB1_VBUS</td><td></td></tr><tr><td></td><td>VDD1V8</td><td></td></tr><tr><td></td><td>USB1_VDD3V3</td><td></td></tr><tr><td></td><td>USB1_DM</td><td></td></tr><tr><td></td><td>USB1_DP</td><td></td></tr><tr><td><strong>SPI 从机</strong></td><td>PIO1_11</td><td>HS_SPI_SCK（Flexcomm 14）</td></tr><tr><td></td><td>PIO1_12</td><td>HS_SPI_MISO（Flexcomm14）</td></tr><tr><td></td><td>PIO1_13</td><td>HS_SPI_MOSI（Flexcomm14）</td></tr><tr><td></td><td>PIO1_14</td><td>HS_SPI_SSEL0（Flexcomm14）</td></tr><tr><td><strong>I2C 从机</strong></td><td>PIO0_15</td><td>FC2_TXD_SCL_MISO_WS</td></tr><tr><td></td><td>PIO0_16</td><td>FC2_RXD_SDA_MOSI_DATA</td></tr><tr><td><strong>UART</strong></td><td>PIO0_1</td><td>FC0_TXD_SCL_MISO_WS</td></tr><tr><td></td><td>PIO0_2</td><td>FC0_RXD_SDA_MOSI_DATA</td></tr></tbody></table><p><strong>表 996. ISP 引脚分配（续）</strong></p><table><thead><tr><th>引导接口</th><th>引脚 (s)</th><th>功能 / 注释</th></tr></thead><tbody><tr><td><strong>SDIO0</strong></td><td>PIO1_30</td><td>SD0_CLK</td></tr><tr><td></td><td>PIO1_31</td><td>SD0_CMD</td></tr><tr><td></td><td>PIO2_0</td><td>SD0_D[0]</td></tr><tr><td></td><td>PIO2_1</td><td>SD0_D[1]</td></tr><tr><td></td><td>PIO2_2</td><td>SD0_D[2]</td></tr><tr><td></td><td>PIO2_3</td><td>SD0_D[3]</td></tr><tr><td></td><td>PIO2_4</td><td>SD0_WR_PRT</td></tr><tr><td></td><td>PIO2_5</td><td>SD0_D[4]</td></tr><tr><td></td><td>PIO2_6</td><td>SD0_D[5]</td></tr><tr><td></td><td>PIO2_7</td><td>SD0_D[6]</td></tr><tr><td></td><td>PIO2_8</td><td>SD0_D[7]</td></tr><tr><td></td><td>PIO2_9</td><td>SD0_CARD_DET_N</td></tr><tr><td></td><td>PIO2_10</td><td>SD0_RESET_N</td></tr><tr><td></td><td>PIO2_11</td><td>SD0_VOLT</td></tr><tr><td><strong>SDIO1</strong></td><td>PIO3_8</td><td>SD1_CLK</td></tr><tr><td></td><td>PIO3_9</td><td>SD1_CMD</td></tr><tr><td></td><td>PIO3_10</td><td>SD1_D[0]</td></tr><tr><td></td><td>PIO3_11</td><td>SD1_D[1]</td></tr><tr><td></td><td>PIO3_12</td><td>SD1_D[2]</td></tr><tr><td></td><td>PIO3_13</td><td>SD1_D[3]</td></tr><tr><td></td><td>PIO3_14</td><td>SD1_WR_PRT</td></tr><tr><td></td><td>PIO3_15</td><td>SD1_D[4]</td></tr><tr><td></td><td>PIO3_16</td><td>SD1_D[5]</td></tr><tr><td></td><td>PIO3_17</td><td>SD1_D[6]</td></tr><tr><td></td><td>PIO3_18</td><td>SD1_D[7]</td></tr><tr><td></td><td>PIO3_19</td><td>SD1_CARD_DET_N</td></tr><tr><td></td><td>PIO3_20</td><td>SD1_RESET_N</td></tr><tr><td></td><td>PIO3_21</td><td>SD1_VOLT</td></tr><tr><td><strong>SPI 闪存（恢复引导）</strong></td><td>-</td><td>用于恢复 SPI 闪存引导的 Flexcomm 端口。</td></tr><tr><td></td><td>FC0</td><td>使用 Flexcomm0 引脚 PIO0_0（SCK）、PIO0_1（MISO）、PIO0_2（MOSI）、PIO0_3（SSEL）</td></tr><tr><td></td><td>FC1</td><td>使用 Flexcomm1 引脚 PIO0_7（SCK）、PIO0_8（MISO）、PIO0_9（MOSI）、PIO0_10（SSEL）[1]</td></tr><tr><td></td><td>FC2</td><td>使用 Flexcomm2 引脚 PIO0_14（SCK）、PIO0_15（MISO）、PIO0_16（MOSI）、PIO0_17（SSEL）</td></tr><tr><td></td><td>FC3</td><td>使用 Flexcomm3 引脚 PIO0_21（SCK）、PIO0_22（MISO）、PIO0_23（MOSI）、PIO0_24（SSEL）</td></tr><tr><td></td><td>FC4</td><td>使用 Flexcomm4 引脚 PIO0_28（SCK）、PIO0_29（MISO）、PIO0_30（MOSI）、PIO0_31（SSEL）</td></tr><tr><td></td><td>FC5</td><td>使用 Flexcomm5 引脚 PIO1_3（SCK）、PIO1_4（MISO）、PIO1_5（MOSI）、PIO1_6（SSEL）</td></tr><tr><td></td><td>FC6</td><td>使用 Flexcomm6 引脚 PIO3_25（SCK）、PIO3_26（MISO）、PIO3_27（MOSI）、PIO3_28（SSEL）</td></tr><tr><td></td><td>FC7</td><td>使用 Flexcomm 7 引脚 PIO4_0（SCK）、PIO4_1（MISO）、PIO4_2（MOSI）、PIO4_3（SSEL）</td></tr><tr><td><strong>ISP</strong></td><td>PIO1_17</td><td>ISP 选择位 2</td></tr><tr><td></td><td>PIO1_16</td><td>ISP 选择位 1</td></tr><tr><td></td><td>PIO1_15</td><td>ISP 选择位 0</td></tr></tbody></table><p>[1] 注：<span style="color: green;">SPI 闪存恢复引导引脚功能与 JTAG 边界扫描功能复用。为确保不会意外进入边界扫描模式，应使用弱下拉电阻（100 kohm）将 TRST 引脚外部拉低，以确保 SPI 闪存恢复引导操作正常。</span></p><style>.lqrnfouuxlge{zoom:80%;}</style><img src="/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-2/TopLevelBootFlow.png" class="lqrnfouuxlge" alt="TopLevelBootFlow"><p><strong>图 187. 顶层引导流程</strong></p><p>图 187 显示了顶层引导流程。引导流程在复位释放后开始。CPU 时钟由 OTP 字段 <code>BOOT_CLK_SPEED</code> 决定，<span style="color: red; font-weight: bold; ">默认情况下为来自 IRC48M 时钟源的 48 MHz</span>。如果 <code>PRIMARY_BOOT_SRC</code> = 4b’0000，引导 ROM 将根据 <code>PRIMARY_BOOT_SRC</code> 或复位期间 ISP 引脚的状态确定引导模式。当 Cortex-M33 启动引导加载程序时，SWD 访问将被禁用，直到引导image开始执行或引导加载程序进入 ISP 模式。</p><p>一旦确定引导模式，并且在所选外部 Flash 设备（SD、eMMC 或串行 NOR Flash）上存在引导image，ROM 引导加载程序将开始<span style="color: red; font-weight: bold; ">将image 头的前 64 字节</span>从外部 Flash 设备复制到片上 SRAM 中。image的开头遵循表 997 中提到的格式。如果boot image通过串行接口（通过 UART、SPI 或 USB）下载，则包括image头在内的整个image已加载到 SRAM 中。</p><p>BootROM 检查以下内容以确保image完整性：</p><ul><li>使用头和image标记验证image。</li><li>使用 CRC32 验证image（如果image头中启用了 CRC 检查功能）。</li></ul><p>引导加载程序通过检查位于偏移量 <code>0x24</code>（<code>imageType</code>）的image类型开始扫描用户image。如果检测到有效image类型，则开始验证image头。通过读取image头中偏移量 <code>0x34</code>（<code>imageLoadAddress</code>）处的image加载地址并将其<span style="color: red; font-weight: bold; ">用作指向有效image头结构的指针</span>，继续对image头进行鉴定。如果 imageType 和 imageLoadAddress 均不为零，则 imageLoadAddress 指向的地址必须包含正在检查的image头。</p><p>image头验证完成后，通过检查image类型字段继续进行鉴定。更多详细信息请参见表 998。<span style="color: green;">如果可引导（非 XIP）image位于外部闪存中，整个image将首先加载到片上 SRAM 中，然后如果启用了 CRC 校验功能，将使用image头中的 imageLength 字段作为长度来执行 CRC 校验。</span></p><p>如果 CRC 功能启用，将对image（片上或外部 XIP image）执行 CRC 校验。CRC 计算从image起始偏移 0x0 处开始，持续到 imageLength 字段指定的字节数（不包括 crcChecksum 字段）。CRC 计算完成后，通过将结果与image头中的 crcChecksum 字段进行比较来确定image有效性：若匹配，则判定image有效，否则判定为无效。</p><p><strong>表 997. image header 格式</strong></p><table><thead><tr><th>偏移量</th><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>0x00-0x1F</td><td>保留</td><td>-</td></tr><tr><td>0x20</td><td>imageLength</td><td>image长度</td></tr><tr><td>0x24</td><td>imageType</td><td>image类型 <br>0x0000 - 普通image <br>0x0001 - 普通签名image <br>0x0002 - 普通 CRC image <br>0x0003 - 加密签名image <br>0x0004 - 普通签名 XIP image <br>0x0005 - 普通 CRC XIP image <br>0x8001 - 包含KeyStore的普通签名image<br>0x8003 - 包含KeyStore的加密签名image</td></tr><tr><td>0x28</td><td>authBlockOffset/crcChecksum</td><td>认证块偏移量 或 CRC32 校验和</td></tr><tr><td>0x2C-0x33</td><td>保留</td><td>-</td></tr><tr><td>0x34</td><td><code>imageLoadAddress</code></td><td>image加载地址</td></tr><tr><td>0x38-0x3F</td><td>保留</td><td>-</td></tr></tbody></table><p><strong>表 998. Plain image布局</strong></p><table><thead><tr><th>偏移量</th><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>0x00</td><td>堆栈指针 Stack Pointer</td><td>普通 CM33 内核异常处理程序</td></tr><tr><td>0x04</td><td>复位处理程序 Reset Handler</td><td></td></tr><tr><td>0x08</td><td>NMI_Handler</td><td>不可屏蔽中断处理程序</td></tr><tr><td>0x0C</td><td>HardFault_Handler</td><td>硬错误处理程序</td></tr><tr><td>0x10</td><td>MemManage_Handler</td><td>内存管理错误处理程序</td></tr><tr><td>0x14</td><td>BusFault_Handler</td><td>总线错误处理程序</td></tr><tr><td>0x18</td><td>UsageFault_Handler</td><td>使用错误处理程序</td></tr><tr><td>0x1C</td><td>SecureFault_Handler</td><td>安全错误处理程序</td></tr><tr><td>0x20</td><td><code>imageLength</code></td><td>image长度</td></tr><tr><td>0x24</td><td><code>imageType</code></td><td>image类型 0x0000 - 普通image 0x0001 - 普通签名image 0x0002 - 普通 CRC image 0x0004 - 普通签名 XIP image 0x0005 - 普通 CRC XIP image 0x8001 - 包含密钥存储的普通签名image</td></tr><tr><td>0x28</td><td>authBlockOffset</td><td>认证块偏移量或 CRC32 校验和</td></tr><tr><td>0x2C</td><td>SVC Handler</td><td>普通 CM33 内核异常处理程序</td></tr><tr><td>0x30</td><td>DebugMon_Handler</td><td>调试监控处理程序</td></tr><tr><td>0x34</td><td><code>imageLoadAddress</code></td><td>image加载地址 <br><strong>注</strong>：imageLoadAddress 必须 ≥ <code>0x1C000</code>。<br>地址 0x0 - 0x1BFFF 由 ROM 使用，直至用户代码启动。</td></tr><tr><td>0x38</td><td>PendSV_Handler</td><td>PendSV 处理程序（普通 CM33 内核异常处理程序）</td></tr><tr><td>0x3C</td><td>SysTick_Handler</td><td>系统滴答定时器处理程序</td></tr></tbody></table><p><strong>表 999. XIP 镜像布局（FlexSPI）</strong></p><table><thead><tr><th>偏移量</th><th>宽度（字节）</th><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>0x0000_0000</td><td>256</td><td><span style="color: red; font-weight: bold; ">KeyBlob用于 OTFAD</span></td><td>可选。若未启用 OTFAD，则全部编程为 0x00。</td></tr><tr><td><code>0x0000_0400</code></td><td>512</td><td>闪存配置块（FCB）</td><td>OSPI 闪存配置块。若 OTP 中的 <code>FLEXSPI_AUTO_PROBE_EN</code> 未熔断，则需要此块。</td></tr><tr><td>0x0000_0600</td><td>4</td><td>Boot image version</td><td>使用双镜像乒乓引导时，此字段用于存储引导镜像版本。更多细节请参考 FlexSPI 引导。</td></tr><tr><td><code>0x0000_0800</code></td><td>2048</td><td>KeyStore</td><td>固定 KeyStore 字段。若启用 KeyStore 功能，则需要此字段。</td></tr><tr><td><code>0x0000_1000</code></td><td>image大小</td><td>Bootable image</td><td>引导镜像，以有效image header开始。</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RT600-RM-CH41：RT6xx-非安全启动-ROM-2&quot;&gt;&lt;a href=&quot;#RT600-RM-CH41：RT6xx-非安全启动-ROM-2&quot; class=&quot;headerlink&quot; title=&quot;RT600 RM CH41：RT6xx 非安全启动 ROM(2)&quot;&gt;&lt;/a&gt;RT600 RM CH41：RT6xx 非安全启动 ROM(2)&lt;/h1&gt;&lt;h2 id=&quot;41-3-概述&quot;&gt;&lt;a href=&quot;#41-3-概述&quot; class=&quot;headerlink&quot; title=&quot;41.3 概述&quot;&gt;&lt;/a&gt;41.3 概述&lt;/h2&gt;&lt;p&gt;内部 ROM 存储器用于存储启动代码。复位后，ARM 处理器从该存储器开始执行代码。每次器件上电或复位时，都会执行BootROM代码。&lt;/p&gt;
&lt;p&gt;由于 RT6xx 没有用于代码和数据存储的内部 Flash，因此必须将image存储在其他位置，以便在复位时下载，或者 CPU 可以从外部存储器（XIP）执行。image可以从外部 Flash 加载到片上 SRAM 中，也可以通过串行端口（UART、SPI、I2C、USB）下载。然后对代码进行验证，引导 ROM 会将向量指向片上 SRAM。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: red; font-weight: bold; &quot;&gt;引导加载程序根据 OTP 位和 ISP 引脚的值，以及image header类型定义，决定是将代码下载到片上 SRAM 中还是从外部存储器运行。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BootROM 首先检查 OTP 位设置，然后检查 ISP 引脚。&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: green;&quot;&gt;&lt;u&gt;如果 OTP 字 BOOT_CFG [0] 中的位 [3:0] 未编程（4b’0000），则引导源由 ISP 引导引脚（PIO1_15、PIO1_16 和 PIO1_17）的状态决定&lt;/u&gt;&lt;/span&gt;，见表 994。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT600" scheme="https://dustofstars.github.io/categories/NXP/RT600/"/>
    
    <category term="BootROM" scheme="https://dustofstars.github.io/categories/NXP/RT600/BootROM/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="RT600" scheme="https://dustofstars.github.io/tags/RT600/"/>
    
    <category term="BootROM" scheme="https://dustofstars.github.io/tags/BootROM/"/>
    
  </entry>
  
  <entry>
    <title>RT600 BootROM RM解析 (1)</title>
    <link href="https://dustofstars.github.io/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-1/"/>
    <id>https://dustofstars.github.io/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-1/</id>
    <published>2025-05-19T09:09:07.000Z</published>
    <updated>2025-05-19T09:09:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RT600-RM-CH41：RT6xx-非安全BootROM-1"><a href="#RT600-RM-CH41：RT6xx-非安全BootROM-1" class="headerlink" title="RT600 RM CH41：RT6xx 非安全BootROM (1)"></a>RT600 RM CH41：RT6xx 非安全BootROM (1)</h1><span id="more"></span><blockquote><style>.bntjxaxlmxmk{zoom:150%;}</style><img src="/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-1/image-20250519170750865.png" class="bntjxaxlmxmk" alt="image-20250519170750865"></blockquote><h2 id="41-1-如何阅读本章"><a href="#41-1-如何阅读本章" class="headerlink" title="41.1 如何阅读本章"></a>41.1 如何阅读本章</h2><p>本章适用于所有 RT6xx 器件。</p><h3 id="41-1-1-RT6xx-上的BootROM-有什么作用"><a href="#41-1-1-RT6xx-上的BootROM-有什么作用" class="headerlink" title="41.1.1 RT6xx 上的BootROM 有什么作用"></a>41.1.1 RT6xx 上的BootROM 有什么作用</h3><p>RT6xx 是一种无内部闪存的 MCU，因此在 MCU 启动前，启动镜像需要存储在外部非易失性启动介质中。读取启动镜像时，需要BootROM 支持访问外部非易失性存储。RT6xx BootROM 支持从外部非易失性存储器（如串行 NOR FLASH、SD 卡、eMMC 设备）启动。</p><p>BootROM 固定了 FlexSPI 模块（串行 NOR 闪存）/ uSDHC 模块（SD/eMMC 存储器）与 MCU 器件之间的外部存储设备引脚连接。因此，设计应用板时，必须为启动接口提供正确的引脚连接。有关引脚连接和其他细节，请参考 41.5 节 “主启动模式”。</p><p>由于 RT6xx 支持三种不同的启动设备，ROM 需要一种方式来决定从哪个设备启动。在 RT6xx ROM 中，通过 ISP 引脚（PIO1_17（ISP2）、PIO1_16（ISP1）、PIO1_15（ISP0））或 OTP 熔丝字 0x60 配置选择启动设备。</p><p>基于 ISP 引脚的启动模式 和 ISP 下载器模式的详细信息见表 995 “基于 ISP 引脚的启动模式和 ISP 下载器模式”，基于 BOOT_CFG [0] 中 <code>PRIMARY_BOOT_SRC</code> 位的 OTP 详细启动设备选择见表 994“基于 BOOT_CFG [0] 中 PRIMARY_BOOT_SRC 位的主启动源”。</p><p>RT6xx BootROM 支持在 ISP 模式（系统编程模式）下通过 ROM ISP 命令擦除 / 编程 / 读取外部非易失性存储器，以将启动镜像放置到外部非易失性存储器中。更多细节，请参考 41.8.16 节 “外部存储器支持”。</p><h3 id="41-1-2-RT6xx-如何启动"><a href="#41-1-2-RT6xx-如何启动" class="headerlink" title="41.1.2 RT6xx 如何启动"></a>41.1.2 RT6xx 如何启动</h3><p>RT6xx 通过BootROM 实现支持三种启动设备。</p><p><span style="color: green;  ">对于 FlexSPI 串行 NOR 闪存启动，有两种可能：</span></p><blockquote><p>加载到 RAM 启动和 XIP 启动。</p></blockquote><ol><li>对于加载到 RAM 启动，BootROM 运行后，会根据连接到 MCU 器件的外部 NOR 闪存类型初始化 FlexSPI 模块。ROM 从 NOR 闪存设备的偏移地址 <code>0x1000</code> 将启动镜像加载到 MCU 内部 SRAM 中，然后跳转到 SRAM 运行启动镜像。</li><li>对于 XIP 启动，BootROM 仅从 NOR 闪存设备引导镜像。启动镜像内部的镜像头会告诉 ROM 该启动镜像是加载到 RAM 的镜像还是 XIP 镜像。有关启动镜像头的更多细节，请参考 <span style="color: green;">表 997 “镜像头格式”</span>。</li></ol><blockquote><p>FlexSPI 启动还支持双镜像启动。如果选择 FlexSPI 作为启动设备，默认支持根据镜像版本选择引导哪个镜像，这称为乒乓启动。</p><p>在 FlexSPI 启动期间，ROM 始终尝试引导最新版本的镜像，如果最新启动镜像引导失败，ROM 会尝试引导旧版本的镜像。如果两个镜像引导都失败，ROM 将进入 ISP 模式。</p><p>有关乒乓启动的更多细节，请参考 41.5.1.4 节 “FlexSPI 双镜像乒乓启动”。</p></blockquote><hr><p>SD/eMMC 存储设备不支持 XIP 访问，因此BootROM 仅支持加载到 RAM 启动。与 FlexSPI NOR 闪存启动一样，ROM 在上电后初始化 uSDHC 接口，将启动镜像从设备偏移地址 <code>0x1000</code> 复制到内部 SRAM，然后跳转到 SRAM 运行启动镜像。</p><p>有关 FlexSPI NOR 闪存和 SD/eMMC 启动的更多细节，请参考 41.3 节 “概述”。</p><ul><li>当 LDO_ENABLE 外部接地为低电平时，用户必须在 VDDCORE=1.0V 或更高（低功耗 / 正常时钟模式）或 VDDCORE=1.13V（高速时钟）下启动。此后，VDDCORE 可以调整到所需电平。</li><li>此外，当执行任何 OTP 读 / 写功能时，无论 LDO_ENABLE 外部接地为高电平还是低电平，VDDCORE 电压必须设置为 1.0V 或更高。</li><li>对于 LDO_ENABLE=1，可以使用 <code>POWER_SetLdoVoltageForFreq</code> API 函数在内部将片上稳压器电压配置为 VDDCORE。</li></ul><h4 id="41-1-2-1-启动时的时钟速度"><a href="#41-1-2-1-启动时的时钟速度" class="headerlink" title="41.1.2.1 启动时的时钟速度"></a>41.1.2.1 启动时的时钟速度</h4><p><span style="color: red; font-weight: bold; ">设备启动时使用的时钟速率由 OTP 配置决定</span>。OTP 字 BOOT_CFG [0] 的位 7 包含 <code>BOOT_CLK_SPEED</code> 控制位，见表 990。<strong>表 990. 启动时钟速率</strong></p><table><thead><tr><th>模式</th><th>描述</th><th>ROM 支持的性能 [1]</th></tr></thead><tbody><tr><td>低功耗 / 正常时钟（BOOT_CLK_SPEED=0）</td><td>在此模式下，当 LDO_ENABLE 外部接高电平时，PMC 中连接到 VDDCORE 内核电压的片上稳压器设置为默认值 <code>1.05</code> V。<br>当 LDO_ENABLE 外部接低电平时，VDDCORE 必须设置为 <code>1.0V</code> 或更高。 <br>内核时钟（CPU + 系统时钟）： <br>- 频率：48 MHz <br>- 时钟源：48/60m_irc <br><br>UART、I2C、SPI： <br>- 时钟源：48/60m_irc <br><br>USB： <br>- USB IP 时钟源：来自晶体振荡器的 clk_in（24 MHz）</td><td>- 频率：48 MHz <br><br>UART：最高 1 Mbaud <br>I2C：最高 200 kHz <br>SPI：最高 12 Mbps <br><br>USB：2 Mbytes/s</td></tr><tr><td>高速时钟（OTP 熔丝决定时钟速度，BOOT_CLK_SPEED=1）</td><td>在此模式下，当 LDO_ENABLE 接高电平时，PMC 中连接到 VDDCORE 内核电压的片上稳压器设置为默认值 <code>1.13V</code>。<br>当 LDO_ENABLE 外部接低电平时，VDDCORE 必须设置为 <code>1.13V</code>。 <br><br>内核时钟（CPU + 系统时钟）： <br>- 频率：198 MHz <br>- 时钟源：main_clk（以 48/60m_irc 为 PLL 时钟源的 <code>main_pll_clk</code>） <br><br>USB： <br>- USB IP 时钟源：来自晶体振荡器的 clk_in（24 MHz） <br><br>FlexSPI： <br>- 时钟源：aux0_pll_clk <br>- 频率： <br>- SDR：30/50/60/80/100/120/133/166/200 MHz - DDR：30/50/60/80/100/120/133/166/200 MHz <br>eMMC/SD： <br>- 时钟源：主时钟（<code>main_pll_clk</code>）</td><td>- USB：2 Mbytes/s <br>FlexSPI：最高 166 MHz <br>uSDHC0=198 MHz <br>uSDHC1=99 MHz</td></tr></tbody></table><p>[1] 标注的速率为典型值。</p><blockquote><style>.juhtkpvgcqrv{zoom:150%;}</style><img src="/NXP/RT600/BootROM/rt600-bootrom-rm%E8%A7%A3%E6%9E%90-1/image-20250519165019163.png" class="juhtkpvgcqrv"></blockquote><h3 id="41-1-3-分步启动-RT6xx-器件"><a href="#41-1-3-分步启动-RT6xx-器件" class="headerlink" title="41.1.3 分步启动 RT6xx 器件"></a>41.1.3 分步启动 RT6xx 器件</h3><p>本节介绍如何通过 FlexSPI、uSDHC 和 SPI 接口启动 RT6xx 器件。</p><h4 id="41-1-3-1-FlexSPI-NOR-启动的基本说明"><a href="#41-1-3-1-FlexSPI-NOR-启动的基本说明" class="headerlink" title="41.1.3.1 FlexSPI NOR 启动的基本说明"></a>41.1.3.1 FlexSPI NOR 启动的基本说明</h4><p>本例将使用 FlexSPI NOR 闪存启动。如以上章节所述，用户需要准备一个可启动的镜像来启动设备。我们暂时称之为 image.bin 文件。</p><p>由于启动镜像需要放置在外部存储器中，ROM 支持将启动镜像编程到外部存储器中。要对外部存储器进行编程，用户首先需要获取 Bootloader 主机应用程序（<a href="https://www.nxp.com/webapp/sps/download/preDownload.jsp%EF%BC%89%EF%BC%8C%E8%AF%A5%E5%B7%A5%E5%85%B7%E7%A7%B0%E4%B8%BA">https://www.nxp.com/webapp/sps/download/preDownload.jsp），该工具称为</a> blhost 工具，用于与BootROM 通信。blhost 工具用户指南也可以在上述链接中找到。</p><p>在使用该工具向BootROM 发送 ISP 命令之前，<span style="color: blue; ">首先应将BootROM 配置为进入串行 ISP（系统编程）模式</span>。在开发周期中，我们建议通过以下 ISP 引脚选择来使用 ISP 引脚将BootROM 选择为进入串行 ISP 模式，更多信息请参考表 995 “基于 ISP 引脚的启动模式和 ISP 下载器模式”。<strong>表 991. 选择串行 ISP 模式</strong></p><table><thead><tr><th>启动模式</th><th>ISP2 PIO1_17</th><th>ISP1 PIO1_16</th><th>ISP0 PIO1_15</th><th>描述</th></tr></thead><tbody><tr><td>串行 ISP（UART、SPI、I2C、USB-HID）</td><td>高</td><td>高</td><td>低</td><td>使用串行接口（UART、SPI、I2C、USB-HID）对 OTP、外部 Flash、SD 或 eMMC 设备进行编程。</td></tr></tbody></table><p>进入 ISP 模式的步骤：首先，关闭电源；其次，将 ISP 引脚的跳线设置为下表所列状态；第三，给开发板上电。完成所有这些步骤后，BootROM 进入串行 ISP 模式。</p><p>当BootROM 处于 ISP 模式时，即可通过 blhost 工具与BootROM 进行 ISP 通信。</p><p>ROM 支持通过 UART、I2C、SPI、HID 四种接口与 blhost 工具通信。表 996 “ISP 引脚分配” 显示了这些接口的引脚分配。ROM 定义了用于命令和数据传输的通信协议。有关系统编程协议的更多细节，请参考 41.8 节 “RT6xx ISP 和 IAP”。</p><p><strong>表 992. UART 的串行 ISP 引脚</strong></p><table><thead><tr><th>启动接口</th><th>引脚</th><th>功能 / 注释</th></tr></thead><tbody><tr><td>UART</td><td>PIO0_1</td><td>FC0_TXD_SCL_MISO_WS</td></tr><tr><td>UART</td><td>PIO0_2</td><td>FC0_RXD_SDA_MOSI_DATA</td></tr></tbody></table><p>在本例中，我们将使用 UART。有关其他接口的使用，请参考 blhost 工具用户指南。在将 UART 用作通信接口之前，PC 的 COM 端口应将 TXD/RXD 引脚连接到BootROM 的 RXD/TXD 引脚。下表显示了BootROM 使用的 UART 引脚。</p><p>当引脚连接准备就绪，且BootROM 也处于 ISP 模式时，主机（blhost）与BootROM 之间的通信即可开始。在对串行 NOR 闪存设备进行编程之前，我们需要使用 blhost 工具告诉BootROM 配置 FlexSPI 接口，然后可以通过 blhost 工具向BootROM 发送其他 ISP 命令（如读 / 写 / 擦除）来访问连接在 MCU 的 FlexSPI 接口上的串行 NOR 闪存。以闪存 MX25UM51345G 为例，以下命令显示了配置、擦除和将启动镜像编程到连接到 FlexSPI 接口端口 A 的外部 NOR 闪存的步骤。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">blhost -p &lt;COM XX&gt; - fill-memory 0x1c000 0x04 0xc0403001  </span><br><span class="line">blhost -p &lt;COM XX&gt; - configure-memory 0x09 0x1c000  </span><br><span class="line">blhost -p &lt;COM XX&gt; – flash-erase-region 0x08000000 0x10000  </span><br><span class="line">blhost -p &lt;COM XX&gt; - fill-memory 0x1c004 0x04 0xf000000f  </span><br><span class="line">blhost -p &lt;COM XX&gt; - configure-memory 0x09 0x1c004  </span><br><span class="line">blhost -p &lt;COM XX&gt; - write-memory 0x08001000 image.bin  </span><br></pre></td></tr></tbody></table></figure><p>以下是 blhost 工具命令用法的一些细节：</p><ul><li><p><code>blhost -p &lt;COM XX&gt; - fill-memory 0x1c000 0x04 0xc0403001</code>这会将<code>闪存配置参数</code>填充到 SRAM 中，0x1c000 是设备上可用的 SRAM 地址，0x4 是参数长度，0xc0403001 是闪存配置参数。不同的闪存设备和不同的闪存工作模式（如四线、八线、SDR、DDR）可能有不同的配置参数。有关参数的详细信息，<span style="color: blue;  ">请参考表 1008 “Option0 定义” 和表 1009 “Option1 定义”</span>。更多细节请参考 41.8.16 节 “外部存储器支持”。</p></li><li><p><code>blhost -p &lt;COM XX&gt; - configure-memory 0x09 0x1c000</code>这是使用写入 RAM 地址 0x1c000 的参数来配置 FlexSPI 接口。发送此命令后，<span style="color: red; font-weight: bold; ">FlexSPI 完成配置，即可访问外部闪存。</span>更多细节请参考 41.8.16 节 “外部存储器支持” 或 blhost 用户指南。</p></li><li><p><code>blhost -p&lt;COM X X&gt; - flash-erase-region 0x08000000 0x10000</code>此命令从地址 0x08000000 开始擦除外部 NOR 闪存，擦除大小为 0x10000。</p></li><li><p><code>blhost -p &lt;COM XX&gt; - fill-memory 0x1c004 0x04 0xf000000f</code><code>blhost -p &lt;COM XX&gt; - configure-memory 0x09 0x1c004</code>此步骤用于填充为外部闪存生成闪存配置块（FCB）的参数，<span style="color: red; font-weight: bold; ">并触发生成 FCB 并将 FCB 编程到闪存偏移地址 <code>0x400</code> 处。</span>FCB 用于在启动过程中配置 FlexSPI 接口。</p><p><span style="color: red; font-weight: bold; ">当 FlexSPI 启动开始时，ROM 首先使用默认的 1 位模式在 <code>0x400</code> 处设置 FCB，然后使用 FCB 配置 FlexSPI 以访问 NOR 闪存</span>。更多细节，请参考 41.5 节 “主启动模式”。更多细节可参考 41.8.16 节 “外部存储器支持” 或 41.5.1.5.3 节 “NOR 闪存配置、擦除和编程”。</p></li><li><p><code>blhost -p &lt;COM XX&gt; - write-memory 0x08001000 image.bin</code>此步骤用于将启动镜像编程到外部 NOR 闪存地址 <code>0x08001000</code> 处。确保将启动镜像编程到外部闪存偏移地址 <code>0x1000</code> 处（参考表 1000 “不同启动介质上的镜像偏移”）。由于 0x08000000 是 FlexSPI 内存映射的 AHB 地址，要将其编程到闪存设备的 0x1000 处，blhost 的编程闪存地址为 0x08001000。</p></li></ul><p>FlexSPI 接口有两个端口，端口 A 和端口 B，BootROM 均支持从这两个端口启动。闪存配置参数存在一些差异。<span style="color: blue; font-weight: bold; ">对于端口 B，闪存数据采样没有 DQS 引脚，因此我们在 SDR 模式下使用内部环回采样时钟源，这需要设置Dummy Cycle。</span>请参考 NOR 闪存设备数据表来设置伪周期。<span style="color: red; font-weight: bold; ">如果使用 DDR 模式，用户需要手动准备 FCB。ROM 不支持为 FlexSPI PORT B 的 DDR 模式自动生成 FCB</span>。有关启用 DDR 模式的信息，请参考 41.5.1.6 节 “为连接在 PORT B 上的闪存启用八线 DDR 模式”。对于以下所示的配置参数 0xc1503051、0x20000014 的用法，请参考 41.5.1.5.2 节 “FlexSPI NOR 闪存配置参数”。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">blhost -p &lt;COM XX&gt; - fill-memory 0x1c000 0x04 0xc1503051  </span><br><span class="line">blhost -p &lt;COM XX&gt; - fill-memory 0x1c004 0x04 0x20000014  </span><br><span class="line">blhost -p &lt;COM XX&gt; - configure-memory 0x09 0x1c000  </span><br><span class="line">blhost -p &lt;COM XX&gt; – flash-erase-region 0x08000000 0x10000  </span><br><span class="line">blhost -p &lt;COM XX&gt; - fill-memory 0x1c008 0x04 0xf000000f  </span><br><span class="line">blhost -p &lt;COM XX&gt; - configure-memory 0x09 0x1c004  </span><br><span class="line">blhost -p &lt;COM XX&gt; - write-memory 0x08001000 image.bin  </span><br></pre></td></tr></tbody></table></figure><p>完成所有这些步骤后，启动镜像将成功编程到外部存储器的偏移地址 0x1000 处，FlexSPI 启动 FCB 也将编程到偏移地址 0x400 处，然后即可启动设备。ROM 支持 FlexSPI 端口 A 和端口 B 启动。关闭开发板电源，通过以下 ISP 引脚设置启动模式，然后给开发板上电，设备将引导之前编程的启动镜像。</p><p><strong>表 993. 从 FlexSPI 端口 A 和端口 B 启动</strong></p><table><thead><tr><th>启动模式</th><th>ISP2 PIO1_17</th><th>ISP1 PIO1_16</th><th>ISP0 PIO1_15</th><th>描述</th></tr></thead><tbody><tr><td>从端口 A 启动 FlexSPI</td><td>低</td><td>高</td><td>高</td><td>从连接到 FlexSPI 接口 0 端口 A 的四线 / 八线 SPI 闪存设备启动。RT6xx 将在外部四线 / 八线 SPI 闪存设备中查找有效镜像。如果未找到有效镜像，RT6xx 将进入恢复启动或 ISP 启动模式。</td></tr><tr><td>从端口 B 启动 FlexSPI</td><td>低</td><td>高</td><td>低</td><td>从连接到 FlexSPI 接口 0 端口 B 的四线或八线 SPI 闪存设备启动。RT6xx 将在外部四线 / 八线 SPI 闪存设备中查找有效镜像。如果未找到有效镜像，RT6xx 将进入恢复启动或 ISP 启动模式。</td></tr></tbody></table><h4 id="41-1-3-2-SD-eMMC-启动的基本说明"><a href="#41-1-3-2-SD-eMMC-启动的基本说明" class="headerlink" title="41.1.3.2 SD/eMMC 启动的基本说明"></a>41.1.3.2 SD/eMMC 启动的基本说明</h4><p>对于 SD/eMMC 启动，其过程与 FlexSPI 加载到 RAM 启动基本相同。以下是启动过程的主要步骤。有关SD/eMMC 启动的更多细节，请参考 41.5 节 “主启动模式” 中关于 SD/eMMC 启动的内容。通过 ISP 引脚将BootROM 设置为 ISP 模式。使用以下 blhost 命令将启动镜像写入 SD 卡：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">blhost -p &lt;COM XX&gt; - fill-memory 0x1c000 0x4 0xd0082100  </span><br><span class="line">blhost -p &lt;COM XX&gt; - configure-memory 0x120 0x1c000  </span><br><span class="line">blhost -p &lt;COM XX&gt; - flash-erase-region 0x0 0x2000 0x120  </span><br><span class="line">blhost -p &lt;COM XX&gt; - write-memory 0x1000 image.bin 0x120  </span><br></pre></td></tr></tbody></table></figure><p>使用以下 blhost 命令将启动镜像写入 eMMC 设备：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">blhost -p &lt;COM XX&gt; – fill-memory 0x1c000 0x4 0xC0721625  </span><br><span class="line">blhost -p &lt;COM XX&gt; – fill-memory 0x1c004 0x4 0x00000000  </span><br><span class="line">blhost -p &lt;COM XX&gt; - configure-memory 0x121 0x1c000  </span><br><span class="line">blhost -p &lt;COM XX&gt; - flash-erase-region 0x0 0x2000 0x121  </span><br><span class="line">blhost -p &lt;COM XX&gt; - write-memory 0x1000 image.bin 0x121  </span><br></pre></td></tr></tbody></table></figure><p>有关 SD/eMMC 配置参数的更多细节，请参考 41.8.16 节 “外部存储器支持”。将镜像编程到 SD/eMMC 设备后，设置引导 ISP 引脚（表 995 “基于 ISP 引脚的启动模式和 ISP 下载器模式”）以选择 SD/eMMC 引导模式，给开发板上电，设备将从 SD/eMMC 设备启动。</p><h4 id="41-1-3-3-1-位串行-NOR-SPI-启动的基本说明"><a href="#41-1-3-3-1-位串行-NOR-SPI-启动的基本说明" class="headerlink" title="41.1.3.3 1 位串行 NOR SPI 启动的基本说明"></a>41.1.3.3 1 位串行 NOR SPI 启动的基本说明</h4><p>对于 1 位 SPI NOR 闪存启动，<span style="color: green; font-weight: bold; ">其过程与 FlexSPI 加载到 RAM 启动基本相同</span>。选择 SPI NOR 启动时，ROM 尝试从连接到 SPI 接口的 NOR 闪存设备获取启动镜像。ROM 通过 SPI 模块使用主 1 位模式访问 NOR 闪存设备，将启动镜像复制到 SRAM，然后跳转到 SRAM 引导镜像。引导操作与 41.6 节 “恢复启动模式” 相同。<span style="color: green; font-weight: bold; ">不同之处在于，ROM 可以通过引导配置熔丝 BOOT_CFG [0] 的位 [3:0] 设置为 b’0111’ 直接选择 SPI 1 位启动。</span>更多细节，请参考表 994“基于 BOOT_CFG [0] 中 PRIMARY_BOOT_SRC 位的主启动源”。</p><p>将BootROM 设置为 ISP 模式，用户可以使用以下 blhost 命令将镜像编程到连接到 SPI 接口的串行 NOR 闪存存储器中：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">blhost -p &lt;COM XX&gt; - fill-memory 0x1c000 0x04 0xc010000  </span><br><span class="line">blhost -p &lt;COM XX&gt; - configure-memory 0x110 0x1c000  </span><br><span class="line">blhost -p &lt;COM XX&gt; - flash-erase-region 0x0 0x10000 0x110  </span><br><span class="line">blhost -p &lt;COM XX&gt; - write-memory 0x1000 image.bin 0x110  </span><br></pre></td></tr></tbody></table></figure><p>SPI 实例由熔丝字 0x60（BOOT_CFG [0] 的位 17 至位 19）选择。更多细节，请参考 41.9 节 “OTP 驱动 API”。SPI NOR 闪存配置参数 <code>0xc010000</code> 的定义可在 41.8.16 节 “外部存储器支持” 中找到。将启动镜像编程到 SPI NOR 闪存存储器后，将设备启动模式设置为 SPI NOR 启动，关闭并重新给开发板上电，设备将通过 SPI 从 1 位 NOR 闪存启动。</p><h4 id="41-2-功能"><a href="#41-2-功能" class="headerlink" title="41.2 功能"></a>41.2 功能</h4><p>256KB 片上BootROM，带引导程序，支持各种启动选项和 API。</p><ul><li>支持基于 ISP 引脚或 OTP 设置（PRIMARY_BOOT_SRC），从应用处理器通过串行接口（UART、SPI、USB-HID）启动，或从串行 NOR（四线或八线 SPI 闪存、HyperFlash）、SD 卡或 eMMC 设备自动启动。</li><li>支持从串行 NOR 闪存（单线、双线、四线或八线模式，<code>带 / 不带 OTFAD</code>）就地执行（XIP）。</li><li>提供用于 OTP 存储器编程的 OTP API，更多细节请参考 41.9 节 “OTP 驱动 API”。</li><li>提供访问串行闪存设备的外部闪存 API。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RT600-RM-CH41：RT6xx-非安全BootROM-1&quot;&gt;&lt;a href=&quot;#RT600-RM-CH41：RT6xx-非安全BootROM-1&quot; class=&quot;headerlink&quot; title=&quot;RT600 RM CH41：RT6xx 非安全BootROM (1)&quot;&gt;&lt;/a&gt;RT600 RM CH41：RT6xx 非安全BootROM (1)&lt;/h1&gt;</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT600" scheme="https://dustofstars.github.io/categories/NXP/RT600/"/>
    
    <category term="BootROM" scheme="https://dustofstars.github.io/categories/NXP/RT600/BootROM/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="RT600" scheme="https://dustofstars.github.io/tags/RT600/"/>
    
    <category term="BootROM" scheme="https://dustofstars.github.io/tags/BootROM/"/>
    
  </entry>
  
  <entry>
    <title>ARM核心--MemoryMap</title>
    <link href="https://dustofstars.github.io/ARM/MemoryMap/arm%E6%A0%B8%E5%BF%83-memorymap/"/>
    <id>https://dustofstars.github.io/ARM/MemoryMap/arm%E6%A0%B8%E5%BF%83-memorymap/</id>
    <published>2025-05-10T08:21:21.000Z</published>
    <updated>2025-05-10T08:22:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARMv7-M-Essentials-0"><a href="#ARMv7-M-Essentials-0" class="headerlink" title="ARMv7-M Essentials 0"></a>ARMv7-M Essentials 0</h1><blockquote><p>Link: <a href="https://www.bilibili.com/video/BV1MMVPzrE8S/?spm_id_from=333.1387.homepage.video_card.click&amp;vd_source=e742ab928a70238934780b04b84d177d">https://www.bilibili.com/video/BV1MMVPzrE8S/?spm_id_from=333.1387.homepage.video_card.click&amp;vd_source=e742ab928a70238934780b04b84d177d</a></p></blockquote><style>.srleklibbvhc{zoom:100%;}</style><img src="/ARM/MemoryMap/arm%E6%A0%B8%E5%BF%83-memorymap/image-20250510154619613.png" class="srleklibbvhc"><span id="more"></span><h2 id="1-可寻址空间大小-可寻址空间范围"><a href="#1-可寻址空间大小-可寻址空间范围" class="headerlink" title="1. 可寻址空间大小 / 可寻址空间范围"></a>1. 可寻址空间大小 / 可寻址空间范围</h2><ul><li>可寻址空间大小：4GB；</li><li>可寻址空间范围：0x0000_0000 ~ 0xFFFF_FFFF</li></ul><h2 id="2-分块"><a href="#2-分块" class="headerlink" title="2. 分块"></a>2. 分块</h2><ol><li>代码：指的是用户代码编译之后机器码存放在片内Flash区域；起始地址给的是<code>0x0</code>?</li><li>SRAM：即片内RAM；存放运行时的数据；一般起始地址就是<code>0x2000_0000</code>;</li><li>外设：用于访问外设；一般起始地址是<code>0x4000_0000</code></li><li>RAM: 指的是片外RAM，起始地址<code>0x6000_0000</code>,对应RT应该是SDRAM；</li><li>设备：</li><li>系统/供应商定义：其中有一个核销的系统控制空间，它里面有CPUID,地址是<code>0xE000_ED00</code>;</li></ol><h2 id="3-示例代码"><a href="#3-示例代码" class="headerlink" title="3. 示例代码"></a>3. 示例代码</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CODE_ADDR_START 0x00000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CODE_ADDR_END   0x1FFFFFFF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SRAM_ADDR_START 0x20000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SRAM_ADDR_END   0x3FFFFFFF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCB_CPUID_ADDR   0xE000ED00</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">example_function</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> example_value = <span class="number">0x12345678</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// get the address of the example function</span></span><br><span class="line">    <span class="type">uint32_t</span> function_addr = (<span class="type">uint32_t</span>)&amp;example_function;</span><br><span class="line">    <span class="keyword">if</span> （function_addr &lt; CODE_ADDR_START || function_addr &gt; CODE_ADDR_END)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// get the address of the example value</span></span><br><span class="line">    <span class="type">uint32_t</span> value_addr = (<span class="type">uint32_t</span>)&amp;example_value;</span><br><span class="line">    <span class="keyword">if</span> （value_addr&lt; SRAM_ADDR_START || value_addr &gt; SRAM_ADDR_END）</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>）;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//get the value of the SCB CPUID register</span></span><br><span class="line">    <span class="type">uint32_t</span> cpuid_value = *(<span class="keyword">volatile</span> <span class="type">uint32_t</span> *)SCB_CPUID_ADDR;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == cpuid_value)</span><br><span class="line">      {</span><br><span class="line">          <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">      }</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>这个工程是为了验证默认的代码和变量区域分别在哪里：</p><ol><li>代码：函数应该在代码区，对应为片内Flash；</li><li>变量：变量应该在SRAM，片内RAM中；</li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ARMv7-M-Essentials-0&quot;&gt;&lt;a href=&quot;#ARMv7-M-Essentials-0&quot; class=&quot;headerlink&quot; title=&quot;ARMv7-M Essentials 0&quot;&gt;&lt;/a&gt;ARMv7-M Essentials 0&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.bilibili.com/video/BV1MMVPzrE8S/?spm_id_from=333.1387.homepage.video_card.click&amp;amp;vd_source=e742ab928a70238934780b04b84d177d&quot;&gt;https://www.bilibili.com/video/BV1MMVPzrE8S/?spm_id_from=333.1387.homepage.video_card.click&amp;amp;vd_source=e742ab928a70238934780b04b84d177d&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;style&gt;.srleklibbvhc{zoom:100%;}&lt;/style&gt;&lt;img src=&quot;/ARM/MemoryMap/arm%E6%A0%B8%E5%BF%83-memorymap/image-20250510154619613.png&quot; class=&quot;srleklibbvhc&quot;&gt;</summary>
    
    
    
    <category term="ARM" scheme="https://dustofstars.github.io/categories/ARM/"/>
    
    <category term="MemoryMap" scheme="https://dustofstars.github.io/categories/ARM/MemoryMap/"/>
    
    
    <category term="ARM" scheme="https://dustofstars.github.io/tags/ARM/"/>
    
    <category term="MemoryMap" scheme="https://dustofstars.github.io/tags/MemoryMap/"/>
    
  </entry>
  
  <entry>
    <title>ARM核心启动流程</title>
    <link href="https://dustofstars.github.io/ARM/Boot/arm%E6%A0%B8%E5%BF%83%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <id>https://dustofstars.github.io/ARM/Boot/arm%E6%A0%B8%E5%BF%83%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</id>
    <published>2025-05-10T08:20:21.000Z</published>
    <updated>2025-05-10T08:20:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARMv7-M-Essentials-1"><a href="#ARMv7-M-Essentials-1" class="headerlink" title="ARMv7-M Essentials 1"></a>ARMv7-M Essentials 1</h1><blockquote><p>Link: <a href="https://www.bilibili.com/video/BV1tTVPz3EdA/?spm_id_from=333.1387.favlist.content.click&amp;vd_source=e742ab928a70238934780b04b84d177d">https://www.bilibili.com/video/BV1tTVPz3EdA/?spm_id_from=333.1387.favlist.content.click&amp;vd_source=e742ab928a70238934780b04b84d177d</a></p></blockquote><span id="more"></span><h2 id="1-框图"><a href="#1-框图" class="headerlink" title="1. 框图"></a>1. 框图</h2><style>.ngobastlmyku{zoom:100%;}</style><img src="/ARM/Boot/arm%E6%A0%B8%E5%BF%83%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image-20250510151632165.png" class="ngobastlmyku"><p>电源引脚上电–&gt; 复位 –&gt; Boot ROM –&gt; 根据VectorTable偏移0地址的内存地址设置MSP –&gt; 将M核心的PC寄存器设置为VectorTable的偏移4字节即复位向量 –&gt; 之后就可以依次执行指令了！</p><blockquote><p>Note: 中断向量表Vector Table：</p><ul><li><span style="color: red; font-weight: bold; ">中断向量表中每个元素都是4个Bytes；</span></li><li>每个元素用于指示MCU中的一个有效存储空间；代表一个内存地址或者函数地址；</li></ul><p>从上图的方框可以看到，VectorTable的内容：</p><ol><li>第一个元素是MSP的初始值；<span style="color: red; font-weight: bold; ">MSP指的是栈顶指针(Main Stack Pointer), 用于指示内存中某个具体地址；</span></li><li><span style="color: red; font-weight: bold; ">往后的元素都是函数地址；</span>最重要的是第二个，<span style="color: red; font-weight: bold; ">复位向量；它指示每次MCU复位后执行的第一条用户指令；</span></li></ol></blockquote><h2 id="2-示例工程"><a href="#2-示例工程" class="headerlink" title="2. 示例工程"></a>2. 示例工程</h2><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">"stm32f10x.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CODE_ADDR_START Ox00000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CODE_ADDR_END   0x1FFFFFFF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SRAM_ADDR_START Ox20000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SRAM_ADDR_END   0x3FFFFFFF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCB_CPUID_ADDR   OxE000ED00</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">example_function</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> example_value = <span class="number">0x12345678</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//get the address of the example function</span></span><br><span class="line">    <span class="type">uint32_t</span> function_addr=（<span class="type">uint32_t</span>)&amp;example_function;</span><br><span class="line">    <span class="keyword">if</span> （function_addr &lt;CODE_ADDR_START I1 function_addr &gt; CODE_ADDR_END)</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">while</span>(<span class="number">1</span>);  </span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// get the address of the example value</span></span><br><span class="line">    <span class="type">uint32_t</span> value_addr = (<span class="type">uint32_t</span>)&amp;example_value;</span><br><span class="line">    <span class="keyword">if</span> (value_addr &lt; SRAM_ADDR_START <span class="number">11</span> value_addr &gt; SRAM_ADDR_END)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    } </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h3><style>.qtluutoridik{zoom:100%;}</style><img src="/ARM/Boot/arm%E6%A0%B8%E5%BF%83%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image-20250510153431340.png" class="qtluutoridik"><ul><li><code>_estack</code>:即栈顶指针MSP；</li><li><code>Reset_Handler</code>: 即复位向量；</li></ul><p>当工程进入调试模式时可以看到，</p><ol><li>PC寄存器指向<code>main()</code>中的第一个指令地址；</li><li>M核心的MSP寄存器指向RAM中的某个地址；</li><li>使用gdb的<code>monitor system_reset</code>指令触发复位，观察PC和MSP两个寄存器的地址：<ul><li>PC：<code>0x8000088c</code> –&gt; 即 Reset_Handler;</li><li>MSP: <code>0x20002000</code> –&gt; 即map中的一致；</li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ARMv7-M-Essentials-1&quot;&gt;&lt;a href=&quot;#ARMv7-M-Essentials-1&quot; class=&quot;headerlink&quot; title=&quot;ARMv7-M Essentials 1&quot;&gt;&lt;/a&gt;ARMv7-M Essentials 1&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.bilibili.com/video/BV1tTVPz3EdA/?spm_id_from=333.1387.favlist.content.click&amp;amp;vd_source=e742ab928a70238934780b04b84d177d&quot;&gt;https://www.bilibili.com/video/BV1tTVPz3EdA/?spm_id_from=333.1387.favlist.content.click&amp;amp;vd_source=e742ab928a70238934780b04b84d177d&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="ARM" scheme="https://dustofstars.github.io/categories/ARM/"/>
    
    <category term="Boot" scheme="https://dustofstars.github.io/categories/ARM/Boot/"/>
    
    
    <category term="ARM" scheme="https://dustofstars.github.io/tags/ARM/"/>
    
    <category term="Boot" scheme="https://dustofstars.github.io/tags/Boot/"/>
    
  </entry>
  
  <entry>
    <title>RT1060 image里面有什么？</title>
    <link href="https://dustofstars.github.io/NXP/RT1060/binary/rt1060-image%E9%87%8C%E9%9D%A2%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>https://dustofstars.github.io/NXP/RT1060/binary/rt1060-image%E9%87%8C%E9%9D%A2%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F/</id>
    <published>2025-02-28T08:43:40.000Z</published>
    <updated>2025-02-28T08:43:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RT1060-image里面有什么？"><a href="#RT1060-image里面有什么？" class="headerlink" title="RT1060 image里面有什么？"></a>RT1060 image里面有什么？</h1><blockquote><p>RT MCU 学习有一段时间了，刚好得空，在这篇文章里面，我们一起分析一个完整的image bin文件，它有哪些部分？分别是什么作用？哪些是不可或缺的？哪些是可选的？</p></blockquote><span id="more"></span><p>我们知道，RT MCU作为跨界控制器/处理器，提供了一个高性能的平台，CM7核心的主频可以达到600MHz以上，可以说单凭这个系列，就打出了NXP的差异性和易用性。原来国外原厂也可以这么有性价比😍简直是Amazing -.-</p><p>但是同时呢，由于RT的flash是外置的嘛，它的image结构也和以往的通用MCU的image有很大区别。以我们本文要研究的Flash XIP的image为例，上电之后，BootROM会先把flexspi跑起来，用一个低速时钟去读flash中的配置参数，然后拿这个flash的配置头重配flexspi，就能高效获取image中的指令和数据啦！</p><p>同时呢，因为一些加密啊，外设配置啊，的需求，image不只是包含这个flash的配置header，还分为很多个其他部分，在这里，我们就一起看一下吧！</p><h2 id="FDCB-Header"><a href="#FDCB-Header" class="headerlink" title="FDCB Header"></a>FDCB Header</h2><blockquote><blockquote><p>再次呢，进入正文之前，提前说明一些东西以防止读者疑惑。</p><ul><li><p>使用的是*.bin格式的image，相比于hex或者s-record，它没有指示物理地址，只有offset，在使用JLink烧录时，我们使用如下命令：</p><p><code>jlink loadfile xxx.bin 0x6000_0000</code></p><p>从这里我们可以看出来，这个bin文件的offset，实际上就是从我们的Flash首地址开始偏移的，这是最重要的前置知识，请知悉。</p></li></ul></blockquote></blockquote><p>在MCU BootUtility中，它显示从<code>0x6000_0000</code>到<code>0x6000_0200</code>之前，都是FDCB段。那么它的大小就是<code>512 Byte</code>.</p><p>这里我们先不管，直接看对我们有用的部分。</p><style>.xkpltwtttzuu{zoom:100%;}</style><img src="/NXP/RT1060/binary/rt1060-image%E9%87%8C%E9%9D%A2%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F/image-20250228155429758.png" class="xkpltwtttzuu"><table><thead><tr><th>Offset</th><th>flash address</th><th>内容</th><th>小端</th><th>意义</th></tr></thead><tbody><tr><td>0x0</td><td>0x6000_0000</td><td>46 43 46 42</td><td>0x42462326</td><td>FCFB<br>flash配置头标志</td></tr><tr><td>0x04-0x07</td><td>0x6000_0004</td><td>00 04 01 56</td><td>0x56010400</td><td>version<br>表示使用flexspi v1.4.0配置</td></tr><tr><td>0x40-0x43</td><td>0x6000_0040</td><td>10 00 00 00</td><td>0x10</td><td>应该是flash的page size<br>16</td></tr><tr><td>0x80-0x83</td><td>0x6000_0080</td><td>EB 04 18 0A</td><td>0x0A1804EB</td><td>Flash的时钟频率<br>典型值133MHz<br>（600/43 x 19 / 2 = 133）</td></tr></tbody></table><h2 id="Image-Version"><a href="#Image-Version" class="headerlink" title="Image Version"></a>Image Version</h2><p>在Offset <code>0x600</code>的地方有个image版本号，用于双image的时候，还没用过。暂且不表。</p><style>.ubhwnzvvceny{zoom:100%;}</style><img src="/NXP/RT1060/binary/rt1060-image%E9%87%8C%E9%9D%A2%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F/image-20250228155738390.png" class="ubhwnzvvceny"><h2 id="IVT"><a href="#IVT" class="headerlink" title="IVT"></a>IVT</h2><style>.sikdruxketmg{zoom:100%;}</style><img src="/NXP/RT1060/binary/rt1060-image%E9%87%8C%E9%9D%A2%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F/image-20250228161351059.png" class="sikdruxketmg"><table><thead><tr><th>Offset</th><th>flash address</th><th>内容</th><th>小端</th><th>意义</th></tr></thead><tbody><tr><td>0x1000</td><td>0x6000_1000</td><td>D1 00 20 41</td><td>0x412000D1</td><td>IVT段的起始标志</td></tr><tr><td>0x1004</td><td>0x6000_1004</td><td>00 20 00 60</td><td>0x60002000</td><td>程序中断向量表地址<br>.isr_vector 以及 g_pfnVectors</td></tr><tr><td>0x1008</td><td>0x6000_1008</td><td>00 00 00 00</td><td>0x0</td><td>DCD地址<br>表示未启用DCD</td></tr><tr><td>0x1010</td><td>0x6000_1010</td><td>20 10 00 60</td><td>0x60001020</td><td>BootData地址<br>指向偏移量0x1020的地方</td></tr></tbody></table><h2 id="Boot-Data"><a href="#Boot-Data" class="headerlink" title="Boot Data"></a>Boot Data</h2><p>根据IVT中 Offset <code>0x1010</code>的指引，找到 Boot Data的地址是：<code>0x6000_1020</code></p><style>.iezcadbhnsfg{zoom:100%;}</style><img src="/NXP/RT1060/binary/rt1060-image%E9%87%8C%E9%9D%A2%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F/image-20250228162214452.png" class="iezcadbhnsfg"><table><thead><tr><th>Offset</th><th>flash address</th><th>内容</th><th>小端</th><th>意义</th></tr></thead><tbody><tr><td>0x1020</td><td>0x6000_1020</td><td>00 00 00 60</td><td>0x60000000</td><td>image的起始地址<br>在这时候就是flash的地址</td></tr><tr><td>0x1024</td><td>0x6000_1024</td><td>00 00 80 00</td><td>0x00800000</td><td>image的大小<br>这里默认是8MB</td></tr></tbody></table><h2 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h2><p>终于到了光秃秃的image部分了~</p><p>根据IVT中的指示，它是程序入口，地址是<code>0x6000_2000</code>!</p><style>.kwyizdrfgdde{zoom:100%;}</style><img src="/NXP/RT1060/binary/rt1060-image%E9%87%8C%E9%9D%A2%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F/image-20250228162759478.png" class="kwyizdrfgdde"><table><thead><tr><th>Offset</th><th>flash address</th><th>内容</th><th>小端</th><th>意义</th></tr></thead><tbody><tr><td>0x2000</td><td>0x6000_2000</td><td>00 00 02 20</td><td>0x2002_0000 (DTCM中的地址)</td><td><strong>初始SP</strong>栈指针</td></tr><tr><td>0x2004</td><td>0x6000_2004</td><td>1D 23 00 60</td><td>0x6000231D</td><td>ResetISR 的地址</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RT1060-image里面有什么？&quot;&gt;&lt;a href=&quot;#RT1060-image里面有什么？&quot; class=&quot;headerlink&quot; title=&quot;RT1060 image里面有什么？&quot;&gt;&lt;/a&gt;RT1060 image里面有什么？&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;RT MCU 学习有一段时间了，刚好得空，在这篇文章里面，我们一起分析一个完整的image bin文件，它有哪些部分？分别是什么作用？哪些是不可或缺的？哪些是可选的？&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1060" scheme="https://dustofstars.github.io/categories/NXP/RT1060/"/>
    
    <category term="binary" scheme="https://dustofstars.github.io/categories/NXP/RT1060/binary/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="image" scheme="https://dustofstars.github.io/tags/image/"/>
    
  </entry>
  
  <entry>
    <title>RT1024 EVK 学习笔记Part3</title>
    <link href="https://dustofstars.github.io/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part3/"/>
    <id>https://dustofstars.github.io/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part3/</id>
    <published>2024-12-24T11:47:46.000Z</published>
    <updated>2024-12-24T11:47:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RT1024-EVK-学习笔记Part3"><a href="#RT1024-EVK-学习笔记Part3" class="headerlink" title="RT1024 EVK 学习笔记Part3"></a>RT1024 EVK 学习笔记Part3</h1><blockquote><p>Page5 MCU PINOUT 部分！</p><p>以及额外的，Page14 BOOT！</p></blockquote><span id="more"></span><h2 id="U1D-SEMC-部分"><a href="#U1D-SEMC-部分" class="headerlink" title="U1D SEMC 部分"></a>U1D SEMC 部分</h2><style>.bmpxomxvhhvb{zoom:100%;}</style><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part3/image-20241224104557031.png" class="bmpxomxvhhvb"><p>SEM接口部分共有42个引脚，为<code>GPIO_EMC_00</code> ~ <code>GPIO_EMC_41</code>。 它的功能分组如下：</p><h3 id="引脚功能分组"><a href="#引脚功能分组" class="headerlink" title="引脚功能分组"></a>引脚功能分组</h3><ul><li>数据线: <code>SEMC_D0</code> ~ <code>SEMC_D15</code> <span style="color: green; font-weight: bold; ">(16位数据总线)；</span></li><li>地址线: <code>SEMC_A0</code> ~ <code>SEMC_A12</code> <span style="color: green; font-weight: bold; ">(13位地址总线)；</span></li><li>控制信号13个: <ul><li>SEMC_DM0, SEMC_WE, SEMC_CAS, SEMC_RAS, SEMC_CS0, <code>SEMC_BA0</code>, <code>SEMC_BA1</code>;</li><li>SEMC_CKE, SEMC_CLK, SEMC_DM1;</li><li>SAI3_MCLK, ENET_MDIO, ENET_MDC;</li></ul></li></ul><h3 id="数据选通信号DQS说明"><a href="#数据选通信号DQS说明" class="headerlink" title="数据选通信号DQS说明"></a>数据选通信号DQS说明</h3><ul><li><p><code>SEMC_DQS</code>: 数据选通信号,用于高速数据传输时的同步; 在MCU端的Pin是<code>GPIO_EMC_28</code>, 它默认用于<code>SAI3_MCLK</code>, 如果需要SEMC的DQS功能，则要断开0Ω电阻<code>R426</code>；</p><ul><li><p><code>SAI3_MCLK</code>: <span style="color: green; font-weight: bold; ">音频接口主时钟信号；</span></p><blockquote><p><span style="color: blue; font-weight: bold; ">如果使用了SEMC_DQS, 且读写时Pin脚float，则能达到133MHz；否则，不使用SEMC_DQS, 读写速度只能达到66MHz；</span></p></blockquote></li></ul></li></ul><h3 id="控制信号详解"><a href="#控制信号详解" class="headerlink" title="控制信号详解"></a>控制信号详解</h3><ul><li><p><code>SEMC_DM0 / SEMC_DM1</code> (Data Mask):</p><ul><li>这是数据掩码信号</li><li>分别控制低8位和高8位；</li></ul></li><li><p><code>SEMC_WE</code> (Write Enable):</p><ul><li>写使能信号</li><li>低电平有效</li><li>用于指示当前是写操作</li><li>与RAS/CAS配合使用来控制读写时序</li></ul></li><li><p><code>SEMC_CAS</code> (Column Address Strobe):</p><ul><li>列地址选通信号</li><li>低电平有效</li><li>用于锁存列地址</li><li><span style="color: green;">SDRAM访问需要先给行地址再给列地址；</span></li></ul></li><li><p><code>SEMC_RAS</code> (Row Address Strobe):</p><ul><li>行地址选通信号</li><li>低电平有效</li><li>用于锁存行地址</li><li>与CAS的组合可以产生不同的SDRAM命令</li></ul></li><li><p><code>SEMC_CS0</code> (Chip Select):</p><ul><li><span style="color: green;">片选信号；</span>–&gt; <span style="color: blue; font-weight: bold; ">因为只有一个片选信号，RT1024应该是只能外接一片SDRAM的；</span></li><li>低电平有效</li><li>系统可以有多个CS信号连接多个SDRAM</li></ul></li><li><p><code>SEMC_BA0/BA1</code> (Bank Address):</p><ul><li><span style="color: green;">SDRAM内部bank地址信号；</span></li><li>用于选择SDRAM内部的存储体</li><li>通常SDRAM有4个bank,需要2位地址</li><li>可以实现bank交错访问提高性能</li></ul></li></ul><h2 id="U1F-NVCC-SD-部分"><a href="#U1F-NVCC-SD-部分" class="headerlink" title="U1F NVCC_SD 部分"></a>U1F NVCC_SD 部分</h2><style>.lxlrjzqpnlur{zoom:100%;}</style><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part3/image-20241224104624579.png" class="lxlrjzqpnlur"><h3 id="电源设计"><a href="#电源设计" class="headerlink" title="电源设计"></a>电源设计</h3><ul><li><code>NVCC_SD</code>为SD接口<code>NVCC_SD0</code>供电；</li><li>使用两个去耦电容:<ul><li>C76(4.7μF): 大电容用于稳定电源</li><li>C77(0.1μF): 小电容用于滤除高频噪声</li></ul></li></ul><h3 id="SD卡接口信号-GPIO-SD-B0-xx组"><a href="#SD卡接口信号-GPIO-SD-B0-xx组" class="headerlink" title="SD卡接口信号(GPIO_SD_B0_xx组)"></a>SD卡接口信号(<code>GPIO_SD_B0_xx</code>组)</h3><p>（7个Pin：00~06）</p><ul><li><code>SD1_D0~D3</code>: <span style="color: green;"> 4位数据线，其中，D0有上拉到<code>NVCC_SD</code>高电平；</span></li><li><code>SD1_CMD</code>: <span style="color: green;">命令线，上拉到<code>NVCC_SD</code>高电平；</span></li><li><code>SD1_CLK</code>: 时钟线；</li><li><code>SD_CD_SW</code>: <span style="color: green;">SD卡检测信号，</span>注意这个Pin脚是<code>GPIO_SD_B0_06</code>；</li></ul><h3 id="其他复用功能-GPIO-SD-B1-xx组"><a href="#其他复用功能-GPIO-SD-B1-xx组" class="headerlink" title="其他复用功能(GPIO_SD_B1_xx组)"></a>其他复用功能(GPIO_SD_B1_xx组)</h3><p>（12个Pin：00~11）</p><ul><li><p><code>CAN1_TX/RX:</code> CAN通信接口；</p></li><li><p><code>I2C4_SCL/SDA</code>: I2C通信接口；</p></li><li><p><code>SAI3</code>相关信号: 音频接口信号：</p><ul><li><code>SAI3_TX_BCLK</code></li><li><code>SAI3_TX_SYNC</code></li><li><code>SAI3_TXD</code></li><li><code>SAI3_RXD</code></li></ul></li><li><p><code>INT1/2_COMBO</code>以及<code>AUD_INT</code>: 中断信号；</p><blockquote><p><span style="color: blue; font-weight: bold; ">其中<code>INT2_COMBO</code>通过DNP未连接0Ω电阻R243到<code>GPIO_SD_B1_05</code>，它也是FlexSPI DQS线，需要floating，使QSPI Flash读写速度达到133MHz；</span></p></blockquote></li><li><p><code>SD_PWREN</code>:<span style="color: green; ">这个也是个重要控制信号，来决定SD卡是否上电！</span></p></li></ul><h2 id="U1C-5V-USB-OTG-部分"><a href="#U1C-5V-USB-OTG-部分" class="headerlink" title="U1C 5V_USB_OTG 部分"></a>U1C 5V_USB_OTG 部分</h2><style>.rnzoyanclomh{zoom:100%;}</style><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part3/image-20241224110847726.png" class="rnzoyanclomh"><p>MCU的USB OTG接口电路部分</p><ol><li><strong>电源设计</strong><ul><li><code>5V_USB_OTG</code>: USB 5V供电，限流25mA，连接到<code>USB_OTG1_VBUS</code>引脚；</li><li><code>VDD_USB_3V</code>: 3.3V供电，连接到<code>VDD_USB_CAP</code>；</li></ul></li><li><strong>信号线</strong><ul><li><code>OTG1_DN / OTG1_DP</code>: USB差分数据对</li><li><code>USB_OTG1_VBUS</code>: VBUS电源检测引脚;</li><li><code>USB_OTG1_CHD</code>: 充电检测引脚;</li></ul></li></ol><h2 id="U1E-NVCC-GPIO-3V3-部分"><a href="#U1E-NVCC-GPIO-3V3-部分" class="headerlink" title="U1E NVCC_GPIO_3V3 部分"></a>U1E NVCC_GPIO_3V3 部分</h2><style>.kyagyiivqupq{zoom:100%;}</style><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part3/image-20241224112223432.png" class="kyagyiivqupq"><h3 id="电源设计-1"><a href="#电源设计-1" class="headerlink" title="电源设计"></a><strong>电源设计</strong></h3><ul><li><span style="color: green; font-weight: bold; "><code>DCDC_3V3</code>转换为<code>NVCC_GPIO_3V3</code>供电；</span></li><li>采用双级去耦电容设计：<ul><li>5个4.7μF大电容：处理低频噪声</li><li>5个0.1μF小电容：处理高频噪声</li></ul></li><li>这种配置确保了GPIO供电的稳定性</li></ul><h3 id="GPIO配置"><a href="#GPIO配置" class="headerlink" title="GPIO配置"></a><strong>GPIO配置</strong></h3><ul><li><code>NVCC_GPIO</code>：<span style="color: green;">5个Pin给GPIO组进行独立供电；</span></li><li><code>GPIO_AD_B0_xx</code>和<code>GPIO_AD_B1_xx</code>：两组GPIO端口，B0组有16个Pin，B1组有10个Pin；</li></ul><h4 id="GPIO-AD-B0-xx-组"><a href="#GPIO-AD-B0-xx-组" class="headerlink" title="GPIO_AD_B0_xx 组"></a>GPIO_AD_B0_xx 组</h4><ol><li><strong>调试接口</strong><ul><li>JTAG接口：<ul><li>JTAG_TMS：测试模式选择</li><li>JTAG_TCK：时钟</li><li>JTAG_TDI：测试数据输入</li><li>JTAG_TDO：测试数据输出</li><li>JTAG_nTRST：复位</li><li><span style="color: blue;">JTAG_MOD 默认接地；</span></li></ul></li><li>SWD接口：<ul><li>SWD_CLK：时钟，复用JTAG_TCK；</li><li>SWD_DIO：数据输入输出，复用JTAG_TMS;</li><li><code>TRACE_SWO</code>：<span style="color: blue; font-weight: bold; ">默认DNP的，复用了<code>GPIO_AD_B0_12</code>;</span></li></ul></li></ul></li><li><strong>通信接口</strong><ul><li>UART1_TXD / RXD：串口通信</li><li>ENET：以太网接口信号<ul><li>4个接收/发送数据线：<ul><li>ENET_RXD1/ ENET_RXD0；</li><li>ENET_TXD1/ ENET_TXD0；</li></ul></li><li>1个时钟线：ENET_TX_REF_CLK</li><li>1个使能线：ENET_TXEN</li><li>1个复位线：ENET_RST</li><li>其他控制线：<ul><li><code>ENET_RXER</code></li><li><code>ENET_CRS_DV</code></li></ul></li></ul></li></ul></li><li><strong>特殊功能</strong><ul><li><code>WDOG_B</code>：看门狗复位，和<code>JTAG_TDI</code>复用；</li><li><code>TRACE_SWO</code>：跟踪调试输出</li></ul></li></ol><h4 id="GPIO-AD-B1-xx-组"><a href="#GPIO-AD-B1-xx-组" class="headerlink" title="GPIO_AD_B1_xx 组"></a>GPIO_AD_B1_xx 组</h4><blockquote><p><span style="color: green; font-weight: bold; ">好像放的是一些外设的重要控制信号？！</span></p></blockquote><ul><li>ENET_INT：以太网中断信号</li><li>SD0_VSELECT：SD卡电压选择，支持1.8V/3.3V双电压模式；</li><li>USER_LED</li><li>USB_OTG1_PWR ： 控制外部USB设备供电</li><li>USB_OTG1_ID ： 用于确定USB角色(主机/设备)</li><li>USB_OTG1_OC ： 检测USB端口是否发生过流</li><li>CAN_STBY</li><li>I2C1_SCL / I2C1_SDA</li></ul><hr><h2 id="Page-14-BOOT"><a href="#Page-14-BOOT" class="headerlink" title="Page 14 BOOT"></a>Page 14 BOOT</h2><style>.jbymkxelppiy{zoom:100%;}</style><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part3/image-20241224134408689.png" class="jbymkxelppiy"><style>.rdvpopkjuhbn{zoom:100%;}</style><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part3/image-20241224134346036.png" class="rdvpopkjuhbn"><p>启动配置部分<code>BOOT_CFG[0:9]</code>：</p><ol><li><strong>FUSE MAP配置表</strong><ul><li><strong>FlexSPI - Serial NOR配置</strong>：<ul><li><code>HOLD TIME</code>可选：500us/1ms/3ms/10ms</li><li>FLASH类型支持多种选项：<ul><li><code>3B/4B读取模式</code></li><li>HyperFlash 1V8/3V3</li><li>QSPI设备 3B读取模式–&gt; <span style="color: blue; font-weight: bold; ">在secondary pinmux选项上；</span>；</li><li>Micron Octal DDR</li><li>MXIC Octal DDR</li></ul></li><li>EncryptedXIP：使能与否；</li></ul></li><li><strong>SD启动配置</strong>：<ul><li>SD/SDXC速度模式4种选择：<ul><li>Normal/SDR12</li><li>High/SDR25</li><li>SDR50</li><li>SDR104</li></ul></li><li><span style="color: green;">总线宽度：1-bit/4-bit</span></li><li>电源循环和时钟源选项</li><li>端口选择：eSDHC1/eSDHC2</li><li>快速启动选项</li></ul></li></ul></li><li><strong>硬件实现</strong><ul><li>**DIP开关(SW8)**：<ul><li>四个选项连接：BT_CFG[0]、BT_CFG[5]、BOOT_MODE[0]、BOOT_MODE[1]；</li><li>用于选择启动模式：<ul><li>Serial Download: 0001</li><li>FlexSPI Boot:       0010</li><li>SD Boot:              0110</li></ul></li></ul></li><li><strong>GPIO连接</strong>：<ul><li>使用GPIO_EMC_16到GPIO_EMC_27</li><li>这些引脚在启动时作为配置引脚</li><li>启动后可以作为普通GPIO使用</li></ul></li></ul></li><li><strong>特殊功能</strong><ul><li>支持加密XIP（Execute In Place）</li><li>可配置快速启动模式</li><li>支持多种存储设备类型</li><li>灵活的时序和总线配置</li></ul></li></ol><p>这种设计提供了灵活的启动选项，允许系统从不同类型的存储设备启动，并且可以通过DIP开关轻松更改启动配置，方便开发和调试。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RT1024-EVK-学习笔记Part3&quot;&gt;&lt;a href=&quot;#RT1024-EVK-学习笔记Part3&quot; class=&quot;headerlink&quot; title=&quot;RT1024 EVK 学习笔记Part3&quot;&gt;&lt;/a&gt;RT1024 EVK 学习笔记Part3&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Page5 MCU PINOUT 部分！&lt;/p&gt;
&lt;p&gt;以及额外的，Page14 BOOT！&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1024" scheme="https://dustofstars.github.io/categories/NXP/RT1024/"/>
    
    <category term="原理图" scheme="https://dustofstars.github.io/categories/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="hardware" scheme="https://dustofstars.github.io/tags/hardware/"/>
    
    <category term="原理图" scheme="https://dustofstars.github.io/tags/%E5%8E%9F%E7%90%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>RT1024 EVK 学习笔记Part2</title>
    <link href="https://dustofstars.github.io/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part2/"/>
    <id>https://dustofstars.github.io/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part2/</id>
    <published>2024-12-23T11:47:45.000Z</published>
    <updated>2024-12-23T11:47:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RT1024-EVK-学习笔记Part2"><a href="#RT1024-EVK-学习笔记Part2" class="headerlink" title="RT1024 EVK 学习笔记Part2"></a>RT1024 EVK 学习笔记Part2</h1><blockquote><p>POWER DOMAIN 部分！</p></blockquote><span id="more"></span><h2 id="功能模块供电"><a href="#功能模块供电" class="headerlink" title="功能模块供电"></a>功能模块供电</h2><h3 id="BUTTON部分"><a href="#BUTTON部分" class="headerlink" title="BUTTON部分"></a>BUTTON部分</h3><ul><li><p>包含三个按键：</p><ol><li>SW2: CPU <code>ONOFF</code>按键；–&gt; 连接到MCU <code>ONOFF</code>引脚；</li><li>SW3: 系统复位按键<code>POR_BUTTON</code>;–&gt; 连接到MCU <code>POR</code> 引脚；</li><li>SW4: 用户按键<code>USER_BUTTON</code>；–&gt; 连接到MCU的<code>WAKEUP</code>;</li></ol></li><li><p>每个按键的结构相似：</p><ol><li>SPST PB（Single Pole Single Throw Push Button）单刀单掷按钮</li><li><span style="color: green;">0.1uF的去抖电容；</span></li><li>接地连接</li></ol></li><li><p>按键工作原理：</p><ul><li>正常状态下通过上拉保持高电平<ul><li><span style="color: green;">按下时接地变为低电平；</span></li><li>电容用于消除按键抖动</li></ul></li></ul></li></ul><h3 id="USER-LED"><a href="#USER-LED" class="headerlink" title="USER LED"></a>USER LED</h3><blockquote><p>LED控制电路，使用了三极管驱动方案：</p></blockquote><ul><li><p>供电：<span style="color: red; font-weight: bold; ">(注意：DCDC_3V3 来自于 5V_SYS, 通过U4，有DCDC_3V3的输出！)</span></p><ul><li><p><code>DCDC_3V3</code>提供3.3V电源</p></li><li><p>R15（220Ω）作为LED**<u>限流电阻</u>**;</p></li></ul></li><li><p>LED部分：</p><ul><li><p><code>D5</code>是一个绿色LED</p></li><li><p><span style="color: blue;">阴极接三极管集电极；</span></p></li></ul></li><li><p>三极管驱动：</p><ul><li><p><code>Q521</code>是BC817-40LT1G <span style="color: green; ">NPN三极管；</span></p></li><li><p>R1870（2.2K）和R1856（22K）构成<span style="color: green; font-weight: bold; ">基极偏置网络；</span></p></li><li><p>MCU的<code>USER_LED</code>信号控制三极管导通；</p></li></ul></li><li><p>工作原理：</p><ul><li><p><code>USER_LED</code>低电平时，V(be) ≈0V, 三极管截止，LED熄灭；</p></li><li><p><code>USER_LED</code>高电平时，V(be) &gt; 0.7V, 三极管导通，LED点亮；</p></li><li><p>使用三极管可以提供更大的驱动能力</p></li></ul></li></ul><h2 id="关键电源管理"><a href="#关键电源管理" class="headerlink" title="关键电源管理"></a>关键电源管理</h2><style>.lswmjqgeqjep{zoom:100%;}</style><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part2/image-20241223180155208.png" class="lswmjqgeqjep"><h3 id="SD-Card-Power-Switch"><a href="#SD-Card-Power-Switch" class="headerlink" title="SD Card Power Switch"></a>SD Card Power Switch</h3><ul><li><p>电源路径：</p><ul><li>输入：<code>DCDC_3V3</code>（3.3V）</li><li>输出：<code>VSD_3V3</code>（SD卡供电）</li></ul></li><li><p>滤波：</p><ul><li><code>C171</code>（1.0μF/10V）：输入滤波</li><li><code>C30</code>（1.0μF/10V）：输出滤波</li></ul></li><li><p>控制逻辑：</p><ul><li><p>R28（10KΩ）上拉电阻到<code>DCDC_3V3</code>;</p></li><li><p>D7、D8二极管（RB521S30）构成AND门: 只有当<code>SD_PWREN</code>为高，且<code>POR_B</code>也为高时，<code>U27</code>才可以使能，有输出<code>VSD_3V3</code>;</p><blockquote><p>即：系统复位完成后，<code>POR_B</code>拉高，只有系统上电后、且SD卡使能 时，U27才工作，有输出：<code>VSD_3V3</code>!</p></blockquote></li></ul></li></ul><hr><style>.gjjhmyeyhyyl{zoom:100%;}</style><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part2/image-20241223180059053.png" class="gjjhmyeyhyyl"><h3 id="3V3-LDO-for-SNVS"><a href="#3V3-LDO-for-SNVS" class="headerlink" title="3V3 LDO for SNVS"></a>3V3 LDO for SNVS</h3><blockquote><p>这部分电路是 <strong>3.3V LDO（低压差稳压器）电源电路</strong>，用于为 <strong>SNVS（安全非易失性存储器供电域）</strong> 提供稳定的 3.3V 电压（<code>VLDO_3V3</code>）。</p></blockquote><p><span style="color: blue; font-weight: bold; ">电路组成：</span></p><ol><li><p><strong>输入电源部分：</strong></p><ul><li><strong>5V_SYS</strong> 是输入电源，提供5V电压。</li><li>C40 (10μF) 和 C41 (0.1μF)：<ul><li>是输入端的去耦电容，分别用于低频和高频噪声的滤波。</li><li><strong>C40</strong> 提供储能，减小输入电源的低频纹波。</li><li><strong>C41</strong> 用于滤除高频噪声，保护稳压器的输入端。</li></ul></li></ul></li><li><p><strong>LDO稳压器 (U3)：</strong></p><ul><li>U3 (UM1750S-00) 是一颗 LDO 稳压芯片，其主要引脚功能如下：<ul><li><strong>IN (1)：</strong> 输入引脚，连接 <code>5V_SYS</code>。</li><li><strong>OUT (5)：</strong> 输出引脚，生成稳定的 <code>VLDO_3V3</code>。</li><li><strong>GND (2)：</strong> 接地。</li><li><strong>FB (4)：</strong> 反馈引脚，用于调节和稳定输出电压，内部参考电压为 1V。</li><li><strong>SHDN (3)：</strong> 使能引脚，高电平使能稳压器，低电平关闭输出。</li></ul></li></ul></li><li><p><strong>反馈电路：</strong></p><ul><li><p>R32 (464kΩ) 和 R34 (200kΩ, 1%)：</p><ul><li><p>组成分压网络，用于将输出电压分压后反馈到 <strong>FB</strong> 引脚。</p></li><li><p>分压电路的电压关系为：</p><style>.nxbmjxqkmabl{zoom:100%;}</style><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part2/image-20241223180947687.png" class="nxbmjxqkmabl"></li></ul></li></ul></li><li><p><strong>输出滤波部分：</strong></p><ul><li>C42 (4.7μF, 6.3V) 和 C43 (0.1μF)：<ul><li><strong>C42</strong> 是主滤波电容，用于稳压器输出端的低频滤波，提供稳定的直流电压。</li><li><strong>C43</strong> 是高频滤波电容，用于抑制高频噪声和瞬态波动，提升稳定性。</li></ul></li></ul></li><li><p><strong>输出端：</strong></p><ul><li><code>VLDO_3V3</code>：<ul><li>是稳压器的输出电压，为后续电路提供稳定的 3.3V 电源，适用于 SNVS 域或其他低功耗模块。</li></ul></li></ul></li></ol><h3 id="SNVS"><a href="#SNVS" class="headerlink" title="SNVS"></a>SNVS</h3><p>在上面的输出<code>VLDO_3V3</code>，刚好就用于SNVS，产生<code>VDD_SNVS_3V3</code>,最终连接到MCU的引脚<code>VDD_SNVS_IN</code>:</p><style>.gpqfypqbrccw{zoom:100%;}</style><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part2/image-20241223184723149.png" class="gpqfypqbrccw"><hr><h3 id="NVCC-SD"><a href="#NVCC-SD" class="headerlink" title="NVCC_SD <SD3.0>"></a>NVCC_SD &lt;SD3.0&gt;</h3><blockquote><p>会根据 输入的 <code>SD0_VSELECT</code>信号，决定输出的<code>NVCC_SD</code>电压是1.8V或者3.3V，默认情况下是3.3V！</p></blockquote><style>.nihkuxbjikeh{zoom:100%;}</style><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part2/image-20241223190241734.png" class="nihkuxbjikeh"><hr><h2 id="核心电源域"><a href="#核心电源域" class="headerlink" title="核心电源域"></a>核心电源域</h2><style>.bnwsbsegehtp{zoom:100%;}</style><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part2/image-20241223182050938.png" class="bnwsbsegehtp"><h3 id="VDDHIGH-NVCC-xxx"><a href="#VDDHIGH-NVCC-xxx" class="headerlink" title="VDDHIGH/NVCC_xxx"></a>VDDHIGH/NVCC_xxx</h3><p>VDDHIGH/NVCC电源管理电路：</p><ol><li><strong>DC-DC转换器部分（U4 MP2144GJ）</strong>：<ul><li><p><strong>输入部分</strong>：</p><ul><li><code>5V_SYS</code>通过R38（0Ω）输入；</li><li>C49(10μF)/C50(10μF)/C51(0.1μF)输入滤波；</li></ul></li><li><p><strong>输出部分</strong>：</p><ul><li><code>L2</code>（1μH）储能电感；</li><li>C52(22μF)/C53(0.1μF)输出滤波；</li><li>输出<code>DCDC_3V3</code>（3.3V）；</li></ul></li><li><p><strong>使能部分：</strong></p><ul><li><span style="color: green;">通过<code>PMIC_ON_REQ</code>信号，当它为高时，才使能U4，有输出<code>DCDC_3V3</code>;</span></li><li>同时，控制U5的复位信号为低，不复位；否则U5会复位整个电路；</li></ul></li><li><p><strong>反馈控制</strong>：</p><ul><li>R40（180KΩ）/R42（40.2K）分压网络；计算得到输出为<code>3.28V</code>;</li><li>FB引脚监测输出电压；</li><li>注释显示R26/R30=4.5；<span style="color: blue; ">(???不知道是干嘛)</span></li></ul></li></ul></li><li><strong>复位控制电路（U5 UM605RE）</strong>：<ul><li><p><strong>输入信号</strong>：</p><ul><li><code>POR_BUTTON</code>：通过D9二极管</li><li><code>WDOG_B</code>：通过D10二极管</li><li>AND逻辑控制</li><li>当两者都为高时，才会使MR为高；只要有一个为低，都会导致MR使能；</li></ul></li><li><p><strong>电源监控</strong>：</p><ul><li>监控<code>VDD_SNVS_3V3</code></li><li>C60(0.1μF)去耦</li></ul></li></ul></li><li><strong>控制逻辑</strong>：<ul><li><p><strong>使能控制</strong>：</p><ul><li><code>PMIC_ON_REQ</code>信号</li><li>通过R41（10K）连接到EN引脚</li></ul></li><li><p><strong>PG（Power Good）</strong>：</p><ul><li>内部上拉到VIN，即<code>5V_SYS</code>;</li><li><code>DCDC_3V3_PG</code>信号输出;<span style="color: blue; font-weight: bold; ">(5V的PG怎么变成3V3的PG的？？搞不清楚)</span></li></ul></li></ul></li></ol><hr><h2 id="辅助电源"><a href="#辅助电源" class="headerlink" title="辅助电源"></a>辅助电源</h2><h3 id="ADC供电"><a href="#ADC供电" class="headerlink" title="ADC供电"></a>ADC供电</h3><p><code>DCDC_3V3</code>产生<code>VDDA_ADC_3V3</code>，供MCU端的引脚<code>VDDA_ADC_3P3</code>使用！</p><h3 id="DCDC-IN-VDD-HIGH-IN"><a href="#DCDC-IN-VDD-HIGH-IN" class="headerlink" title="DCDC_IN/VDD_HIGH_IN"></a>DCDC_IN/VDD_HIGH_IN</h3><p><code>DCDC_3V3</code>产生<code>MCU_DCDC_IN_3V3</code>，供MCU端的引脚<code>DCDC_IN</code>使用！</p><p><code>DCDC_3V3</code>产生<code>VDD_HIGH_IN_3V3</code>，供MCU端的引脚<code>VDD_HIGH_IN</code>使用！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>SOC的输入：(<code>VDD_SOC_IN</code>)的来源路径：</p><blockquote><p>5V_SYS -&gt; MP2144GJ(DC-DC) -&gt; DCDC_3V3/MCU_DCDC_IN_3V3 -&gt; DCDC_LP/DCDC_OUT -&gt; J4 -&gt; VDD_SOC_IN -&gt; MCU核心</p></blockquote></li><li><p>VDD_SNVS_IN</p><blockquote><p>5V_SYS -&gt; UM1750S-00 -&gt; VLDO_3V3 -&gt; VDD_SNVS_3V3</p></blockquote></li><li><p>VDD_HIGH_IN</p><blockquote><p>5V_SYS -&gt; MP2144GJ(DC-DC) -&gt; DCDC_3V3 -&gt; VDD_HIGH_IN_3V3</p></blockquote></li><li><p>VDDA_ADC_3P3</p><blockquote><p>5V_SYS -&gt; MP2144GJ(DC-DC) -&gt; DCDC_3V3 -&gt; VDDA_ADC_3P3</p></blockquote></li></ol><hr><style>.orymjxomwoev{zoom:100%;}</style><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part2/image-20241223192811426.png" class="orymjxomwoev"><ul><li>此外，先有 <code>MCU_DCDC_IN_3V3</code>, 然后才有 <code>MCU_DCDC_IN</code>。 <code>DCDC_LP</code> 引脚输出<code>DCDC_OUT</code>,供<code>VDD_SOC_IN</code>使用；</li><li><code>DCDC_PWITCH</code>引脚有一个PWITCH RC Delay电路，应该是用来保证上电时序的；</li><li><code>PMIC_ON_REQ</code>引脚对外输出该信号。决定了是否有<code>DCDC_3V3</code>的产生；</li><li><code>POR</code>引脚应该是低电平复位。接收输入的<code>POR_B</code>、<code>RST_TGTMCU_B</code>和U2。上电时，当电压达到阈值会释放复位，来确保上电时序。确保系统在电源稳定后才开始工作。</li><li><code>XTALI/XTALO</code>连接一个外部的24MHz晶振；<code>Y4</code></li><li><code>RTC_XTALI/RTC_XTALO</code>连接一个32.768KHZ的晶振：<code>Y2</code>;</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RT1024-EVK-学习笔记Part2&quot;&gt;&lt;a href=&quot;#RT1024-EVK-学习笔记Part2&quot; class=&quot;headerlink&quot; title=&quot;RT1024 EVK 学习笔记Part2&quot;&gt;&lt;/a&gt;RT1024 EVK 学习笔记Part2&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;POWER DOMAIN 部分！&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1024" scheme="https://dustofstars.github.io/categories/NXP/RT1024/"/>
    
    <category term="原理图" scheme="https://dustofstars.github.io/categories/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="hardware" scheme="https://dustofstars.github.io/tags/hardware/"/>
    
    <category term="原理图" scheme="https://dustofstars.github.io/tags/%E5%8E%9F%E7%90%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>RT1024 EVK 学习笔记Part1</title>
    <link href="https://dustofstars.github.io/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part1/"/>
    <id>https://dustofstars.github.io/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part1/</id>
    <published>2024-12-23T11:47:43.000Z</published>
    <updated>2024-12-23T11:47:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RT1024-EVK-学习笔记Part1"><a href="#RT1024-EVK-学习笔记Part1" class="headerlink" title="RT1024 EVK 学习笔记Part1"></a>RT1024 EVK 学习笔记Part1</h1><blockquote><p>Main Power &amp; USB &amp; FreeLink Debugger部分详细解释！</p></blockquote><span id="more"></span><h2 id="Page3-Main-Power"><a href="#Page3-Main-Power" class="headerlink" title="Page3 Main Power"></a>Page3 Main Power</h2><p>输入可以是三种电源选项，但是输出就一定是<code>5V_SYS</code>， 它用来给整个MCU系统供电。以下详细的从左到右：</p><ol><li><p><strong>电源输入部分</strong>：</p><ul><li>Barrel Connector（桶型接口）<code>J2</code>：用于连接外部5V的电源适配器；</li><li>C4 <code>0.1uF</code>电容：输入滤波电容，用于滤除输入电源的噪声;</li><li><code>TP1</code>：测试点，用于测量输入电压</li></ul></li><li><p><strong>MOSFET控制部分</strong>：</p><ul><li>FDMA530PZ（<code>Q1</code>）：功率MOSFET，用于电源开关控制；</li><li><code>D1</code>二极管：保护二极管，防止反向电流；</li><li><code>R3</code> 3.3K 电阻：限流电阻，保护MOSFET；</li></ul></li><li><p><strong>中间控制电路</strong>：</p><ul><li><code>SW1</code>：开关；</li><li>R4-R9：分压和偏置电阻网络</li><li>C5：稳定电容，用于滤波</li></ul></li><li><p><strong>LED指示电路</strong>：</p><ul><li><code>D3</code> LED_RED-GRN：双色LED，用于指示电源状态</li><li><code>Q4</code>（BSH1115）：控制LED的MOSFET</li><li>R10-R11：LED驱动电阻;</li></ul></li><li><p><strong>输出部分</strong>：</p><ul><li>C1-C3：输出滤波电容</li><li><code>J1</code>：输出接口;</li><li>C179-C180：去耦电容，用于稳定输出电压</li></ul></li></ol><blockquote><p><span style="color: red; font-weight: bold; ">关于J1短接选择不同的供电方式：</span></p><ul><li><p>1-2位置：<code>DC_5V_IN</code></p><ul><li><p>连接到<code>J2</code>的直流电源输入</p></li><li><p>适用于使用外部5V电源适配器供电的场景</p></li></ul></li><li><p>3-4位置：<code>5V_USB_OTG_S</code></p><ul><li>通过USB接口供电</li></ul></li><li><p>5-6位置：<code>P5V_SDA_S</code></p><ul><li><p>通过OpenSDA调试器供电</p></li><li><p>适用于使用调试器进行程序下载和调试的场景</p></li><li><p>集成了调试和供电功能</p></li></ul></li></ul></blockquote><p>那么，我们可以先看 <code>5V_USB_OTG_S</code>:</p><blockquote><p><span style="color: green; font-weight: bold; ">Page6 USB</span></p></blockquote><p>再看 <code>P5V_SDA_S</code>:</p><blockquote><p><span style="color: green; font-weight: bold; ">Page13 FREELINK</span></p></blockquote><h2 id="Page6-USB"><a href="#Page6-USB" class="headerlink" title="Page6 USB"></a>Page6 USB</h2><h3 id="USB-OTG-部分"><a href="#USB-OTG-部分" class="headerlink" title="USB OTG 部分"></a>USB OTG 部分</h3><ol><li><p><strong>接口部分</strong>：</p><ul><li>使用<code>USB AB 5</code>型接口，（指的是5Pin typeA/B）</li><li>包含5个引脚：VBUS（电源）、D+、D-（数据线）和GND（地）、和<strong>ID；</strong></li></ul></li><li><p><strong>保护电路</strong>：</p><ul><li>TVS二极管阵列（<code>U8</code> RClamp0854P）提供ESD保护;</li><li>保护USB接口免受静电和瞬态电压的损害</li><li>四个二极管保护四条信号线</li></ul></li><li><p><strong>EMI抑制</strong>：</p><ul><li>L3和L5（330Ω电感）用于抑制电磁干扰</li><li><span style="color: green;">L4（共模电感）用于抑制D+/D-信号线上的共模噪声；</span></li><li>这些元件确保信号传输的质量和稳定性</li></ul></li><li><p><strong>信号连接</strong>：</p><ul><li><code>OTG1_DN</code>和<code>OTG1_DP</code>是MCU的差分数据信号；</li><li>通过0Ω电阻（R68）连接ID线和<code>USB_OTG1_ID</code>信号，可以方便地断开或连接信号；</li><li><code>5V_USB_OTG</code>和<code>5V_USB_OTG_S</code>分别是USB供电的输入和输出</li></ul></li><li><p><strong>工作流程</strong>：</p><ul><li><p>当作为Host时：提供5V电源给外部设备</p></li><li><p>当作为Device时：接收外部供电</p></li><li><p>数据信号经过EMI滤波和ESD保护后与MCU连接</p><blockquote><p>作为device时，PC端供电，通过VBUS，提供给<code>5V_USB_OTG_S</code>，继而给整个MCU供电！</p></blockquote></li></ul></li></ol><style>.zoijephubkbj{zoom:100%;}</style><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part1/image-20241223152622192.png" class="zoijephubkbj"><h3 id="USB-POWER-部分"><a href="#USB-POWER-部分" class="headerlink" title="USB POWER 部分"></a>USB POWER 部分</h3><p>USB Power电路的工作原理如下：</p><ol><li><strong>核心控制芯片</strong>：<ul><li><code>U7</code>（NX5P3090UK）是一个专用的USB电源开关/限流器</li><li>主要功能如下，其中，<code>USB_OTG1_OC（过流检测信号）</code>，连接到<code>FAULT</code>引脚：<ul><li>电流限制</li><li>过流保护</li><li>电压监测</li><li>故障检测</li></ul></li></ul></li><li><strong>输入控制信号</strong>：<ul><li>EN（使能）引脚：控制电源开关的开启/关闭；</li><li>FAULT（故障）引脚：指示过流或短路故障；</li><li>VNT1/VNT2/VNT3：电压监测点；</li></ul></li><li><strong>工作流程</strong>：<ul><li>当MCU需要提供USB主机供电时：<ul><li>通过<code>USB_OTG1_ID</code>信号，自动检测是Device/Host，根据这个角色决定是否使能U7；<span style="color: green; font-weight: bold; ">工作在device模式，使能U7，对MCU供电；工作在Host模式，禁用U7；</span></li><li>U7监控输出电流和电压；</li><li>如果发生过流，FAULT信号激活；</li></ul></li></ul></li><li><strong>关键电路组件</strong>：<ul><li>C82/C83：输入滤波电容</li><li>C84：输出滤波电容</li><li>R67/R68：上拉电阻（100K）</li><li>R69/R70：配置电阻</li></ul></li><li><strong>应用场景</strong>：<ul><li>MCU作为USB主机时提供受控的5V电源</li><li>保护MCU和外部设备免受电气故障损坏</li></ul></li></ol><p>其中，两个最重要的信号线：</p><ol><li><p><code>USB_OTG1_OC</code> (Over Current):</p><ul><li><p>连接到U7的FAULT引脚</p></li><li><p>当发生过流时会触发</p></li><li><p>这个信号会反馈给MCU，用于过流保护</p></li></ul></li><li><p><code>5V_USB_OTG</code> VBUS:</p><ul><li><p>这是U7的输出端</p></li><li><p>提供受控的5V电源给USB接口</p></li><li><p>通过VBUS1/2/3引脚输出</p></li><li><p>经过C84去耦电容滤波</p></li></ul></li></ol><p>这两个信号构成了USB供电的核心监控和输出功能：</p><ul><li>一个负责监控安全（OC）</li><li>一个负责实际供电（VBUS）</li></ul><p>另外需要注意的是：</p><ol><li><p><strong>Device模式（作为设备被供电）</strong>：</p><ul><li>供电流程：<ul><li>外部USB Host提供5V电源</li><li>通过USB接口进入，形成<code>5V_USB_OTG</code></li><li>经过R312连接到<code>5V_USB_OTG_S</code></li><li>通过J1(3-4)选择作为<code>5V_SYS</code></li><li>为整个系统供电</li></ul></li><li><span style="color: green;">此时U7不工作，仅作为通路；</span></li></ul></li><li><p><strong>Host模式（作为主机供电）</strong>：</p><ul><li>供电流程：<ul><li>通过其他方式（DC或OpenSDA）产生<code>5V_SYS</code></li><li><span style="color: green;"><code>5V_SYS</code>作为<code>U7</code>的输入；</span></li><li>U7控制并输出<code>5V_USB_OTG</code>；</li><li>通过USB接口<code>VBUS</code>引脚对外供电<code>5V_USB_OTG</code>;</li></ul></li><li>U7提供电流限制和保护功能</li></ul></li><li><p><strong>关键理解点</strong>：</p><ul><li>5V_USB_OTG和5V_USB_OTG_S的关系：<ul><li>它们在电路中是相连的</li><li>但在不同模式下电流方向不同</li></ul></li><li>U7的作用：<ul><li>仅在Host模式时起作用</li><li>提供受控的5V输出</li><li>保护系统免受过流影响</li></ul></li></ul></li><li><p><strong>工作模式切换</strong>：</p><ul><li>通过ID信号识别当前模式</li><li>自动配置电源流向</li><li>U7根据模式自动使能或禁用</li></ul></li></ol><p>这种设计支持USB OTG的双向供电特性，允许设备在不同场景下灵活切换角色。看似复杂的电源路径实际上是为了实现这种灵活性。</p><style>.tdfwucylglku{zoom:100%;}</style><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part1/image-20241223160209612.png" class="tdfwucylglku"><h2 id="Page13-FREELINK"><a href="#Page13-FREELINK" class="headerlink" title="Page13 FREELINK"></a>Page13 FREELINK</h2><blockquote><p>FreeLink部分的核心组件是<code>LPC4322JET100</code>，暂时先不看它，只需要知道<code>J42</code>跳线帽会控制FreeLink的DFU模式，进入firmware重新烧写即可！ </p><p><span style="color: red; ">还有一个有意思的点，这个LPC需要外部的12MHz晶振<code>Y5</code>;</span></p><p>还有，MCU的UART1连接了电平转换芯片<code>NTS0102</code>，因此可以到PC的虚拟串口输出打印log。</p></blockquote><p>对于Power部分来说，仍然是上一节的老朋友：</p><p><code>U31</code>仍然是一个<code>NX5P3090UK</code>:</p><style>.lusvbhrjsmbg{zoom:100%;}</style><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part1/image-20241223160614690.png" class="lusvbhrjsmbg"><ol><li><strong>电源路径</strong>：<ul><li>输入：<code>P5V_SDA</code>通过U31的输入端</li><li>控制：经过U31的内部开关和保护电路</li><li>输出：通过U31的<code>VBUS1/2/3</code>引脚输出到<code>P5V_SDA_S</code></li></ul></li><li><strong>控制机制</strong>：<ul><li><code>POWER_EN</code>通过R216（1K）控制U31的使能</li><li><code>VTRG_FAULT_B</code>通过R215（10K）提供故障监测</li><li><code>5V_SDA_PSW</code>是在输出端额外引出的监测信号，可供外部使用；</li></ul></li></ol><p>那么，对于这种方式，电源路径如下：</p><blockquote><p>  <span style="color: green; font-weight: bold; ">调试器USB -&gt; VBUS -&gt; P5V_SDA -&gt; U31 -&gt; P5V_SDA_S -&gt; J1(5-6) -&gt; 5V_SYS</span></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RT1024-EVK-学习笔记Part1&quot;&gt;&lt;a href=&quot;#RT1024-EVK-学习笔记Part1&quot; class=&quot;headerlink&quot; title=&quot;RT1024 EVK 学习笔记Part1&quot;&gt;&lt;/a&gt;RT1024 EVK 学习笔记Part1&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Main Power &amp;amp; USB &amp;amp; FreeLink Debugger部分详细解释！&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1024" scheme="https://dustofstars.github.io/categories/NXP/RT1024/"/>
    
    <category term="原理图" scheme="https://dustofstars.github.io/categories/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="hardware" scheme="https://dustofstars.github.io/tags/hardware/"/>
    
    <category term="原理图" scheme="https://dustofstars.github.io/tags/%E5%8E%9F%E7%90%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>RT1060--串口edma详解(SDK)</title>
    <link href="https://dustofstars.github.io/NXP/RT1060/rt1060-%E4%B8%B2%E5%8F%A3edma%E8%AF%A6%E8%A7%A3-sdk/"/>
    <id>https://dustofstars.github.io/NXP/RT1060/rt1060-%E4%B8%B2%E5%8F%A3edma%E8%AF%A6%E8%A7%A3-sdk/</id>
    <published>2024-12-18T15:38:41.000Z</published>
    <updated>2024-12-18T15:38:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="串口edma详解"><a href="#串口edma详解" class="headerlink" title="串口edma详解"></a>串口edma详解</h1><blockquote><p>这次我们来一起看一下，基于 NXP MIMXRT1060 开发板的串口通信示例工程，学习如何使用 EDMA(增强型直接内存访问)来实现高效的串口数据传输。</p></blockquote><p>主要特点：</p><ol><li>使用 LPUART (低功耗串口)进行通信</li><li>利用 EDMA 实现数据传输，减少 CPU 干预</li><li>实现了一个回显功能 - 将接收到的数据发送回去</li></ol><span id="more"></span><h2 id="关键数据流"><a href="#关键数据流" class="headerlink" title="关键数据流"></a>关键数据流</h2><ul><li><p><span style="color: blue;"><strong>接收流程：</strong></span>串口输入 -&gt; LPUART接收寄存器 -&gt; EDMA传输 -&gt; 接收缓冲区(<code>g_rxBuffer</code>)</p></li><li><p><span style="color: blue;"><strong>发送流程：</strong></span>发送缓冲区(<code>g_txBuffer</code>) -&gt; EDMA传输 -&gt; LPUART发送寄存器 -&gt; 串口输出</p></li></ul><h2 id="lpuart-edma-transfer-c-工作流程"><a href="#lpuart-edma-transfer-c-工作流程" class="headerlink" title="lpuart_edma_transfer.c 工作流程"></a>lpuart_edma_transfer.c 工作流程</h2><ol><li>系统初始化：</li></ol><ul><li>配置 LPUART（波特率115200，使能收发）</li><li>配置 DMAMUX（设置 DMA 通道映射）</li><li>初始化 EDMA（并创建传输句柄）</li></ul><ol start="2"><li>主循环逻辑：</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* If RX is idle and g_rxBuffer is empty, start to read data to g_rxBuffer. */</span></span><br><span class="line">    <span class="keyword">if</span> ((!rxOnGoing) &amp;&amp; rxBufferEmpty)</span><br><span class="line">    {</span><br><span class="line">        rxOnGoing = <span class="literal">true</span>;</span><br><span class="line">        LPUART_ReceiveEDMA(DEMO_LPUART, &amp;g_lpuartEdmaHandle, &amp;receiveXfer);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If TX is idle and g_txBuffer is full, start to send data. */</span></span><br><span class="line">    <span class="keyword">if</span> ((!txOnGoing) &amp;&amp; txBufferFull)</span><br><span class="line">    {</span><br><span class="line">        txOnGoing = <span class="literal">true</span>;</span><br><span class="line">        LPUART_SendEDMA(DEMO_LPUART, &amp;g_lpuartEdmaHandle, &amp;sendXfer);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If g_txBuffer is empty and g_rxBuffer is full, copy g_rxBuffer to g_txBuffer. */</span></span><br><span class="line">    <span class="keyword">if</span> ((!rxBufferEmpty) &amp;&amp; (!txBufferFull))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">memcpy</span>(g_txBuffer, g_rxBuffer, ECHO_BUFFER_LENGTH);</span><br><span class="line">        rxBufferEmpty = <span class="literal">true</span>;</span><br><span class="line">        txBufferFull  = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>检查接收缓冲区状态，空闲则启动新的接收</li><li>检查发送缓冲区状态，满则启动新的发送</li><li>在接收完成且发送空闲时，将数据从接收缓冲区复制到发送缓冲区</li></ul><ol start="3"><li>状态管理：</li></ol><ul><li>使用回调函数处理传输完成事件</li><li>通过状态标志(<code>rxBufferEmpty</code>, <code>txBufferFull</code>等)协调收发过程</li></ul><h2 id="仔细分析callback机制"><a href="#仔细分析callback机制" class="headerlink" title="仔细分析callback机制"></a>仔细分析callback机制</h2><blockquote><p>首先看到几个关键的回调函数:</p><ol><li><code>LPUART_UserCallback</code> - 这是用户层的回调函数,在main中注册</li><li><code>LPUART_SendEDMACallback</code> - EDMA发送完成的回调</li><li><code>LPUART_ReceiveEDMACallback</code> - EDMA接收完成的回调</li><li><code>LPUART_TransferEdmaHandleIRQ</code> - LPUART的EDMA中断处理函数</li></ol></blockquote><p><span style="color: blue; font-weight: bold;">从代码中可以看到调用链路:</span></p><ol><li><p>在main中通过<code>LPUART_TransferCreateHandleEDMA</code>注册了用户回调:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create LPUART DMA handle. */</span></span><br><span class="line">LPUART_TransferCreateHandleEDMA(DEMO_LPUART, &amp;g_lpuartEdmaHandle, LPUART_UserCallback, <span class="literal">NULL</span>, &amp;g_lpuartTxEdmaHandle,</span><br><span class="line">                                &amp;g_lpuartRxEdmaHandle);</span><br></pre></td></tr></tbody></table></figure></li><li><p><span style="color: blue;"><strong>当EDMA传输完成时,会触发中断,调用<code>LPUART_TransferEdmaHandleIRQ()</code>;</strong></span></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Save the handle in global variables to support the double weak mechanism. */</span></span><br><span class="line">s_lpuartHandle[instance] = handle;</span><br><span class="line"><span class="comment">/* Set LPUART_TransferEdmaHandleIRQ as DMA IRQ handler */</span></span><br><span class="line">s_lpuartIsr[instance] = LPUART_TransferEdmaHandleIRQ;</span><br><span class="line"><span class="comment">/* Disable all LPUART internal interrupts */</span></span><br><span class="line">LPUART_DisableInterrupts(base, (<span class="type">uint32_t</span>)kLPUART_AllInterruptEnable);</span><br><span class="line"><span class="comment">/* Enable interrupt in NVIC. */</span></span><br><span class="line">(<span class="type">void</span>)EnableIRQ(s_lpuartIRQ[instance]);</span><br></pre></td></tr></tbody></table></figure></li><li><p>在EDMA的回调中会更新状态标志并调用用户回调:</p></li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LPUART_SendEDMACallback</span><br><span class="line">LPUART_ReceiveEDMACallback</span><br><span class="line">    --&gt; LPUART_UserCallback</span><br></pre></td></tr></tbody></table></figure><p>以下是LPUART EDMA传输的回调流程图:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[EDMA传输开始] --&gt; B[EDMA传输完成中断]</span><br><span class="line">    B --&gt; C[LPUART_TransferEdmaHandleIRQ]</span><br><span class="line">    C --&gt; D{传输类型?}</span><br><span class="line">    D --&gt;|发送完成| E[LPUART_SendEDMACallback]</span><br><span class="line">    D --&gt;|接收完成| F[LPUART_ReceiveEDMACallback]</span><br><span class="line">    E --&gt; G[LPUART_UserCallback]</span><br><span class="line">    F --&gt; G</span><br><span class="line">    G --&gt;|TX完成| H[设置txBufferFull=false&lt;br&gt;txOnGoing=false]</span><br><span class="line">    G --&gt;|RX完成| I[设置rxBufferEmpty=false&lt;br&gt;rxOnGoing=false]</span><br></pre></td></tr></tbody></table></figure><style>.oqfmgcptmdpp{zoom:100%;}</style><img src="/NXP/RT1060/rt1060-%E4%B8%B2%E5%8F%A3edma%E8%AF%A6%E8%A7%A3-sdk/image-20241218231344599.png" class="oqfmgcptmdpp"><p><span style="color: blue; font-weight: bold;">所以整个调用链是:</span></p><ol><li>EDMA完成传输</li><li>触发LPUART传输完成中断</li><li>调用<code>LPUART_TransferEdmaHandleIRQ</code></li><li><code>LPUART_TransferEdmaHandleIRQ</code>调用用户回调</li><li>用户回调更新状态标志</li></ol><p>这个机制实现了:</p><ol><li>硬件中断与软件处理的解耦</li><li>灵活的状态管理</li><li>异步操作的完成通知</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>初始化流程:</li></ol><ul><li>main函数中创建EDMA handle</li><li>注册<code>LPUART_UserCallback</code>作为用户回调</li><li>配置EDMA通道和中断</li></ul><ol start="2"><li>发送流程:</li></ol><ul><li>LPUART_SendEDMA触发发送</li><li>EDMA完成后触发中断</li><li>通过回调链更新状态标志</li></ul><ol start="3"><li>接收流程:</li></ol><ul><li>LPUART_ReceiveEDMA启动接收</li><li>EDMA完成后触发中断</li><li>通过回调链更新状态标志</li></ul><ol start="4"><li>状态管理:</li></ol><ul><li>txOnGoing/rxOnGoing表示传输进行状态</li><li>txBufferFull/rxBufferEmpty表示缓冲区状态</li><li>这些标志在回调中更新,在主循环中使用</li></ul><p>这种回调机制实现了:</p><ol><li>异步处理EDMA传输</li><li>状态管理的解耦</li><li>用户代码与底层驱动的分离</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;串口edma详解&quot;&gt;&lt;a href=&quot;#串口edma详解&quot; class=&quot;headerlink&quot; title=&quot;串口edma详解&quot;&gt;&lt;/a&gt;串口edma详解&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;这次我们来一起看一下，基于 NXP MIMXRT1060 开发板的串口通信示例工程，学习如何使用 EDMA(增强型直接内存访问)来实现高效的串口数据传输。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;主要特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 LPUART (低功耗串口)进行通信&lt;/li&gt;
&lt;li&gt;利用 EDMA 实现数据传输，减少 CPU 干预&lt;/li&gt;
&lt;li&gt;实现了一个回显功能 - 将接收到的数据发送回去&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1060" scheme="https://dustofstars.github.io/categories/NXP/RT1060/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="中断" scheme="https://dustofstars.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
    <category term="DMA" scheme="https://dustofstars.github.io/tags/DMA/"/>
    
  </entry>
  
  <entry>
    <title>RT1060--串口中断传输详解(SDK)</title>
    <link href="https://dustofstars.github.io/NXP/RT1060/rt1060-%E4%B8%B2%E5%8F%A3%E4%B8%AD%E6%96%AD%E4%BC%A0%E8%BE%93%E8%AF%A6%E8%A7%A3-sdk/"/>
    <id>https://dustofstars.github.io/NXP/RT1060/rt1060-%E4%B8%B2%E5%8F%A3%E4%B8%AD%E6%96%AD%E4%BC%A0%E8%BE%93%E8%AF%A6%E8%A7%A3-sdk/</id>
    <published>2024-12-17T09:42:42.000Z</published>
    <updated>2024-12-17T09:42:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="串口中断传输详解-SDK"><a href="#串口中断传输详解-SDK" class="headerlink" title="串口中断传输详解(SDK)"></a>串口中断传输详解(SDK)</h1><span id="more"></span><h2 id="1-evkmimxrt1060-lpuart-interrupt"><a href="#1-evkmimxrt1060-lpuart-interrupt" class="headerlink" title="1. evkmimxrt1060_lpuart_interrupt"></a>1. evkmimxrt1060_lpuart_interrupt</h2><blockquote><p>使用 NXP 的 <code>fsl_lpuart.h</code> 库，通过中断方式实现 LPUART 的数据接收和回显。</p><p>它使用了一个<code>ring buffer</code>来暂存接收到的数据，然后在主循环中将缓冲区的数据发送出去。</p></blockquote><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ol><li><p>宏定义：</p><ul><li><code>DEMO_LPUART</code>: 定义使用的 LPUART 外设为 <code>LPUART1</code>。</li><li><code>DEMO_LPUART_CLK_FREQ</code>: 定义 LPUART 的时钟频率。</li><li><code>DEMO_LPUART_IRQn</code>: 定义 LPUART 的中断号。</li><li><code>DEMO_LPUART_IRQHandler</code>: 定义 LPUART 的中断处理函数名。</li><li><code>DEMO_RING_BUFFER_SIZE</code>: 定义环形缓冲区的大小为 16 字节。</li></ul></li><li><p>全局变量：</p><ul><li><code>g_tipString</code>: 提示字符串，程序启动时发送到串口。</li><li><code>demoRingBuffer</code>: 环形缓冲区，<span style="color:green">用于存储接收到的数据</span>。</li><li><code>txIndex</code>: 发送索引，指向下一个要发送的数据在环形缓冲区中的位置。</li><li><code>rxIndex</code>: 接收索引，指向下一个要写入接收数据的环形缓冲区位置。</li></ul></li><li><p><code>DEMO_LPUART_IRQHandler()</code> 函数：</p><p> LPUART 中断处理函数：</p><ul><li>如果Rx Data 寄存器满，则：<ul><li>读取receiver register数据： (<code>LPUART_ReadByte()</code>)。</li><li>读完之后检查环形缓冲区是否已满，如果未满，则将接收到的数据写入环形缓冲区，并更新 <code>rxIndex</code>。</li></ul></li></ul></li><li><p><code>main()</code> 函数：</p><ul><li>初始化开发板和 LPUART。</li><li>发送提示字符串。</li><li>使能 LPUART 的接收满中断  (<code>kLPUART_RxDataRegFullInterruptEnable</code>)。</li><li>使能 LPUART 中断 (<code>EnableIRQ(DEMO_LPUART_IRQn)</code>)。</li><li>进入主循环：<ul><li>检查 LPUART 发送寄存器是否为空 (<code>kLPUART_TxDataRegEmptyFlag</code>)。</li><li>检查环形缓冲区是否非空。</li><li>如果发送寄存器为空且缓冲区非空，则从环形缓冲区读取数据 (<code>demoRingBuffer[txIndex]</code>)，并通过 <code>LPUART_WriteByte()</code> 发送出去，并更新 <code>txIndex</code>。</li></ul></li></ul></li></ol><h3 id="数据-中断-callback调用流程图"><a href="#数据-中断-callback调用流程图" class="headerlink" title="数据/中断/callback调用流程图"></a><strong>数据/中断/callback调用流程图</strong></h3><style>.dfnneidhuxsr{zoom:100%;}</style><img src="/NXP/RT1060/rt1060-%E4%B8%B2%E5%8F%A3%E4%B8%AD%E6%96%AD%E4%BC%A0%E8%BE%93%E8%AF%A6%E8%A7%A3-sdk/image-20241217175339831.png" class="dfnneidhuxsr"><p><strong>详细流程解释：</strong></p><ol><li>中断处理：<ul><li>读取接收到的数据并存入环形缓冲区 <code>demoRingBuffer</code>。</li><li>更新接收索引 <code>rxIndex</code>。</li></ul></li><li>主循环处理：<ul><li>主循环不断检查 LPUART 发送寄存器是否为空以及环形缓冲区是否非空。</li><li>如果条件满足，则从环形缓冲区读取数据，并通过 <code>LPUART_WriteByte()</code> 发送出去。</li><li>更新发送索引 <code>txIndex</code>。</li></ul></li><li><strong>数据发送：</strong> LPUART 硬件将数据发送到串口接收端。</li></ol><h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a><strong>关键点</strong></h3><ul><li><strong>环形缓冲区：</strong> 用于在中断处理函数和主循环之间传递数据，避免数据丢失。</li><li><strong>中断驱动：</strong> 使用中断来处理接收事件，提高了 CPU 效率。</li><li><strong>非阻塞发送：</strong> 主循环中轮询检查发送寄存器是否为空和ring buffer非空，用于读取数据并发送，更新<code>txIndex</code>;</li></ul><h2 id="2-evkmimxrt1060-lpuart-interrupt-transfer"><a href="#2-evkmimxrt1060-lpuart-interrupt-transfer" class="headerlink" title="2. evkmimxrt1060_lpuart_interrupt_transfer"></a>2. evkmimxrt1060_lpuart_interrupt_transfer</h2><blockquote><p>使用 LPUART 进行回显。</p><p>程序通过 LPUART 接收用户输入的 8 个字符，然后将这 8 个字符回显给用户终端。</p></blockquote><h3 id="代码解释-1"><a href="#代码解释-1" class="headerlink" title="代码解释"></a>代码解释</h3><p><strong>代码结构：</strong></p><ol><li><p><strong>宏定义</strong>：定义了一些宏和变量，例如使用的 LPUART 实例 (<code>DEMO_LPUART</code>)、时钟频率 (<code>DEMO_LPUART_CLK_FREQ</code>)、回显缓冲区长度 (<code>ECHO_BUFFER_LENGTH</code>) 。</p></li><li><p><strong>callback声明</strong>：声明了一个 LPUART 用户回调函数 <code>LPUART_UserCallback</code>。</p></li><li><p><strong>变量</strong>：定义了一些全局变量，例如用于存储句柄 (<code>g_lpuartHandle</code>)、提示信息字符串 (<code>g_tipString</code>)、发送缓冲区 (<code>g_txBuffer</code>)、接收缓冲区 (<code>g_rxBuffer</code>) 等，还有一些标志位用于指示缓冲区状态和传输状态：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> rxBufferEmpty            = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> txBufferFull             = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> txOnGoing                = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> rxOnGoing                = <span class="literal">false</span>;</span><br></pre></td></tr></tbody></table></figure></li><li><p>**LPUART 用户回调函数 (LPUART_UserCallback)**：该函数会在 LPUART 传输完成 (发送或接收) 时被调用。它更新发送和接收缓冲区的相关标志位 (txBufferFull、txOnGoing、rxBufferEmpty、rxOnGoing)。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* LPUART user callback */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LPUART_UserCallback</span><span class="params">(LPUART_Type *base, <span class="type">lpuart_handle_t</span> *handle, <span class="type">status_t</span> status, <span class="type">void</span> *userData)</span></span><br><span class="line">{</span><br><span class="line">    userData = userData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kStatus_LPUART_TxIdle == status) <span class="comment">// 实际上就是发送完成！</span></span><br><span class="line">    {</span><br><span class="line">        txBufferFull = <span class="literal">false</span>;</span><br><span class="line">        txOnGoing    = <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kStatus_LPUART_RxIdle == status) <span class="comment">// 实际上对应接收完成！</span></span><br><span class="line">    {</span><br><span class="line">        rxBufferEmpty = <span class="literal">false</span>;</span><br><span class="line">        rxOnGoing     = <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>主函数 (main)</p><ul><li><p>初始化时钟、引脚复用等。</p></li><li><p>配置 LPUART：设置波特率、启用发送和接收功能等。</p></li><li><p>创建 LPUART 传输句柄。</p><p><code>LPUART_TransferCreateHandle(DEMO_LPUART, &amp;g_lpuartHandle, LPUART_UserCallback, NULL);</code></p></li><li><p>发送提示信息字符串。</p><p><code>LPUART_TransferSendNonBlocking(DEMO_LPUART, &amp;g_lpuartHandle, &amp;xfer);</code></p></li><li><p>进入循环，实现回显功能：</p><ul><li><p>如果接收空闲且接收缓冲区为空，则启动接收数据到接收缓冲区。</p><p><code>LPUART_TransferReceiveNonBlocking(DEMO_LPUART, &amp;g_lpuartHandle, &amp;receiveXfer, NULL);</code></p></li><li><p>如果发送空闲且发送缓冲区满，则启动发送数据。</p><p><code>LPUART_TransferSendNonBlocking(DEMO_LPUART, &amp;g_lpuartHandle, &amp;sendXfer);</code></p></li><li><p>如果接收非空且发送不满，则将接收缓冲区内容复制到发送缓冲区，并更新缓冲区标志位。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(g_txBuffer, g_rxBuffer, ECHO_BUFFER_LENGTH);</span><br><span class="line">rxBufferEmpty = <span class="literal">true</span>;</span><br><span class="line">txBufferFull  = <span class="literal">true</span>;</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li></ol><p><strong>流程图：</strong></p><p><strong>数据流：</strong></p><ol><li>初始化阶段：<ul><li>配置 LPUART。</li></ul></li><li>发送提示信息：<ul><li>将提示信息字符串拷贝到发送缓冲区。</li><li>启动发送。</li></ul></li><li>回显循环：<ul><li>接收数据：<ul><li>如果接收空闲且接收缓冲区为空，则启动接收数据。</li><li>接收完成触发回调函数，更新接收缓冲区标志位。</li></ul></li><li>发送数据：<ul><li>如果发送空闲且发送缓冲区满，则启动发送数据。</li><li>发送完成触发回调函数，更新发送缓冲区标志位。</li></ul></li><li>复制数据：<ul><li>如果接收非空且发送不满，则将接收缓冲区内容复制到发送缓冲区。</li><li>更新接收和发送缓冲区标志位。</li></ul></li></ul></li></ol><p><strong>中断和回调流程：</strong></p><ol><li>当数据接收完成或发送完成后，会产生中断。</li><li>中断服务程序会将控制权转移到 LPUART 驱动程序。</li><li>驱动程序会调用用户回调函数 <code>LPUART_UserCallback</code>。</li><li>回调函数中，根据传输完成类型 (发送/接收) 更新相关的缓冲区标志位。</li></ol><p><strong>注意：</strong></p><ul><li>该代码使用非阻塞式传输，即发送或接收启动后，程序不会等待传输完成，而是继续执行其他操作。</li><li>回调函数中只更新了标志位，并没有直接操作数据缓冲区。数据处理是在主循环中进行的。</li></ul><p><strong>代码关键点</strong></p><ul><li><strong>非阻塞传输：</strong> 使用了 <code>LPUART_TransferSendNonBlocking</code> 和 <code>LPUART_TransferReceiveNonBlocking</code> 函数，这意味着发送和接收操作会在后台进行，不会阻塞主循环。</li><li><strong>回调函数：</strong> <code>LPUART_UserCallback</code> 函数用于处理传输完成事件。在这个函数中，主要任务是更新标志位，例如 <code>txOnGoing</code>、<code>txBufferFull</code>、<code>rxOnGoing</code> 和 <code>rxBufferEmpty</code>。</li><li><strong>缓冲区管理：</strong> 使用了 <code>g_txBuffer</code> 和 <code>g_rxBuffer</code> 作为发送和接收缓冲区，并通过 <code>memcpy</code> 函数在两个缓冲区之间复制数据。</li><li><strong>主循环逻辑：</strong> 主循环负责启动发送和接收操作，并在缓冲区之间复制数据。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    subgraph 初始化</span><br><span class="line">        A[初始化 LPUART] --&gt; B{发送提示信息}</span><br><span class="line">        B --&gt; C[启动发送&lt;br&gt;LPUART_TransferSendNonBlocking]</span><br><span class="line">        C --&gt; D{等待发送完成&lt;br&gt; txOnGoing }</span><br><span class="line">    end</span><br><span class="line">    D --&gt; E[回显循环]</span><br><span class="line">    subgraph 接收</span><br><span class="line">        E --&gt; F{接收空闲 &amp; 接收缓冲区为空&lt;br&gt; !rxOnGoing &amp;&amp; rxBufferEmpty }</span><br><span class="line">        F -- 是 --&gt; G[启动接收&lt;br&gt;LPUART_TransferReceiveNonBlocking]</span><br><span class="line">        G --&gt; H[LPUART 硬件接收数据&lt;br&gt;RxDataRegFullFlag 置位]</span><br><span class="line">        H --&gt; I[产生中断信号]</span><br><span class="line">        I --&gt; J[NVIC 处理中断&lt;br&gt;调用中断服务例程&lt;br&gt;LPUART_TransferHandleIRQ]</span><br><span class="line">        J --&gt; K[中断服务例程&lt;br&gt;调用 LPUART_UserCallback&lt;br&gt;kStatus_LPUART_RxIdle&lt;br&gt;rxBufferEmpty = false&lt;br&gt;rxOnGoing = false]</span><br><span class="line">    end</span><br><span class="line">    subgraph 发送</span><br><span class="line">        E --&gt; L{发送空闲 &amp; 发送缓冲区满&lt;br&gt; !txOnGoing &amp;&amp; txBufferFull }</span><br><span class="line">        L -- 是 --&gt; M[启动发送&lt;br&gt;LPUART_TransferSendNonBlocking]</span><br><span class="line">        M --&gt; N[LPUART 硬件发送数据]</span><br><span class="line">        N --&gt; O[发送完成&lt;br&gt;产生中断信号]</span><br><span class="line">        O --&gt; P[NVIC 处理中断&lt;br&gt;调用中断服务例程&lt;br&gt;LPUART_TransferHandleIRQ]</span><br><span class="line">        P --&gt; Q[中断服务例程&lt;br&gt;调用 LPUART_UserCallback&lt;br&gt;kStatus_LPUART_TxIdle&lt;br&gt;txBufferFull = false&lt;br&gt;txOnGoing = false]</span><br><span class="line">    end</span><br><span class="line">    E --&gt; R{接收缓冲区非空 &amp; 发送缓冲区未满&lt;br&gt; !rxBufferEmpty &amp;&amp; !txBufferFull}</span><br><span class="line">    R -- 是 --&gt; S[数据复制&lt;br&gt;memcpy&lt;br&gt;rxBufferEmpty = true&lt;br&gt;txBufferFull = true]</span><br><span class="line">    K --&gt; E</span><br><span class="line">    Q --&gt; E</span><br><span class="line">    S --&gt; E</span><br></pre></td></tr></tbody></table></figure><p><img src="/export.svg"></p><h3 id="代码逻辑解释："><a href="#代码逻辑解释：" class="headerlink" title="代码逻辑解释："></a><strong>代码逻辑解释：</strong></h3><ol><li><p><strong>初始化：</strong> 程序首先初始化 LPUART 外设，然后发送一个提示信息。</p></li><li><p>回显循环：</p><p> 程序进入一个无限循环，不断检查以下条件：</p><ul><li><span style="color:green"><strong>接收：</strong></span><ul><li>如果当前没有正在接收数据 (<code>!rxOnGoing</code>) 并且接收缓冲区为空 (<code>rxBufferEmpty</code>)，则启动一次非阻塞的接收操作 (<code>LPUART_TransferReceiveNonBlocking</code>)。</li><li>当 LPUART 硬件接收到数据后，<code>RxDataRegFullFlag</code> 标志位会被置位，触发中断。</li><li>NVIC 接收到中断请求后，会调用中断服务例程。在中断服务例程中，会调用用户定义的回调函数 <code>LPUART_UserCallback</code>。<ul><li>回调函数根据 <code>kStatus_LPUART_RxIdle</code> 状态将 <code>rxBufferEmpty</code> 设置为 <code>false</code>，将 <code>rxOnGoing</code> 设置为 <code>false</code>，表明接收已完成。</li></ul></li></ul></li><li><span style="color:green"><strong>发送：</strong></span><ul><li>如果当前没有正在发送数据 (<code>!txOnGoing</code>) 并且发送缓冲区已满 (<code>txBufferFull</code>)，则启动一次非阻塞的发送操作 (<code>LPUART_TransferSendNonBlocking</code>)。</li><li>LPUART 硬件发送完数据后，会产生中断。</li><li>NVIC 处理中断，并调用回调函数 <code>LPUART_UserCallback</code>。<ul><li>回调函数根据 <code>kStatus_LPUART_TxIdle</code> 状态将 <code>txBufferFull</code> 设置为 <code>false</code>，将 <code>txOnGoing</code> 设置为 <code>false</code>，表明发送已完成。</li></ul></li></ul></li><li><span style="color:green"><strong>数据复制：</strong></span>如果接收缓冲区非空 (<code>!rxBufferEmpty</code>) 并且发送缓冲区未满 (<code>!txBufferFull</code>)，则使用 <code>memcpy</code> 函数将接收缓冲区的数据复制到发送缓冲区，并将 <code>rxBufferEmpty</code> 设置为 <code>true</code>，<code>txBufferFull</code> 设置为 <code>true</code>，为下一次接收和发送做准备。</li></ul></li></ol><h3 id="关于中断和回调"><a href="#关于中断和回调" class="headerlink" title="关于中断和回调"></a>关于中断和回调</h3><p><code>LPUART_UserCallback</code> 是一个用户自定义的回调函数，它会在 LPUART 驱动程序中的中断处理函数 <code>LPUART_TransferHandleIRQ</code> 中，当特定的传输事件发生后被调用。具体来说，以下几种情况下会调用 <code>LPUART_UserCallback</code>：</p><ol><li><strong>接收完成：</strong> 当使用 <code>LPUART_TransferReceiveNonBlocking</code> 函数启动非阻塞接收，并且所有请求的数据都已接收完毕时，<code>LPUART_TransferHandleIRQ</code> 函数会在处理接收数据就绪中断时调用 <code>LPUART_UserCallback</code>，并传递状态 <code>kStatus_LPUART_RxIdle</code>。</li><li><strong>发送完成：</strong> 当使用 <code>LPUART_TransferSendNonBlocking</code> 函数启动非阻塞发送，并且所有数据都已发送完毕时，<code>LPUART_TransferHandleIRQ</code> 函数会在处理发送完成中断时调用 <code>LPUART_UserCallback</code>，并传递状态 <code>kStatus_LPUART_TxIdle</code>。</li><li><strong>接收硬件溢出：</strong> 当 LPUART 硬件发生接收溢出错误时，<code>LPUART_TransferHandleIRQ</code> 函数会在处理接收溢出中断时调用 <code>LPUART_UserCallback</code>，并传递状态 <code>kStatus_LPUART_RxHardwareOverrun</code>。这个状态表示有数据在接收之前就被覆盖了，导致数据丢失。</li></ol><h3 id="完整的接收流程和发送流程"><a href="#完整的接收流程和发送流程" class="headerlink" title="完整的接收流程和发送流程"></a>完整的接收流程和发送流程</h3><p><strong>接收流程：</strong></p><ol><li>应用程序调用 <code>LPUART_TransferReceiveNonBlocking</code> 函数启动非阻塞接收。</li><li><code>LPUART_TransferReceiveNonBlocking</code> 函数配置 LPUART 硬件，使能接收中断，并将接收请求的信息保存在 <code>lpuart_handle_t</code> 结构体中。</li><li>LPUART 硬件接收到数据后，触发中断。</li><li>CPU 响应中断，执行中断服务例程 <code>LPUART_TransferHandleIRQ</code>。</li><li><code>LPUART_TransferHandleIRQ</code> 函数检查中断状态，如果是接收数据就绪中断，则调用 <code>LPUART_TransferHandleReceiveDataFull</code> 函数。</li><li><code>LPUART_TransferHandleReceiveDataFull</code>函数将数据从LPUART接收FIFO读取到handle指定的缓冲区。</li><li><code>LPUART_TransferHandleReceiveDataFull</code>函数检查是否所有请求的数据都已接收完毕，如果是，则在<code>LPUART_TransferHandleIRQ</code>中调用<code>handle-&gt;callback</code>，即 <code>LPUART_UserCallback</code>，并传递 <code>kStatus_LPUART_RxIdle</code> 状态。</li></ol><p><strong>发送流程：</strong></p><ol><li>应用程序调用 <code>LPUART_TransferSendNonBlocking</code> 函数启动非阻塞发送。</li><li><code>LPUART_TransferSendNonBlocking</code> 函数配置 LPUART 硬件，使能发送中断，并将发送请求的信息保存在 <code>lpuart_handle_t</code> 结构体中。</li><li>当发送数据寄存器为空时，LPUART 硬件触发中断。</li><li>CPU 响应中断，执行中断服务例程 <code>LPUART_TransferHandleIRQ</code>。</li><li><code>LPUART_TransferHandleIRQ</code> 函数检查中断状态，如果是发送数据寄存器空中断，则调用 <code>LPUART_TransferHandleSendDataEmpty</code> 函数。</li><li><code>LPUART_TransferHandleSendDataEmpty</code>函数将数据从handle指定的缓冲区写入LPUART发送FIFO。</li><li><code>LPUART_TransferHandleSendDataEmpty</code>函数检查是否所有数据都已发送完毕。如果是，则当发送完成后，在<code>LPUART_TransferHandleIRQ</code>中调用 <code>handle-&gt;callback</code>，即 <code>LPUART_UserCallback</code>，并传递 <code>kStatus_LPUART_TxIdle</code> 状态。</li></ol><p><strong>总结：</strong></p><p><code>LPUART_UserCallback</code> 是一个在中断上下文中被调用的回调函数。它允许用户在 LPUART 传输完成后执行自定义的操作，例如：</p><ul><li>设置标志位，通知应用程序传输已完成。</li><li>启动下一次传输。</li><li>处理接收到的数据。</li><li>进行错误处理。</li></ul><p>通过使用回调函数，可以实现事件驱动的编程模型，提高程序的效率和响应性。用户不需要在主循环中轮询 LPUART 的状态，而是通过回调函数在传输完成后得到通知。</p><p>因此，<code>LPUART_UserCallback</code> 的调用时机取决于 LPUART 的传输状态和中断事件，主要发生在接收完成、发送完成和接收溢出等情况下。它在整个 LPUART 驱动程序中起到了连接驱动程序和用户应用程序的重要作用。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;串口中断传输详解-SDK&quot;&gt;&lt;a href=&quot;#串口中断传输详解-SDK&quot; class=&quot;headerlink&quot; title=&quot;串口中断传输详解(SDK)&quot;&gt;&lt;/a&gt;串口中断传输详解(SDK)&lt;/h1&gt;</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1060" scheme="https://dustofstars.github.io/categories/NXP/RT1060/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="中断" scheme="https://dustofstars.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
    <category term="UART" scheme="https://dustofstars.github.io/tags/UART/"/>
    
  </entry>
  
  <entry>
    <title>RT1060--串口空闲中断&amp;EDMA接收不定长数据</title>
    <link href="https://dustofstars.github.io/NXP/RT1060/rt1060-%E4%B8%B2%E5%8F%A3%E7%A9%BA%E9%97%B2%E4%B8%AD%E6%96%AD-edma%E6%8E%A5%E6%94%B6%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%95%B0%E6%8D%AE/"/>
    <id>https://dustofstars.github.io/NXP/RT1060/rt1060-%E4%B8%B2%E5%8F%A3%E7%A9%BA%E9%97%B2%E4%B8%AD%E6%96%AD-edma%E6%8E%A5%E6%94%B6%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%95%B0%E6%8D%AE/</id>
    <published>2024-12-04T06:41:42.000Z</published>
    <updated>2024-12-04T06:41:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="串口空闲中断-EDMA-接收不定长数据"><a href="#串口空闲中断-EDMA-接收不定长数据" class="headerlink" title="串口空闲中断 &amp; EDMA 接收不定长数据"></a>串口空闲中断 &amp; EDMA 接收不定长数据</h1><blockquote><p>客户有接收不定长数据的需求，但是如果采用协议适配的方法会非常繁琐。使用UART的IDLE中断+DMA的方式，即可高效的解决这一问题！</p></blockquote><p>另外，如果通过协议先接收单独的单字节，串口进中断接收在数据量大的时候效率会低很多</p><p>以RT1060EVK为例来进行这一操作！</p><span id="more"></span><h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">让我仔细分析一下这个main函数的执行流程和中断调用关系...</span><br><span class="line"></span><br><span class="line">首先看到几个关键的中断和回调:</span><br><span class="line">1. DEMO_LPUART_IRQHandler - UART的中断处理函数</span><br><span class="line">2. LPUART_UserCallback - DMA传输完成的回调函数</span><br><span class="line"></span><br><span class="line">中断触发的场景:</span><br><span class="line">1. IDLE线检测 - 接收到一帧数据后的空闲状态</span><br><span class="line">2. TC(传输完成)中断 - 发送完成后触发</span><br><span class="line">3. DMA传输完成中断 - 通过callback通知</span><br><span class="line"></span><br><span class="line">数据流转过程:</span><br><span class="line">1. 初始状态是接收模式</span><br><span class="line">2. 数据到来 -&gt; DMA自动接收到buffer</span><br><span class="line">3. 检测到空闲 -&gt; IDLE中断</span><br><span class="line">4. 处理数据 -&gt; 准备发送</span><br><span class="line">5. DMA发送 -&gt; 发送完成触发TC中断</span><br><span class="line">6. TC中断中切换回接收模式</span><br><span class="line"></span><br><span class="line">这里面有很多细节需要梳理,让我详细分析每个阶段的处理...</span><br></pre></td></tr></tbody></table></figure><p>让我详细解释main函数的逻辑和中断调用关系:</p><h3 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置:"></a><strong>初始化配置</strong>:</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置UART中断</span></span><br><span class="line">LPUART_EnableInterrupts(DEMO_LPUART, </span><br><span class="line">    kLPUART_IdleLineInterruptEnable|      <span class="comment">// 空闲线检测中断</span></span><br><span class="line">    kLPUART_RxOverrunInterruptEnable|     <span class="comment">// 接收溢出中断</span></span><br><span class="line">    kLPUART_NoiseErrorInterruptEnable|    <span class="comment">// 噪声错误中断</span></span><br><span class="line">    kLPUART_FramingErrorInterruptEnable|  <span class="comment">// 帧错误中断</span></span><br><span class="line">    kLPUART_ParityErrorInterruptEnable);  <span class="comment">// 奇偶校验错误中断</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始时禁用TC中断</span></span><br><span class="line">LPUART_DisableInterrupts(DEMO_LPUART, kLPUART_TransmissionCompleteInterruptEnable);</span><br></pre></td></tr></tbody></table></figure><h3 id="中断和DMA的调用流程"><a href="#中断和DMA的调用流程" class="headerlink" title="中断和DMA的调用流程:"></a><strong>中断和DMA的调用流程</strong>:</h3><h4 id="接收数据流程"><a href="#接收数据流程" class="headerlink" title="接收数据流程:"></a><strong>接收数据流程</strong>:</h4><ul><li>DMA持续接收数据到<code>g_rxBuffer</code></li><li>当检测到空闲线(<span style="color:red"><em><u>一段时间没有新数据</u></em></span>)时,触发IDLE中断；</li><li>在IDLE中断处理函数中:<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DEMO_LPUART_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> ((kLPUART_IdleLineFlag)&amp;stat)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 1. 获取已接收的数据长度</span></span><br><span class="line">        LPUART_TransferGetReceiveCountEDMA(...);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 复制数据到发送缓冲区</span></span><br><span class="line">        <span class="built_in">memcpy</span>(g_txBuffer, g_rxBuffer, rx_count);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 设置发送标志</span></span><br><span class="line">        reciveFrame = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 重新启动接收</span></span><br><span class="line">        LPUART_TransferAbortReceiveEDMA(...);</span><br><span class="line">        LPUART_ReceiveEDMA(...);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="发送数据流程"><a href="#发送数据流程" class="headerlink" title="发送数据流程:"></a><strong>发送数据流程</strong>:</h4><ul><li>main循环检测到<code>reciveFrame</code>为true时启动发送</li><li>DMA开始发送数据</li><li>发送完成后触发DMA完成中断,调用<code>LPUART_UserCallback</code></li><li>在callback中使能TC中断:<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LPUART_UserCallback</span><span class="params">(...)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (kStatus_LPUART_TxIdle == status)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 使能TC中断</span></span><br><span class="line">        LPUART_EnableInterrupts(DEMO_LPUART, kLPUART_TransmissionCompleteInterruptEnable);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>TC中断触发后,在中断处理函数中:<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((kLPUART_TransmissionCompleteFlag)&amp;stat)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 1. 禁用TC中断</span></span><br><span class="line">    LPUART_DisableInterrupts(DEMO_LPUART, kLPUART_TransmissionCompleteInterruptEnable);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 切换到接收模式</span></span><br><span class="line">    Set_RS485_Receive();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 重新启动接收</span></span><br><span class="line">    LPUART_TransferAbortReceiveEDMA(...);</span><br><span class="line">    LPUART_ReceiveEDMA(...);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="主循环逻辑"><a href="#主循环逻辑" class="headerlink" title="主循环逻辑:"></a><strong>主循环逻辑</strong>:</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(reciveFrame)  <span class="comment">// 检查是否收到完整数据帧</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 1. 准备发送数据</span></span><br><span class="line">        sendXfer.data = g_txBuffer;</span><br><span class="line">        sendXfer.dataSize = send_size;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 切换到发送模式</span></span><br><span class="line">        Set_RS485_Transimit();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 启动DMA发送</span></span><br><span class="line">        LPUART_SendEDMA(DEMO_LPUART, &amp;g_lpuartEdmaHandle, &amp;sendXfer);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 清除标志</span></span><br><span class="line">        reciveFrame = <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="关键点说明"><a href="#关键点说明" class="headerlink" title="关键点说明"></a>关键点说明</h2><ol><li>DMA用于实际的数据传输,不占用CPU</li><li><span style="color:red"><strong><u>IDLE中断用于检测一帧数据的接收完成</u></strong></span></li><li>TC中断用于确保最后一个字节完全发送出去</li><li>使用回调和中断机制实现自动的收发切换</li><li>主循环只负责检测标志并启动新的发送</li></ol><p>这种设计实现了高效的非阻塞式数据收发,同时正确处理了RS485半双工通信的方向切换时序。</p><h2 id="备注：详细的回调-中断实现的自动收发切换"><a href="#备注：详细的回调-中断实现的自动收发切换" class="headerlink" title="备注：详细的回调/中断实现的自动收发切换"></a>备注：详细的回调/中断实现的自动收发切换</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    A[初始状态: 接收模式] --&gt;|DMA接收数据| B[接收数据]</span><br><span class="line">    </span><br><span class="line">    B --&gt;|检测到IDLE| C[IDLE中断处理]</span><br><span class="line">    C --&gt;|1. 获取接收数据长度&lt;br&gt;2. 复制数据到TX buffer&lt;br&gt;3. 设置reciveFrame标志| D[主循环]</span><br><span class="line">    </span><br><span class="line">    D --&gt;|检测到reciveFrame| E[开始发送]</span><br><span class="line">    E --&gt;|1. 切换RS485方向&lt;br&gt;2. 启动DMA发送| F[DMA发送数据]</span><br><span class="line">    </span><br><span class="line">    F --&gt;|DMA发送完成| G[DMA完成回调&lt;br&gt;LPUART_UserCallback]</span><br><span class="line">    G --&gt;|使能TC中断| H[等待最后一个字节发送]</span><br><span class="line">    </span><br><span class="line">    H --&gt;|TC中断触发| I[TC中断处理]</span><br><span class="line">    I --&gt;|1. 禁用TC中断&lt;br&gt;2. 切换RS485方向&lt;br&gt;3. 重启DMA接收| A</span><br></pre></td></tr></tbody></table></figure><p>让我详细解释每个阶段的切换过程：</p><ol><li><p><strong>接收阶段</strong>:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始配置为接收模式</span></span><br><span class="line">Set_RS485_Receive();  <span class="comment">// GPIO设为低电平</span></span><br><span class="line">LPUART_ReceiveEDMA(...);  <span class="comment">// 启动DMA接收</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>接收完成检测</strong>:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IDLE中断处理函数中</span></span><br><span class="line"><span class="keyword">if</span> ((kLPUART_IdleLineFlag)&amp;stat)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 获取接收到的数据</span></span><br><span class="line">    LPUART_TransferGetReceiveCountEDMA(...);</span><br><span class="line">    <span class="built_in">memcpy</span>(g_txBuffer, g_rxBuffer, rx_count);</span><br><span class="line">    reciveFrame = <span class="literal">true</span>;  <span class="comment">// 设置标志通知主循环</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>切换到发送模式</strong>:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主循环中</span></span><br><span class="line"><span class="keyword">if</span>(reciveFrame)</span><br><span class="line">{</span><br><span class="line">    Set_RS485_Transimit();  <span class="comment">// GPIO设为高电平</span></span><br><span class="line">    LPUART_SendEDMA(...);   <span class="comment">// 启动DMA发送</span></span><br><span class="line">    reciveFrame = <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>发送完成处理</strong>:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DMA发送完成回调</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LPUART_UserCallback</span><span class="params">(...)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (kStatus_LPUART_TxIdle == status)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 使能TC中断，等待最后一个字节发送完成</span></span><br><span class="line">        LPUART_EnableInterrupts(DEMO_LPUART, kLPUART_TransmissionCompleteInterruptEnable);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// TC中断处理</span></span><br><span class="line"><span class="keyword">if</span>((kLPUART_TransmissionCompleteFlag)&amp;stat)</span><br><span class="line">{</span><br><span class="line">    LPUART_DisableInterrupts(DEMO_LPUART, kLPUART_TransmissionCompleteInterruptEnable);</span><br><span class="line">    Set_RS485_Receive();  <span class="comment">// 切换回接收模式</span></span><br><span class="line">    <span class="comment">// 重新启动接收</span></span><br><span class="line">    LPUART_TransferAbortReceiveEDMA(...);</span><br><span class="line">    LPUART_ReceiveEDMA(...);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><p>关键设计考虑：</p><ol><li><p><strong>为什么需要TC中断？</strong></p><ul><li>DMA完成不代表最后一个字节已经完全发送出去</li><li>TC中断确保最后一个字节完全发送后才切换方向</li><li>避免方向切换过早导致数据截断</li></ul></li><li><p><strong>方向切换时序</strong>:</p><ul><li>发送前：先切换方向，再开始发送</li><li>发送后：等待TC中断确认完全发送后，再切换回接收</li></ul></li><li><p><strong>自动化处理</strong>:</p><ul><li>使用中断和回调机制，无需主循环干预</li><li>主循环只负责启动新的发送</li><li>其他切换过程由中断自动完成</li></ul></li></ol><p>这种设计保证了RS485半双工通信的可靠性，同时通过DMA和中断机制提高了效率。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;串口空闲中断-EDMA-接收不定长数据&quot;&gt;&lt;a href=&quot;#串口空闲中断-EDMA-接收不定长数据&quot; class=&quot;headerlink&quot; title=&quot;串口空闲中断 &amp;amp; EDMA 接收不定长数据&quot;&gt;&lt;/a&gt;串口空闲中断 &amp;amp; EDMA 接收不定长数据&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;客户有接收不定长数据的需求，但是如果采用协议适配的方法会非常繁琐。使用UART的IDLE中断+DMA的方式，即可高效的解决这一问题！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外，如果通过协议先接收单独的单字节，串口进中断接收在数据量大的时候效率会低很多&lt;/p&gt;
&lt;p&gt;以RT1060EVK为例来进行这一操作！&lt;/p&gt;</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1060" scheme="https://dustofstars.github.io/categories/NXP/RT1060/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="中断" scheme="https://dustofstars.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
    <category term="DMA" scheme="https://dustofstars.github.io/tags/DMA/"/>
    
  </entry>
  
</feed>
