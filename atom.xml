<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DustOfStars</title>
  
  <subtitle>--jxw</subtitle>
  <link href="https://dustofstars.github.io/atom.xml" rel="self"/>
  
  <link href="https://dustofstars.github.io/"/>
  <updated>2024-12-24T11:47:47.000Z</updated>
  <id>https://dustofstars.github.io/</id>
  
  <author>
    <name>Gavin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RT1024 EVK 学习笔记Part3</title>
    <link href="https://dustofstars.github.io/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part3/"/>
    <id>https://dustofstars.github.io/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part3/</id>
    <published>2024-12-24T11:47:46.000Z</published>
    <updated>2024-12-24T11:47:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RT1024-EVK-学习笔记Part3"><a href="#RT1024-EVK-学习笔记Part3" class="headerlink" title="RT1024 EVK 学习笔记Part3"></a>RT1024 EVK 学习笔记Part3</h1><blockquote><p>Page5 MCU PINOUT 部分！</p><p>以及额外的，Page14 BOOT！</p></blockquote><span id="more"></span><h2 id="U1D-SEMC-部分"><a href="#U1D-SEMC-部分" class="headerlink" title="U1D SEMC 部分"></a>U1D SEMC 部分</h2><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part3/image-20241224104557031.png" class="" title="image-20241224104557031"><p>SEM接口部分共有42个引脚，为<code>GPIO_EMC_00</code> ~ <code>GPIO_EMC_41</code>。 它的功能分组如下：</p><h3 id="引脚功能分组"><a href="#引脚功能分组" class="headerlink" title="引脚功能分组"></a>引脚功能分组</h3><ul><li>数据线: <code>SEMC_D0</code> ~ <code>SEMC_D15</code> <span style="color: green; font-weight: bold; ">(16位数据总线)；</span></li><li>地址线: <code>SEMC_A0</code> ~ <code>SEMC_A12</code> <span style="color: green; font-weight: bold; ">(13位地址总线)；</span></li><li>控制信号13个: <ul><li>SEMC_DM0, SEMC_WE, SEMC_CAS, SEMC_RAS, SEMC_CS0, <code>SEMC_BA0</code>, <code>SEMC_BA1</code>;</li><li>SEMC_CKE, SEMC_CLK, SEMC_DM1;</li><li>SAI3_MCLK, ENET_MDIO, ENET_MDC;</li></ul></li></ul><h3 id="数据选通信号DQS说明"><a href="#数据选通信号DQS说明" class="headerlink" title="数据选通信号DQS说明"></a>数据选通信号DQS说明</h3><ul><li><p><code>SEMC_DQS</code>: 数据选通信号,用于高速数据传输时的同步; 在MCU端的Pin是<code>GPIO_EMC_28</code>, 它默认用于<code>SAI3_MCLK</code>, 如果需要SEMC的DQS功能，则要断开0Ω电阻<code>R426</code>；</p><ul><li><p><code>SAI3_MCLK</code>: <span style="color: green; font-weight: bold; ">音频接口主时钟信号；</span></p><blockquote><p><span style="color: blue; font-weight: bold; ">如果使用了SEMC_DQS, 且读写时Pin脚float，则能达到133MHz；否则，不使用SEMC_DQS, 读写速度只能达到66MHz；</span></p></blockquote></li></ul></li></ul><h3 id="控制信号详解"><a href="#控制信号详解" class="headerlink" title="控制信号详解"></a>控制信号详解</h3><ul><li><p><code>SEMC_DM0 / SEMC_DM1</code> (Data Mask):</p><ul><li>这是数据掩码信号</li><li>分别控制低8位和高8位；</li></ul></li><li><p><code>SEMC_WE</code> (Write Enable):</p><ul><li>写使能信号</li><li>低电平有效</li><li>用于指示当前是写操作</li><li>与RAS/CAS配合使用来控制读写时序</li></ul></li><li><p><code>SEMC_CAS</code> (Column Address Strobe):</p><ul><li>列地址选通信号</li><li>低电平有效</li><li>用于锁存列地址</li><li><span style="color: green;">SDRAM访问需要先给行地址再给列地址；</span></li></ul></li><li><p><code>SEMC_RAS</code> (Row Address Strobe):</p><ul><li>行地址选通信号</li><li>低电平有效</li><li>用于锁存行地址</li><li>与CAS的组合可以产生不同的SDRAM命令</li></ul></li><li><p><code>SEMC_CS0</code> (Chip Select):</p><ul><li><span style="color: green;">片选信号；</span>–&gt; <span style="color: blue; font-weight: bold; ">因为只有一个片选信号，RT1024应该是只能外接一片SDRAM的；</span></li><li>低电平有效</li><li>系统可以有多个CS信号连接多个SDRAM</li></ul></li><li><p><code>SEMC_BA0/BA1</code> (Bank Address):</p><ul><li><span style="color: green;">SDRAM内部bank地址信号；</span></li><li>用于选择SDRAM内部的存储体</li><li>通常SDRAM有4个bank,需要2位地址</li><li>可以实现bank交错访问提高性能</li></ul></li></ul><h2 id="U1F-NVCC-SD-部分"><a href="#U1F-NVCC-SD-部分" class="headerlink" title="U1F NVCC_SD 部分"></a>U1F NVCC_SD 部分</h2><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part3/image-20241224104624579.png" class="" title="image-20241224104624579"><h3 id="电源设计"><a href="#电源设计" class="headerlink" title="电源设计"></a>电源设计</h3><ul><li><code>NVCC_SD</code>为SD接口<code>NVCC_SD0</code>供电；</li><li>使用两个去耦电容:<ul><li>C76(4.7μF): 大电容用于稳定电源</li><li>C77(0.1μF): 小电容用于滤除高频噪声</li></ul></li></ul><h3 id="SD卡接口信号-GPIO-SD-B0-xx组"><a href="#SD卡接口信号-GPIO-SD-B0-xx组" class="headerlink" title="SD卡接口信号(GPIO_SD_B0_xx组)"></a>SD卡接口信号(<code>GPIO_SD_B0_xx</code>组)</h3><p>（7个Pin：00~06）</p><ul><li><code>SD1_D0~D3</code>: <span style="color: green;"> 4位数据线，其中，D0有上拉到<code>NVCC_SD</code>高电平；</span></li><li><code>SD1_CMD</code>: <span style="color: green;">命令线，上拉到<code>NVCC_SD</code>高电平；</span></li><li><code>SD1_CLK</code>: 时钟线；</li><li><code>SD_CD_SW</code>: <span style="color: green;">SD卡检测信号，</span>注意这个Pin脚是<code>GPIO_SD_B0_06</code>；</li></ul><h3 id="其他复用功能-GPIO-SD-B1-xx组"><a href="#其他复用功能-GPIO-SD-B1-xx组" class="headerlink" title="其他复用功能(GPIO_SD_B1_xx组)"></a>其他复用功能(GPIO_SD_B1_xx组)</h3><p>（12个Pin：00~11）</p><ul><li><p><code>CAN1_TX/RX:</code> CAN通信接口；</p></li><li><p><code>I2C4_SCL/SDA</code>: I2C通信接口；</p></li><li><p><code>SAI3</code>相关信号: 音频接口信号：</p><ul><li><code>SAI3_TX_BCLK</code></li><li><code>SAI3_TX_SYNC</code></li><li><code>SAI3_TXD</code></li><li><code>SAI3_RXD</code></li></ul></li><li><p><code>INT1/2_COMBO</code>以及<code>AUD_INT</code>: 中断信号；</p><blockquote><p><span style="color: blue; font-weight: bold; ">其中<code>INT2_COMBO</code>通过DNP未连接0Ω电阻R243到<code>GPIO_SD_B1_05</code>，它也是FlexSPI DQS线，需要floating，使QSPI Flash读写速度达到133MHz；</span></p></blockquote></li><li><p><code>SD_PWREN</code>:<span style="color: green; ">这个也是个重要控制信号，来决定SD卡是否上电！</span></p></li></ul><h2 id="U1C-5V-USB-OTG-部分"><a href="#U1C-5V-USB-OTG-部分" class="headerlink" title="U1C 5V_USB_OTG 部分"></a>U1C 5V_USB_OTG 部分</h2><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part3/image-20241224110847726.png" class="" title="image-20241224110847726"><p>MCU的USB OTG接口电路部分</p><ol><li><strong>电源设计</strong><ul><li><code>5V_USB_OTG</code>: USB 5V供电，限流25mA，连接到<code>USB_OTG1_VBUS</code>引脚；</li><li><code>VDD_USB_3V</code>: 3.3V供电，连接到<code>VDD_USB_CAP</code>；</li></ul></li><li><strong>信号线</strong><ul><li><code>OTG1_DN / OTG1_DP</code>: USB差分数据对</li><li><code>USB_OTG1_VBUS</code>: VBUS电源检测引脚;</li><li><code>USB_OTG1_CHD</code>: 充电检测引脚;</li></ul></li></ol><h2 id="U1E-NVCC-GPIO-3V3-部分"><a href="#U1E-NVCC-GPIO-3V3-部分" class="headerlink" title="U1E NVCC_GPIO_3V3 部分"></a>U1E NVCC_GPIO_3V3 部分</h2><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part3/image-20241224112223432.png" class="" title="image-20241224112223432"><h3 id="电源设计-1"><a href="#电源设计-1" class="headerlink" title="电源设计"></a><strong>电源设计</strong></h3><ul><li><span style="color: green; font-weight: bold; "><code>DCDC_3V3</code>转换为<code>NVCC_GPIO_3V3</code>供电；</span></li><li>采用双级去耦电容设计：<ul><li>5个4.7μF大电容：处理低频噪声</li><li>5个0.1μF小电容：处理高频噪声</li></ul></li><li>这种配置确保了GPIO供电的稳定性</li></ul><h3 id="GPIO配置"><a href="#GPIO配置" class="headerlink" title="GPIO配置"></a><strong>GPIO配置</strong></h3><ul><li><code>NVCC_GPIO</code>：<span style="color: green;">5个Pin给GPIO组进行独立供电；</span></li><li><code>GPIO_AD_B0_xx</code>和<code>GPIO_AD_B1_xx</code>：两组GPIO端口，B0组有16个Pin，B1组有10个Pin；</li></ul><h4 id="GPIO-AD-B0-xx-组"><a href="#GPIO-AD-B0-xx-组" class="headerlink" title="GPIO_AD_B0_xx 组"></a>GPIO_AD_B0_xx 组</h4><ol><li><strong>调试接口</strong><ul><li>JTAG接口：<ul><li>JTAG_TMS：测试模式选择</li><li>JTAG_TCK：时钟</li><li>JTAG_TDI：测试数据输入</li><li>JTAG_TDO：测试数据输出</li><li>JTAG_nTRST：复位</li><li><span style="color: blue;">JTAG_MOD 默认接地；</span></li></ul></li><li>SWD接口：<ul><li>SWD_CLK：时钟，复用JTAG_TCK；</li><li>SWD_DIO：数据输入输出，复用JTAG_TMS;</li><li><code>TRACE_SWO</code>：<span style="color: blue; font-weight: bold; ">默认DNP的，复用了<code>GPIO_AD_B0_12</code>;</span></li></ul></li></ul></li><li><strong>通信接口</strong><ul><li>UART1_TXD / RXD：串口通信</li><li>ENET：以太网接口信号<ul><li>4个接收/发送数据线：<ul><li>ENET_RXD1/ ENET_RXD0；</li><li>ENET_TXD1/ ENET_TXD0；</li></ul></li><li>1个时钟线：ENET_TX_REF_CLK</li><li>1个使能线：ENET_TXEN</li><li>1个复位线：ENET_RST</li><li>其他控制线：<ul><li><code>ENET_RXER</code></li><li><code>ENET_CRS_DV</code></li></ul></li></ul></li></ul></li><li><strong>特殊功能</strong><ul><li><code>WDOG_B</code>：看门狗复位，和<code>JTAG_TDI</code>复用；</li><li><code>TRACE_SWO</code>：跟踪调试输出</li></ul></li></ol><h4 id="GPIO-AD-B1-xx-组"><a href="#GPIO-AD-B1-xx-组" class="headerlink" title="GPIO_AD_B1_xx 组"></a>GPIO_AD_B1_xx 组</h4><blockquote><p><span style="color: green; font-weight: bold; ">好像放的是一些外设的重要控制信号？！</span></p></blockquote><ul><li>ENET_INT：以太网中断信号</li><li>SD0_VSELECT：SD卡电压选择，支持1.8V/3.3V双电压模式；</li><li>USER_LED</li><li>USB_OTG1_PWR ： 控制外部USB设备供电</li><li>USB_OTG1_ID ： 用于确定USB角色(主机/设备)</li><li>USB_OTG1_OC ： 检测USB端口是否发生过流</li><li>CAN_STBY</li><li>I2C1_SCL / I2C1_SDA</li></ul><hr><h2 id="Page-14-BOOT"><a href="#Page-14-BOOT" class="headerlink" title="Page 14 BOOT"></a>Page 14 BOOT</h2><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part3/image-20241224134408689.png" class="" title="image-20241224134408689"><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part3/image-20241224134346036.png" class="" title="image-20241224134346036"><p>启动配置部分<code>BOOT_CFG[0:9]</code>：</p><ol><li><strong>FUSE MAP配置表</strong><ul><li><strong>FlexSPI - Serial NOR配置</strong>：<ul><li><code>HOLD TIME</code>可选：500us/1ms/3ms/10ms</li><li>FLASH类型支持多种选项：<ul><li><code>3B/4B读取模式</code></li><li>HyperFlash 1V8/3V3</li><li>QSPI设备 3B读取模式–&gt; <span style="color: blue; font-weight: bold; ">在secondary pinmux选项上；</span>；</li><li>Micron Octal DDR</li><li>MXIC Octal DDR</li></ul></li><li>EncryptedXIP：使能与否；</li></ul></li><li><strong>SD启动配置</strong>：<ul><li>SD/SDXC速度模式4种选择：<ul><li>Normal/SDR12</li><li>High/SDR25</li><li>SDR50</li><li>SDR104</li></ul></li><li><span style="color: green;">总线宽度：1-bit/4-bit</span></li><li>电源循环和时钟源选项</li><li>端口选择：eSDHC1/eSDHC2</li><li>快速启动选项</li></ul></li></ul></li><li><strong>硬件实现</strong><ul><li>**DIP开关(SW8)**：<ul><li>四个选项连接：BT_CFG[0]、BT_CFG[5]、BOOT_MODE[0]、BOOT_MODE[1]；</li><li>用于选择启动模式：<ul><li>Serial Download: 0001</li><li>FlexSPI Boot:       0010</li><li>SD Boot:              0110</li></ul></li></ul></li><li><strong>GPIO连接</strong>：<ul><li>使用GPIO_EMC_16到GPIO_EMC_27</li><li>这些引脚在启动时作为配置引脚</li><li>启动后可以作为普通GPIO使用</li></ul></li></ul></li><li><strong>特殊功能</strong><ul><li>支持加密XIP（Execute In Place）</li><li>可配置快速启动模式</li><li>支持多种存储设备类型</li><li>灵活的时序和总线配置</li></ul></li></ol><p>这种设计提供了灵活的启动选项，允许系统从不同类型的存储设备启动，并且可以通过DIP开关轻松更改启动配置，方便开发和调试。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RT1024-EVK-学习笔记Part3&quot;&gt;&lt;a href=&quot;#RT1024-EVK-学习笔记Part3&quot; class=&quot;headerlink&quot; title=&quot;RT1024 EVK 学习笔记Part3&quot;&gt;&lt;/a&gt;RT1024 EVK 学习笔记Part3&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Page5 MCU PINOUT 部分！&lt;/p&gt;
&lt;p&gt;以及额外的，Page14 BOOT！&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1024" scheme="https://dustofstars.github.io/categories/NXP/RT1024/"/>
    
    <category term="原理图" scheme="https://dustofstars.github.io/categories/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="hardware" scheme="https://dustofstars.github.io/tags/hardware/"/>
    
    <category term="原理图" scheme="https://dustofstars.github.io/tags/%E5%8E%9F%E7%90%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>RT1024 EVK 学习笔记Part2</title>
    <link href="https://dustofstars.github.io/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part2/"/>
    <id>https://dustofstars.github.io/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part2/</id>
    <published>2024-12-23T11:47:45.000Z</published>
    <updated>2024-12-23T11:47:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RT1024-EVK-学习笔记Part2"><a href="#RT1024-EVK-学习笔记Part2" class="headerlink" title="RT1024 EVK 学习笔记Part2"></a>RT1024 EVK 学习笔记Part2</h1><blockquote><p>POWER DOMAIN 部分！</p></blockquote><span id="more"></span><h2 id="功能模块供电"><a href="#功能模块供电" class="headerlink" title="功能模块供电"></a>功能模块供电</h2><h3 id="BUTTON部分"><a href="#BUTTON部分" class="headerlink" title="BUTTON部分"></a>BUTTON部分</h3><ul><li><p>包含三个按键：</p><ol><li>SW2: CPU <code>ONOFF</code>按键；–&gt; 连接到MCU <code>ONOFF</code>引脚；</li><li>SW3: 系统复位按键<code>POR_BUTTON</code>;–&gt; 连接到MCU <code>POR</code> 引脚；</li><li>SW4: 用户按键<code>USER_BUTTON</code>；–&gt; 连接到MCU的<code>WAKEUP</code>;</li></ol></li><li><p>每个按键的结构相似：</p><ol><li>SPST PB（Single Pole Single Throw Push Button）单刀单掷按钮</li><li><span style="color: green;">0.1uF的去抖电容；</span></li><li>接地连接</li></ol></li><li><p>按键工作原理：</p><ul><li>正常状态下通过上拉保持高电平<ul><li><span style="color: green;">按下时接地变为低电平；</span></li><li>电容用于消除按键抖动</li></ul></li></ul></li></ul><h3 id="USER-LED"><a href="#USER-LED" class="headerlink" title="USER LED"></a>USER LED</h3><blockquote><p>LED控制电路，使用了三极管驱动方案：</p></blockquote><ul><li><p>供电：<span style="color: red; font-weight: bold; ">(注意：DCDC_3V3 来自于 5V_SYS, 通过U4，有DCDC_3V3的输出！)</span></p><ul><li><p><code>DCDC_3V3</code>提供3.3V电源</p></li><li><p>R15（220Ω）作为LED**<u>限流电阻</u>**;</p></li></ul></li><li><p>LED部分：</p><ul><li><p><code>D5</code>是一个绿色LED</p></li><li><p><span style="color: blue;">阴极接三极管集电极；</span></p></li></ul></li><li><p>三极管驱动：</p><ul><li><p><code>Q521</code>是BC817-40LT1G <span style="color: green; ">NPN三极管；</span></p></li><li><p>R1870（2.2K）和R1856（22K）构成<span style="color: green; font-weight: bold; ">基极偏置网络；</span></p></li><li><p>MCU的<code>USER_LED</code>信号控制三极管导通；</p></li></ul></li><li><p>工作原理：</p><ul><li><p><code>USER_LED</code>低电平时，V(be) ≈0V, 三极管截止，LED熄灭；</p></li><li><p><code>USER_LED</code>高电平时，V(be) &gt; 0.7V, 三极管导通，LED点亮；</p></li><li><p>使用三极管可以提供更大的驱动能力</p></li></ul></li></ul><h2 id="关键电源管理"><a href="#关键电源管理" class="headerlink" title="关键电源管理"></a>关键电源管理</h2><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part2/image-20241223180155208.png" class="" title="image-20241223180155208"><h3 id="SD-Card-Power-Switch"><a href="#SD-Card-Power-Switch" class="headerlink" title="SD Card Power Switch"></a>SD Card Power Switch</h3><ul><li><p>电源路径：</p><ul><li>输入：<code>DCDC_3V3</code>（3.3V）</li><li>输出：<code>VSD_3V3</code>（SD卡供电）</li></ul></li><li><p>滤波：</p><ul><li><code>C171</code>（1.0μF/10V）：输入滤波</li><li><code>C30</code>（1.0μF/10V）：输出滤波</li></ul></li><li><p>控制逻辑：</p><ul><li><p>R28（10KΩ）上拉电阻到<code>DCDC_3V3</code>;</p></li><li><p>D7、D8二极管（RB521S30）构成AND门: 只有当<code>SD_PWREN</code>为高，且<code>POR_B</code>也为高时，<code>U27</code>才可以使能，有输出<code>VSD_3V3</code>;</p><blockquote><p>即：系统复位完成后，<code>POR_B</code>拉高，只有系统上电后、且SD卡使能 时，U27才工作，有输出：<code>VSD_3V3</code>!</p></blockquote></li></ul></li></ul><hr><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part2/image-20241223180059053.png" class="" title="image-20241223180059053"><h3 id="3V3-LDO-for-SNVS"><a href="#3V3-LDO-for-SNVS" class="headerlink" title="3V3 LDO for SNVS"></a>3V3 LDO for SNVS</h3><blockquote><p>这部分电路是 <strong>3.3V LDO（低压差稳压器）电源电路</strong>，用于为 <strong>SNVS（安全非易失性存储器供电域）</strong> 提供稳定的 3.3V 电压（<code>VLDO_3V3</code>）。</p></blockquote><p><span style="color: blue; font-weight: bold; ">电路组成：</span></p><ol><li><p><strong>输入电源部分：</strong></p><ul><li><strong>5V_SYS</strong> 是输入电源，提供5V电压。</li><li>C40 (10μF) 和 C41 (0.1μF)：<ul><li>是输入端的去耦电容，分别用于低频和高频噪声的滤波。</li><li><strong>C40</strong> 提供储能，减小输入电源的低频纹波。</li><li><strong>C41</strong> 用于滤除高频噪声，保护稳压器的输入端。</li></ul></li></ul></li><li><p><strong>LDO稳压器 (U3)：</strong></p><ul><li>U3 (UM1750S-00) 是一颗 LDO 稳压芯片，其主要引脚功能如下：<ul><li><strong>IN (1)：</strong> 输入引脚，连接 <code>5V_SYS</code>。</li><li><strong>OUT (5)：</strong> 输出引脚，生成稳定的 <code>VLDO_3V3</code>。</li><li><strong>GND (2)：</strong> 接地。</li><li><strong>FB (4)：</strong> 反馈引脚，用于调节和稳定输出电压，内部参考电压为 1V。</li><li><strong>SHDN (3)：</strong> 使能引脚，高电平使能稳压器，低电平关闭输出。</li></ul></li></ul></li><li><p><strong>反馈电路：</strong></p><ul><li><p>R32 (464kΩ) 和 R34 (200kΩ, 1%)：</p><ul><li><p>组成分压网络，用于将输出电压分压后反馈到 <strong>FB</strong> 引脚。</p></li><li><p>分压电路的电压关系为：</p><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part2/image-20241223180947687.png" class="" title="image-20241223180947687"></li></ul></li></ul></li><li><p><strong>输出滤波部分：</strong></p><ul><li>C42 (4.7μF, 6.3V) 和 C43 (0.1μF)：<ul><li><strong>C42</strong> 是主滤波电容，用于稳压器输出端的低频滤波，提供稳定的直流电压。</li><li><strong>C43</strong> 是高频滤波电容，用于抑制高频噪声和瞬态波动，提升稳定性。</li></ul></li></ul></li><li><p><strong>输出端：</strong></p><ul><li><code>VLDO_3V3</code>：<ul><li>是稳压器的输出电压，为后续电路提供稳定的 3.3V 电源，适用于 SNVS 域或其他低功耗模块。</li></ul></li></ul></li></ol><h3 id="SNVS"><a href="#SNVS" class="headerlink" title="SNVS"></a>SNVS</h3><p>在上面的输出<code>VLDO_3V3</code>，刚好就用于SNVS，产生<code>VDD_SNVS_3V3</code>,最终连接到MCU的引脚<code>VDD_SNVS_IN</code>:</p><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part2/image-20241223184723149.png" class="" title="image-20241223184723149"><hr><h3 id="NVCC-SD"><a href="#NVCC-SD" class="headerlink" title="NVCC_SD <SD3.0>"></a>NVCC_SD &lt;SD3.0&gt;</h3><blockquote><p>会根据 输入的 <code>SD0_VSELECT</code>信号，决定输出的<code>NVCC_SD</code>电压是1.8V或者3.3V，默认情况下是3.3V！</p></blockquote><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part2/image-20241223190241734.png" class="" title="image-20241223190241734"><hr><h2 id="核心电源域"><a href="#核心电源域" class="headerlink" title="核心电源域"></a>核心电源域</h2><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part2/image-20241223182050938.png" class="" title="image-20241223182050938"><h3 id="VDDHIGH-NVCC-xxx"><a href="#VDDHIGH-NVCC-xxx" class="headerlink" title="VDDHIGH/NVCC_xxx"></a>VDDHIGH/NVCC_xxx</h3><p>VDDHIGH/NVCC电源管理电路：</p><ol><li><strong>DC-DC转换器部分（U4 MP2144GJ）</strong>：<ul><li><p><strong>输入部分</strong>：</p><ul><li><code>5V_SYS</code>通过R38（0Ω）输入；</li><li>C49(10μF)/C50(10μF)/C51(0.1μF)输入滤波；</li></ul></li><li><p><strong>输出部分</strong>：</p><ul><li><code>L2</code>（1μH）储能电感；</li><li>C52(22μF)/C53(0.1μF)输出滤波；</li><li>输出<code>DCDC_3V3</code>（3.3V）；</li></ul></li><li><p><strong>使能部分：</strong></p><ul><li><span style="color: green;">通过<code>PMIC_ON_REQ</code>信号，当它为高时，才使能U4，有输出<code>DCDC_3V3</code>;</span></li><li>同时，控制U5的复位信号为低，不复位；否则U5会复位整个电路；</li></ul></li><li><p><strong>反馈控制</strong>：</p><ul><li>R40（180KΩ）/R42（40.2K）分压网络；计算得到输出为<code>3.28V</code>;</li><li>FB引脚监测输出电压；</li><li>注释显示R26/R30=4.5；<span style="color: blue; ">(???不知道是干嘛)</span></li></ul></li></ul></li><li><strong>复位控制电路（U5 UM605RE）</strong>：<ul><li><p><strong>输入信号</strong>：</p><ul><li><code>POR_BUTTON</code>：通过D9二极管</li><li><code>WDOG_B</code>：通过D10二极管</li><li>AND逻辑控制</li><li>当两者都为高时，才会使MR为高；只要有一个为低，都会导致MR使能；</li></ul></li><li><p><strong>电源监控</strong>：</p><ul><li>监控<code>VDD_SNVS_3V3</code></li><li>C60(0.1μF)去耦</li></ul></li></ul></li><li><strong>控制逻辑</strong>：<ul><li><p><strong>使能控制</strong>：</p><ul><li><code>PMIC_ON_REQ</code>信号</li><li>通过R41（10K）连接到EN引脚</li></ul></li><li><p><strong>PG（Power Good）</strong>：</p><ul><li>内部上拉到VIN，即<code>5V_SYS</code>;</li><li><code>DCDC_3V3_PG</code>信号输出;<span style="color: blue; font-weight: bold; ">(5V的PG怎么变成3V3的PG的？？搞不清楚)</span></li></ul></li></ul></li></ol><hr><h2 id="辅助电源"><a href="#辅助电源" class="headerlink" title="辅助电源"></a>辅助电源</h2><h3 id="ADC供电"><a href="#ADC供电" class="headerlink" title="ADC供电"></a>ADC供电</h3><p><code>DCDC_3V3</code>产生<code>VDDA_ADC_3V3</code>，供MCU端的引脚<code>VDDA_ADC_3P3</code>使用！</p><h3 id="DCDC-IN-VDD-HIGH-IN"><a href="#DCDC-IN-VDD-HIGH-IN" class="headerlink" title="DCDC_IN/VDD_HIGH_IN"></a>DCDC_IN/VDD_HIGH_IN</h3><p><code>DCDC_3V3</code>产生<code>MCU_DCDC_IN_3V3</code>，供MCU端的引脚<code>DCDC_IN</code>使用！</p><p><code>DCDC_3V3</code>产生<code>VDD_HIGH_IN_3V3</code>，供MCU端的引脚<code>VDD_HIGH_IN</code>使用！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>SOC的输入：(<code>VDD_SOC_IN</code>)的来源路径：</p><blockquote><p>5V_SYS -&gt; MP2144GJ(DC-DC) -&gt; DCDC_3V3/MCU_DCDC_IN_3V3 -&gt; DCDC_LP/DCDC_OUT -&gt; J4 -&gt; VDD_SOC_IN -&gt; MCU核心</p></blockquote></li><li><p>VDD_SNVS_IN</p><blockquote><p>5V_SYS -&gt; UM1750S-00 -&gt; VLDO_3V3 -&gt; VDD_SNVS_3V3</p></blockquote></li><li><p>VDD_HIGH_IN</p><blockquote><p>5V_SYS -&gt; MP2144GJ(DC-DC) -&gt; DCDC_3V3 -&gt; VDD_HIGH_IN_3V3</p></blockquote></li><li><p>VDDA_ADC_3P3</p><blockquote><p>5V_SYS -&gt; MP2144GJ(DC-DC) -&gt; DCDC_3V3 -&gt; VDDA_ADC_3P3</p></blockquote></li></ol><hr><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part2/image-20241223192811426.png" class="" title="image-20241223192811426"><ul><li>此外，先有 <code>MCU_DCDC_IN_3V3</code>, 然后才有 <code>MCU_DCDC_IN</code>。 <code>DCDC_LP</code> 引脚输出<code>DCDC_OUT</code>,供<code>VDD_SOC_IN</code>使用；</li><li><code>DCDC_PWITCH</code>引脚有一个PWITCH RC Delay电路，应该是用来保证上电时序的；</li><li><code>PMIC_ON_REQ</code>引脚对外输出该信号。决定了是否有<code>DCDC_3V3</code>的产生；</li><li><code>POR</code>引脚应该是低电平复位。接收输入的<code>POR_B</code>、<code>RST_TGTMCU_B</code>和U2。上电时，当电压达到阈值会释放复位，来确保上电时序。确保系统在电源稳定后才开始工作。</li><li><code>XTALI/XTALO</code>连接一个外部的24MHz晶振；<code>Y4</code></li><li><code>RTC_XTALI/RTC_XTALO</code>连接一个32.768KHZ的晶振：<code>Y2</code>;</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RT1024-EVK-学习笔记Part2&quot;&gt;&lt;a href=&quot;#RT1024-EVK-学习笔记Part2&quot; class=&quot;headerlink&quot; title=&quot;RT1024 EVK 学习笔记Part2&quot;&gt;&lt;/a&gt;RT1024 EVK 学习笔记Part2&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;POWER DOMAIN 部分！&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1024" scheme="https://dustofstars.github.io/categories/NXP/RT1024/"/>
    
    <category term="原理图" scheme="https://dustofstars.github.io/categories/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="hardware" scheme="https://dustofstars.github.io/tags/hardware/"/>
    
    <category term="原理图" scheme="https://dustofstars.github.io/tags/%E5%8E%9F%E7%90%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>RT1024 EVK 学习笔记Part1</title>
    <link href="https://dustofstars.github.io/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part1/"/>
    <id>https://dustofstars.github.io/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part1/</id>
    <published>2024-12-23T11:47:43.000Z</published>
    <updated>2024-12-23T11:47:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RT1024-EVK-学习笔记Part1"><a href="#RT1024-EVK-学习笔记Part1" class="headerlink" title="RT1024 EVK 学习笔记Part1"></a>RT1024 EVK 学习笔记Part1</h1><blockquote><p>Main Power &amp; USB &amp; FreeLink Debugger部分详细解释！</p></blockquote><span id="more"></span><h2 id="Page3-Main-Power"><a href="#Page3-Main-Power" class="headerlink" title="Page3 Main Power"></a>Page3 Main Power</h2><p>输入可以是三种电源选项，但是输出就一定是<code>5V_SYS</code>， 它用来给整个MCU系统供电。以下详细的从左到右：</p><ol><li><p><strong>电源输入部分</strong>：</p><ul><li>Barrel Connector（桶型接口）<code>J2</code>：用于连接外部5V的电源适配器；</li><li>C4 <code>0.1uF</code>电容：输入滤波电容，用于滤除输入电源的噪声;</li><li><code>TP1</code>：测试点，用于测量输入电压</li></ul></li><li><p><strong>MOSFET控制部分</strong>：</p><ul><li>FDMA530PZ（<code>Q1</code>）：功率MOSFET，用于电源开关控制；</li><li><code>D1</code>二极管：保护二极管，防止反向电流；</li><li><code>R3</code> 3.3K 电阻：限流电阻，保护MOSFET；</li></ul></li><li><p><strong>中间控制电路</strong>：</p><ul><li><code>SW1</code>：开关；</li><li>R4-R9：分压和偏置电阻网络</li><li>C5：稳定电容，用于滤波</li></ul></li><li><p><strong>LED指示电路</strong>：</p><ul><li><code>D3</code> LED_RED-GRN：双色LED，用于指示电源状态</li><li><code>Q4</code>（BSH1115）：控制LED的MOSFET</li><li>R10-R11：LED驱动电阻;</li></ul></li><li><p><strong>输出部分</strong>：</p><ul><li>C1-C3：输出滤波电容</li><li><code>J1</code>：输出接口;</li><li>C179-C180：去耦电容，用于稳定输出电压</li></ul></li></ol><blockquote><p><span style="color: red; font-weight: bold; ">关于J1短接选择不同的供电方式：</span></p><ul><li><p>1-2位置：<code>DC_5V_IN</code></p><ul><li><p>连接到<code>J2</code>的直流电源输入</p></li><li><p>适用于使用外部5V电源适配器供电的场景</p></li></ul></li><li><p>3-4位置：<code>5V_USB_OTG_S</code></p><ul><li>通过USB接口供电</li></ul></li><li><p>5-6位置：<code>P5V_SDA_S</code></p><ul><li><p>通过OpenSDA调试器供电</p></li><li><p>适用于使用调试器进行程序下载和调试的场景</p></li><li><p>集成了调试和供电功能</p></li></ul></li></ul></blockquote><p>那么，我们可以先看 <code>5V_USB_OTG_S</code>:</p><blockquote><p><span style="color: green; font-weight: bold; ">Page6 USB</span></p></blockquote><p>再看 <code>P5V_SDA_S</code>:</p><blockquote><p><span style="color: green; font-weight: bold; ">Page13 FREELINK</span></p></blockquote><h2 id="Page6-USB"><a href="#Page6-USB" class="headerlink" title="Page6 USB"></a>Page6 USB</h2><h3 id="USB-OTG-部分"><a href="#USB-OTG-部分" class="headerlink" title="USB OTG 部分"></a>USB OTG 部分</h3><ol><li><p><strong>接口部分</strong>：</p><ul><li>使用<code>USB AB 5</code>型接口，（指的是5Pin typeA/B）</li><li>包含5个引脚：VBUS（电源）、D+、D-（数据线）和GND（地）、和<strong>ID；</strong></li></ul></li><li><p><strong>保护电路</strong>：</p><ul><li>TVS二极管阵列（<code>U8</code> RClamp0854P）提供ESD保护;</li><li>保护USB接口免受静电和瞬态电压的损害</li><li>四个二极管保护四条信号线</li></ul></li><li><p><strong>EMI抑制</strong>：</p><ul><li>L3和L5（330Ω电感）用于抑制电磁干扰</li><li><span style="color: green;">L4（共模电感）用于抑制D+/D-信号线上的共模噪声；</span></li><li>这些元件确保信号传输的质量和稳定性</li></ul></li><li><p><strong>信号连接</strong>：</p><ul><li><code>OTG1_DN</code>和<code>OTG1_DP</code>是MCU的差分数据信号；</li><li>通过0Ω电阻（R68）连接ID线和<code>USB_OTG1_ID</code>信号，可以方便地断开或连接信号；</li><li><code>5V_USB_OTG</code>和<code>5V_USB_OTG_S</code>分别是USB供电的输入和输出</li></ul></li><li><p><strong>工作流程</strong>：</p><ul><li><p>当作为Host时：提供5V电源给外部设备</p></li><li><p>当作为Device时：接收外部供电</p></li><li><p>数据信号经过EMI滤波和ESD保护后与MCU连接</p><blockquote><p>作为device时，PC端供电，通过VBUS，提供给<code>5V_USB_OTG_S</code>，继而给整个MCU供电！</p></blockquote></li></ul></li></ol><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part1/image-20241223152622192.png" class="" title="image-20241223152622192"><h3 id="USB-POWER-部分"><a href="#USB-POWER-部分" class="headerlink" title="USB POWER 部分"></a>USB POWER 部分</h3><p>USB Power电路的工作原理如下：</p><ol><li><strong>核心控制芯片</strong>：<ul><li><code>U7</code>（NX5P3090UK）是一个专用的USB电源开关/限流器</li><li>主要功能如下，其中，<code>USB_OTG1_OC（过流检测信号）</code>，连接到<code>FAULT</code>引脚：<ul><li>电流限制</li><li>过流保护</li><li>电压监测</li><li>故障检测</li></ul></li></ul></li><li><strong>输入控制信号</strong>：<ul><li>EN（使能）引脚：控制电源开关的开启/关闭；</li><li>FAULT（故障）引脚：指示过流或短路故障；</li><li>VNT1/VNT2/VNT3：电压监测点；</li></ul></li><li><strong>工作流程</strong>：<ul><li>当MCU需要提供USB主机供电时：<ul><li>通过<code>USB_OTG1_ID</code>信号，自动检测是Device/Host，根据这个角色决定是否使能U7；<span style="color: green; font-weight: bold; ">工作在device模式，使能U7，对MCU供电；工作在Host模式，禁用U7；</span></li><li>U7监控输出电流和电压；</li><li>如果发生过流，FAULT信号激活；</li></ul></li></ul></li><li><strong>关键电路组件</strong>：<ul><li>C82/C83：输入滤波电容</li><li>C84：输出滤波电容</li><li>R67/R68：上拉电阻（100K）</li><li>R69/R70：配置电阻</li></ul></li><li><strong>应用场景</strong>：<ul><li>MCU作为USB主机时提供受控的5V电源</li><li>保护MCU和外部设备免受电气故障损坏</li></ul></li></ol><p>其中，两个最重要的信号线：</p><ol><li><p><code>USB_OTG1_OC</code> (Over Current):</p><ul><li><p>连接到U7的FAULT引脚</p></li><li><p>当发生过流时会触发</p></li><li><p>这个信号会反馈给MCU，用于过流保护</p></li></ul></li><li><p><code>5V_USB_OTG</code> VBUS:</p><ul><li><p>这是U7的输出端</p></li><li><p>提供受控的5V电源给USB接口</p></li><li><p>通过VBUS1/2/3引脚输出</p></li><li><p>经过C84去耦电容滤波</p></li></ul></li></ol><p>这两个信号构成了USB供电的核心监控和输出功能：</p><ul><li>一个负责监控安全（OC）</li><li>一个负责实际供电（VBUS）</li></ul><p>另外需要注意的是：</p><ol><li><p><strong>Device模式（作为设备被供电）</strong>：</p><ul><li>供电流程：<ul><li>外部USB Host提供5V电源</li><li>通过USB接口进入，形成<code>5V_USB_OTG</code></li><li>经过R312连接到<code>5V_USB_OTG_S</code></li><li>通过J1(3-4)选择作为<code>5V_SYS</code></li><li>为整个系统供电</li></ul></li><li><span style="color: green;">此时U7不工作，仅作为通路；</span></li></ul></li><li><p><strong>Host模式（作为主机供电）</strong>：</p><ul><li>供电流程：<ul><li>通过其他方式（DC或OpenSDA）产生<code>5V_SYS</code></li><li><span style="color: green;"><code>5V_SYS</code>作为<code>U7</code>的输入；</span></li><li>U7控制并输出<code>5V_USB_OTG</code>；</li><li>通过USB接口<code>VBUS</code>引脚对外供电<code>5V_USB_OTG</code>;</li></ul></li><li>U7提供电流限制和保护功能</li></ul></li><li><p><strong>关键理解点</strong>：</p><ul><li>5V_USB_OTG和5V_USB_OTG_S的关系：<ul><li>它们在电路中是相连的</li><li>但在不同模式下电流方向不同</li></ul></li><li>U7的作用：<ul><li>仅在Host模式时起作用</li><li>提供受控的5V输出</li><li>保护系统免受过流影响</li></ul></li></ul></li><li><p><strong>工作模式切换</strong>：</p><ul><li>通过ID信号识别当前模式</li><li>自动配置电源流向</li><li>U7根据模式自动使能或禁用</li></ul></li></ol><p>这种设计支持USB OTG的双向供电特性，允许设备在不同场景下灵活切换角色。看似复杂的电源路径实际上是为了实现这种灵活性。</p><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part1/image-20241223160209612.png" class="" title="image-20241223160209612"><h2 id="Page13-FREELINK"><a href="#Page13-FREELINK" class="headerlink" title="Page13 FREELINK"></a>Page13 FREELINK</h2><blockquote><p>FreeLink部分的核心组件是<code>LPC4322JET100</code>，暂时先不看它，只需要知道<code>J42</code>跳线帽会控制FreeLink的DFU模式，进入firmware重新烧写即可！ </p><p><span style="color: red; ">还有一个有意思的点，这个LPC需要外部的12MHz晶振<code>Y5</code>;</span></p><p>还有，MCU的UART1连接了电平转换芯片<code>NTS0102</code>，因此可以到PC的虚拟串口输出打印log。</p></blockquote><p>对于Power部分来说，仍然是上一节的老朋友：</p><p><code>U31</code>仍然是一个<code>NX5P3090UK</code>:</p><img src="/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/rt1024-evk-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0part1/image-20241223160614690.png" class="" title="image-20241223160614690"><ol><li><strong>电源路径</strong>：<ul><li>输入：<code>P5V_SDA</code>通过U31的输入端</li><li>控制：经过U31的内部开关和保护电路</li><li>输出：通过U31的<code>VBUS1/2/3</code>引脚输出到<code>P5V_SDA_S</code></li></ul></li><li><strong>控制机制</strong>：<ul><li><code>POWER_EN</code>通过R216（1K）控制U31的使能</li><li><code>VTRG_FAULT_B</code>通过R215（10K）提供故障监测</li><li><code>5V_SDA_PSW</code>是在输出端额外引出的监测信号，可供外部使用；</li></ul></li></ol><p>那么，对于这种方式，电源路径如下：</p><blockquote><p>  <span style="color: green; font-weight: bold; ">调试器USB -&gt; VBUS -&gt; P5V_SDA -&gt; U31 -&gt; P5V_SDA_S -&gt; J1(5-6) -&gt; 5V_SYS</span></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RT1024-EVK-学习笔记Part1&quot;&gt;&lt;a href=&quot;#RT1024-EVK-学习笔记Part1&quot; class=&quot;headerlink&quot; title=&quot;RT1024 EVK 学习笔记Part1&quot;&gt;&lt;/a&gt;RT1024 EVK 学习笔记Part1&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Main Power &amp;amp; USB &amp;amp; FreeLink Debugger部分详细解释！&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1024" scheme="https://dustofstars.github.io/categories/NXP/RT1024/"/>
    
    <category term="原理图" scheme="https://dustofstars.github.io/categories/NXP/RT1024/%E5%8E%9F%E7%90%86%E5%9B%BE/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="hardware" scheme="https://dustofstars.github.io/tags/hardware/"/>
    
    <category term="原理图" scheme="https://dustofstars.github.io/tags/%E5%8E%9F%E7%90%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>RT1060--串口edma详解(SDK)</title>
    <link href="https://dustofstars.github.io/NXP/RT1060/rt1060-%E4%B8%B2%E5%8F%A3edma%E8%AF%A6%E8%A7%A3-sdk/"/>
    <id>https://dustofstars.github.io/NXP/RT1060/rt1060-%E4%B8%B2%E5%8F%A3edma%E8%AF%A6%E8%A7%A3-sdk/</id>
    <published>2024-12-18T15:38:41.000Z</published>
    <updated>2024-12-18T15:38:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="串口edma详解"><a href="#串口edma详解" class="headerlink" title="串口edma详解"></a>串口edma详解</h1><blockquote><p>这次我们来一起看一下，基于 NXP MIMXRT1060 开发板的串口通信示例工程，学习如何使用 EDMA(增强型直接内存访问)来实现高效的串口数据传输。</p></blockquote><p>主要特点：</p><ol><li>使用 LPUART (低功耗串口)进行通信</li><li>利用 EDMA 实现数据传输，减少 CPU 干预</li><li>实现了一个回显功能 - 将接收到的数据发送回去</li></ol><span id="more"></span><h2 id="关键数据流"><a href="#关键数据流" class="headerlink" title="关键数据流"></a>关键数据流</h2><ul><li><p><span style="color: blue;"><strong>接收流程：</strong></span>串口输入 -&gt; LPUART接收寄存器 -&gt; EDMA传输 -&gt; 接收缓冲区(<code>g_rxBuffer</code>)</p></li><li><p><span style="color: blue;"><strong>发送流程：</strong></span>发送缓冲区(<code>g_txBuffer</code>) -&gt; EDMA传输 -&gt; LPUART发送寄存器 -&gt; 串口输出</p></li></ul><h2 id="lpuart-edma-transfer-c-工作流程"><a href="#lpuart-edma-transfer-c-工作流程" class="headerlink" title="lpuart_edma_transfer.c 工作流程"></a>lpuart_edma_transfer.c 工作流程</h2><ol><li>系统初始化：</li></ol><ul><li>配置 LPUART（波特率115200，使能收发）</li><li>配置 DMAMUX（设置 DMA 通道映射）</li><li>初始化 EDMA（并创建传输句柄）</li></ul><ol start="2"><li>主循环逻辑：</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* If RX is idle and g_rxBuffer is empty, start to read data to g_rxBuffer. */</span></span><br><span class="line">    <span class="keyword">if</span> ((!rxOnGoing) &amp;&amp; rxBufferEmpty)</span><br><span class="line">    {</span><br><span class="line">        rxOnGoing = <span class="literal">true</span>;</span><br><span class="line">        LPUART_ReceiveEDMA(DEMO_LPUART, &amp;g_lpuartEdmaHandle, &amp;receiveXfer);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If TX is idle and g_txBuffer is full, start to send data. */</span></span><br><span class="line">    <span class="keyword">if</span> ((!txOnGoing) &amp;&amp; txBufferFull)</span><br><span class="line">    {</span><br><span class="line">        txOnGoing = <span class="literal">true</span>;</span><br><span class="line">        LPUART_SendEDMA(DEMO_LPUART, &amp;g_lpuartEdmaHandle, &amp;sendXfer);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If g_txBuffer is empty and g_rxBuffer is full, copy g_rxBuffer to g_txBuffer. */</span></span><br><span class="line">    <span class="keyword">if</span> ((!rxBufferEmpty) &amp;&amp; (!txBufferFull))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">memcpy</span>(g_txBuffer, g_rxBuffer, ECHO_BUFFER_LENGTH);</span><br><span class="line">        rxBufferEmpty = <span class="literal">true</span>;</span><br><span class="line">        txBufferFull  = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>检查接收缓冲区状态，空闲则启动新的接收</li><li>检查发送缓冲区状态，满则启动新的发送</li><li>在接收完成且发送空闲时，将数据从接收缓冲区复制到发送缓冲区</li></ul><ol start="3"><li>状态管理：</li></ol><ul><li>使用回调函数处理传输完成事件</li><li>通过状态标志(<code>rxBufferEmpty</code>, <code>txBufferFull</code>等)协调收发过程</li></ul><h2 id="仔细分析callback机制"><a href="#仔细分析callback机制" class="headerlink" title="仔细分析callback机制"></a>仔细分析callback机制</h2><blockquote><p>首先看到几个关键的回调函数:</p><ol><li><code>LPUART_UserCallback</code> - 这是用户层的回调函数,在main中注册</li><li><code>LPUART_SendEDMACallback</code> - EDMA发送完成的回调</li><li><code>LPUART_ReceiveEDMACallback</code> - EDMA接收完成的回调</li><li><code>LPUART_TransferEdmaHandleIRQ</code> - LPUART的EDMA中断处理函数</li></ol></blockquote><p><span style="color: blue; font-weight: bold;">从代码中可以看到调用链路:</span></p><ol><li><p>在main中通过<code>LPUART_TransferCreateHandleEDMA</code>注册了用户回调:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create LPUART DMA handle. */</span></span><br><span class="line">LPUART_TransferCreateHandleEDMA(DEMO_LPUART, &amp;g_lpuartEdmaHandle, LPUART_UserCallback, <span class="literal">NULL</span>, &amp;g_lpuartTxEdmaHandle,</span><br><span class="line">                                &amp;g_lpuartRxEdmaHandle);</span><br></pre></td></tr></tbody></table></figure></li><li><p><span style="color: blue;"><strong>当EDMA传输完成时,会触发中断,调用<code>LPUART_TransferEdmaHandleIRQ()</code>;</strong></span></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Save the handle in global variables to support the double weak mechanism. */</span></span><br><span class="line">s_lpuartHandle[instance] = handle;</span><br><span class="line"><span class="comment">/* Set LPUART_TransferEdmaHandleIRQ as DMA IRQ handler */</span></span><br><span class="line">s_lpuartIsr[instance] = LPUART_TransferEdmaHandleIRQ;</span><br><span class="line"><span class="comment">/* Disable all LPUART internal interrupts */</span></span><br><span class="line">LPUART_DisableInterrupts(base, (<span class="type">uint32_t</span>)kLPUART_AllInterruptEnable);</span><br><span class="line"><span class="comment">/* Enable interrupt in NVIC. */</span></span><br><span class="line">(<span class="type">void</span>)EnableIRQ(s_lpuartIRQ[instance]);</span><br></pre></td></tr></tbody></table></figure></li><li><p>在EDMA的回调中会更新状态标志并调用用户回调:</p></li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LPUART_SendEDMACallback</span><br><span class="line">LPUART_ReceiveEDMACallback</span><br><span class="line">    --&gt; LPUART_UserCallback</span><br></pre></td></tr></tbody></table></figure><p>以下是LPUART EDMA传输的回调流程图:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[EDMA传输开始] --&gt; B[EDMA传输完成中断]</span><br><span class="line">    B --&gt; C[LPUART_TransferEdmaHandleIRQ]</span><br><span class="line">    C --&gt; D{传输类型?}</span><br><span class="line">    D --&gt;|发送完成| E[LPUART_SendEDMACallback]</span><br><span class="line">    D --&gt;|接收完成| F[LPUART_ReceiveEDMACallback]</span><br><span class="line">    E --&gt; G[LPUART_UserCallback]</span><br><span class="line">    F --&gt; G</span><br><span class="line">    G --&gt;|TX完成| H[设置txBufferFull=false&lt;br&gt;txOnGoing=false]</span><br><span class="line">    G --&gt;|RX完成| I[设置rxBufferEmpty=false&lt;br&gt;rxOnGoing=false]</span><br></pre></td></tr></tbody></table></figure><img src="/NXP/RT1060/rt1060-%E4%B8%B2%E5%8F%A3edma%E8%AF%A6%E8%A7%A3-sdk/image-20241218231344599.png" class="" title="image-20241218231344599"><p><span style="color: blue; font-weight: bold;">所以整个调用链是:</span></p><ol><li>EDMA完成传输</li><li>触发LPUART传输完成中断</li><li>调用<code>LPUART_TransferEdmaHandleIRQ</code></li><li><code>LPUART_TransferEdmaHandleIRQ</code>调用用户回调</li><li>用户回调更新状态标志</li></ol><p>这个机制实现了:</p><ol><li>硬件中断与软件处理的解耦</li><li>灵活的状态管理</li><li>异步操作的完成通知</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>初始化流程:</li></ol><ul><li>main函数中创建EDMA handle</li><li>注册<code>LPUART_UserCallback</code>作为用户回调</li><li>配置EDMA通道和中断</li></ul><ol start="2"><li>发送流程:</li></ol><ul><li>LPUART_SendEDMA触发发送</li><li>EDMA完成后触发中断</li><li>通过回调链更新状态标志</li></ul><ol start="3"><li>接收流程:</li></ol><ul><li>LPUART_ReceiveEDMA启动接收</li><li>EDMA完成后触发中断</li><li>通过回调链更新状态标志</li></ul><ol start="4"><li>状态管理:</li></ol><ul><li>txOnGoing/rxOnGoing表示传输进行状态</li><li>txBufferFull/rxBufferEmpty表示缓冲区状态</li><li>这些标志在回调中更新,在主循环中使用</li></ul><p>这种回调机制实现了:</p><ol><li>异步处理EDMA传输</li><li>状态管理的解耦</li><li>用户代码与底层驱动的分离</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;串口edma详解&quot;&gt;&lt;a href=&quot;#串口edma详解&quot; class=&quot;headerlink&quot; title=&quot;串口edma详解&quot;&gt;&lt;/a&gt;串口edma详解&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;这次我们来一起看一下，基于 NXP MIMXRT1060 开发板的串口通信示例工程，学习如何使用 EDMA(增强型直接内存访问)来实现高效的串口数据传输。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;主要特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 LPUART (低功耗串口)进行通信&lt;/li&gt;
&lt;li&gt;利用 EDMA 实现数据传输，减少 CPU 干预&lt;/li&gt;
&lt;li&gt;实现了一个回显功能 - 将接收到的数据发送回去&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1060" scheme="https://dustofstars.github.io/categories/NXP/RT1060/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="中断" scheme="https://dustofstars.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
    <category term="DMA" scheme="https://dustofstars.github.io/tags/DMA/"/>
    
  </entry>
  
  <entry>
    <title>RT1060--串口中断传输详解(SDK)</title>
    <link href="https://dustofstars.github.io/NXP/RT1060/rt1060-%E4%B8%B2%E5%8F%A3%E4%B8%AD%E6%96%AD%E4%BC%A0%E8%BE%93%E8%AF%A6%E8%A7%A3-sdk/"/>
    <id>https://dustofstars.github.io/NXP/RT1060/rt1060-%E4%B8%B2%E5%8F%A3%E4%B8%AD%E6%96%AD%E4%BC%A0%E8%BE%93%E8%AF%A6%E8%A7%A3-sdk/</id>
    <published>2024-12-17T09:42:42.000Z</published>
    <updated>2024-12-17T09:42:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="串口中断传输详解-SDK"><a href="#串口中断传输详解-SDK" class="headerlink" title="串口中断传输详解(SDK)"></a>串口中断传输详解(SDK)</h1><span id="more"></span><h2 id="1-evkmimxrt1060-lpuart-interrupt"><a href="#1-evkmimxrt1060-lpuart-interrupt" class="headerlink" title="1. evkmimxrt1060_lpuart_interrupt"></a>1. evkmimxrt1060_lpuart_interrupt</h2><blockquote><p>使用 NXP 的 <code>fsl_lpuart.h</code> 库，通过中断方式实现 LPUART 的数据接收和回显。</p><p>它使用了一个<code>ring buffer</code>来暂存接收到的数据，然后在主循环中将缓冲区的数据发送出去。</p></blockquote><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ol><li><p>宏定义：</p><ul><li><code>DEMO_LPUART</code>: 定义使用的 LPUART 外设为 <code>LPUART1</code>。</li><li><code>DEMO_LPUART_CLK_FREQ</code>: 定义 LPUART 的时钟频率。</li><li><code>DEMO_LPUART_IRQn</code>: 定义 LPUART 的中断号。</li><li><code>DEMO_LPUART_IRQHandler</code>: 定义 LPUART 的中断处理函数名。</li><li><code>DEMO_RING_BUFFER_SIZE</code>: 定义环形缓冲区的大小为 16 字节。</li></ul></li><li><p>全局变量：</p><ul><li><code>g_tipString</code>: 提示字符串，程序启动时发送到串口。</li><li><code>demoRingBuffer</code>: 环形缓冲区，<span style="color:green">用于存储接收到的数据</span>。</li><li><code>txIndex</code>: 发送索引，指向下一个要发送的数据在环形缓冲区中的位置。</li><li><code>rxIndex</code>: 接收索引，指向下一个要写入接收数据的环形缓冲区位置。</li></ul></li><li><p><code>DEMO_LPUART_IRQHandler()</code> 函数：</p><p> LPUART 中断处理函数：</p><ul><li>如果Rx Data 寄存器满，则：<ul><li>读取receiver register数据： (<code>LPUART_ReadByte()</code>)。</li><li>读完之后检查环形缓冲区是否已满，如果未满，则将接收到的数据写入环形缓冲区，并更新 <code>rxIndex</code>。</li></ul></li></ul></li><li><p><code>main()</code> 函数：</p><ul><li>初始化开发板和 LPUART。</li><li>发送提示字符串。</li><li>使能 LPUART 的接收满中断  (<code>kLPUART_RxDataRegFullInterruptEnable</code>)。</li><li>使能 LPUART 中断 (<code>EnableIRQ(DEMO_LPUART_IRQn)</code>)。</li><li>进入主循环：<ul><li>检查 LPUART 发送寄存器是否为空 (<code>kLPUART_TxDataRegEmptyFlag</code>)。</li><li>检查环形缓冲区是否非空。</li><li>如果发送寄存器为空且缓冲区非空，则从环形缓冲区读取数据 (<code>demoRingBuffer[txIndex]</code>)，并通过 <code>LPUART_WriteByte()</code> 发送出去，并更新 <code>txIndex</code>。</li></ul></li></ul></li></ol><h3 id="数据-中断-callback调用流程图"><a href="#数据-中断-callback调用流程图" class="headerlink" title="数据/中断/callback调用流程图"></a><strong>数据/中断/callback调用流程图</strong></h3><img src="/NXP/RT1060/rt1060-%E4%B8%B2%E5%8F%A3%E4%B8%AD%E6%96%AD%E4%BC%A0%E8%BE%93%E8%AF%A6%E8%A7%A3-sdk/image-20241217175339831.png" class="" title="image-20241217175339831"><p><strong>详细流程解释：</strong></p><ol><li>中断处理：<ul><li>读取接收到的数据并存入环形缓冲区 <code>demoRingBuffer</code>。</li><li>更新接收索引 <code>rxIndex</code>。</li></ul></li><li>主循环处理：<ul><li>主循环不断检查 LPUART 发送寄存器是否为空以及环形缓冲区是否非空。</li><li>如果条件满足，则从环形缓冲区读取数据，并通过 <code>LPUART_WriteByte()</code> 发送出去。</li><li>更新发送索引 <code>txIndex</code>。</li></ul></li><li><strong>数据发送：</strong> LPUART 硬件将数据发送到串口接收端。</li></ol><h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a><strong>关键点</strong></h3><ul><li><strong>环形缓冲区：</strong> 用于在中断处理函数和主循环之间传递数据，避免数据丢失。</li><li><strong>中断驱动：</strong> 使用中断来处理接收事件，提高了 CPU 效率。</li><li><strong>非阻塞发送：</strong> 主循环中轮询检查发送寄存器是否为空和ring buffer非空，用于读取数据并发送，更新<code>txIndex</code>;</li></ul><h2 id="2-evkmimxrt1060-lpuart-interrupt-transfer"><a href="#2-evkmimxrt1060-lpuart-interrupt-transfer" class="headerlink" title="2. evkmimxrt1060_lpuart_interrupt_transfer"></a>2. evkmimxrt1060_lpuart_interrupt_transfer</h2><blockquote><p>使用 LPUART 进行回显。</p><p>程序通过 LPUART 接收用户输入的 8 个字符，然后将这 8 个字符回显给用户终端。</p></blockquote><h3 id="代码解释-1"><a href="#代码解释-1" class="headerlink" title="代码解释"></a>代码解释</h3><p><strong>代码结构：</strong></p><ol><li><p><strong>宏定义</strong>：定义了一些宏和变量，例如使用的 LPUART 实例 (<code>DEMO_LPUART</code>)、时钟频率 (<code>DEMO_LPUART_CLK_FREQ</code>)、回显缓冲区长度 (<code>ECHO_BUFFER_LENGTH</code>) 。</p></li><li><p><strong>callback声明</strong>：声明了一个 LPUART 用户回调函数 <code>LPUART_UserCallback</code>。</p></li><li><p><strong>变量</strong>：定义了一些全局变量，例如用于存储句柄 (<code>g_lpuartHandle</code>)、提示信息字符串 (<code>g_tipString</code>)、发送缓冲区 (<code>g_txBuffer</code>)、接收缓冲区 (<code>g_rxBuffer</code>) 等，还有一些标志位用于指示缓冲区状态和传输状态：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> rxBufferEmpty            = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> txBufferFull             = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> txOnGoing                = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> rxOnGoing                = <span class="literal">false</span>;</span><br></pre></td></tr></tbody></table></figure></li><li><p>**LPUART 用户回调函数 (LPUART_UserCallback)**：该函数会在 LPUART 传输完成 (发送或接收) 时被调用。它更新发送和接收缓冲区的相关标志位 (txBufferFull、txOnGoing、rxBufferEmpty、rxOnGoing)。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* LPUART user callback */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LPUART_UserCallback</span><span class="params">(LPUART_Type *base, <span class="type">lpuart_handle_t</span> *handle, <span class="type">status_t</span> status, <span class="type">void</span> *userData)</span></span><br><span class="line">{</span><br><span class="line">    userData = userData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kStatus_LPUART_TxIdle == status) <span class="comment">// 实际上就是发送完成！</span></span><br><span class="line">    {</span><br><span class="line">        txBufferFull = <span class="literal">false</span>;</span><br><span class="line">        txOnGoing    = <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kStatus_LPUART_RxIdle == status) <span class="comment">// 实际上对应接收完成！</span></span><br><span class="line">    {</span><br><span class="line">        rxBufferEmpty = <span class="literal">false</span>;</span><br><span class="line">        rxOnGoing     = <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>主函数 (main)</p><ul><li><p>初始化时钟、引脚复用等。</p></li><li><p>配置 LPUART：设置波特率、启用发送和接收功能等。</p></li><li><p>创建 LPUART 传输句柄。</p><p><code>LPUART_TransferCreateHandle(DEMO_LPUART, &amp;g_lpuartHandle, LPUART_UserCallback, NULL);</code></p></li><li><p>发送提示信息字符串。</p><p><code>LPUART_TransferSendNonBlocking(DEMO_LPUART, &amp;g_lpuartHandle, &amp;xfer);</code></p></li><li><p>进入循环，实现回显功能：</p><ul><li><p>如果接收空闲且接收缓冲区为空，则启动接收数据到接收缓冲区。</p><p><code>LPUART_TransferReceiveNonBlocking(DEMO_LPUART, &amp;g_lpuartHandle, &amp;receiveXfer, NULL);</code></p></li><li><p>如果发送空闲且发送缓冲区满，则启动发送数据。</p><p><code>LPUART_TransferSendNonBlocking(DEMO_LPUART, &amp;g_lpuartHandle, &amp;sendXfer);</code></p></li><li><p>如果接收非空且发送不满，则将接收缓冲区内容复制到发送缓冲区，并更新缓冲区标志位。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(g_txBuffer, g_rxBuffer, ECHO_BUFFER_LENGTH);</span><br><span class="line">rxBufferEmpty = <span class="literal">true</span>;</span><br><span class="line">txBufferFull  = <span class="literal">true</span>;</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li></ol><p><strong>流程图：</strong></p><p><strong>数据流：</strong></p><ol><li>初始化阶段：<ul><li>配置 LPUART。</li></ul></li><li>发送提示信息：<ul><li>将提示信息字符串拷贝到发送缓冲区。</li><li>启动发送。</li></ul></li><li>回显循环：<ul><li>接收数据：<ul><li>如果接收空闲且接收缓冲区为空，则启动接收数据。</li><li>接收完成触发回调函数，更新接收缓冲区标志位。</li></ul></li><li>发送数据：<ul><li>如果发送空闲且发送缓冲区满，则启动发送数据。</li><li>发送完成触发回调函数，更新发送缓冲区标志位。</li></ul></li><li>复制数据：<ul><li>如果接收非空且发送不满，则将接收缓冲区内容复制到发送缓冲区。</li><li>更新接收和发送缓冲区标志位。</li></ul></li></ul></li></ol><p><strong>中断和回调流程：</strong></p><ol><li>当数据接收完成或发送完成后，会产生中断。</li><li>中断服务程序会将控制权转移到 LPUART 驱动程序。</li><li>驱动程序会调用用户回调函数 <code>LPUART_UserCallback</code>。</li><li>回调函数中，根据传输完成类型 (发送/接收) 更新相关的缓冲区标志位。</li></ol><p><strong>注意：</strong></p><ul><li>该代码使用非阻塞式传输，即发送或接收启动后，程序不会等待传输完成，而是继续执行其他操作。</li><li>回调函数中只更新了标志位，并没有直接操作数据缓冲区。数据处理是在主循环中进行的。</li></ul><p><strong>代码关键点</strong></p><ul><li><strong>非阻塞传输：</strong> 使用了 <code>LPUART_TransferSendNonBlocking</code> 和 <code>LPUART_TransferReceiveNonBlocking</code> 函数，这意味着发送和接收操作会在后台进行，不会阻塞主循环。</li><li><strong>回调函数：</strong> <code>LPUART_UserCallback</code> 函数用于处理传输完成事件。在这个函数中，主要任务是更新标志位，例如 <code>txOnGoing</code>、<code>txBufferFull</code>、<code>rxOnGoing</code> 和 <code>rxBufferEmpty</code>。</li><li><strong>缓冲区管理：</strong> 使用了 <code>g_txBuffer</code> 和 <code>g_rxBuffer</code> 作为发送和接收缓冲区，并通过 <code>memcpy</code> 函数在两个缓冲区之间复制数据。</li><li><strong>主循环逻辑：</strong> 主循环负责启动发送和接收操作，并在缓冲区之间复制数据。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    subgraph 初始化</span><br><span class="line">        A[初始化 LPUART] --&gt; B{发送提示信息}</span><br><span class="line">        B --&gt; C[启动发送&lt;br&gt;LPUART_TransferSendNonBlocking]</span><br><span class="line">        C --&gt; D{等待发送完成&lt;br&gt; txOnGoing }</span><br><span class="line">    end</span><br><span class="line">    D --&gt; E[回显循环]</span><br><span class="line">    subgraph 接收</span><br><span class="line">        E --&gt; F{接收空闲 &amp; 接收缓冲区为空&lt;br&gt; !rxOnGoing &amp;&amp; rxBufferEmpty }</span><br><span class="line">        F -- 是 --&gt; G[启动接收&lt;br&gt;LPUART_TransferReceiveNonBlocking]</span><br><span class="line">        G --&gt; H[LPUART 硬件接收数据&lt;br&gt;RxDataRegFullFlag 置位]</span><br><span class="line">        H --&gt; I[产生中断信号]</span><br><span class="line">        I --&gt; J[NVIC 处理中断&lt;br&gt;调用中断服务例程&lt;br&gt;LPUART_TransferHandleIRQ]</span><br><span class="line">        J --&gt; K[中断服务例程&lt;br&gt;调用 LPUART_UserCallback&lt;br&gt;kStatus_LPUART_RxIdle&lt;br&gt;rxBufferEmpty = false&lt;br&gt;rxOnGoing = false]</span><br><span class="line">    end</span><br><span class="line">    subgraph 发送</span><br><span class="line">        E --&gt; L{发送空闲 &amp; 发送缓冲区满&lt;br&gt; !txOnGoing &amp;&amp; txBufferFull }</span><br><span class="line">        L -- 是 --&gt; M[启动发送&lt;br&gt;LPUART_TransferSendNonBlocking]</span><br><span class="line">        M --&gt; N[LPUART 硬件发送数据]</span><br><span class="line">        N --&gt; O[发送完成&lt;br&gt;产生中断信号]</span><br><span class="line">        O --&gt; P[NVIC 处理中断&lt;br&gt;调用中断服务例程&lt;br&gt;LPUART_TransferHandleIRQ]</span><br><span class="line">        P --&gt; Q[中断服务例程&lt;br&gt;调用 LPUART_UserCallback&lt;br&gt;kStatus_LPUART_TxIdle&lt;br&gt;txBufferFull = false&lt;br&gt;txOnGoing = false]</span><br><span class="line">    end</span><br><span class="line">    E --&gt; R{接收缓冲区非空 &amp; 发送缓冲区未满&lt;br&gt; !rxBufferEmpty &amp;&amp; !txBufferFull}</span><br><span class="line">    R -- 是 --&gt; S[数据复制&lt;br&gt;memcpy&lt;br&gt;rxBufferEmpty = true&lt;br&gt;txBufferFull = true]</span><br><span class="line">    K --&gt; E</span><br><span class="line">    Q --&gt; E</span><br><span class="line">    S --&gt; E</span><br></pre></td></tr></tbody></table></figure><img src="/NXP/RT1060/rt1060-%E4%B8%B2%E5%8F%A3%E4%B8%AD%E6%96%AD%E4%BC%A0%E8%BE%93%E8%AF%A6%E8%A7%A3-sdk/export.svg" class=""><h3 id="代码逻辑解释："><a href="#代码逻辑解释：" class="headerlink" title="代码逻辑解释："></a><strong>代码逻辑解释：</strong></h3><ol><li><p><strong>初始化：</strong> 程序首先初始化 LPUART 外设，然后发送一个提示信息。</p></li><li><p>回显循环：</p><p> 程序进入一个无限循环，不断检查以下条件：</p><ul><li><span style="color:green"><strong>接收：</strong></span><ul><li>如果当前没有正在接收数据 (<code>!rxOnGoing</code>) 并且接收缓冲区为空 (<code>rxBufferEmpty</code>)，则启动一次非阻塞的接收操作 (<code>LPUART_TransferReceiveNonBlocking</code>)。</li><li>当 LPUART 硬件接收到数据后，<code>RxDataRegFullFlag</code> 标志位会被置位，触发中断。</li><li>NVIC 接收到中断请求后，会调用中断服务例程。在中断服务例程中，会调用用户定义的回调函数 <code>LPUART_UserCallback</code>。<ul><li>回调函数根据 <code>kStatus_LPUART_RxIdle</code> 状态将 <code>rxBufferEmpty</code> 设置为 <code>false</code>，将 <code>rxOnGoing</code> 设置为 <code>false</code>，表明接收已完成。</li></ul></li></ul></li><li><span style="color:green"><strong>发送：</strong></span><ul><li>如果当前没有正在发送数据 (<code>!txOnGoing</code>) 并且发送缓冲区已满 (<code>txBufferFull</code>)，则启动一次非阻塞的发送操作 (<code>LPUART_TransferSendNonBlocking</code>)。</li><li>LPUART 硬件发送完数据后，会产生中断。</li><li>NVIC 处理中断，并调用回调函数 <code>LPUART_UserCallback</code>。<ul><li>回调函数根据 <code>kStatus_LPUART_TxIdle</code> 状态将 <code>txBufferFull</code> 设置为 <code>false</code>，将 <code>txOnGoing</code> 设置为 <code>false</code>，表明发送已完成。</li></ul></li></ul></li><li><span style="color:green"><strong>数据复制：</strong></span>如果接收缓冲区非空 (<code>!rxBufferEmpty</code>) 并且发送缓冲区未满 (<code>!txBufferFull</code>)，则使用 <code>memcpy</code> 函数将接收缓冲区的数据复制到发送缓冲区，并将 <code>rxBufferEmpty</code> 设置为 <code>true</code>，<code>txBufferFull</code> 设置为 <code>true</code>，为下一次接收和发送做准备。</li></ul></li></ol><h3 id="关于中断和回调"><a href="#关于中断和回调" class="headerlink" title="关于中断和回调"></a>关于中断和回调</h3><p><code>LPUART_UserCallback</code> 是一个用户自定义的回调函数，它会在 LPUART 驱动程序中的中断处理函数 <code>LPUART_TransferHandleIRQ</code> 中，当特定的传输事件发生后被调用。具体来说，以下几种情况下会调用 <code>LPUART_UserCallback</code>：</p><ol><li><strong>接收完成：</strong> 当使用 <code>LPUART_TransferReceiveNonBlocking</code> 函数启动非阻塞接收，并且所有请求的数据都已接收完毕时，<code>LPUART_TransferHandleIRQ</code> 函数会在处理接收数据就绪中断时调用 <code>LPUART_UserCallback</code>，并传递状态 <code>kStatus_LPUART_RxIdle</code>。</li><li><strong>发送完成：</strong> 当使用 <code>LPUART_TransferSendNonBlocking</code> 函数启动非阻塞发送，并且所有数据都已发送完毕时，<code>LPUART_TransferHandleIRQ</code> 函数会在处理发送完成中断时调用 <code>LPUART_UserCallback</code>，并传递状态 <code>kStatus_LPUART_TxIdle</code>。</li><li><strong>接收硬件溢出：</strong> 当 LPUART 硬件发生接收溢出错误时，<code>LPUART_TransferHandleIRQ</code> 函数会在处理接收溢出中断时调用 <code>LPUART_UserCallback</code>，并传递状态 <code>kStatus_LPUART_RxHardwareOverrun</code>。这个状态表示有数据在接收之前就被覆盖了，导致数据丢失。</li></ol><h3 id="完整的接收流程和发送流程"><a href="#完整的接收流程和发送流程" class="headerlink" title="完整的接收流程和发送流程"></a>完整的接收流程和发送流程</h3><p><strong>接收流程：</strong></p><ol><li>应用程序调用 <code>LPUART_TransferReceiveNonBlocking</code> 函数启动非阻塞接收。</li><li><code>LPUART_TransferReceiveNonBlocking</code> 函数配置 LPUART 硬件，使能接收中断，并将接收请求的信息保存在 <code>lpuart_handle_t</code> 结构体中。</li><li>LPUART 硬件接收到数据后，触发中断。</li><li>CPU 响应中断，执行中断服务例程 <code>LPUART_TransferHandleIRQ</code>。</li><li><code>LPUART_TransferHandleIRQ</code> 函数检查中断状态，如果是接收数据就绪中断，则调用 <code>LPUART_TransferHandleReceiveDataFull</code> 函数。</li><li><code>LPUART_TransferHandleReceiveDataFull</code>函数将数据从LPUART接收FIFO读取到handle指定的缓冲区。</li><li><code>LPUART_TransferHandleReceiveDataFull</code>函数检查是否所有请求的数据都已接收完毕，如果是，则在<code>LPUART_TransferHandleIRQ</code>中调用<code>handle-&gt;callback</code>，即 <code>LPUART_UserCallback</code>，并传递 <code>kStatus_LPUART_RxIdle</code> 状态。</li></ol><p><strong>发送流程：</strong></p><ol><li>应用程序调用 <code>LPUART_TransferSendNonBlocking</code> 函数启动非阻塞发送。</li><li><code>LPUART_TransferSendNonBlocking</code> 函数配置 LPUART 硬件，使能发送中断，并将发送请求的信息保存在 <code>lpuart_handle_t</code> 结构体中。</li><li>当发送数据寄存器为空时，LPUART 硬件触发中断。</li><li>CPU 响应中断，执行中断服务例程 <code>LPUART_TransferHandleIRQ</code>。</li><li><code>LPUART_TransferHandleIRQ</code> 函数检查中断状态，如果是发送数据寄存器空中断，则调用 <code>LPUART_TransferHandleSendDataEmpty</code> 函数。</li><li><code>LPUART_TransferHandleSendDataEmpty</code>函数将数据从handle指定的缓冲区写入LPUART发送FIFO。</li><li><code>LPUART_TransferHandleSendDataEmpty</code>函数检查是否所有数据都已发送完毕。如果是，则当发送完成后，在<code>LPUART_TransferHandleIRQ</code>中调用 <code>handle-&gt;callback</code>，即 <code>LPUART_UserCallback</code>，并传递 <code>kStatus_LPUART_TxIdle</code> 状态。</li></ol><p><strong>总结：</strong></p><p><code>LPUART_UserCallback</code> 是一个在中断上下文中被调用的回调函数。它允许用户在 LPUART 传输完成后执行自定义的操作，例如：</p><ul><li>设置标志位，通知应用程序传输已完成。</li><li>启动下一次传输。</li><li>处理接收到的数据。</li><li>进行错误处理。</li></ul><p>通过使用回调函数，可以实现事件驱动的编程模型，提高程序的效率和响应性。用户不需要在主循环中轮询 LPUART 的状态，而是通过回调函数在传输完成后得到通知。</p><p>因此，<code>LPUART_UserCallback</code> 的调用时机取决于 LPUART 的传输状态和中断事件，主要发生在接收完成、发送完成和接收溢出等情况下。它在整个 LPUART 驱动程序中起到了连接驱动程序和用户应用程序的重要作用。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;串口中断传输详解-SDK&quot;&gt;&lt;a href=&quot;#串口中断传输详解-SDK&quot; class=&quot;headerlink&quot; title=&quot;串口中断传输详解(SDK)&quot;&gt;&lt;/a&gt;串口中断传输详解(SDK)&lt;/h1&gt;</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1060" scheme="https://dustofstars.github.io/categories/NXP/RT1060/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="中断" scheme="https://dustofstars.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
    <category term="UART" scheme="https://dustofstars.github.io/tags/UART/"/>
    
  </entry>
  
  <entry>
    <title>RT1060--串口空闲中断&amp;EDMA接收不定长数据</title>
    <link href="https://dustofstars.github.io/NXP/RT1060/rt1060-%E4%B8%B2%E5%8F%A3%E7%A9%BA%E9%97%B2%E4%B8%AD%E6%96%AD-edma%E6%8E%A5%E6%94%B6%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%95%B0%E6%8D%AE/"/>
    <id>https://dustofstars.github.io/NXP/RT1060/rt1060-%E4%B8%B2%E5%8F%A3%E7%A9%BA%E9%97%B2%E4%B8%AD%E6%96%AD-edma%E6%8E%A5%E6%94%B6%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%95%B0%E6%8D%AE/</id>
    <published>2024-12-04T06:41:42.000Z</published>
    <updated>2024-12-04T06:41:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="串口空闲中断-EDMA-接收不定长数据"><a href="#串口空闲中断-EDMA-接收不定长数据" class="headerlink" title="串口空闲中断 &amp; EDMA 接收不定长数据"></a>串口空闲中断 &amp; EDMA 接收不定长数据</h1><blockquote><p>客户有接收不定长数据的需求，但是如果采用协议适配的方法会非常繁琐。使用UART的IDLE中断+DMA的方式，即可高效的解决这一问题！</p></blockquote><p>另外，如果通过协议先接收单独的单字节，串口进中断接收在数据量大的时候效率会低很多</p><p>以RT1060EVK为例来进行这一操作！</p><span id="more"></span><h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">让我仔细分析一下这个main函数的执行流程和中断调用关系...</span><br><span class="line"></span><br><span class="line">首先看到几个关键的中断和回调:</span><br><span class="line">1. DEMO_LPUART_IRQHandler - UART的中断处理函数</span><br><span class="line">2. LPUART_UserCallback - DMA传输完成的回调函数</span><br><span class="line"></span><br><span class="line">中断触发的场景:</span><br><span class="line">1. IDLE线检测 - 接收到一帧数据后的空闲状态</span><br><span class="line">2. TC(传输完成)中断 - 发送完成后触发</span><br><span class="line">3. DMA传输完成中断 - 通过callback通知</span><br><span class="line"></span><br><span class="line">数据流转过程:</span><br><span class="line">1. 初始状态是接收模式</span><br><span class="line">2. 数据到来 -&gt; DMA自动接收到buffer</span><br><span class="line">3. 检测到空闲 -&gt; IDLE中断</span><br><span class="line">4. 处理数据 -&gt; 准备发送</span><br><span class="line">5. DMA发送 -&gt; 发送完成触发TC中断</span><br><span class="line">6. TC中断中切换回接收模式</span><br><span class="line"></span><br><span class="line">这里面有很多细节需要梳理,让我详细分析每个阶段的处理...</span><br></pre></td></tr></tbody></table></figure><p>让我详细解释main函数的逻辑和中断调用关系:</p><h3 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置:"></a><strong>初始化配置</strong>:</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置UART中断</span></span><br><span class="line">LPUART_EnableInterrupts(DEMO_LPUART, </span><br><span class="line">    kLPUART_IdleLineInterruptEnable|      <span class="comment">// 空闲线检测中断</span></span><br><span class="line">    kLPUART_RxOverrunInterruptEnable|     <span class="comment">// 接收溢出中断</span></span><br><span class="line">    kLPUART_NoiseErrorInterruptEnable|    <span class="comment">// 噪声错误中断</span></span><br><span class="line">    kLPUART_FramingErrorInterruptEnable|  <span class="comment">// 帧错误中断</span></span><br><span class="line">    kLPUART_ParityErrorInterruptEnable);  <span class="comment">// 奇偶校验错误中断</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始时禁用TC中断</span></span><br><span class="line">LPUART_DisableInterrupts(DEMO_LPUART, kLPUART_TransmissionCompleteInterruptEnable);</span><br></pre></td></tr></tbody></table></figure><h3 id="中断和DMA的调用流程"><a href="#中断和DMA的调用流程" class="headerlink" title="中断和DMA的调用流程:"></a><strong>中断和DMA的调用流程</strong>:</h3><h4 id="接收数据流程"><a href="#接收数据流程" class="headerlink" title="接收数据流程:"></a><strong>接收数据流程</strong>:</h4><ul><li>DMA持续接收数据到<code>g_rxBuffer</code></li><li>当检测到空闲线(<span style="color:red"><em><u>一段时间没有新数据</u></em></span>)时,触发IDLE中断；</li><li>在IDLE中断处理函数中:<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DEMO_LPUART_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> ((kLPUART_IdleLineFlag)&amp;stat)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 1. 获取已接收的数据长度</span></span><br><span class="line">        LPUART_TransferGetReceiveCountEDMA(...);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 复制数据到发送缓冲区</span></span><br><span class="line">        <span class="built_in">memcpy</span>(g_txBuffer, g_rxBuffer, rx_count);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 设置发送标志</span></span><br><span class="line">        reciveFrame = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 重新启动接收</span></span><br><span class="line">        LPUART_TransferAbortReceiveEDMA(...);</span><br><span class="line">        LPUART_ReceiveEDMA(...);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="发送数据流程"><a href="#发送数据流程" class="headerlink" title="发送数据流程:"></a><strong>发送数据流程</strong>:</h4><ul><li>main循环检测到<code>reciveFrame</code>为true时启动发送</li><li>DMA开始发送数据</li><li>发送完成后触发DMA完成中断,调用<code>LPUART_UserCallback</code></li><li>在callback中使能TC中断:<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LPUART_UserCallback</span><span class="params">(...)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (kStatus_LPUART_TxIdle == status)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 使能TC中断</span></span><br><span class="line">        LPUART_EnableInterrupts(DEMO_LPUART, kLPUART_TransmissionCompleteInterruptEnable);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>TC中断触发后,在中断处理函数中:<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((kLPUART_TransmissionCompleteFlag)&amp;stat)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 1. 禁用TC中断</span></span><br><span class="line">    LPUART_DisableInterrupts(DEMO_LPUART, kLPUART_TransmissionCompleteInterruptEnable);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 切换到接收模式</span></span><br><span class="line">    Set_RS485_Receive();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 重新启动接收</span></span><br><span class="line">    LPUART_TransferAbortReceiveEDMA(...);</span><br><span class="line">    LPUART_ReceiveEDMA(...);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="主循环逻辑"><a href="#主循环逻辑" class="headerlink" title="主循环逻辑:"></a><strong>主循环逻辑</strong>:</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(reciveFrame)  <span class="comment">// 检查是否收到完整数据帧</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 1. 准备发送数据</span></span><br><span class="line">        sendXfer.data = g_txBuffer;</span><br><span class="line">        sendXfer.dataSize = send_size;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 切换到发送模式</span></span><br><span class="line">        Set_RS485_Transimit();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 启动DMA发送</span></span><br><span class="line">        LPUART_SendEDMA(DEMO_LPUART, &amp;g_lpuartEdmaHandle, &amp;sendXfer);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 清除标志</span></span><br><span class="line">        reciveFrame = <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="关键点说明"><a href="#关键点说明" class="headerlink" title="关键点说明"></a>关键点说明</h2><ol><li>DMA用于实际的数据传输,不占用CPU</li><li><span style="color:red"><strong><u>IDLE中断用于检测一帧数据的接收完成</u></strong></span></li><li>TC中断用于确保最后一个字节完全发送出去</li><li>使用回调和中断机制实现自动的收发切换</li><li>主循环只负责检测标志并启动新的发送</li></ol><p>这种设计实现了高效的非阻塞式数据收发,同时正确处理了RS485半双工通信的方向切换时序。</p><h2 id="备注：详细的回调-中断实现的自动收发切换"><a href="#备注：详细的回调-中断实现的自动收发切换" class="headerlink" title="备注：详细的回调/中断实现的自动收发切换"></a>备注：详细的回调/中断实现的自动收发切换</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    A[初始状态: 接收模式] --&gt;|DMA接收数据| B[接收数据]</span><br><span class="line">    </span><br><span class="line">    B --&gt;|检测到IDLE| C[IDLE中断处理]</span><br><span class="line">    C --&gt;|1. 获取接收数据长度&lt;br&gt;2. 复制数据到TX buffer&lt;br&gt;3. 设置reciveFrame标志| D[主循环]</span><br><span class="line">    </span><br><span class="line">    D --&gt;|检测到reciveFrame| E[开始发送]</span><br><span class="line">    E --&gt;|1. 切换RS485方向&lt;br&gt;2. 启动DMA发送| F[DMA发送数据]</span><br><span class="line">    </span><br><span class="line">    F --&gt;|DMA发送完成| G[DMA完成回调&lt;br&gt;LPUART_UserCallback]</span><br><span class="line">    G --&gt;|使能TC中断| H[等待最后一个字节发送]</span><br><span class="line">    </span><br><span class="line">    H --&gt;|TC中断触发| I[TC中断处理]</span><br><span class="line">    I --&gt;|1. 禁用TC中断&lt;br&gt;2. 切换RS485方向&lt;br&gt;3. 重启DMA接收| A</span><br></pre></td></tr></tbody></table></figure><p>让我详细解释每个阶段的切换过程：</p><ol><li><p><strong>接收阶段</strong>:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始配置为接收模式</span></span><br><span class="line">Set_RS485_Receive();  <span class="comment">// GPIO设为低电平</span></span><br><span class="line">LPUART_ReceiveEDMA(...);  <span class="comment">// 启动DMA接收</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>接收完成检测</strong>:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IDLE中断处理函数中</span></span><br><span class="line"><span class="keyword">if</span> ((kLPUART_IdleLineFlag)&amp;stat)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 获取接收到的数据</span></span><br><span class="line">    LPUART_TransferGetReceiveCountEDMA(...);</span><br><span class="line">    <span class="built_in">memcpy</span>(g_txBuffer, g_rxBuffer, rx_count);</span><br><span class="line">    reciveFrame = <span class="literal">true</span>;  <span class="comment">// 设置标志通知主循环</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>切换到发送模式</strong>:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主循环中</span></span><br><span class="line"><span class="keyword">if</span>(reciveFrame)</span><br><span class="line">{</span><br><span class="line">    Set_RS485_Transimit();  <span class="comment">// GPIO设为高电平</span></span><br><span class="line">    LPUART_SendEDMA(...);   <span class="comment">// 启动DMA发送</span></span><br><span class="line">    reciveFrame = <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>发送完成处理</strong>:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DMA发送完成回调</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LPUART_UserCallback</span><span class="params">(...)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (kStatus_LPUART_TxIdle == status)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 使能TC中断，等待最后一个字节发送完成</span></span><br><span class="line">        LPUART_EnableInterrupts(DEMO_LPUART, kLPUART_TransmissionCompleteInterruptEnable);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// TC中断处理</span></span><br><span class="line"><span class="keyword">if</span>((kLPUART_TransmissionCompleteFlag)&amp;stat)</span><br><span class="line">{</span><br><span class="line">    LPUART_DisableInterrupts(DEMO_LPUART, kLPUART_TransmissionCompleteInterruptEnable);</span><br><span class="line">    Set_RS485_Receive();  <span class="comment">// 切换回接收模式</span></span><br><span class="line">    <span class="comment">// 重新启动接收</span></span><br><span class="line">    LPUART_TransferAbortReceiveEDMA(...);</span><br><span class="line">    LPUART_ReceiveEDMA(...);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><p>关键设计考虑：</p><ol><li><p><strong>为什么需要TC中断？</strong></p><ul><li>DMA完成不代表最后一个字节已经完全发送出去</li><li>TC中断确保最后一个字节完全发送后才切换方向</li><li>避免方向切换过早导致数据截断</li></ul></li><li><p><strong>方向切换时序</strong>:</p><ul><li>发送前：先切换方向，再开始发送</li><li>发送后：等待TC中断确认完全发送后，再切换回接收</li></ul></li><li><p><strong>自动化处理</strong>:</p><ul><li>使用中断和回调机制，无需主循环干预</li><li>主循环只负责启动新的发送</li><li>其他切换过程由中断自动完成</li></ul></li></ol><p>这种设计保证了RS485半双工通信的可靠性，同时通过DMA和中断机制提高了效率。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;串口空闲中断-EDMA-接收不定长数据&quot;&gt;&lt;a href=&quot;#串口空闲中断-EDMA-接收不定长数据&quot; class=&quot;headerlink&quot; title=&quot;串口空闲中断 &amp;amp; EDMA 接收不定长数据&quot;&gt;&lt;/a&gt;串口空闲中断 &amp;amp; EDMA 接收不定长数据&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;客户有接收不定长数据的需求，但是如果采用协议适配的方法会非常繁琐。使用UART的IDLE中断+DMA的方式，即可高效的解决这一问题！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外，如果通过协议先接收单独的单字节，串口进中断接收在数据量大的时候效率会低很多&lt;/p&gt;
&lt;p&gt;以RT1060EVK为例来进行这一操作！&lt;/p&gt;</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1060" scheme="https://dustofstars.github.io/categories/NXP/RT1060/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="中断" scheme="https://dustofstars.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
    <category term="DMA" scheme="https://dustofstars.github.io/tags/DMA/"/>
    
  </entry>
  
  <entry>
    <title>RT1050开发--第7节 RT1050 硬件启动模式</title>
    <link href="https://dustofstars.github.io/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dustofstars.github.io/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-12-11T06:11:12.000Z</published>
    <updated>2023-12-11T06:11:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第7节-RT1050-硬件启动模式详解"><a href="#第7节-RT1050-硬件启动模式详解" class="headerlink" title="第7节 RT1050 硬件启动模式详解"></a>第7节 RT1050 硬件启动模式详解</h1><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/Snipaste_2023-12-11_14-33-24.bmp" class=""><span id="more"></span><h2 id="硬件启动配置"><a href="#硬件启动配置" class="headerlink" title="硬件启动配置"></a>硬件启动配置</h2><h3 id="外部设备设备配置"><a href="#外部设备设备配置" class="headerlink" title="外部设备设备配置"></a>外部设备设备配置</h3><ol><li><p>开发板配置选项</p><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/Snipaste_2023-12-11_14-35-48.bmp" class=""></li><li><p>启动配置选项电路</p><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/Snipaste_2023-12-11_14-42-44.bmp" class=""></li><li><p>启动配置引脚</p><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/Snipaste_2023-12-11_14-51-14.bmp" class=""></li><li><p>启动模式选择</p><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/Snipaste_2023-12-11_14-52-23.bmp" class=""><p>启动模式选择可以有：从Fuses、从串口下载、从内部；</p></li><li><p>串行Flash配置选项</p><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/Snipaste_2023-12-11_14-55-01.bmp" class=""><p>这两位控制支持的Flash Type；</p><p><strong><u><em>即SW7的前两位确定Flash的规格，后两位确定启动的方式！</em></u></strong></p></li></ol><h2 id="Nor-Flash-启动流程"><a href="#Nor-Flash-启动流程" class="headerlink" title="Nor Flash 启动流程"></a>Nor Flash 启动流程</h2><blockquote><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/Snipaste_2023-12-11_14-59-46.bmp" class=""></blockquote><style>.wmxdpuicajly{zoom:150%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/Snipaste_2023-12-11_16-48-41.bmp" class="wmxdpuicajly"><p>BootRom里面的程序：</p><ol><li>配置 FlexSPI 的Pin复用功能，配置时钟频率30MHz，进行基础的读取操作；<ul><li>FlexSPI最高300MHz，这里不知道外部Flash是啥情况，<u>配置为低速时钟用来读NorFlash的头上的配置信息</u>；</li><li>获取到外部Flash的配置参数；</li></ul></li><li>读取了外部Flash的配置参数之后，RT用来配置它的外设 FlexSPI ；<ul><li>它是根据读取的外部Flash的配置参数，来配置FlexSPI；</li></ul></li><li>设置boot device 参数<ul><li>Image 地址， memory范围；</li><li>即：**<u>真正的代码段的地址和长度</u>**；</li></ul></li><li>判断Image是否直接在Flash的片上进行取址：<ol><li><u><strong>如果XIP，则从FlexSPI1的地址空间中执行Image；</strong></u></li><li><u><strong>如果非XIP，则拷贝到OCRAM中，再从OCRAM中运行Image；</strong></u></li></ol></li></ol><h3 id="Flash的配置参数"><a href="#Flash的配置参数" class="headerlink" title="Flash的配置参数"></a>Flash的配置参数</h3><style>.kiusnfjbkpzi{zoom:200%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/Snipaste_2023-12-11_16-59-06.bmp" class="kiusnfjbkpzi"><p>512字节的串口Nor Flash配置字段：</p><ul><li>memCfg：外部时序，时钟等；</li><li>pageSize：页大小；</li><li>sectorSize：块大小；</li><li>xxxClkFreq: 串口的时钟频率；</li></ul><p><strong><u><em>工程代码：</em></u></strong></p><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/image-20231211170401921.png" class="" title="image-20231211170401921"><h3 id="Image的关键信息"><a href="#Image的关键信息" class="headerlink" title="Image的关键信息"></a>Image的关键信息</h3><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/image-20231211170553725.png" class="" title="image-20231211170553725"><ul><li>Image vector table（IVT）：声明image的具体位置，即代码在 nor flash 的具体位置是多少；</li><li>Boot data：image位置和大小；</li><li>Device configuration data （DCD）：</li><li>User code and data：</li></ul><h4 id="IVT-Boot-data"><a href="#IVT-Boot-data" class="headerlink" title="IVT + Boot data"></a>IVT + Boot data</h4><ul><li><p>IVT 需要<u>放在外部Flash的固定偏移地址，供ROM读取以便让系统知道用户Image的第一条可执行指令放在哪里，以及Boot Data和DCD的存放位置</u>；</p><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/image-20231211171225319.png" class="" title="image-20231211171225319"></li><li><p>BootData保存了完整的Image首地址和整个Image所占大小；</p><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/image-20231211171319387.png" class="" title="image-20231211171319387"></li><li><p>程序代码：</p><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/image-20231211171351373.png" class="" title="image-20231211171351373"></li></ul><h4 id="DCD"><a href="#DCD" class="headerlink" title="DCD"></a>DCD</h4><ul><li><p>DCD包含了一些配置命令以便在跳到用户程序入口之前，供ROM调用配置内部外设以更好的匹配外部IC，一般如果系统外挂了SDRAM的情况下需要配置好DCD；</p></li><li><p>程序代码：</p><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC7%E8%8A%82-rt1050-%E7%A1%AC%E4%BB%B6%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/image-20231211171607245.png" class="" title="image-20231211171607245"></li></ul>]]></content>
    
    
    <summary type="html">第七节课！硬件启动模式详解！</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1050" scheme="https://dustofstars.github.io/categories/NXP/RT1050/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="RT1050" scheme="https://dustofstars.github.io/tags/RT1050/"/>
    
  </entry>
  
  <entry>
    <title>RT1050开发--第6节 RT1050 Memory Mapping</title>
    <link href="https://dustofstars.github.io/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC6%E8%8A%82-rt1050-memory-mapping/"/>
    <id>https://dustofstars.github.io/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC6%E8%8A%82-rt1050-memory-mapping/</id>
    <published>2023-12-11T05:37:29.000Z</published>
    <updated>2023-12-11T05:37:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第6节-RT1050-Memory-Mapping"><a href="#第6节-RT1050-Memory-Mapping" class="headerlink" title="第6节 RT1050 Memory Mapping"></a>第6节 RT1050 Memory Mapping</h1><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC6%E8%8A%82-rt1050-memory-mapping/Snipaste_2023-12-11_13-40-00.bmp" class=""><span id="more"></span><h2 id="RT1052结构框图"><a href="#RT1052结构框图" class="headerlink" title="RT1052结构框图"></a>RT1052结构框图</h2><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC6%E8%8A%82-rt1050-memory-mapping/Snipaste_2023-12-11_13-43-52.bmp" class=""><h2 id="Cortex-M7-存储器映射"><a href="#Cortex-M7-存储器映射" class="headerlink" title="Cortex-M7 存储器映射"></a>Cortex-M7 存储器映射</h2><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC6%E8%8A%82-rt1050-memory-mapping/Snipaste_2023-12-11_13-45-20.bmp" class=""><ul><li>如果给存储器再分配一个地址，就叫做存储器重映射；</li><li>在4GB的地址空间，ARM粗线条的平均分为7个块，每个块也规定了用途，大部分的款大小都是512MB以上，显然是很大的，芯片厂商在每个块的范围内设计外设时根本用不完；</li></ul><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC6%E8%8A%82-rt1050-memory-mapping/Snipaste_2023-12-11_13-49-42.bmp" class=""><h2 id="RT1052存储器功能划分"><a href="#RT1052存储器功能划分" class="headerlink" title="RT1052存储器功能划分"></a>RT1052存储器功能划分</h2><blockquote><p><mark><strong><u>重点！！！</u></strong></mark></p><p>在这上面的7个Block中，有4个非常重要。</p><ul><li>Block0 主要用于存储**<u>程序代码</u>**，一般采用FLASH存储器；</li><li>Block1 主要用于**<u>运行时内存</u>**，一般采用SRAM存储器；</li><li>Block2 用来设计成片上外设，内核通过相应的地址访问片上外设；</li><li>Block5 用于NVIC，系统定时器，系统功能控制块；</li></ul></blockquote><h3 id="Block0"><a href="#Block0" class="headerlink" title="Block0"></a>Block0</h3><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC6%E8%8A%82-rt1050-memory-mapping/Block0.bmp" class=""><p>自下往上看：</p><ol><li>ITCM：是Instruction Tightly-Coupled Memory的缩写，指的是**<u>指令紧耦合内存</u>**。<ul><li>所谓紧耦合，指的是该内存与内核紧密连接，有很高的访问速度，而“指令”，表示该内存用于缓存指令；</li><li>对于我们希望有极高执行速度的代码，可以要求内核上电后把相应的代码从外部的Flash加载至ITCM，那么在运行时，代码的执行速度就不会因为外部的Flash访问速度而存在瓶颈。</li></ul></li><li>ROCMP：**<u>这是一小段ROM空间，用于存储芯片启动时的加载代码</u><strong>，即Bootloader，</strong><u>Bootloader负载把指令从外部存储器加载到ITCM</u>**；</li><li><mark><strong>FlexSPI：和SEMC一起是RT1052中可用于控制外部并行和串行NorFlash的两个外设，此处把它们映射到这个代码空间，是歪了支持XIP功能（即指令直接在NorFlash中运行，不需要加载到内部的ITCM）。</strong></mark></li><li>SEMC：智能外部存储器控制器；</li></ol><h3 id="Block1"><a href="#Block1" class="headerlink" title="Block1"></a>Block1</h3><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC6%E8%8A%82-rt1050-memory-mapping/Block1.bmp" class=""><ol><li>DTCM：数据紧耦合内存，和ITCM类似，有着极高的访问速度，*<u><strong>不过它是专门用来存储程序数据的，即带啊吗中变量的存储位置</strong></u>*；</li><li>OCRAM：是 On-chip RAM 的缩写。即片上内存，可以完全把它理解为传统MCU内部的SRAM，它没有像ITCM和DTCM的专用限制，**<u>可以用于存储指令和数据</u>**（通用目的）。</li></ol><h3 id="注意！"><a href="#注意！" class="headerlink" title="注意！"></a>注意！</h3><p>在RT1052中，TCM只有512KB，不是分别ITCM DTCM OCRAM都有，而是它们三个共有512KB！</p><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC6%E8%8A%82-rt1050-memory-mapping/FlexRAM%E5%88%86%E9%85%8D.bmp" class=""><p>通过FUSE，有16种FlexRAM的配置！这个和后续的分散加载文件息息相关！</p><ul><li>具体来说，ITCM DTCM OCRAM三种存储器**<u>共享内部FlexRAM的空间，而这个内部的FlexRAM空间在RT1052中是512KB</u>**；</li><li>默认是第一种配置，256-128-128；</li></ul><h3 id="Block2"><a href="#Block2" class="headerlink" title="Block2"></a>Block2</h3><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC6%E8%8A%82-rt1050-memory-mapping/Block2.bmp" class=""><p>Block2 用于设计片内的外设，在RT1052中，它的外设使用4条总线与内核进行连接，AIPS 是 <code>ARM IP Bus</code> 的缩写，**<u>它一边与 AHB 总线连接，另一边与片上的各种外设连接</u><strong>，AIPS1~4 即连接了各种各样的外设，此处</strong><u>每条总线划分的地址范围是1MB，内核根据地址可以访问相应总线下的外设，达到控制目的</u>**。</p><h3 id="Block5"><a href="#Block5" class="headerlink" title="Block5"></a>Block5</h3><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC6%E8%8A%82-rt1050-memory-mapping/Block5.bmp" class=""><h2 id="谁影响了代码的运行速度？"><a href="#谁影响了代码的运行速度？" class="headerlink" title="谁影响了代码的运行速度？"></a>谁影响了代码的运行速度？</h2><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC6%E8%8A%82-rt1050-memory-mapping/Snipaste_2023-12-11_14-22-39.bmp" class=""><blockquote><p>订正：</p><ul><li>I-Cache/D-Cache</li></ul></blockquote><p>RT1052没有内置的Flash，那么如果像原来一样，在MCU的Flash中运行，就会受限于NorFlash的总线访问速度，无法发挥CPU速度的优势。那么，通过分散加载文件，到Cache，TCM中运行，就是一个可行的解决方案了。</p>]]></content>
    
    
    <summary type="html">第六节课！Memory Mapping！</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1050" scheme="https://dustofstars.github.io/categories/NXP/RT1050/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="RT1050" scheme="https://dustofstars.github.io/tags/RT1050/"/>
    
  </entry>
  
  <entry>
    <title>RT1050开发--第5节 RT1050 Hello World （Keil V5）</title>
    <link href="https://dustofstars.github.io/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC5%E8%8A%82-rt1050-hello-world-%EF%BC%88keil-v5%EF%BC%89/"/>
    <id>https://dustofstars.github.io/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC5%E8%8A%82-rt1050-hello-world-%EF%BC%88keil-v5%EF%BC%89/</id>
    <published>2023-12-05T14:28:25.000Z</published>
    <updated>2023-12-05T14:28:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第5节-RT1050-Hello-World-（Keil-V5）"><a href="#第5节-RT1050-Hello-World-（Keil-V5）" class="headerlink" title="第5节 RT1050 Hello World （Keil V5）"></a>第5节 RT1050 Hello World （Keil V5）</h1><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC5%E8%8A%82-rt1050-hello-world-%EF%BC%88keil-v5%EF%BC%89/image-20231205210519877.png" class="" title="image-20231205210519877"><span id="more"></span><h2 id="HelloWorld工程介绍"><a href="#HelloWorld工程介绍" class="headerlink" title="HelloWorld工程介绍"></a>HelloWorld工程介绍</h2><h3 id="工程文件位置"><a href="#工程文件位置" class="headerlink" title="工程文件位置"></a>工程文件位置</h3><p><code>C:\Users\Gavin\Documents\RT\Keil5\rt1050 keil sdk &amp; doc\SDK_2_14_0_EVKB-IMXRT1050\boards\evkbimxrt1050\demo_apps\hello_world\</code></p><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC5%E8%8A%82-rt1050-hello-world-%EF%BC%88keil-v5%EF%BC%89/image-20231205211106693.png" class="" title="image-20231205211106693"><h3 id="Keil工程位置"><a href="#Keil工程位置" class="headerlink" title="Keil工程位置"></a>Keil工程位置</h3><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC5%E8%8A%82-rt1050-hello-world-%EF%BC%88keil-v5%EF%BC%89/image-20231205211232436.png" class="" title="image-20231205211232436"><hr><h3 id="MDK工程目录结构"><a href="#MDK工程目录结构" class="headerlink" title="MDK工程目录结构"></a>MDK工程目录结构</h3><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC5%E8%8A%82-rt1050-hello-world-%EF%BC%88keil-v5%EF%BC%89/image-20231205211757977.png" class="" title="image-20231205211757977"><h4 id="几种工程目标"><a href="#几种工程目标" class="headerlink" title="几种工程目标"></a>几种工程目标</h4><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC5%E8%8A%82-rt1050-hello-world-%EF%BC%88keil-v5%EF%BC%89/image-20231205211932870.png" class="" title="image-20231205211932870"><p>—&gt; <mark><strong><u>我们在这里用的是<code>flexspi_nor_debug</code>工程，代码段放在nor flash，数据段放在TCM中！</u></strong></mark></p><h4 id="工程工作组"><a href="#工程工作组" class="headerlink" title="工程工作组"></a>工程工作组</h4><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC5%E8%8A%82-rt1050-hello-world-%EF%BC%88keil-v5%EF%BC%89/image-20231205212708560.png" class="" title="image-20231205212708560"><p><strong><u><em>关于xip的用处：</em></u></strong></p><ul><li>由于RT没有内部Flash，代码都存放在外部ROM空间，那么，在系统启动时，RT是不知道外部flash的信息的，比如：代码地址，空间大小等等；</li><li>所以，需要把这些信息先存放在外部Flash中，然后RT通过SPI通信获得了这部分信息之后，才可以到外部Flash中去取指令；</li></ul><h2 id="打造自己的HelloWorld工程"><a href="#打造自己的HelloWorld工程" class="headerlink" title="打造自己的HelloWorld工程"></a>打造自己的HelloWorld工程</h2><h3 id="SDK工程路径"><a href="#SDK工程路径" class="headerlink" title="SDK工程路径"></a>SDK工程路径</h3><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC5%E8%8A%82-rt1050-hello-world-%EF%BC%88keil-v5%EF%BC%89/image-20231205213504551.png" class="" title="image-20231205213504551"><h3 id="创建hello-world工程"><a href="#创建hello-world工程" class="headerlink" title="创建hello_world工程"></a>创建hello_world工程</h3><ul><li>创建01-hello_world文件夹；</li><li>复制SDK的主要文件；<ul><li>根据工程包含的路径复制，得到：</li><li><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC5%E8%8A%82-rt1050-hello-world-%EF%BC%88keil-v5%EF%BC%89/image-20231205214932520.png" class="" title="image-20231205214932520"></li></ul></li><li>打开这个新建的工程，消除找不到文件的感叹号<code>❗</code></li><li><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC5%E8%8A%82-rt1050-hello-world-%EF%BC%88keil-v5%EF%BC%89/image-20231205215148765.png" class="" title="image-20231205215148765"></li></ul><p>—&gt; 消除方法：通过使用文本编辑器打开该Keil工程，全文搜索并替换这几个include的相对路径！</p><p>—&gt; Reload!</p><p>—&gt; 完成！</p><blockquote><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC5%E8%8A%82-rt1050-hello-world-%EF%BC%88keil-v5%EF%BC%89/image-20231205221003063.png" class="" title="image-20231205221003063"></blockquote><h2 id="分析Hello-world-c"><a href="#分析Hello-world-c" class="headerlink" title="分析Hello_world.c"></a>分析Hello_world.c</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Init board hardware. 初始化开发板*/</span></span><br><span class="line">    BOARD_ConfigMPU();  <span class="comment">//配置内存保护单元</span></span><br><span class="line">    BOARD_InitBootPins();<span class="comment">//初始化开发板IO模式</span></span><br><span class="line">    BOARD_InitBootClocks();<span class="comment">//初始化开发板系统时钟</span></span><br><span class="line">    BOARD_InitDebugConsole();<span class="comment">//初始化调试控制台</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Just enable the trace clock, leave coresight initialization to IDE debugger */</span></span><br><span class="line">    SystemCoreClockUpdate();</span><br><span class="line">    CLOCK_EnableClock(kCLOCK_Trace);</span><br><span class="line"></span><br><span class="line">    PRINTF(<span class="string">"hello world.\r\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        ch = GETCHAR();</span><br><span class="line">        PUTCHAR(ch);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="烧写代码"><a href="#烧写代码" class="headerlink" title="烧写代码"></a>烧写代码</h2><blockquote><p>Keil 快捷键 F8 </p><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC5%E8%8A%82-rt1050-hello-world-%EF%BC%88keil-v5%EF%BC%89/image-20231205221649324.png" class="" title="image-20231205221649324"></blockquote><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC5%E8%8A%82-rt1050-hello-world-%EF%BC%88keil-v5%EF%BC%89/image-20231205221717414.png" class="" title="image-20231205221717414"><h3 id="实验现象"><a href="#实验现象" class="headerlink" title="实验现象"></a>实验现象</h3><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC5%E8%8A%82-rt1050-hello-world-%EF%BC%88keil-v5%EF%BC%89/image-20231205222337955.png" class="" title="image-20231205222337955">]]></content>
    
    
    <summary type="html">第五节课！Keil写一个自己的工程！</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1050" scheme="https://dustofstars.github.io/categories/NXP/RT1050/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="RT1050" scheme="https://dustofstars.github.io/tags/RT1050/"/>
    
  </entry>
  
  <entry>
    <title>RT1050开发--第4节 RT1050开发环境搭建</title>
    <link href="https://dustofstars.github.io/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC4%E8%8A%82-rt1050%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://dustofstars.github.io/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC4%E8%8A%82-rt1050%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2023-12-04T14:33:36.000Z</published>
    <updated>2023-12-04T14:33:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第4节-RT1050开发环境搭建"><a href="#第4节-RT1050开发环境搭建" class="headerlink" title="第4节 RT1050开发环境搭建"></a>第4节 RT1050开发环境搭建</h1><blockquote><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC4%E8%8A%82-rt1050%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20231205110854127.png" class="" title="image-20231205110854127"></blockquote><span id="more"></span><h2 id="Keil5安装"><a href="#Keil5安装" class="headerlink" title="Keil5安装"></a>Keil5安装</h2><ol><li>安装MDK-Keil5；</li><li>安装RT1052 Keil5依赖包；<ol><li>地址：<code>https://www.keil.arm.com/packs/mimxrt1052_dfp-nxp/devices/</code></li><li><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC4%E8%8A%82-rt1050%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20231205115624338.png" class="" title="image-20231205115624338"></li></ol></li></ol><h2 id="仿真器驱动安装"><a href="#仿真器驱动安装" class="headerlink" title="仿真器驱动安装"></a>仿真器驱动安装</h2><ul><li><p>CMSIS-DAP仿真器驱动；</p></li><li><p>串口驱动；</p></li><li><blockquote><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC4%E8%8A%82-rt1050%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20231205115830490.png" class="" title="image-20231205115830490"></blockquote></li></ul><h2 id="SDK下载"><a href="#SDK下载" class="headerlink" title="SDK下载"></a>SDK下载</h2><ol><li>下载地址：<code>https://mcuxpresso.nxp.com/en/select</code></li><li><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC4%E8%8A%82-rt1050%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20231205120209889.png" class="" title="image-20231205120209889"></li></ol><h2 id="SDK介绍"><a href="#SDK介绍" class="headerlink" title="SDK介绍"></a>SDK介绍</h2><ul><li><p>SDK概述</p><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC4%E8%8A%82-rt1050%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20231205121253428.png" class="" title="image-20231205121253428"></li><li><p>SDK源码目录</p><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC4%E8%8A%82-rt1050%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20231205121358508.png" class="" title="image-20231205121358508"></li><li><p>API手册外设驱动结构</p><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC4%E8%8A%82-rt1050%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20231205121447229.png" class="" title="image-20231205121447229"></li></ul><h2 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h2><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC4%E8%8A%82-rt1050%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20231205121856419.png" class="" title="image-20231205121856419"><h2 id="数据手册"><a href="#数据手册" class="headerlink" title="数据手册"></a>数据手册</h2><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC4%E8%8A%82-rt1050%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20231205122245517.png" class="" title="image-20231205122245517"><ul><li>MIMXRT1050 EVKB Board Hardware User’s Guide ： <code>https://www.nxp.com/webapp/sps/download/preDownload.jsp?render=true</code></li><li>DataSheet:</li><li><style>.skmcgeiufmmc{zoom:150%;}</style><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC4%E8%8A%82-rt1050%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20231205123621629.png" class="skmcgeiufmmc" alt="image-20231205123621629"></li></ul>]]></content>
    
    
    <summary type="html">第四节课！ RT1050开发环境搭建。。不咋重要的一节。。</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1050" scheme="https://dustofstars.github.io/categories/NXP/RT1050/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="RT1050" scheme="https://dustofstars.github.io/tags/RT1050/"/>
    
  </entry>
  
  <entry>
    <title>RT1050开发--第3节 RT1050硬件平台</title>
    <link href="https://dustofstars.github.io/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC3%E8%8A%82-rt1050%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/"/>
    <id>https://dustofstars.github.io/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC3%E8%8A%82-rt1050%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/</id>
    <published>2023-12-04T14:31:32.000Z</published>
    <updated>2023-12-04T14:31:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第3节-RT1050硬件平台使用"><a href="#第3节-RT1050硬件平台使用" class="headerlink" title="第3节 RT1050硬件平台使用"></a>第3节 RT1050硬件平台使用</h1><blockquote><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC3%E8%8A%82-rt1050%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/image-20231205103223182.png" class="" title="image-20231205103223182"></blockquote><h2 id="RT1050-EVKB开发板介绍"><a href="#RT1050-EVKB开发板介绍" class="headerlink" title="RT1050 EVKB开发板介绍"></a>RT1050 EVKB开发板介绍</h2><span id="more"></span><h3 id="EVKB硬件框图"><a href="#EVKB硬件框图" class="headerlink" title="EVKB硬件框图"></a>EVKB硬件框图</h3><ol><li>原理图</li></ol><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC3%E8%8A%82-rt1050%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/image-20231205103422056.png" class="" title="image-20231205103422056"><ul><li><p>FlexSPI：</p><ul><li>HyperFlash –高性能高速 CYPRESS S26K</li><li>QSPI Flash</li><li>–&gt; **<u><em>用于外部扩展ROM存储器</em></u>**；</li></ul></li><li><p>SDRAM：</p><ul><li>16bit接口，<u><strong>内部控制器是<code>SEMC</code>！</strong></u></li><li>扩展RAM；</li></ul></li><li><p>SDMC：</p><ul><li>使用SD卡存储大型文件；</li></ul></li></ul><h3 id="PCB图"><a href="#PCB图" class="headerlink" title="PCB图"></a>PCB图</h3><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC3%E8%8A%82-rt1050%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/image-20231205103953019.png" class="" title="image-20231205103953019"><ol><li>开发板硬件清单</li></ol><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC3%E8%8A%82-rt1050%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/image-20231205104237835.png" class="" title="image-20231205104237835"><ul><li>重点看一下Mass Storage，可以看到除了SD卡外，还有64M的QSPI Flash和512M的HyperFlash；</li></ul><ol start="2"><li><p>开发板供电模式</p><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC3%E8%8A%82-rt1050%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/image-20231205104639064.png" class="" title="image-20231205104639064"><blockquote><p>J1 放在5-6时，由OpenSDA那个USB口供电：J28；</p></blockquote></li></ol><h2 id="开发板启动模式配置"><a href="#开发板启动模式配置" class="headerlink" title="开发板启动模式配置"></a>开发板启动模式配置</h2><h3 id="启动配置引脚"><a href="#启动配置引脚" class="headerlink" title="启动配置引脚"></a>启动配置引脚</h3><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC3%E8%8A%82-rt1050%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/image-20231205104954445.png" class="" title="image-20231205104954445"><ul><li><u><strong>最常用的是：10–Internal Boot 模式！</strong></u></li><li>SW7就是4个拨码开关：x-x-1-0  –&gt; Internal Boot！</li></ul><hr><h3 id="高级启动序列"><a href="#高级启动序列" class="headerlink" title="高级启动序列"></a>高级启动序列</h3><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC3%E8%8A%82-rt1050%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/image-20231205105329551.png" class="" title="image-20231205105329551"><blockquote><p>即：Internal Boot的执行流程：</p><ul><li>最上方是低功耗的WakeUp检测；如果是WakeUp模式启动，就正常Execute Image；</li><li>如果不是，就会检测Boot的启动模式；Internal Boot or 串口下载？<ul><li>Internal Boot：<ul><li>根据GPIO引脚的配置（高低电平），选择是从SD卡还是QSPI还是HyperFlash启动；</li><li>Authenticate image；</li><li>校验通过就Execute Image；</li></ul></li><li>串口下载：*<u>暂时略过</u>*；</li></ul></li></ul></blockquote><h3 id="外部启动模式选择（通过拨码开关）"><a href="#外部启动模式选择（通过拨码开关）" class="headerlink" title="外部启动模式选择（通过拨码开关）"></a>外部启动模式选择（通过拨码开关）</h3><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC3%E8%8A%82-rt1050%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/image-20231205105944436.png" class="" title="image-20231205105944436"><hr><h2 id="开发板烧写-仿真接口"><a href="#开发板烧写-仿真接口" class="headerlink" title="开发板烧写/仿真接口"></a>开发板烧写/仿真接口</h2><h3 id="OpenSDA"><a href="#OpenSDA" class="headerlink" title="OpenSDA"></a>OpenSDA</h3><blockquote><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC3%E8%8A%82-rt1050%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/image-20231205110133794.png" class="" title="image-20231205110133794"></blockquote><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC3%E8%8A%82-rt1050%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/image-20231205110147365.png" class="" title="image-20231205110147365"><h3 id="CMSIS-DAP接口"><a href="#CMSIS-DAP接口" class="headerlink" title="CMSIS-DAP接口"></a>CMSIS-DAP接口</h3><blockquote><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC3%E8%8A%82-rt1050%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/image-20231205110445636.png" class="" title="image-20231205110445636"></blockquote><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC3%E8%8A%82-rt1050%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/image-20231205110458191.png" class="" title="image-20231205110458191"><h3 id="使用要求"><a href="#使用要求" class="headerlink" title="使用要求"></a>使用要求</h3><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC3%E8%8A%82-rt1050%E7%A1%AC%E4%BB%B6%E5%B9%B3%E5%8F%B0/image-20231205110606490.png" class="" title="image-20231205110606490">]]></content>
    
    
    <summary type="html">第三节课！ RT1050硬件平台EVKB板子的使用！</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1050" scheme="https://dustofstars.github.io/categories/NXP/RT1050/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="RT1050" scheme="https://dustofstars.github.io/tags/RT1050/"/>
    
  </entry>
  
  <entry>
    <title>RT1050开发--第2节 NXP RT1050系列芯片</title>
    <link href="https://dustofstars.github.io/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC2%E8%8A%82-nxp-rt1050%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87/"/>
    <id>https://dustofstars.github.io/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC2%E8%8A%82-nxp-rt1050%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87/</id>
    <published>2023-12-04T14:28:29.000Z</published>
    <updated>2023-12-04T14:28:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二节-RT1050系列芯片"><a href="#第二节-RT1050系列芯片" class="headerlink" title="第二节 RT1050系列芯片"></a>第二节 RT1050系列芯片</h1><blockquote><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC2%E8%8A%82-nxp-rt1050%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87/image-20231204214727923.png" class="" title="image-20231204214727923"></blockquote><hr><span id="more"></span><h2 id="MCU与MPU开发模式"><a href="#MCU与MPU开发模式" class="headerlink" title="MCU与MPU开发模式"></a>MCU与MPU开发模式</h2><h3 id="MPU嵌入式开发流程"><a href="#MPU嵌入式开发流程" class="headerlink" title="MPU嵌入式开发流程"></a>MPU嵌入式开发流程</h3><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC2%E8%8A%82-nxp-rt1050%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87/image-20231204214944808.png" class="" title="image-20231204214944808"><h3 id="MCU物联网开发流程"><a href="#MCU物联网开发流程" class="headerlink" title="MCU物联网开发流程"></a>MCU物联网开发流程</h3><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC2%E8%8A%82-nxp-rt1050%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87/image-20231204215132544.png" class="" title="image-20231204215132544"><h3 id="新的需求"><a href="#新的需求" class="headerlink" title="新的需求"></a>新的需求</h3><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC2%E8%8A%82-nxp-rt1050%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87/image-20231204215345727.png" class="" title="image-20231204215345727"><hr><h2 id="iMX-RT-1050跨界处理器"><a href="#iMX-RT-1050跨界处理器" class="headerlink" title="iMX.RT 1050跨界处理器"></a>iMX.RT 1050跨界处理器</h2><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC2%E8%8A%82-nxp-rt1050%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87/image-20231205100755320.png" class="" title="image-20231205100755320"><h3 id="降低成本-–-无需片内闪存"><a href="#降低成本-–-无需片内闪存" class="headerlink" title="降低成本 – 无需片内闪存"></a>降低成本 – 无需片内闪存</h3><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC2%E8%8A%82-nxp-rt1050%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87/image-20231205100923019.png" class="" title="image-20231205100923019"><h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><blockquote><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC2%E8%8A%82-nxp-rt1050%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87/image-20231205101211113.png" class="" title="image-20231205101211113"></blockquote><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC2%E8%8A%82-nxp-rt1050%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87/image-20231205101220140.png" class="" title="image-20231205101220140"><h3 id="低中断延时"><a href="#低中断延时" class="headerlink" title="低中断延时"></a>低中断延时</h3><blockquote><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC2%E8%8A%82-nxp-rt1050%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87/image-20231205101743111.png" class="" title="image-20231205101743111"></blockquote><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC2%E8%8A%82-nxp-rt1050%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87/image-20231205101754029.png" class="" title="image-20231205101754029"><h3 id="高效能"><a href="#高效能" class="headerlink" title="高效能"></a>高效能</h3><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC2%E8%8A%82-nxp-rt1050%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87/image-20231205102016092.png" class="" title="image-20231205102016092"><blockquote><p>RT把DC-DC放到芯片里面，每MHz电流消耗降低了接近一半！</p></blockquote><hr><h2 id="RT1050特色外设"><a href="#RT1050特色外设" class="headerlink" title="RT1050特色外设"></a>RT1050特色外设</h2><h3 id="通用外设"><a href="#通用外设" class="headerlink" title="通用外设"></a>通用外设</h3><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC2%E8%8A%82-nxp-rt1050%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87/image-20231205102154012.png" class="" title="image-20231205102154012"><h3 id="低功耗外设"><a href="#低功耗外设" class="headerlink" title="低功耗外设"></a>低功耗外设</h3><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC2%E8%8A%82-nxp-rt1050%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87/image-20231205102237384.png" class="" title="image-20231205102237384"><h3 id="灵活外设"><a href="#灵活外设" class="headerlink" title="灵活外设"></a>灵活外设</h3><blockquote> <img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC2%E8%8A%82-nxp-rt1050%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87/image-20231205102336054.png" class="" title="image-20231205102336054"></blockquote><blockquote><p>**<u>FlexSPI</u>**重点，覆盖了所有的SPI接口，并且速度更快，接近200M；</p><p><mark><strong><u>FlexRAM</u></strong></mark>：DTCM、ITCM，但是RT内核只提供了一个512K的RAM，但是它可以灵活的分配为DTCM、ITCM等；</p></blockquote><h3 id="高级外设"><a href="#高级外设" class="headerlink" title="高级外设"></a>高级外设</h3><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC2%E8%8A%82-nxp-rt1050%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87/image-20231205102806831.png" class="" title="image-20231205102806831"><p>SEMC:<u><em><strong>安全外部存储器控制器，之前提到的SDRAM、NOR NAND都可以通过这个接口接入</strong></em></u>；</p>]]></content>
    
    
    <summary type="html">第二节课！RT1050系列芯片跨界处理器的特色！</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1050" scheme="https://dustofstars.github.io/categories/NXP/RT1050/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="RT1050" scheme="https://dustofstars.github.io/tags/RT1050/"/>
    
  </entry>
  
  <entry>
    <title>RT1050开发--第1节 ARM Cortex-M7体系结构</title>
    <link href="https://dustofstars.github.io/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>https://dustofstars.github.io/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</id>
    <published>2023-12-04T14:26:22.000Z</published>
    <updated>2023-12-04T14:26:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一节-ARM-Cortex-M7体系结构"><a href="#第一节-ARM-Cortex-M7体系结构" class="headerlink" title="第一节 ARM Cortex-M7体系结构"></a>第一节 ARM Cortex-M7体系结构</h1><span id="more"></span><blockquote><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204205936163.png" class="" title="image-20231204205936163"></blockquote><hr><h2 id="认识ARM"><a href="#认识ARM" class="headerlink" title="认识ARM"></a>认识ARM</h2><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204210036757.png" class="" title="image-20231204210036757"><h3 id="A系列-–-移动的王者"><a href="#A系列-–-移动的王者" class="headerlink" title="A系列 – 移动的王者"></a>A系列 – 移动的王者</h3><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204210232296.png" class="" title="image-20231204210232296"><h2 id="M系列-–-无处不在"><a href="#M系列-–-无处不在" class="headerlink" title="M系列 – 无处不在"></a>M系列 – 无处不在</h2><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204210508859.png" class="" title="image-20231204210508859"><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204210629438.png" class="" title="image-20231204210629438"><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204210816730.png" class="" title="image-20231204210816730"><hr><h2 id="Cortex-M7介绍"><a href="#Cortex-M7介绍" class="headerlink" title="Cortex-M7介绍"></a>Cortex-M7介绍</h2><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204210956321.png" class="" title="image-20231204210956321"><h3 id="规格特点"><a href="#规格特点" class="headerlink" title="规格特点"></a>规格特点</h3><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204211218436.png" class="" title="image-20231204211218436"><h3 id="对外接口"><a href="#对外接口" class="headerlink" title="对外接口"></a>对外接口</h3><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204211325476.png" class="" title="image-20231204211325476"><hr><h2 id="Cortex-M7-编程模型"><a href="#Cortex-M7-编程模型" class="headerlink" title="Cortex-M7 编程模型"></a>Cortex-M7 编程模型</h2><h3 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h3><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204211548215.png" class="" title="image-20231204211548215"><blockquote><p>所有M系列都是这两个模式：线程模式 + 处理模式（中断模式）</p><p>即：主程序都是在线程模式，中断处理函数都是处理模式，处理模式下拥有特权；</p></blockquote><hr><h3 id="操作状态"><a href="#操作状态" class="headerlink" title="操作状态"></a>操作状态</h3><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204211740877.png" class="" title="image-20231204211740877"><blockquote><p>即：一个运行，一个调试；</p></blockquote><h3 id="特权访问和非特权访问"><a href="#特权访问和非特权访问" class="headerlink" title="特权访问和非特权访问"></a>特权访问和非特权访问</h3><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204211828379.png" class="" title="image-20231204211828379"><blockquote><p>特权访问：即可以触碰到CPU所有的资源；非特权访问有些资源碰不到！</p><p><mark><strong><u>线程模式一般就是非特权的，处理模式都是特权的！</u></strong></mark></p></blockquote><hr><h3 id="系统的地址映射"><a href="#系统的地址映射" class="headerlink" title="系统的地址映射"></a>系统的地址映射</h3><blockquote><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204212206094.png" class="" title="image-20231204212206094"></blockquote><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204212237605.png" class="" title="image-20231204212237605"><blockquote><p>0x0000_0000 ~ 0xFFFF_FFFF  一共 4GB；</p><p>Code ： 即 ROM；</p><p>SRAM：即数据；</p><p>Peripheral：放外设，M7把代码、数据、外设 都映射到同一片地址空间；</p><p>External RAM： 外部存储器！</p><p>External device：外部设备</p><p>内部私有外设总线；</p><p>外部私有外设总线；–》 M7内核的；</p></blockquote><h3 id="处理器的核心寄存器"><a href="#处理器的核心寄存器" class="headerlink" title="处理器的核心寄存器"></a>处理器的核心寄存器</h3><blockquote><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204212830460.png" class="" title="image-20231204212830460"></blockquote><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204212848276.png" class="" title="image-20231204212848276"><p>R13栈指针一个寄存器映射两个区域：<mark><strong><code>MSP</code></strong> 和 **<code>PSP</code>**；</mark></p><blockquote><p><strong><u><em>纯裸机编程时，只有一个栈，所以只有MSP主栈指针；</em></u></strong></p><p>FreeRTOS才会用到PSP进程栈指针；</p></blockquote><hr><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204213402264.png" class="" title="image-20231204213402264"><img src="/NXP/RT1050/rt1050%E5%BC%80%E5%8F%91-%E7%AC%AC1%E8%8A%82-arm-cortex-m7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231204213423024.png" class="" title="image-20231204213423024"><p><strong><mark><u>ARM的异常处理流程：</u></mark></strong></p><ul><li>1– 保存当前程序的上下文，即：xPSR、PC、LR、R0-R3,R12;<ul><li>通过MSP或者PSP读取地址，把这些寄存器全都入栈，就保存了下来；</li></ul></li><li>2– 把当前要返回的地址放在LR链接寄存器中；</li><li>3a– 切换模式，从线程模式切换到处理模式；</li><li>3b– 指针指向新的栈顶；</li><li>4– 找到该中断的向量地址，赋值给PC指针，执行中断处理函数；</li></ul>]]></content>
    
    
    <summary type="html">第一节课！介绍ARM的体系结构！</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1050" scheme="https://dustofstars.github.io/categories/NXP/RT1050/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="RT1050" scheme="https://dustofstars.github.io/tags/RT1050/"/>
    
  </entry>
  
  <entry>
    <title>野火RT1052开发板1创建环境</title>
    <link href="https://dustofstars.github.io/NXP/RT1050/%E9%87%8E%E7%81%AB/%E9%87%8E%E7%81%ABrt1052%E5%BC%80%E5%8F%91%E6%9D%BF1%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83/"/>
    <id>https://dustofstars.github.io/NXP/RT1050/%E9%87%8E%E7%81%AB/%E9%87%8E%E7%81%ABrt1052%E5%BC%80%E5%8F%91%E6%9D%BF1%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83/</id>
    <published>2023-11-30T13:32:20.000Z</published>
    <updated>2023-11-30T13:32:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="野火RT1052开发板1-–-NXP-MCU-Link-Pro-Keil-V5-编译环境创建"><a href="#野火RT1052开发板1-–-NXP-MCU-Link-Pro-Keil-V5-编译环境创建" class="headerlink" title="野火RT1052开发板1 – NXP MCU-Link Pro + Keil V5 编译环境创建"></a>野火RT1052开发板1 – NXP MCU-Link Pro + Keil V5 编译环境创建</h1><blockquote><p>野火i.MX RT1052 EVK Pro是个很好的学习工具，野火不仅做了汉化，另外，把所有的Pin脚都做了引出，虽然是个老产品，但是一通百通所以这个系列准备使用野火的板子来入门，具体要更几篇待定…，但是尽量每一篇都有真东西，这是第一篇：使用NXP MCU-Link Pro + Keil V5，创建编译环境运行第一个demo。</p></blockquote><span id="more"></span><img src="/NXP/RT1050/%E9%87%8E%E7%81%AB/%E9%87%8E%E7%81%ABrt1052%E5%BC%80%E5%8F%91%E6%9D%BF1%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83/image-20231130220915920.png" class="" title="image-20231130220915920"><ul><li>芯片Part Number： <strong>196pin</strong> 的工业级的 <code>MIMXRT1052CVL5B</code></li></ul><h2 id="安装Keil-V5"><a href="#安装Keil-V5" class="headerlink" title="安装Keil V5"></a>安装Keil V5</h2><blockquote><p>参考这个视频： <a href="https://www.bilibili.com/video/av544829324/?vd_source=e742ab928a70238934780b04b84d177d">https://www.bilibili.com/video/av544829324/?vd_source=e742ab928a70238934780b04b84d177d</a></p></blockquote><h3 id="安装芯片包"><a href="#安装芯片包" class="headerlink" title="安装芯片包"></a>安装芯片包</h3><ul><li>KEIL5 需要自己安装对应芯片的芯片包。直接去 keil 的官网下载：<a href="http://www.keil.com/dd2/pack/">http://www.keil.com/dd2/pack/</a></li><li>下载之后双击安装即可！</li></ul><img src="/NXP/RT1050/%E9%87%8E%E7%81%AB/%E9%87%8E%E7%81%ABrt1052%E5%BC%80%E5%8F%91%E6%9D%BF1%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83/image-20231130221413145.png" class="" title="芯片包安装成功"><h3 id="更换编译器"><a href="#更换编译器" class="headerlink" title="更换编译器"></a>更换编译器</h3><p>Keil的新版本不再提供ARM Compiler V5，因此需要自己下载，去百度这个关键词：**<u><em>ARMCompiler_506_Windows_x86_b960.zip</em></u>** 找到的就是最后一个V5编译器，下载并安装。</p><ul><li>安装地址推荐：**<u><em>C:\Keil_v5\ARM\ARMCC</em></u>** (新建一个ARMCC文件夹，安装到这个文件夹)</li></ul><p>然后，需要在project中手动增加这个编译器：</p><ol><li><p>Add another Arm Compiler Version to List：</p><img src="/NXP/RT1050/%E9%87%8E%E7%81%AB/%E9%87%8E%E7%81%ABrt1052%E5%BC%80%E5%8F%91%E6%9D%BF1%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83/image-20231130222156941.png" class="" title="image-20231130222156941"></li><li><p>在项目中改为这个编译器：</p></li></ol><img src="/NXP/RT1050/%E9%87%8E%E7%81%AB/%E9%87%8E%E7%81%ABrt1052%E5%BC%80%E5%8F%91%E6%9D%BF1%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83/image-20231130222240551.png" class="" title="image-20231130222240551"><h3 id="更换Flash下载算法"><a href="#更换Flash下载算法" class="headerlink" title="更换Flash下载算法"></a>更换Flash下载算法</h3><p>i.MX RT 系列芯片内部不具备 FLASH 存储器，即其程序代码需要存储在外部的存储器中，使用时需要自己提供对应 FLASH 的下载算法给 KEIL 软件，野火 i.MX RT1052 系 列开发板使用 32MB 的 SPI-NorFlash 芯片存储程序。野火提供了自己的Flash下载算法，有两个版本，寄存器版本和库函数版本：</p><ul><li>iMXRT1052_W25Q256JV_CFG_By_Fire.FLM(寄存器版本工程使用)</li><li>Embedfire_RT1052_QSPI_R1.FLM（库函数版本工程使用）</li></ul><p>需要把这两个文件复制到Keil的安装目录下：**<u><em>C:\Keil_v5\ARM\Flash</em></u>**</p><p><u><strong>====&gt; 到此为止，编译所需的软件基本整理完毕！==</strong></u></p><h2 id="硬件连接"><a href="#硬件连接" class="headerlink" title="硬件连接"></a>硬件连接</h2><p>先把载板丢一边，看看这个核心板，核心板有一个供电口，一个SWD debug口，还有一个三线的UART接口。</p><img src="/NXP/RT1050/%E9%87%8E%E7%81%AB/%E9%87%8E%E7%81%ABrt1052%E5%BC%80%E5%8F%91%E6%9D%BF1%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83/image-20231130223734281.png" class="" title="image-20231130223734281"><img src="/NXP/RT1050/%E9%87%8E%E7%81%AB/%E9%87%8E%E7%81%ABrt1052%E5%BC%80%E5%8F%91%E6%9D%BF1%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83/image-20231130223748254.png" class="" title="image-20231130223748254"><p>原装的DAP下载器不见了，刚好试试NXP更为强大的MCU-Link Pro ! 小试牛刀！</p><h3 id="MCU-Link-Pro"><a href="#MCU-Link-Pro" class="headerlink" title="MCU-Link Pro"></a>MCU-Link Pro</h3><p>MCU-Link Pro的官方主页在这：<a href="https://www.nxp.com.cn/design/software/development-software/mcuxpresso-software-and-tools-/mcu-link-pro-debug-probe:MCU-LINK-PRO">MCU-Link Pro硬件调试器 | NXP 半导体</a></p><p>支持很多NXP产品的调试，而且可以方便的烧录CMSIS-DAP和JLink的固件，虽然贵点，但是相当于一颗更比两颗强，值了！</p><img src="/NXP/RT1050/%E9%87%8E%E7%81%AB/%E9%87%8E%E7%81%ABrt1052%E5%BC%80%E5%8F%91%E6%9D%BF1%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83/image-20231130224325691.png" class="" title="image-20231130224325691"><p>看一下这里对它的总体介绍：</p><blockquote><p>MCU-Link Pro基于恩智浦的MCU-Link架构，可以在MCU-Link低成本硬件调试器和板载评估板中找到，所有这些版本都运行相同的固件。除了基本MCU-Link中的SWD调试、SWO分析和USB到UART桥接功能(VCOM)之外，MCU-LinkPro型号还增加了J-Link LITE固件选项、能量测量、模拟信号监视器、USB转SPI和I2C桥接功能，以及外设仿真的板载LPC804。MCU-Link Pro基于Arm® Cortex-M33®双核LPC55S69微控制器，并具有高速USB接口，提供低成本、高性能的调试。</p></blockquote><img src="/NXP/RT1050/%E9%87%8E%E7%81%AB/%E9%87%8E%E7%81%ABrt1052%E5%BC%80%E5%8F%91%E6%9D%BF1%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83/image-20231130225008405.png" class="" title="image-20231130225008405"><p>在这个用法中，我们主要用到J7连接板子，J19中的UART信号接出来到板子上：RX &lt;—&gt; TX  TX &lt;—&gt; RX</p><img src="/NXP/RT1050/%E9%87%8E%E7%81%AB/%E9%87%8E%E7%81%ABrt1052%E5%BC%80%E5%8F%91%E6%9D%BF1%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83/image-20231130225346948.png" class="" title="image-20231130225346948"><h3 id="JTAG接口转接"><a href="#JTAG接口转接" class="headerlink" title="JTAG接口转接"></a>JTAG接口转接</h3><p>由于配备的cable是个小口，还需要一个小转大的转接板，因此，需要找个20PinJTAG口的定义，查阅这个链接：<a href="https://blog.csdn.net/chenhuanqiangnihao/article/details/113835905">JTAG各类接口针脚定义、含义以及SWD接线方式_jtag接口定义_学海无涯_come on的博客-CSDN博客</a></p><img src="/NXP/RT1050/%E9%87%8E%E7%81%AB/%E9%87%8E%E7%81%ABrt1052%E5%BC%80%E5%8F%91%E6%9D%BF1%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83/image-20231130225730949.png" class="" title="image-20231130225730949"><p>注意，方形焊盘都是1号Pin脚；</p><img src="/NXP/RT1050/%E9%87%8E%E7%81%AB/%E9%87%8E%E7%81%ABrt1052%E5%BC%80%E5%8F%91%E6%9D%BF1%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83/image-20231130225915289.png" class="" title="image-20231130225915289"><p><strong>==—》至此，硬件连接部分搞定！==</strong></p><h2 id="跑Demo！"><a href="#跑Demo！" class="headerlink" title="跑Demo！"></a>跑Demo！</h2><h3 id="先展示一下硬件连接"><a href="#先展示一下硬件连接" class="headerlink" title="先展示一下硬件连接"></a>先展示一下硬件连接</h3><img src="/NXP/RT1050/%E9%87%8E%E7%81%AB/%E9%87%8E%E7%81%ABrt1052%E5%BC%80%E5%8F%91%E6%9D%BF1%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83/%E7%A1%AC%E4%BB%B6%E8%BF%9E%E6%8E%A5.jpg" class="" title="硬件连接"><hr><p>注意：</p><ul><li>一定要先给板子上电，再给debugger上电，不然有可能通信失败！</li></ul><h3 id="运行自带的验证程序"><a href="#运行自带的验证程序" class="headerlink" title="运行自带的验证程序"></a>运行自带的验证程序</h3><blockquote><p>1052-H1核心板测试代码\1052-H1测试程序</p></blockquote><p>先编译看看：</p><img src="/NXP/RT1050/%E9%87%8E%E7%81%AB/%E9%87%8E%E7%81%ABrt1052%E5%BC%80%E5%8F%91%E6%9D%BF1%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83/image-20231130232535899.png" class="" title="image-20231130232535899"><p>🆗！</p><p>再烧录进来：</p><img src="/NXP/RT1050/%E9%87%8E%E7%81%AB/%E9%87%8E%E7%81%ABrt1052%E5%BC%80%E5%8F%91%E6%9D%BF1%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83/image-20231130232615101.png" class="" title="image-20231130232615101"><p>看看使用VCOM的串口输出：</p><img src="/NXP/RT1050/%E9%87%8E%E7%81%AB/%E9%87%8E%E7%81%ABrt1052%E5%BC%80%E5%8F%91%E6%9D%BF1%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83/shot.png" class=""><hr><p>完美运行按键检测的demo~</p><p>后续可以看一下按键中断是如何实现的，以及，继续看一下RT库开发手册！</p><p>— 2023/11/30</p>]]></content>
    
    
    <summary type="html">第一部分，野火RT1052开发板为例，环境创建先跑起来再说</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="RT1050" scheme="https://dustofstars.github.io/categories/NXP/RT1050/"/>
    
    <category term="野火" scheme="https://dustofstars.github.io/categories/NXP/RT1050/%E9%87%8E%E7%81%AB/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="RT1050" scheme="https://dustofstars.github.io/tags/RT1050/"/>
    
  </entry>
  
  <entry>
    <title>kw38点灯大师2_GPIO中断</title>
    <link href="https://dustofstars.github.io/NXP/KW38/GPIO%E4%B8%AD%E6%96%AD/kw38%E7%82%B9%E7%81%AF%E5%A4%A7%E5%B8%882-gpio%E4%B8%AD%E6%96%AD/"/>
    <id>https://dustofstars.github.io/NXP/KW38/GPIO%E4%B8%AD%E6%96%AD/kw38%E7%82%B9%E7%81%AF%E5%A4%A7%E5%B8%882-gpio%E4%B8%AD%E6%96%AD/</id>
    <published>2023-03-29T07:52:43.000Z</published>
    <updated>2023-03-29T07:52:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kw38点灯大师2-GPIO中断"><a href="#kw38点灯大师2-GPIO中断" class="headerlink" title="kw38点灯大师2_GPIO中断"></a>kw38点灯大师2_GPIO中断</h1><blockquote><p>frdmkw38_gpio_led_output   工程frdmkw38_gpio_input_interrupt   工程</p></blockquote><span id="more"></span><img src="/NXP/KW38/GPIO%E4%B8%AD%E6%96%AD/kw38%E7%82%B9%E7%81%AF%E5%A4%A7%E5%B8%882-gpio%E4%B8%AD%E6%96%AD/gpio%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6LED.gif" class="" title="light"><h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* Define the init structure for the output LED pin*/</span></span><br><span class="line">    <span class="type">gpio_pin_config_t</span> led_config = {</span><br><span class="line">        kGPIO_DigitalOutput,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Define the init structure for the input switch pin */</span></span><br><span class="line">    <span class="type">gpio_pin_config_t</span> sw_config = {</span><br><span class="line">        kGPIO_DigitalInput,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Board pin, clock, debug console init */</span></span><br><span class="line">    BOARD_InitPins();</span><br><span class="line">    BOARD_BootClockRUN();</span><br><span class="line">    BOARD_InitDebugConsole();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Print a note to terminal. */</span></span><br><span class="line">    PRINTF(<span class="string">"\r\n GPIO Driver example\r\n"</span>);</span><br><span class="line">    PRINTF(<span class="string">"\r\n The LED is blinking.\r\n"</span>);</span><br><span class="line">    PRINTF(<span class="string">"\r\n 按压开关 %s 来开关和切换LED.\r\n"</span>, BOARD_SW_NAME);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Init input switch GPIO. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (defined(FSL_FEATURE_PORT_HAS_NO_INTERRUPT) &amp;&amp; FSL_FEATURE_PORT_HAS_NO_INTERRUPT)</span></span><br><span class="line">    GPIO_SetPinInterruptConfig(BOARD_SW2_GPIO, BOARD_SW2_GPIO_PIN, kGPIO_InterruptFallingEdge);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    PORT_SetPinInterruptConfig(BOARD_SW2_PORT, BOARD_SW2_GPIO_PIN, kPORT_InterruptFallingEdge);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    EnableIRQ(BOARD_SW2_IRQ);</span><br><span class="line">    GPIO_PinInit(BOARD_SW2_GPIO, BOARD_SW2_GPIO_PIN, &amp;sw_config);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Init output LED GPIO. */</span></span><br><span class="line">    GPIO_PinInit(BOARD_LED_GPIO0, BOARD_LED_GPIO_PIN0, &amp;led_config);</span><br><span class="line">    GPIO_PinInit(BOARD_LED_GPIO1, BOARD_LED_GPIO_PIN1, &amp;led_config);</span><br><span class="line">    GPIO_PinInit(BOARD_LED_GPIO2, BOARD_LED_GPIO_PIN2, &amp;led_config);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (g_ButtonPress)</span><br><span class="line">        {</span><br><span class="line">            temp ++;</span><br><span class="line">            PRINTF(<span class="string">" %s is pressed, it is time: %d \r\n"</span>, BOARD_SW_NAME, temp);</span><br><span class="line">            <span class="keyword">switch</span>(temp%<span class="number">3</span>)</span><br><span class="line">            {</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                PRINTF(<span class="string">" case 0, BLUE LED ON"</span>);</span><br><span class="line">                LED_RED_OFF();</span><br><span class="line">                LED_GREEN_OFF();</span><br><span class="line">                LED_BLUE_ON();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                PRINTF(<span class="string">" case 1, GREEN LED ON"</span>);</span><br><span class="line">                LED_RED_OFF();</span><br><span class="line">                LED_GREEN_ON();</span><br><span class="line">                LED_BLUE_OFF();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                PRINTF(<span class="string">" case 2, RED LED ON"</span>);</span><br><span class="line">                LED_RED_ON();</span><br><span class="line">                LED_GREEN_OFF();</span><br><span class="line">                LED_BLUE_OFF();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"><span class="comment">//            /* Toggle LED. */</span></span><br><span class="line"><span class="comment">//            GPIO_PortToggle(BOARD_LED_GPIO, 1U &lt;&lt; BOARD_LED_GPIO_PIN);</span></span><br><span class="line"><span class="comment">//            /* Reset state of button. */</span></span><br><span class="line">            g_ButtonPress = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="中断处理函数"><a href="#中断处理函数" class="headerlink" title="中断处理函数"></a>中断处理函数</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BOARD_SW2_IRQ_HANDLER</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* Clear external interrupt flag. */</span></span><br><span class="line">    GPIO_PortClearInterruptFlags(BOARD_SW2_GPIO, <span class="number">1U</span> &lt;&lt; BOARD_SW2_GPIO_PIN);</span><br><span class="line">    <span class="comment">/* Change state of button. */</span></span><br><span class="line">    g_ButtonPress = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">/* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F Store immediate overlapping</span></span><br><span class="line"><span class="comment">  exception return operation might vector to incorrect interrupt */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined __CORTEX_M &amp;&amp; (__CORTEX_M == 4U)</span></span><br><span class="line">    __DSB();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="预定义"><a href="#预定义" class="headerlink" title="预定义"></a>预定义</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BOARD_LED_GPIO0 BOARD_LED_RED_GPIO</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOARD_LED_GPIO_PIN0 BOARD_LED_RED_GPIO_PIN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOARD_LED_GPIO1 BOARD_LED_GREEN_GPIO</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOARD_LED_GPIO_PIN1 BOARD_LED_GREEN_GPIO_PIN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOARD_LED_GPIO2 BOARD_LED_BLUE_GPIO</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOARD_LED_GPIO_PIN2 BOARD_LED_BLUE_GPIO_PIN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOARD_SW_NAME BOARD_SW2_NAME</span></span><br></pre></td></tr></tbody></table></figure><h1 id="总结GPIO中断的流程"><a href="#总结GPIO中断的流程" class="headerlink" title="总结GPIO中断的流程"></a>总结GPIO中断的流程</h1><ol><li>变量flag <code>volatile bool g_ButtonPress = false;</code>  指示是否按下开关</li><li>中断处理函数 <code>void BOARD_SW2_IRQ_HANDLER()</code><ol><li>先清空外部中断，<code>GPIO_PortClearInterruptFlags(BOARD_SW2_GPIO, 1U &lt;&lt; BOARD_SW2_GPIO_PIN);</code></li><li>再对flag置一，表示中断已经发生；</li><li>之后，它会进入到main的while循环里面的<code>if(g_ButtonPress)</code>;</li></ol></li><li>main函数里面初始化板子之后，要初始化SW的GPIO；<ol><li>中断config设置  <code>GPIO_SetPinInterruptConfig(BOARD_SW2_GPIO, BOARD_SW2_GPIO_PIN, kGPIO_InterruptFallingEdge);</code>;</li><li>GPIO_PinInit   <code>GPIO_PinInit(BOARD_SW2_GPIO, BOARD_SW2_GPIO_PIN, &amp;sw_config);</code></li></ol></li><li>然后 <code>EnableIRQ(BOARD_SW2_IRQ);</code></li></ol>]]></content>
    
    
    <summary type="html">KW38点灯大师进阶版.</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="KW38" scheme="https://dustofstars.github.io/categories/NXP/KW38/"/>
    
    <category term="GPIO中断" scheme="https://dustofstars.github.io/categories/NXP/KW38/GPIO%E4%B8%AD%E6%96%AD/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="GPIO中断" scheme="https://dustofstars.github.io/tags/GPIO%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>kw38点灯大师</title>
    <link href="https://dustofstars.github.io/NXP/KW38/kw38%E7%82%B9%E7%81%AF%E5%A4%A7%E5%B8%88/"/>
    <id>https://dustofstars.github.io/NXP/KW38/kw38%E7%82%B9%E7%81%AF%E5%A4%A7%E5%B8%88/</id>
    <published>2023-03-24T09:06:42.000Z</published>
    <updated>2023-03-24T09:06:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="KW38点灯大师"><a href="#KW38点灯大师" class="headerlink" title="KW38点灯大师"></a>KW38点灯大师</h1><blockquote><p>frdmkw38_gpio_led_output   工程</p><p>KW38点灯大师哈哈哈.</p></blockquote><span id="more"></span><img src="/NXP/KW38/kw38%E7%82%B9%E7%81%AF%E5%A4%A7%E5%B8%88/light2.gif" class="" title="light"><h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* Define the init structure for the output LED pin*/</span></span><br><span class="line">    <span class="type">gpio_pin_config_t</span> led_config = {</span><br><span class="line">        kGPIO_DigitalOutput,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Board pin, clock, debug console init */</span></span><br><span class="line">    BOARD_InitPins();</span><br><span class="line">    BOARD_BootClockRUN();</span><br><span class="line">    BOARD_InitDebugConsole();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Print a note to terminal. */</span></span><br><span class="line">    PRINTF(<span class="string">"\r\n GPIO Driver example\r\n"</span>);</span><br><span class="line">    PRINTF(<span class="string">"\r\n The LED is blinking.\r\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Init output LED GPIO. */</span></span><br><span class="line">    GPIO_PinInit(BOARD_LED_GPIO, BOARD_LED_GPIO_PIN, &amp;led_config);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        delay();</span><br><span class="line">        GPIO_PortToggle(BOARD_LED_GPIO, <span class="number">1u</span> &lt;&lt; BOARD_LED_GPIO_PIN);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>这段代码是一个GPIO驱动的示例代码，它使用了MCUXpresso SDK提供的GPIO驱动库来控制开发板上的LED灯。</p></blockquote><p>在这个示例中，我们使用了<code>GPIO_PinInit()</code>函数来初始化LED灯的GPIO引脚，然后在一个while循环中不断地切换LED灯的状态，从而实现LED灯的闪烁效果。</p><p>具体来说，我们使用了<code>GPIO_PortToggle()</code>函数来切换LED灯的状态，使用了<code>delay()</code>函数来控制LED灯的闪烁频率。</p><h3 id="led-config-结构体"><a href="#led-config-结构体" class="headerlink" title="led_config 结构体"></a>led_config 结构体</h3><p>定义了一个<code>gpio_pin_config_t</code>类型的变量<code>led_config</code>，它是一个结构体类型，<strong>用于配置GPIO引脚的属性</strong>。具体来说，它包含两个成员变量，</p><ul><li>第一个成员变量是<strong>GPIO的工作模式</strong>，这里我们使用了<code>kGPIO_DigitalOutput</code>模式，<strong>表示这个GPIO引脚是一个数字输出引脚</strong>；</li><li>第二个成员变量是<strong>GPIO的初始电平</strong>，这里我们使用了0，表示<strong>初始电平为低电平</strong>。</li></ul><p>这个led_config变量会在GPIO_PinInit函数中被使用，<strong>用于初始化LED灯的GPIO引脚</strong>。</p><h3 id="GPIO-PinInit-函数"><a href="#GPIO-PinInit-函数" class="headerlink" title="GPIO_PinInit 函数"></a>GPIO_PinInit 函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化GPIO引脚</span></span><br><span class="line">GPIO_PinInit(BOARD_LED_GPIO, BOARD_LED_GPIO_PIN, &amp;led_config);</span><br></pre></td></tr></tbody></table></figure><p>三个参数：</p><ul><li>BOARD_LED_GPIO ： 第一个参数是GPIO的端口号</li><li>BOARD_LED_GPIO_PIN ： 第二个参数是GPIO的引脚号</li><li>&amp;led_config ： 第三个参数是一个指向gpio_pin_config_t类型的指针，用于配置GPIO引脚的属性</li></ul><p>这个函数会根据传入的参数来初始化GPIO引脚，从而使得LED灯能够正常工作。</p><p>这里根据宏定义，使用的是红灯，查找<code>board.h</code>可以知道：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BOARD_LED_RED_GPIO</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOARD_LED_RED_GPIO GPIOC</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOARD_LED_RED_GPIO_PORT PORTC</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BOARD_LED_RED_GPIO_PIN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOARD_LED_RED_GPIO_PIN 1U</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// 红灯是GPIOC Pin1 绿灯是GPIOA Pin16 蓝灯是GPIOB Pin2</span></span><br></pre></td></tr></tbody></table></figure><p><code>GPIO_PinInit()</code>函数初始化了一个由板子使用的GPIO引脚。它接受参数：</p><ul><li>GPIO外设基址指针(GPIOA、GPIOB、GPIOC等)、</li><li>GPIO端口引脚号和</li><li>GPIO引脚配置指针。</li></ul><p>该函数<strong>根据配置将引脚设置为输入或输出引脚</strong>。</p><p>该函数首先检查配置指针是否不为空。<strong>然后它将标志设置为1。</strong></p><ul><li><p>如果引脚方向设置为<strong>数字输入，则函数在端口数据方向寄存器(PDDR)中清除引脚号处的位</strong>。（<strong>按位与上0</strong>）</p></li><li><p>如果引脚方向设置为数字输出，则函数使用<code>GPIO_PinWrite()</code>函数将输出逻辑值写入引脚，并在PDDR中设置引脚号处的位(<strong>按位或上1</strong>)。</p></li></ul><h3 id="GPIO-PinWrite-函数"><a href="#GPIO-PinWrite-函数" class="headerlink" title="GPIO_PinWrite()函数"></a>GPIO_PinWrite()函数</h3><p>关于 <code>GPIO_PinWrite()</code>函数：</p><p>用于设置GPIO的输出电平。函数的输入参数：包括GPIO的基地址、GPIO的引脚号以及输出电平。</p><p>函数的实现是通过设置GPIO的寄存器来实现的。</p><p>如果输出电平为0，则通过<code>PCOR</code>寄存器清除对应引脚的输出电平；如果输出电平为1，则通过<code>PSOR</code>寄存器设置对应引脚的输出电平。</p><h3 id="GPIO-PortToggle-函数"><a href="#GPIO-PortToggle-函数" class="headerlink" title="GPIO_PortToggle() 函数"></a>GPIO_PortToggle() 函数</h3><p>用来控制GPIO口输出，它的作用是<strong>将指定的GPIO口的指定引脚的电平翻转</strong>。在这个例子中，它被用来控制开发板上的LED灯的闪烁。</p><p>GPIO_PortToggle()函数的第一个参数是GPIO端口号，第二个参数是要翻转的引脚号。</p><p>在这个例子中，BOARD_LED_GPIO和BOARD_LED_GPIO_PIN分别定义了LED灯的GPIO端口号和引脚号。GPIO_PortToggle(BOARD_LED_GPIO, 1u &lt;&lt; BOARD_LED_GPIO_PIN)的作用是将LED灯的电平翻转。</p><p>其中<code>1u &lt;&lt; BOARD_LED_GPIO_PIN</code>是将1左移BOARD_LED_GPIO_PIN位，<strong>得到一个只有<code>BOARD_LED_GPIO_PIN</code>位为1的数，这个数表示要翻转的引脚</strong>。GPIO_PortToggle()函数会将这个数对应的引脚的电平翻转。</p><p><code>base-&gt;PTOR = mask;</code>通过配置<code>PTOR</code>寄存器设置引脚电平翻转。</p><h2 id="宏定义和原型函数"><a href="#宏定义和原型函数" class="headerlink" title="宏定义和原型函数"></a>宏定义和原型函数</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BOARD_LED_GPIO BOARD_LED_RED_GPIO</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOARD_LED_GPIO_PIN BOARD_LED_RED_GPIO_PIN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment"> * Prototypes</span></span><br><span class="line"><span class="comment"> ******************************************************************************/</span></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @brief delay a while.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment"> * Variables</span></span><br><span class="line"><span class="comment"> ******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment"> * Code</span></span><br><span class="line"><span class="comment"> ******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">800000</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">        __asm(<span class="string">"NOP"</span>); <span class="comment">/* delay */</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="delay函数"><a href="#delay函数" class="headerlink" title="delay函数"></a>delay函数</h3><p>delay函数中的for循环执行了<strong>800000次</strong>，每次循环都执行了一个<strong>空指令</strong><code>__asm("NOP")</code>，这个指令的作用是延迟一段时间。</p><p>具体来说，这个循环的执行时间取决于CPU的主频和循环次数，<strong>假设CPU主频为100MHz，那么这个循环的执行时间大约为8ms</strong>。因此，delay函数的作用是延迟一段时间，用于控制LED灯的闪烁频率。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="mtb-c"><a href="#mtb-c" class="headerlink" title="mtb.c"></a>mtb.c</h2><blockquote><p>这个文件是MTB初始化文件。MTB是Micro Trace Buffer的缩写，是一种用于调试的技术。</p></blockquote><p>MTB可以记录程序的执行过程，包括程序<u><em>计数器的值、寄存器的值、函数调用和返回</em></u>等信息。这个文件中的代码<strong>用于初始化MTB缓冲区</strong>。</p><ul><li>如果定义了<code>__MTB_DISABLE</code>，则不会创建MTB缓冲区。</li><li>如果没有定义<code>__MTB_BUFFER_SIZE</code>，则会<strong>提供一个小的默认缓冲区</strong>。</li><li>如果定义了<code>__MTB_RAM_BANK</code>，则<strong>会将MTB缓冲区放置在指定的RAM bank中</strong>。</li><li>如果没有定义<code>__MTB_RAM_BANK</code>，则会将MTB缓冲区放置在<strong>默认</strong>的RAM bank中。</li><li>如果<code>__MTB_BUFFER_SIZE</code>大于0，则会引入<code>cr_mtb_buffer.h</code>头文件，并将MTB缓冲区放置在<code>RAM bank</code>中。</li></ul><h2 id="semihost-hardfault-c"><a href="#semihost-hardfault-c" class="headerlink" title="semihost_hardfault.c"></a>semihost_hardfault.c</h2><blockquote><p>这个文件是提供硬故障处理程序的，以<strong>允许半主机代码在调试器未连接时不挂起应用程序</strong>。</p></blockquote><p>在应用程序中包含半主机操作（例如printf调用）的应用程序的一个问题是，<strong>当调试器未连接时，代码将无法正确执行。通常，这将显示为应用程序似乎只是挂起。</strong>这可能包括从复位运行应用程序或启动板子（已经在FLASH中存在应用程序），以及在调试会话终止后应用程序无法继续执行。</p><h1 id="总结点灯的流程"><a href="#总结点灯的流程" class="headerlink" title="总结点灯的流程"></a>总结点灯的流程</h1><ol><li>BOARD_InitPins();  <ol><li>里面有Port的时钟使能，<code>CLOCK_EnableClock(kCLOCK_PortA);</code></li><li>引脚复用  <code>PORT_SetPinMux(BOARD_INITPINS_myGreen_PORT, BOARD_INITPINS_myGreen_PIN, kPORT_MuxAsGpio);</code></li></ol></li><li>BOARD_BootClockRUN();  板子时钟RUN模式使能</li><li>BOARD_InitDebugConsole();   板子console debug初始化</li><li>GPIO_PinInit(BOARD_LED_GPIO0, BOARD_LED_GPIO_PIN0, &amp;led_config);   GPIO引脚初始化；</li><li>GPIO_PortToggle(BOARD_LED_GPIO0, 1u &lt;&lt; BOARD_LED_GPIO_PIN0);    GPIO端口高低电平切换</li></ol>]]></content>
    
    
    <summary type="html">KW38点灯大师哈哈哈.</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="KW38" scheme="https://dustofstars.github.io/categories/NXP/KW38/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
  </entry>
  
  <entry>
    <title>kw38_helloworld</title>
    <link href="https://dustofstars.github.io/NXP/KW38/kw38-helloworld/"/>
    <id>https://dustofstars.github.io/NXP/KW38/kw38-helloworld/</id>
    <published>2023-03-24T04:01:45.000Z</published>
    <updated>2023-03-24T04:01:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kw38-helloworld"><a href="#kw38-helloworld" class="headerlink" title="kw38_helloworld"></a>kw38_helloworld</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Init board hardware. */</span></span><br><span class="line">    BOARD_InitPins();</span><br><span class="line">    BOARD_BootClockRUN();</span><br><span class="line">    BOARD_InitDebugConsole();</span><br><span class="line"></span><br><span class="line">    PRINTF(<span class="string">"hello world.\r\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        ch = GETCHAR();</span><br><span class="line">        PUTCHAR(ch);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><h2 id="main功能"><a href="#main功能" class="headerlink" title="main功能"></a>main功能</h2><p>这段代码是一个简单的hello world程序，它的作用是在终端输出”hello world.”，并且可以接收终端输入的字符并将其输出。</p><p>在main函数中，首先调用了BOARD_InitPins()函数来初始化板子的引脚，然后调用了BOARD_BootClockRUN()函数来初始化时钟，最后调用了BOARD_InitDebugConsole()函数来初始化调试控制台。</p><p>接下来，使用PRINTF函数在终端输出”hello world.”，然后进入一个死循环，不断地接收终端输入的字符并将其输出，直到程序结束。</p><p>其中，GETCHAR函数用于接收终端输入的字符，PUTCHAR函数用于将字符输出到终端。</p><h2 id="main的函数调用"><a href="#main的函数调用" class="headerlink" title="main的函数调用"></a>main的函数调用</h2><p>这段代码调用了三个函数，分别是BOARD_InitPins()、BOARD_BootClockRUN()和BOARD_InitDebugConsole()。</p><ul><li>BOARD_InitPins()函数用于初始化板子的引脚，</li><li>BOARD_BootClockRUN()函数用于初始化时钟，</li><li>BOARD_InitDebugConsole()函数用于初始化调试控制台。</li></ul><p>在这个程序中，这三个函数的作用是为了确保程序能够正常运行，因为程序需要使用板子的引脚、时钟和调试控制台。</p><h2 id="main的包含头文件"><a href="#main的包含头文件" class="headerlink" title="main的包含头文件"></a>main的包含头文件</h2><p>这段代码include了以下几个文件：</p><ul><li>fsl_device_registers.h：包含了芯片的寄存器定义，用于访问芯片的寄存器。</li><li>fsl_debug_console.h：包含了调试控制台的相关函数，用于在终端输出和输入字符。</li><li>board.h：包含了板子的相关函数和宏定义，用于初始化板子的引脚和时钟。</li><li>pin_mux.h：包含了引脚的配置信息，用于初始化板子的引脚。</li><li>stdbool.h：包含了bool类型的定义，用于定义布尔类型的变量。</li><li>clock_config.h：包含了时钟的配置信息，用于初始化时钟。</li></ul><p>其中，fsl_device_registers.h、fsl_debug_console.h、board.h和pin_mux.h是MCUXpresso SDK提供的库文件，而stdbool.h和clock_config.h是标准C库文件。这些文件的作用是为了确保程序能够正常运行，因为程序需要使用芯片的寄存器、调试控制台、板子的引脚和时钟。</p><h2 id="pin-mux-h"><a href="#pin-mux-h" class="headerlink" title="pin_mux.h"></a>pin_mux.h</h2><p>这是一个头文件，用于使用 MCUXpresso 配置工具为微控制器配置引脚复用和电气特性。</p><p>它提供了一个函数来初始化微控制器使用的引脚，可以在启动期间调用。 该文件定义了用于配置引脚电气特性的宏常量 <code>SOPT5_LPUART0ODE_0b0</code>、<code>SOPT5_LPUART0RXSRC_0b0</code> 和 <code>SOPT5_LPUART0TXSRC_0b00</code>。 </p><p>头文件由包含保护 (<code>#ifndef _PIN_MUX_H_</code>) 保护，确保它在编译单元中仅包含一次。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SOPT5_LPUART0ODE_0b0 0x00u    <span class="comment">/*LPUART0开漏禁用*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOPT5_LPUART0RXSRC_0b0 0x00u  <span class="comment">/*LPUART0接收数据源选择：LPUART_RX pin */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOPT5_LPUART0TXSRC_0b00 0x00u <span class="comment">/*LPUART0发送数据源选择：LPUART_TX pin */</span></span></span><br></pre></td></tr></tbody></table></figure><p>声明了两个函数：</p><ul><li>void BOARD_InitPins(void);  配置引脚routing和可选引脚电气特性</li><li>void BOARD_InitBootPins(void);  初始化启动引脚；</li></ul><h2 id="pin-mux-c"><a href="#pin-mux-c" class="headerlink" title="pin_mux.c"></a>pin_mux.c</h2><h3 id="void-BOARD-IninPins-void"><a href="#void-BOARD-IninPins-void" class="headerlink" title="void BOARD_IninPins(void)"></a>void BOARD_IninPins(void)</h3><p>这段代码是来自项目中的“pin_mux.c”文件，该文件包含了MKW38A512微控制器的引脚配置函数。</p><p>所选代码块是函数“BOARD_InitPins()”，它配置了LPUART0外设的引脚路由和电气特性。</p><p>具体来说，它将</p><ol><li>使能PortC的时钟；</li><li>42号和43号引脚的引脚复用设置为LPUART0_RX和LPUART0_TX。</li><li>将LPUART0传输数据源设置为LPUART0_TX引脚，将LPUART0接收数据源设置为LPUART_RX引脚，并在LPUART0上禁用了开漏特性。</li></ol><p>该函数由“BOARD_InitBootPins()”调用，在引导过程中调用以初始化引脚。</p><h2 id="clock-config-c"><a href="#clock-config-c" class="headerlink" title="clock_config.c"></a>clock_config.c</h2><h3 id="void-BOARD-BootClockRUN-void"><a href="#void-BOARD-BootClockRUN-void" class="headerlink" title="void BOARD_BootClockRUN(void)"></a>void BOARD_BootClockRUN(void)</h3><p>这段代码是MKW38A512芯片的时钟配置代码，主要包括两个函数：BOARD_BootClockRUN和BOARD_BootClockVLPR。</p><p>这两个函数分别用于配置系统在RUN模式和VLPR模式下的时钟。在这两个函数中，主要使用了MCUXpresso Config Tools提供的时钟驱动函数来配置系统时钟。具体来说，这两个函数的主要步骤如下：</p><ol><li>BOARD_RfOscInit函数：<strong>初始化射频晶振，用于提供系统时钟的参考时钟</strong>。</li><li>CLOCK_SetSimSafeDivs函数：设置<strong>系统时钟分频器的初始值</strong>，以确保在时钟模式切换时，核心时钟、总线时钟、flexbus时钟和flash时钟都在允许的范围内。</li><li>BOARD_InitOsc0函数：初始化MCG OSC，用于提供系统时钟的参考时钟。</li><li>CLOCK_BootToFeeMode函数：<strong>将MCG模式设置为FEE模式</strong>，即FLL Engaged External模式，此时FLL时钟和外部参考时钟都被使能。</li><li>CLOCK_SetInternalRefClkConfig函数：配置<strong>内部参考时钟MCGIRCLK</strong>。</li><li>CLOCK_SetSimConfig函数：设置<strong>SIM模块的时钟配置</strong>。</li><li>SystemCoreClock变量：设置当前系统核心时钟的频率。</li></ol><p>其中，BOARD_BootClockRUN函数用于配置系统在RUN模式下的时钟，而BOARD_BootClockVLPR函数用于配置系统在VLPR模式下的时钟。</p><p>在这两个函数中，<strong>主要的区别在于MCG模式的设置不同，以及时钟分频器的设置不同</strong>。</p><ul><li>在RUN模式下，MCG模式被设置为<strong>FEE</strong>模式，时钟分频器的初始值为1，2，2，5，</li><li>而在VLPR模式下，MCG模式被设置为<strong>BLPI</strong>模式，时钟分频器的初始值为1，5，1，</li></ul><h2 id="board-c"><a href="#board-c" class="headerlink" title="board.c"></a>board.c</h2><h3 id="void-BOARD-InitDebugConsole-void"><a href="#void-BOARD-InitDebugConsole-void" class="headerlink" title="void BOARD_InitDebugConsole(void)"></a>void BOARD_InitDebugConsole(void)</h3><p>这段代码是初始化调试控制台的函数。在这个函数中，首先设置了<strong>LPUART0的时钟源为OSCERCLK</strong>，然后初始化了调试控制台。</p><p>调试控制台的初始化使用了MCUXpresso SDK提供的DbgConsole_Init函数，该函数需要传入调试控制台的实例、波特率、类型和时钟源频率等参数。在这个函数中，调试控制台的实例为BOARD_DEBUG_UART_INSTANCE，波特率为BOARD_DEBUG_UART_BAUDRATE，类型为BOARD_DEBUG_UART_TYPE，时钟源频率为uartClkSrcFreq。</p><h2 id="fsl-debug-console-c"><a href="#fsl-debug-console-c" class="headerlink" title="fsl_debug_console.c"></a>fsl_debug_console.c</h2><h3 id="int-DbgConsole-Printf-const-char-formatString-…"><a href="#int-DbgConsole-Printf-const-char-formatString-…" class="headerlink" title="int DbgConsole_Printf(const char *formatString, …)"></a>int DbgConsole_Printf(const char *formatString, …)</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* See fsl_debug_console.h for documentation of this function. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">DbgConsole_Printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *formatString, ...)</span></span><br><span class="line">{</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="type">int</span> logLength = <span class="number">0</span>, dbgResult = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> printBuf[DEBUG_CONSOLE_PRINTF_MAX_LOG_LEN] = {<span class="string">'\0'</span>};</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != g_serialHandle)</span><br><span class="line">    {</span><br><span class="line">        va_start(ap, formatString);</span><br><span class="line">        <span class="comment">/* format print log first */</span></span><br><span class="line">        logLength = StrFormatPrintf(formatString, ap, printBuf, DbgConsole_PrintCallback);</span><br><span class="line">        <span class="comment">/* print log */</span></span><br><span class="line">        dbgResult = DbgConsole_SendDataReliable((<span class="type">uint8_t</span> *)printBuf, (<span class="type">size_t</span>)logLength);</span><br><span class="line"></span><br><span class="line">        va_end(ap);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dbgResult;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这段代码是fsl_debug_console.c文件的一部分。该文件包含了调试控制台模块的实现。调试控制台模块提供了一组函数来初始化、去初始化、打印和从调试控制台读取数据。</p><p>所选代码是DbgConsole_Printf函数的实现。该函数用于将格式化数据打印到调试控制台。</p><blockquote><p>该函数接受<strong>一个格式字符串</strong>和<strong>一个可变数量的参数</strong>。格式字符串指定输出字符串的格式，参数是要格式化和打印的值。</p></blockquote><p>该函数首先使用StrFormatPrintf函数格式化输出字符串。该函数将格式字符串、可变参数和回调函数作为输入。<strong>回调函数用于输出格式化数据</strong>。在这种情况下，回调函数是DbgConsole_PrintCallback。</p><p>格式化输出字符串后，该函数使用DbgConsole_SendDataReliable函数将数据发送到调试控制台。该函数可靠地发送数据，这意味着它将重试发送数据，直到成功发送为止。</p><p>后缀代码包含了DbgConsole_Putchar和DbgConsole_Scanf函数的实现。DbgConsole_Putchar函数用于<strong>将单个字符打印到调试控制台</strong>。该函数只需调用DbgConsole_SendDataReliable函数并传递要打印的字符即可。</p><p>DbgConsole_Scanf函数用于从调试控制台读取格式化数据。该函数接受一个格式字符串和一个可变数量的参数。格式字符串指定输入数据的格式，参数是指向存储输入数据的变量的指针。</p><p>该函数首先使用DbgConsole_ReadLine<strong>函数读取一行输入</strong>。然后使用StrFormatScanf函数格式化输入数据，并将格式化数据存储在由参数指向的变量中。</p><p>总的来说，这些函数提供了一种方便的方式来与调试控制台交互，并打印和读取格式化数据。</p><h2 id="关于引脚的四种输出情况"><a href="#关于引脚的四种输出情况" class="headerlink" title="关于引脚的四种输出情况"></a>关于引脚的四种输出情况</h2><p>上拉 (Pull-up) 和下拉 (Pull-down) 是指在数字电路中使用电阻将输入或输出引脚连接到电源或地，以确保在没有输入信号的情况下，引脚保持在一个已知状态。具体来说，上拉是指将引脚连接到电源（通常是高电平），下拉是指将引脚连接到地（通常是低电平）。在某些情况下，还可以使用弱上拉或弱下拉，即使用较大阻值的电阻。</p><p>开漏 (Open-Drain) 和推挽 (Push-Pull) 是指输出引脚的驱动方式。<strong>开漏输出只能将引脚拉到低电平，而不能将其拉到高电平，而推挽输出可以将引脚驱动到高电平或低电平。</strong>在使用开漏输出时，还需要在输出引脚和电源之间连接一个上拉电阻，以确保输出引脚能够被拉到高电平。</p><p>开漏输出通常用于需要将多个设备连接到同一个总线上的情况，而推挽输出则更适用于需要直接驱动其他器件的情况。</p>]]></content>
    
    
    <summary type="html">KW38的最基础代码，从一个HelloWorld开始...</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="KW38" scheme="https://dustofstars.github.io/categories/NXP/KW38/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="KW38" scheme="https://dustofstars.github.io/tags/KW38/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式common</title>
    <link href="https://dustofstars.github.io/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80/%E5%B5%8C%E5%85%A5%E5%BC%8Fcommon/"/>
    <id>https://dustofstars.github.io/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80/%E5%B5%8C%E5%85%A5%E5%BC%8Fcommon/</id>
    <published>2023-03-21T08:47:42.000Z</published>
    <updated>2023-03-21T08:47:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="startup-c是做什么的？"><a href="#startup-c是做什么的？" class="headerlink" title="startup.c是做什么的？"></a>startup.c是做什么的？</h1><p>startup.c通常是指嵌入式系统中的启动代码，它的主要作用是<strong>初始化系统并启动应用程序</strong>。</p><p>在启动过程中，会进行一些初始化操作，如设置堆栈、复制数据段、清零BSS段、设置中断向量表等。此外，startup.c还会加载应用程序，将控制转移到应用程序的入口处，开始执行应用程序的功能。</p><p>因此，startup.c非常重要，涉及到整个系统的启动和运行。不同的嵌入式平台和芯片厂商会有不同的startup.c代码，但它们的基本逻辑和流程是类似的。</p><span id="more"></span><h1 id="启动文件为什么会比main先启动？"><a href="#启动文件为什么会比main先启动？" class="headerlink" title="启动文件为什么会比main先启动？"></a>启动文件为什么会比main先启动？</h1><p>这个问题总结起来就是CPU启动时根据外部boot引脚状态从(<strong>起始地址+0x4</strong>)地址加载数据，赋值给PC(<strong>执行程序寄存器，r15</strong>)，而编译器将<code>startup.s</code>文件中的<strong>ResetHander函数的地址编译到(起始地址+0x4)内部</strong>，所以startup.s被先调用。</p><p>详细的解释需要参考Cortex-M系列的知识，下面来详细说明。首先参考STM32F1x的手册2.4启动配置这句话</p><img src="https://pic1.zhimg.com/50/v2-2e5c249ab76e390a9e582c37e4b0aba3_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="1213" data-rawheight="119" class="origin_image zh-lightbox-thumb" width="1213" data-original="https://pic1.zhimg.com/v2-2e5c249ab76e390a9e582c37e4b0aba3_r.jpg?source=1940ef5c"><p>那么就可以理解从0x04地址执行代码，这是由芯片设计时规定的，至于如何实现就是集成电路相关的知识了，这里不在说明，那么就是第二个问题，ResetHander如何被编译到0x04偏移地址的，这就涉及中断向量表的知识，下面来自于&lt;Cortex-M3权威指南&gt;关于异常的说明章节。</p><img src="https://pic1.zhimg.com/50/v2-f20a9e9511c6df3a64db9be45b2a8710_720w.jpg?source=1940ef5c" data-caption="" data-size="normal" data-rawwidth="1289" data-rawheight="534" data-default-watermark-src="https://pic1.zhimg.com/50/v2-30a6353a8582f2c2b3aa1298f3ac59c3_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="1289" data-original="https://pica.zhimg.com/v2-f20a9e9511c6df3a64db9be45b2a8710_r.jpg?source=1940ef5c"><p>从上面可以看出，<strong>在0x04偏移地址中定位的就是复位向量</strong>，而在代码startup.s中，就可以看到</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__Vectors       DCD     __initial_sp               ; Top of Stack</span><br><span class="line">                DCD     Reset_Handler              ; Reset Handler</span><br><span class="line">                DCD     NMI_Handler                ; NMI Handler</span><br><span class="line">                ...</span><br><span class="line">__Vectors_End</span><br></pre></td></tr></tbody></table></figure><p>也就是说由内核特性和STM芯片的定义，<strong>上电时的入口地址一定是Reset_Handler</strong>，而Reset_Handler就放置在在启动文件startup.s中，这就是启动文件startup.s比main先调用的总的原因.</p><p>简略回答： startup比main更先调用，确实和编译器设置有关，但更多的是程序本来如此。</p><p>详细回答：背景知识程序的生成步骤一般分成四步 preprocess(.c) -&gt; compile(.S) -&gt; assemble (.o) -&gt; link，具体可阅读 The Four Stages of Compiling a C Program 。</p><p>Linker Script的基本知识： Simple Linker Script Example具体例子下面的截图是Atmel SAMD10D14AM的souce code，第一张是 Linker Script (samd10d14am_flash.ld)，第二张是 Startup file (startup_samd10.c)。接下来解释highlight部分的含义。</p><img src="https://picx.zhimg.com/50/v2-52138c1fa6536fabc081b364d8044619_720w.jpg?source=1940ef5c" data-size="normal" data-rawwidth="868" data-rawheight="477" data-default-watermark-src="https://pica.zhimg.com/50/v2-4afd7ce25c84fe1b9b95b959264292aa_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="868" data-original="https://pic1.zhimg.com/v2-52138c1fa6536fabc081b364d8044619_r.jpg?source=1940ef5c">Linker Script<img src="https://pic1.zhimg.com/50/v2-a571c5379d301d831a96446f8c56c10a_720w.jpg?source=1940ef5c" data-size="normal" data-rawwidth="790" data-rawheight="482" data-default-watermark-src="https://picx.zhimg.com/50/v2-4a734839eec7f0c9f8fb2cebee129d8e_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="790" data-original="https://picx.zhimg.com/v2-a571c5379d301d831a96446f8c56c10a_r.jpg?source=1940ef5c">Vector Table<p>Vectors就是所谓Exception Table。对于ARM处理器Cortex M系列，<strong>Table的第一条是Stack Pointer的地址，第二条就是最重要的ISR for reset的地址</strong>。</p><p>左边的Linker Script指定把 section(“.vector”) 放在生成程序的.text代码段，一般也就是flash的起始地址。从keyword MEMORY的定义来看，flash rom的起始地址是0x00000000，大小是0x00000800 (16K)，刚好符合官方文档的描述 <a href="https://web.eecs.umich.edu/~prabal/teaching/resources/eecs373/ARM_Cortex_AppNote179.pdf">https://web.eecs.umich.edu/~prabal/teaching/resources/eecs373/ARM_Cortex_AppNote179.pdf</a> </p><blockquote><p>1.1 Nested Vectored Interrupt Controller (NVIC)The initial stack pointer and the address of the reset handler must be located at 0x0 and 0x4 respectively. These values are then loaded into the appropriate CPU registers at reset.</p></blockquote><p><em><strong>Reset_Handler()这个ISR就是CPU power on或者reset后的第一个routine，里面会先做一些简单初始化，比如Intialize the C libray（这样我们才能在后头的代码里直接用strcpy()等常见函数），最后跳往我们最熟悉的main()。</strong></em></p><p>其余的ISR都是optional，可以留白，会自动被Dummy_Handler填充，因为keyword weak。结论启动文件startup比main()先启动，是因为程序的启动顺序就是这样的，**CPU power on / reset -&gt; Reset_Handler() -&gt; main()**。</p><h1 id="BSS段是做什么的？"><a href="#BSS段是做什么的？" class="headerlink" title="BSS段是做什么的？"></a>BSS段是做什么的？</h1><p>BSS段（Block Started by Symbol）是指<strong>程序中未被初始化的全局变量和静态变量所占用的一段内存空间</strong>。在程序加载运行时，操作系统会自动分配一块内存空间用于存放BSS段。</p><p><strong>BSS段中的变量被默认初始化为0</strong>，因此，在程序编写中不需要为它们显式地赋初值。BSS段对于节省内存空间和程序运行效率都有很大的帮助。这是因为，程序中的未初始化变量会在BSS段中被统一地设置为0，而不需要在程序中存储这些变量的具体值。这样，在程序执行过程中，<strong>BSS段所占空间可以被多次重用并动态分配，从而使得程序的内存利用率更高</strong>。</p><h1 id="RAM中的各个段"><a href="#RAM中的各个段" class="headerlink" title="RAM中的各个段"></a>RAM中的各个段</h1><h2 id="RAM内存"><a href="#RAM内存" class="headerlink" title="RAM内存"></a>RAM内存</h2><p>RAM内存包括：</p><ul><li>代码段（text）</li><li>数据段(data)</li><li>bss段</li><li>堆栈段（head stack）</li></ul><p><img src="/./%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9A%84common%E7%9F%A5%E8%AF%86/RAM%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.png" alt="RAM内存分区.png"></p><h2 id="编译器编译结果分析"><a href="#编译器编译结果分析" class="headerlink" title="编译器编译结果分析"></a>编译器编译结果分析</h2><p><img src="/./%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9A%84common%E7%9F%A5%E8%AF%86/%E7%BC%96%E8%AF%91%E7%BB%93%E6%9E%9C.png" alt="编译结果.png"></p><p>编译结果有代码段（text）、数据段(data)、bss段。</p><ul><li>代码段（.text）是可<strong>执行指令的集合</strong>；</li><li>数据段 (.data) 表示<strong>已经初始化不为0的存放在静态区的数据（全局 or 静态）</strong>。</li><li>.bss段 表示未初始化的或为0的存放在静态区的数据（全局 or 静态）。</li></ul><p>从可执行程序的角度来说，如果一个数据未被初始化，就不需要为其分配空间，所以.data 和.bss 的区别就是： <strong>.bss 并不占用可执行文件的大小，仅仅记录需要用多少空间来存储这些未初始化的数据，而不分配实际空间</strong>。</p><p>所以代码段（text）、数据段(data)这两者相加共同构成可执行文件的大小，dec也就是文件大小(hex也是文件大小，只不过是16进制表示的)。</p><h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><h3 id="堆-heap"><a href="#堆-heap" class="headerlink" title="堆 heap"></a>堆 heap</h3><p><strong>堆保存函数内部动态分配（malloc 或 new）的内存，是另外一种用来保存程序信息的数据结构。</strong>堆是先进先出（FIFO）数据结构。堆的地址空间是向上增加，即当堆上保存的数据越多，堆的地址越高。动态内存分配。注意：<strong>堆内存需要程序员手动管理内存，通常适用于较大的内存分配，如频繁的分配较小的内存，容易导致内存碎片化</strong>。</p><h3 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈 stack"></a>栈 stack</h3><p><strong>栈保存函数的局部变量（不包括 static 修饰的变量），参数以及返回值</strong>。是一种后进先出（LIFO）的数据结构。在调用函数或过程后，系统会清除栈上保存的局部变量、函数调用信息及其他信息。栈的另外一个重要特征是，它的地址空间 向下减少，即当栈上保存的数据越多，栈的地址越低。<strong>静态内存分配</strong>。</p><blockquote><p><em><strong>注意：由于栈的空间通常比较小，一般 linux 程序只有几 M，故局部变量，函数入参应该避免出现超大栈内存使用，比如超大结构体，数组等，避免出现 stack overflow。</strong></em></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th>段名</th><th>存储属性</th><th>内存分配</th></tr></thead><tbody><tr><td>代码段<br>.text</td><td>存放可执行程序的指令，存储态和运行态都有</td><td>静态</td></tr><tr><td>数据段<br>.data</td><td>存放已初始化（非零初始化的全局变量和静态局部变量）的数据，存储态和运行态都有</td><td>静态</td></tr><tr><td>bss段<br>.bss</td><td>存放未初始化（未初始化或者0初始化的全局变量和静态局部变量）的数据，存储态和运行态都有</td><td>静态</td></tr><tr><td>堆<br>heap</td><td>动态分配内存，需要通过malloc手动申请，free手动释放，适合大块内存。容易造成内存泄漏和内存碎片。运行态才有</td><td>动态</td></tr><tr><td>栈<br>stack</td><td>存放函数局部变量和参数以及返回值，函数返回后，由操作系统立即回收。栈空间不大，使用不当容易栈溢出。运行态才有</td><td>静态</td></tr></tbody></table><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;<span class="comment">//初始化的全局变量:保存在数据段</span></span><br><span class="line"><span class="type">char</span> *p1;<span class="comment">//未初始化的全局变量:保存在BSS段</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> b;<span class="comment">//未初始化的局部变量:保存在栈上</span></span><br><span class="line">    <span class="type">char</span> s[] = <span class="string">"abc"</span>;</span><br><span class="line">    <span class="comment">/* "abc"为字符串常量保存在常量区；数组保存在栈上，</span></span><br><span class="line"><span class="comment">    并将常量区的"abc\0"复制到该数组中。这个数组可以随意修改而不会有任何隐患，</span></span><br><span class="line"><span class="comment">    而"123"这个字符串依然会保留在静态区中。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">char</span> *p2;<span class="comment">//p2保存在栈上</span></span><br><span class="line">    <span class="type">char</span> *p3 = <span class="string">"123456"</span>;<span class="comment">//p3保存在栈上，"123456\0"保存在data区的read-only部分</span></span><br><span class="line">    <span class="comment">//注意：如果令p3[1] = 9; 则程序崩溃，指针可以访问但不允许改变常量区的内容</span></span><br><span class="line">    <span class="comment">/* 声明了一个指针p3并指向"123456\0"在静态区中的地址，事实上，p3应该声明为</span></span><br><span class="line"><span class="comment">    char const *，以免可以通过p3[i]='\n'这一类的语法去修改这个字符串的内容。如果这样做了，在支持“常量区”的系统中可能会导致异常，在“合并相同字符串”的编译方法下会导致其它地方的字符串常量古怪地发生变化。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> c = <span class="number">0</span>;<span class="comment">//初始化的静态局部变量:保存在数据区（数据段）</span></span><br><span class="line"> </span><br><span class="line">    p1 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">10</span>);<span class="comment">//分配的10字节区域保存在堆上</span></span><br><span class="line">    p2 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">20</span>);<span class="comment">//分配的20字节区域保存在堆上</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">strcpy</span>(p1, <span class="string">"123456"</span>);</span><br><span class="line">    <span class="comment">//"123456\0"放在常量区，编译器可能会将它与p3所指向"123456"优化成一个地方</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">了解嵌入式代码里面的一些common内容</summary>
    
    
    
    <category term="嵌入式基础" scheme="https://dustofstars.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="ARM" scheme="https://dustofstars.github.io/tags/ARM/"/>
    
  </entry>
  
  <entry>
    <title>代码解读之fsl_gpio</title>
    <link href="https://dustofstars.github.io/NXP/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8Bfsl-gpio/"/>
    <id>https://dustofstars.github.io/NXP/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8Bfsl-gpio/</id>
    <published>2023-03-21T06:22:40.000Z</published>
    <updated>2023-03-21T06:22:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="读fsl-gpio-c-和-fsl-gpio-h-代码"><a href="#读fsl-gpio-c-和-fsl-gpio-h-代码" class="headerlink" title="读fsl_gpio.c 和 fsl_gpio.h 代码"></a>读fsl_gpio.c 和 fsl_gpio.h 代码</h1><blockquote><p>使用kw38的win mcuxpresso版本 <code>SDK_2_6_615_FRDM-KW38_mcuxpresso_win</code></p></blockquote><span id="more"></span><h1 id="fsl-gpio-h"><a href="#fsl-gpio-h" class="headerlink" title="fsl_gpio.h"></a>fsl_gpio.h</h1><blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _FSL_GPIO_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _FSL_GPIO_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"fsl_common.h"</span></span></span><br></pre></td></tr></tbody></table></figure></blockquote><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="Part1-gpio-pin-direction-t-和-gpio-checker-attribute-t"><a href="#Part1-gpio-pin-direction-t-和-gpio-checker-attribute-t" class="headerlink" title="Part1 gpio_pin_direction_t 和 gpio_checker_attribute_t"></a>Part1 gpio_pin_direction_t 和 gpio_checker_attribute_t</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">gpio_pin_direction</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    kGPIO_DigitalInput  = <span class="number">0U</span>, <span class="comment">/*!&lt; Set current pin as digital input*/</span></span><br><span class="line">    kGPIO_DigitalOutput = <span class="number">1U</span>, <span class="comment">/*!&lt; Set current pin as digital output*/</span></span><br><span class="line">} <span class="type">gpio_pin_direction_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">gpio_checker_attribute</span>{</span></span><br><span class="line">}<span class="type">gpio_checker_attribute_t</span>;</span><br></pre></td></tr></tbody></table></figure><p><code>gpio_pin_direction_t</code> 确定Pin引脚方向，输入为0，输出为1。</p><p>GPIO 检查器属性用于某些具有 GPIO 属性检查器功能的 NXP 微控制器。此功能用于安全目的，<strong>根据访问属性检查是否允许访问 GPIO 引脚</strong>。</p><p><code>gpio_checker_attribute_t</code> 枚举定义了可以检查的可能属性。这些属性指定不同权限级别（用户非安全、用户安全和特权安全）的读取和写入权限。</p><p>另外还有一个属性值<code>kGPIO_IgnoreAttributeCheck</code>，表示忽略属性检查。</p><p>GPIO 检查器属性与 <code>GPIO_CheckAttribute()</code> 函数结合使用，<strong>以根据操作的属性检查是否允许 GPIO 引脚上的特定操作</strong>。</p><h3 id="Part2-gpio-pin-config-t-和-gpio-interrupt-config-t"><a href="#Part2-gpio-pin-config-t-和-gpio-interrupt-config-t" class="headerlink" title="Part2 gpio_pin_config_t 和 gpio_interrupt_config_t"></a>Part2 gpio_pin_config_t 和 gpio_interrupt_config_t</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">gpio_pin_config</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">gpio_pin_direction_t</span> pinDirection;</span><br><span class="line">    <span class="type">uint8_t</span> outputLogic; <span class="comment">/*!&lt; Set a default output logic, which has no use in input */</span></span><br><span class="line">} <span class="type">gpio_pin_config_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">gpio_interrupt_config</span>{</span></span><br><span class="line">} <span class="type">gpio_interrupt_config_t</span>;</span><br></pre></td></tr></tbody></table></figure><p>这是一个 C 语言代码片段，它定义了两个数据结构和一个枚举类型，用于在微控制器上配置通用输入/输出 (GPIO) 引脚。</p><ol><li><code>gpio_pin_config_t</code> 定义了 GPIO 引脚的配置参数，包括它的方向（输入或输出）和<strong>它的默认输出逻辑（如果它是一个输出引脚）</strong>。</li><li>第二个数据结构 <code>gpio_interrupt_config_t</code> 是有条件地定义的，具体取决于微控制器是否支持其 GPIO 引脚上的中断。如果是，则此结构定义中断生成条件的配置参数。</li><li>枚举类型 <code>gpio_interrupt_config_t</code> 定义了中断生成条件的可能值，例如在上升沿、下降沿、任一边沿或逻辑电平为高或低时启用中断。</li></ol><h2 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h2><h3 id="GPIO配置"><a href="#GPIO配置" class="headerlink" title="GPIO配置"></a>GPIO配置</h3><h3 id="Part1-GPIO-PinInit"><a href="#Part1-GPIO-PinInit" class="headerlink" title="Part1 GPIO_PinInit()"></a>Part1 GPIO_PinInit()</h3><p>这是名为 <code>GPIO_PinInit()</code> 的函数的代码片段，它是用于处理微控制器上的通用输入/输出 (GPIO) 引脚的更大驱动程序的一部分。该驱动程序提供一组函数<strong>来配置、读取和写入 GPIO 引脚</strong>。</p><p>函数 <code>GPIO_PinInit()</code> <strong>初始化板使用的 GPIO 引脚</strong>。它采用三个参数：</p><ul><li>GPIO 外设的基地址 GPIO peripheral base pointer (GPIOA, GPIOB, GPIOC, and so on.)</li><li>GPIO 端口的引脚号 GPIO port pin number</li><li>以及指向定义 GPIO 引脚配置的 gpio_pin_config_t 结构的指针 GPIO pin configuration pointer</li></ul><p>gpio_pin_config_t 结构包含两个字段：</p><ul><li>pinDirection：GPIO引脚的方向，可以设置为kGPIO_DigitalInput或kGPIO_DigitalOutput。</li><li>outputLogic：GPIO引脚的输出逻辑电平，仅在引脚配置为数字输出时适用。它可以设置为 0 或 1。</li></ul><p>函数 <code>GPIO_PinInit()</code> 使用 <code>gpio_pin_config_t</code> 结构中定义的配置初始化 GPIO 引脚。</p><h3 id="GPIO输入操作"><a href="#GPIO输入操作" class="headerlink" title="GPIO输入操作"></a>GPIO输入操作</h3><h3 id="Part2-静态函数-GPIO-PinWrite"><a href="#Part2-静态函数-GPIO-PinWrite" class="headerlink" title="Part2 静态函数 GPIO_PinWrite()"></a>Part2 静态函数 GPIO_PinWrite()</h3><p>这是名为 <code>GPIO_PinWrite()</code> 的函数的代码片段。</p><p>函数<code>GPIO_PinWrite()</code>将一个GPIO引脚的输出电平设置为逻辑1或逻辑0。它需要三个参数：</p><ul><li>GPIO外设的基址、</li><li>GPIO端口的引脚号、</li><li>GPIO引脚的输出电平.</li></ul><p>输出参数可以设置为 0 或 1 以指定 GPIO 引脚的输出逻辑电平。<strong>如果输出为 0，则相应的引脚输出设置为逻辑低电平，否则，如果输出为 1，则相应的引脚输出设置为逻辑高电平</strong>。</p><p>函数 GPIO_PinWrite() 使用<strong>按位操作</strong>来设置 GPIO 引脚的输出电平。如果输出参数为0，则使用左移操作清除GPIO端口输出清除寄存器（<strong>GPIOx_PCOR</strong>）中的相应位。否则，如果输出参数为 1，则使用左移操作设置 GPIO 端口输出设置寄存器 (<strong>GPIOx_PSOR</strong>) 中的相应位。</p><p>此代码是用 C 编程语言编写的，并假定微控制器具有 GPIO 寄存器的特定实现，例如分别用于清除和设置 GPIO 输出引脚的 PCOR 和 PSOR 寄存器。</p><h3 id="Part3-静态函数-GPIO-PortSet"><a href="#Part3-静态函数-GPIO-PortSet" class="headerlink" title="Part3 静态函数 GPIO_PortSet()"></a>Part3 静态函数 GPIO_PortSet()</h3><p>这是名为 GPIO_PortSet() 的函数的代码片段.</p><p>函数 <code>GPIO_PortSet()</code> <strong>将多个 GPIO 引脚的输出电平设置为逻辑 1</strong>。它有两个参数：</p><ul><li>GPIO 外设的基址, base GPIO peripheral base pointer (GPIOA, GPIOB, GPIOC, and so on.)</li><li>指定要设置哪些 GPIO 引脚的掩码。GPIO pin number macro</li></ul><p><strong>掩码参数是一个位掩码，指示要设置的引脚。掩码参数的每一位对应一个特定的 GPIO 引脚。如果某位设置为 1，则相应的 GPIO 引脚输出设置为逻辑高电平</strong>。</p><p>函数 <code>GPIO_PortSet()</code> 通过使用<strong>按位或</strong>运算写入 GPIO 端口输出设置寄存器 (<strong>GPIOx_PSOR</strong>)，将指定 GPIO 引脚的输出电平设置为逻辑 1。在执行按位或操作之前，将掩码参数的值左移以与 GPIO 端口输出设置寄存器的位位置对齐。</p><p>此代码是用 C 编程语言编写的，并假定微控制器具有 GPIO 寄存器的特定实现，例如用于设置 GPIO 输出引脚的 PSOR 寄存器。</p><h3 id="Part4-静态函数-GPIO-PortClear"><a href="#Part4-静态函数-GPIO-PortClear" class="headerlink" title="Part4 静态函数 GPIO_PortClear()"></a>Part4 静态函数 GPIO_PortClear()</h3><p>这是名为 <code>GPIO_PortClear()</code> 的函数的代码片段.</p><p>函数 <code>GPIO_PortClear()</code> <strong>将多个 GPIO 引脚的输出电平设置为逻辑 0</strong>。它有两个参数：</p><ul><li>GPIO 外设的基址</li><li>和指定要清除哪些 GPIO 引脚的掩码。</li></ul><p>掩码参数是一个位掩码，指示要清除哪些引脚。掩码参数的每一位对应一个特定的 GPIO 引脚。如果某位设置为0，则相应的 GPIO 引脚输出设置为逻辑低电平。</p><p>函数 <code>GPIO_PortClear()</code> 通过使用按位或运算写入 GPIO 端口输出清除寄存器 (<strong>GPIOx_PCOR</strong>)，将指定 GPIO 引脚的输出电平设置为逻辑 0。在执行按位或操作之前，将掩码参数的值左移以与 GPIO 端口输出清除寄存器的位位置对齐。</p><p>此代码是用 C 编程语言编写的，并假定微控制器具有 GPIO 寄存器的特定实现，例如用于清除 GPIO 输出引脚的 PCOR 寄存器。</p><h3 id="Part5-静态函数-GPIO-PortToggle"><a href="#Part5-静态函数-GPIO-PortToggle" class="headerlink" title="Part5 静态函数 GPIO_PortToggle()"></a>Part5 静态函数 GPIO_PortToggle()</h3><p>这是名为 <code>GPIO_PortToggle()</code> 的函数的代码片段。</p><p>函数 <code>GPIO_PortToggle()</code> <strong>反转多个 GPIO 引脚的当前输出逻辑</strong>。它有两个参数：</p><ul><li>GPIO 外设的基地址</li><li>和一个掩码，它指定要切换的 GPIO 引脚。</li></ul><p>掩码参数是一个位掩码，指示要切换的引脚。掩码参数的每一位对应一个特定的 GPIO 引脚。如果某位设置为 1，则相应的 GPIO 引脚输出逻辑反转，即如果设置为逻辑 1，则变为逻辑 0，反之亦然。</p><p>函数 <code>GPIO_PortToggle()</code> 通过使用<strong>按位或</strong>运算写入 GPIO 端口<strong>输出切换寄存器 (GPIOx_PTOR)</strong> 来反转指定 GPIO 引脚的输出逻辑。在执行按位或操作之前，掩码参数的值左移以与 GPIO 端口输出切换寄存器的位位置对齐。</p><p>此代码是用 C 编程语言编写的，并假定微控制器具有 GPIO 寄存器的特定实现，例如用于切换 GPIO 输出引脚的 PTOR 寄存器。</p><h3 id="GPIO输入操作-1"><a href="#GPIO输入操作-1" class="headerlink" title="GPIO输入操作"></a>GPIO输入操作</h3><h3 id="Part6-静态函数-GPIO-PinRead"><a href="#Part6-静态函数-GPIO-PinRead" class="headerlink" title="Part6 静态函数 GPIO_PinRead()"></a>Part6 静态函数 GPIO_PinRead()</h3><p>这是一个名为 <code>GPIO_PinRead()</code> 的函数的代码片段。</p><p>函数 <code>GPIO_PinRead()</code> <strong>读取单个 GPIO 引脚的当前输入值</strong>。它需要两个参数：GPIO外设的基地址和要读取的GPIO引脚的引脚号。</p><p>函数 <code>GPIO_PinRead()</code> 通过使用<strong>移位和与操作</strong>从 GPIO 端口输入数据寄存器 (<strong>GPIOx_PDIR</strong>) 读取来读取指定 GPIO 引脚的输入值。按位移位操作将 GPIO 端口输入数据寄存器的值右对齐，以与指定 GPIO 引脚的位位置对齐。 <em><strong>AND 运算会屏蔽除对应于指定 GPIO 引脚的位之外的所有位</strong></em>。</p><p>该函数将指定 GPIO 引脚的输入值作为single-bit值（0 或 1）返回。</p><p>此代码是用 C 编程语言编写的，并假定微控制器具有 GPIO 寄存器的特定实现，例如用于读取 GPIO 输入引脚的 PDIR 寄存器。</p><h3 id="GPIO中断"><a href="#GPIO中断" class="headerlink" title="GPIO中断"></a>GPIO中断</h3><h3 id="GPIO-PortGetInterruptFlags-和-GPIO-PortClearInterruptFlags"><a href="#GPIO-PortGetInterruptFlags-和-GPIO-PortClearInterruptFlags" class="headerlink" title="GPIO_PortGetInterruptFlags() 和 GPIO_PortClearInterruptFlags()"></a>GPIO_PortGetInterruptFlags() 和 GPIO_PortClearInterruptFlags()</h3><p>此代码提供了一个 API，用于配置和处理 GPIO 引脚上的中断。</p><p>前两个函数 <code>GPIO_PortGetInterruptFlags()</code> 和 <code>GPIO_PortClearInterruptFlags()</code> <strong>分别用于读取和清除 GPIO 端口中多个引脚的中断状态标志</strong>。 </p><p>base参数是指GPIO peripheral的基地址，mask参数是用来指定要对哪个GPIO引脚进行读或清除操作。</p><p>此语句似乎描述了与数字系统中的 DMA 请求或电平敏感中断相关联的标志的行为。</p><p>如果某个引脚被配置为生成 DMA 请求，则当<strong>请求的 DMA 传输完成时，相应的标志将自动清除</strong>。这意味着该标志指示 DMA 传输的状态，并在传输完成时重置。</p><p>另一方面，如果引脚未配置为生成 DMA 请求，则相应的标志将保持设置状态，<strong>直到将逻辑 1 写入该标志</strong>。这意味着该标志可用于指示与 DMA 无关的事件的发生，例如中断或数据传输。</p><p>最后，如果引脚被配置为电平敏感中断并且中断信号保持有效，则标志立即再次设置。此行为允许系统响应连续信号，例如按钮按下或传感器读数，而不会错过任何事件。</p><h3 id="GPIO-SetPinInterruptConfig-和-GPIO-GetPinsDMARequestFlags-GPIO-SetMultipleInterruptPinsConfig"><a href="#GPIO-SetPinInterruptConfig-和-GPIO-GetPinsDMARequestFlags-GPIO-SetMultipleInterruptPinsConfig" class="headerlink" title="GPIO_SetPinInterruptConfig() 和 GPIO_GetPinsDMARequestFlags() GPIO_SetMultipleInterruptPinsConfig()"></a>GPIO_SetPinInterruptConfig() 和 GPIO_GetPinsDMARequestFlags() GPIO_SetMultipleInterruptPinsConfig()</h3><p>其余函数是有条件的，取决于 GPIO 端口是否支持中断。如果支持中断，则 <code>GPIO_SetPinInterruptConfig()</code> 函数用于设置单个引脚的中断配置。 pin 参数指定 GPIO 引脚号，而 config 参数用于指定中断配置。</p><p><code>GPIO_SetPinInterruptConfig()</code> 函数用于<strong>读取多个引脚的 DMA 请求标志</strong>。 <code>GPIO_SetMultipleInterruptPinsConfig()</code> 函数<strong>用于同时设置多个引脚的中断配置</strong>。 mask 参数用于指定要为其设置中断配置的 GPIO 引脚，而 config 参数指定中断配置。</p><p><em>中断配置选项包括设置中断/DMA 请求、触发中断/DMA 请求的边沿类型、触发中断的逻辑电平以及输出触发模式</em>。</p><h3 id="GPIO-CheckAttributeBytes"><a href="#GPIO-CheckAttributeBytes" class="headerlink" title="GPIO_CheckAttributeBytes()"></a>GPIO_CheckAttributeBytes()</h3><p>此代码片段定义了一个名为 <code>GPIO_CheckAttributeBytes()</code> 的函数。该函数有两个参数：一个指向 GPIO 外设（基）的指针和一个名为 attribute 的 gpio_checker_attribute_t 参数。</p><p>该函数检查 GPIO 模块是否具有设备特定数量的数据端口，以及它是否支持属性检查器。如果满足这些条件，该函数将继续检查成功访问指定 GPIO 引脚（掩码）的 GPIO 编程模型所需的字节级属性。</p><p>属性参数是一个枚举，表示 GACR 中 4 个数据字节的属性控制值。字节级属性是使用小端数据约定定义的。</p><h3 id="fgpio-driver-快速GPIO"><a href="#fgpio-driver-快速GPIO" class="headerlink" title="fgpio_driver  快速GPIO"></a>fgpio_driver  快速GPIO</h3><h3 id="FGPIO-PortInit"><a href="#FGPIO-PortInit" class="headerlink" title="FGPIO_PortInit()"></a>FGPIO_PortInit()</h3><blockquote><p>此代码片段介绍了 FGPIO 功能，该功能仅在某些 Kinetis MCU 上受支持。 FGPIO 寄存器是 <code>IOPORT</code> 接口的别名，通过 IOPORT 接口的访问与任何指令获取并行发生，并在一个周期内完成。此内存映射称为 <code>FGPIO</code>。</p></blockquote><p>然后代码定义了一个名为 <code>FGPIO_PortInit()</code> 的函数，该函数将指向 FGPIO 外设（基）的指针作为其参数。此函数<strong>通过关闭其时钟来初始化 FGPIO 外设</strong>。</p><p><code>FGPIO_Type</code> 可能是表示 FGPIO 外设的结构的类型定义。特定的 FGPIO 外设用后缀（FGPIOA、FGPIOB、FGPIOC 等）表示，并且可能具有不同的配置和引脚映射。</p><p>还有一个条件预处理器指令，用于检查 <code>FSL_FEATURE_SOC_FGPIO_COUNT</code> 功能是否已定义和支持。如果不支持，则不会编译指令中的代码。</p><p>同样，还有另一个条件预处理器指令检查 <code>FSL_FEATURE_PCC_HAS_FGPIO_CLOCK_GATE_CONTROL</code> 功能是否已定义和支持。如果不支持，则不会编译指令中的代码。</p><p>总的来说，这段代码设置了 FGPIO 功能并提供了一个函数来初始化 FGPIO 外设。但是，如果没有关于如何使用此代码以及 FGPIO_Type 结构是什么样子的更多上下文，则很难提供更详细的分析。</p><h1 id="fsl-gpio-c"><a href="#fsl-gpio-c" class="headerlink" title="fsl_gpio.c"></a>fsl_gpio.c</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PORT_Type *<span class="type">const</span> s_portBases[] = PORT_BASE_PTRS;</span><br><span class="line"><span class="type">static</span> GPIO_Type *<span class="type">const</span> s_gpioBases[] = GPIO_BASE_PTRS;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">GPIO_GetInstance</span><span class="params">(GPIO_Type *base)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint32_t</span> instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Find the instance index from base address mappings. */</span></span><br><span class="line">    <span class="keyword">for</span> (instance = <span class="number">0</span>; instance &lt; ARRAY_SIZE(s_gpioBases); instance++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (s_gpioBases[instance] == base)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    assert(instance &lt; ARRAY_SIZE(s_gpioBases));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_PinInit</span><span class="params">(GPIO_Type *base, <span class="type">uint32_t</span> pin, <span class="type">const</span> <span class="type">gpio_pin_config_t</span> *config)</span></span><br><span class="line">{</span><br><span class="line">    assert(<span class="literal">NULL</span> != config);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> u32flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (config-&gt;pinDirection == kGPIO_DigitalInput)</span><br><span class="line">    {</span><br><span class="line">        base-&gt;PDDR &amp;= ~(u32flag &lt;&lt; pin);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        GPIO_PinWrite(base, pin, config-&gt;outputLogic);</span><br><span class="line">        base-&gt;PDDR |= (u32flag &lt;&lt; pin);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">GPIO_PortGetInterruptFlags</span><span class="params">(GPIO_Type *base)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint8_t</span> instance;</span><br><span class="line">    PORT_Type *portBase;</span><br><span class="line">    instance = (<span class="type">uint8_t</span>)GPIO_GetInstance(base);</span><br><span class="line">    portBase = s_portBases[instance];</span><br><span class="line">    <span class="keyword">return</span> portBase-&gt;ISFR;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_PortClearInterruptFlags</span><span class="params">(GPIO_Type *base, <span class="type">uint32_t</span> mask)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint8_t</span> instance;</span><br><span class="line">    PORT_Type *portBase;</span><br><span class="line">    instance       = (<span class="type">uint8_t</span>)GPIO_GetInstance(base);</span><br><span class="line">    portBase       = s_portBases[instance];</span><br><span class="line">    portBase-&gt;ISFR = mask;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_CheckAttributeBytes</span><span class="params">(GPIO_Type *base, <span class="type">gpio_checker_attribute_t</span> attribute)</span></span><br><span class="line">{</span><br><span class="line">    base-&gt;GACR = ((<span class="type">uint32_t</span>)attribute &lt;&lt; GPIO_GACR_ACB0_SHIFT) | ((<span class="type">uint32_t</span>)attribute &lt;&lt; GPIO_GACR_ACB1_SHIFT) |</span><br><span class="line">                 ((<span class="type">uint32_t</span>)attribute &lt;&lt; GPIO_GACR_ACB2_SHIFT) | ((<span class="type">uint32_t</span>)attribute &lt;&lt; GPIO_GACR_ACB3_SHIFT);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">解读NXP的fsl_gpio代码（.c &amp; .h）</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="嵌入式基础" scheme="https://dustofstars.github.io/categories/NXP/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="GPIO" scheme="https://dustofstars.github.io/tags/GPIO/"/>
    
  </entry>
  
  <entry>
    <title>代码解读之GPIO_Adapter</title>
    <link href="https://dustofstars.github.io/NXP/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8Bgpio-adapter/"/>
    <id>https://dustofstars.github.io/NXP/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80/%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8Bgpio-adapter/</id>
    <published>2023-03-20T07:58:38.000Z</published>
    <updated>2023-03-20T07:58:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="读fsl-adapter-gpio-c-和-h-代码"><a href="#读fsl-adapter-gpio-c-和-h-代码" class="headerlink" title="读fsl_adapter_gpio.c 和 .h 代码"></a>读fsl_adapter_gpio.c 和 .h 代码</h1><h2 id="1-fsl-adapter-gpio-c"><a href="#1-fsl-adapter-gpio-c" class="headerlink" title="1. fsl_adapter_gpio.c"></a>1. fsl_adapter_gpio.c</h2><p>这个代码是一个包含头文件并定义与MCU中的GPIO（通用输入/输出）功能相关的一些宏的 C 源文件。它是为 NXP 公司制造的特定MCU编写的。</p><span id="more"></span><p>该文件包含以下头文件：</p><ul><li>fsl_device_registers.h：包含设备特定的寄存器定义。</li><li>fsl_gpio.h：提供用于GPIO操作的API函数。</li><li>fsl_port.h：提供用于PORT（端口控制和中断）操作的API函数。</li><li>fsl_adapter_gpio.h：提供用于GPIO操作的适配器功能。该文件还定义了一个组件ID，<code>tools</code>使用它。</li></ul><p>该代码定义了两个宏：</p><ul><li>HAL_GPIO_CLZ(x)：计算32位数字x中前导零的数量，该数量用于确定GPIO引脚的bit位置。此宏的实现取决于用于编译代码的工具链。</li><li>HAL_GPIO_BSR(x)：根据GPIO引脚掩码的值计算GPIO引脚的bit位置。此宏使用 HAL_GPIO_CLZ(x) 宏计算掩码中前导零的数量，然后从31中减去结果（因为GPIO引脚编号是从LSB到MSB进行计数）。</li></ul><h3 id="1-1-结构体hal-gpio-pin-t-和-hal-gpio-state-t"><a href="#1-1-结构体hal-gpio-pin-t-和-hal-gpio-state-t" class="headerlink" title="1.1 结构体hal_gpio_pin_t 和 hal_gpio_state_t"></a>1.1 结构体<code>hal_gpio_pin_t</code> 和 <code>hal_gpio_state_t</code></h3><p>这些结构体定义了单片机中GPIO引脚的引脚配置和状态。</p><p><code>hal_gpio_pin_t</code>结构体用于配置GPIO引脚的属性，具有以下字段：</p><ul><li>port：一个整数值（0-7），指定引脚的PORT编号。</li><li>reserved：值为0的位域，用于填充。</li><li>pin：一个整数值（0-31），指定指定PORT内的引脚编号。</li><li>direction：一个整数值（0或1），<strong>指定引脚的方向（输入或输出）</strong>。</li><li>trigger：一个整数值（0-7），<strong>指定在引脚上启用中断时的触发条件</strong>。</li><li>reserved2：值为0的位域，用于填充。</li></ul><p><code>hal_gpio_state_t</code>结构体用于存储GPIO引脚的状态，具有以下字段：</p><ul><li>next：指向链表中下一个元素的指针。</li><li>callback：<strong>指向回调函数的函数指针，当引脚上的中断被触发时将执行该函数</strong>。</li><li>callbackParam：指向<strong>将传递给回调函数的数据的指针</strong>。</li><li>direction：一个整数值（0或1），指定引脚的方向（输入或输出）。</li><li>level：一个整数值（0或1），指定引脚的当前逻辑电平。</li><li>port：一个整数值（0-7），指定引脚的PORT编号。</li><li>pin：一个整数值（0-31），指定指定PORT内的引脚编号。</li><li>trigger：一个整数值（0-7），指定在引脚上启用中断时的触发条件。</li></ul><h3 id="1-2-静态变量-static-GPIO-Type-const-s-GpioPort-和-static-hal-gpio-state-t-s-GpioHead"><a href="#1-2-静态变量-static-GPIO-Type-const-s-GpioPort-和-static-hal-gpio-state-t-s-GpioHead" class="headerlink" title="1.2 静态变量 static GPIO_Type *const s_GpioPort[] 和 static hal_gpio_state_t *s_GpioHead;"></a>1.2 静态变量 static GPIO_Type <code>*const s_GpioPort[]</code> 和 static hal_gpio_state_t <code>*s_GpioHead</code>;</h3><p>这个部分定义了函数的原型，这些函数将在源文件中使用，但在这种情况下没有原型。</p><p>该部分还定义了一些静态变量：</p><ul><li><p>s_GpioPort：<u>指向GPIO_Type结构体指针的数组。每个指针对应微控制器中的一个GPIO端口</u>。</p></li><li><p>s_GpioHead：指向<code>hal_gpio_state_t</code>结构体链表的头部的指针。<strong>此链表用于跟踪MCU中所有GPIO引脚的状态</strong>。</p></li></ul><h3 id="1-3-函数-static-void-HAL-GpioInterruptHandle-uint8-t-port"><a href="#1-3-函数-static-void-HAL-GpioInterruptHandle-uint8-t-port" class="headerlink" title="1.3 函数 static void HAL_GpioInterruptHandle(uint8_t port)"></a>1.3 函数 static void HAL_GpioInterruptHandle(uint8_t port)</h3><p>这段代码片段是一个GPIO（通用输入/输出）驱动程序的C实现。代码定义了两个数据结构，<code>hal_gpio_pin_t</code>和<code>hal_gpio_state_t</code>，它们分别<strong>包含有关引脚配置和状态的信息</strong>。代码还定义了几个函数<strong>来处理中断和添加/删除GPIO状态节点的链接列表</strong>。</p><ul><li><p><code>HAL_GpioInterruptHandle</code>函数：==通过迭代GPIO状态节点的链表并检查指定port上的任何pin是否触发了中断来处理GPIO中断。如果引脚发生中断，则该函数执行与该引脚相关联的回调函数==。</p></li><li><p><code>HAL_GpioConflictSearch</code>函数：搜索GPIO状态节点的链表，**<u>以检查引脚是否与已注册的引脚冲突</u>**。仅当定义了<code>HAL_GPIO_CONFLICT_CHECK_ENABLE</code>宏并将其设置为大于零的值时，才使用此函数。</p></li><li><p><code>HAL_GpioAddItem</code>函数：将新的GPIO状态节点添加到链接列表中。该函数首先检查新节点是否与已注册的引脚发生冲突，然后再将其添加到列表中。</p></li><li><p><code>HAL_GpioRemoveItem</code>函数：从链接列表中删除GPIO状态节点。该函数通过遍历列表以查找指定的节点并将其删除。</p></li></ul><p>总的来说，这段代码片段提供了GPIO驱动程序的基本实现，可用于配置和控制微控制器上的GPIO引脚。</p><p>这是<code>HAL_GpioInterruptHandle</code>函数的函数实现，该函数==负责处理GPIO中断==。</p><ol><li><p>该函数接受一个参数<code>port</code>，该参数是发生中断的端口号。该函数首先遍历GPIO引脚状态结构的链表，以找到与端口号相对应的结构。如果找不到一个合适的结构，则函数将简单地返回。</p></li><li><p>接下来，该函数使用<code>GPIO_GpioGetInterruptFlags</code>或<code>GPIO_PortGetInterruptFlags</code>函数**<u>检索在指定端口上发生的引脚中断的集合</u><strong>，具体取决于芯片是否具有每个引脚的个别GPIO中断标志。然后，</strong>该函数清除引发中断的引脚的中断标志**。</p></li><li><p>然后，该函数再次遍历GPIO引脚状态结构的链表，这次检查每个结构以查看它是否对应于触发中断的引脚之一。如果找到匹配项，则函数调用与引脚关联的回调函数来处理中断。</p></li><li><p>最后，该函数通过清除刚刚处理的引脚的中断标志来更新触发中断的引脚中断集。如果没有更多的中断需要处理，该函数将返回。</p></li></ol><h3 id="1-4-函数-static-hal-gpio-status-t-HAL-GpioConflictSearch-hal-gpio-state-t-head-uint8-t-port-uint8-t-pin"><a href="#1-4-函数-static-hal-gpio-status-t-HAL-GpioConflictSearch-hal-gpio-state-t-head-uint8-t-port-uint8-t-pin" class="headerlink" title="1.4 函数 static hal_gpio_status_t HAL_GpioConflictSearch(hal_gpio_state_t *head, uint8_t port, uint8_t pin)"></a>1.4 函数 static hal_gpio_status_t HAL_GpioConflictSearch(hal_gpio_state_t *head, uint8_t port, uint8_t pin)</h3><p>这段代码定义了一个函数<code>HAL_GpioConflictSearch</code>，它通过遍历<code>hal_gpio_state_t</code>结构体的链表来**<u>查找指定的端口和引脚与链表中现有的端口和引脚是否有冲突</u>**。</p><ol><li><p>该函数需要链表的头部（head）、端口号（port）和引脚号（pin）作为输入。</p></li><li><p>然后，它使用while循环遍历链表，检查是否有<code>hal_gpio_state_t</code>结构体的端口和引脚与输入的相同。</p></li><li><p>如果找到匹配的<code>hal_gpio_state_t</code>结构体，则该函数返回<code>kStatus_HAL_GpioPinConflict</code>，表示存在冲突。如果没有找到匹配的结构体，则函数返回<code>kStatus_HAL_GpioSuccess</code>，表示不存在冲突。</p></li></ol><p>当预处理宏<code>HAL_GPIO_CONFLICT_CHECK_ENABLE</code>被定义且其值大于零时，才会编译此函数。</p><p>预处理指令，用于检查宏<code>HAL_GPIO_CONFLICT_CHECK_ENABLE</code>是否被定义，并且其值大于0。</p><p>如果该宏被定义并且其值大于0，那么<code>#if</code>和<code>#endif</code>语句中的代码将会被编译，否则将被跳过。</p><h3 id="1-5-函数-static-hal-gpio-status-t-HAL-GpioAddItem-hal-gpio-state-t-head-hal-gpio-state-t-node"><a href="#1-5-函数-static-hal-gpio-status-t-HAL-GpioAddItem-hal-gpio-state-t-head-hal-gpio-state-t-node" class="headerlink" title="1.5 函数 static hal_gpio_status_t HAL_GpioAddItem(hal_gpio_state_t **head, hal_gpio_state_t *node)"></a>1.5 函数 static hal_gpio_status_t HAL_GpioAddItem(hal_gpio_state_t **head, hal_gpio_state_t *node)</h3><p>这个函数**<u>将一个新的 GPIO 引脚添加到 GPIO 引脚的链表中</u>**。它把链表头的指针和要添加的新 GPIO 引脚的指针作为输入参数。</p><p>该函数<strong>首先禁用全局中断</strong>，然后<strong>检查链表是否为空</strong>。</p><ol><li>如果它是空的，新的 GPIO 引脚将添加为链表的第一个元素。</li><li>否则，函数通过搜索链表来检查新的 GPIO 引脚是否与任何现有 GPIO 引脚冲突。</li><li>如果找到冲突，函数会重新启用全局中断并返回指示 GPIO 引脚冲突的错误状态。</li><li>如果没有发现冲突，则在链接列表的末尾添加新的 GPIO 引脚，并返回成功状态。</li><li>最后，在返回之前，该函数启用全局中断。</li></ol><h3 id="1-6-函数-static-hal-gpio-status-t-HAL-GpioRemoveItem-hal-gpio-state-t-head-hal-gpio-state-t-node"><a href="#1-6-函数-static-hal-gpio-status-t-HAL-GpioRemoveItem-hal-gpio-state-t-head-hal-gpio-state-t-node" class="headerlink" title="1.6 函数 static hal_gpio_status_t HAL_GpioRemoveItem(hal_gpio_state_t **head, hal_gpio_state_t *node)"></a>1.6 函数 static hal_gpio_status_t HAL_GpioRemoveItem(hal_gpio_state_t **head, hal_gpio_state_t *node)</h3><p>此函数从 GPIO 引脚的链表中移除一个节点。它以列表的头<code>**head</code>和要移除的节点 <code>*node</code>作为输入，二者都是指向 <code>hal_gpio_state_t</code> 结构的指针。</p><p>该函数通过使用 <code>DisableGlobalIRQ() </code>函数<strong>禁用中断</strong>并将 <code>PRIMASK</code> 寄存器的值存储在 <code>regPrimask</code> 中来启动。然后它使用 while 循环<strong>遍历列表，查找要删除的节点</strong>。一旦找到，它会更新指针以从列表中删除节点。如果要移除的节点是列表的头，则会更新 *head。</p><p>最后，该函数使用 <code>EnableGlobalIRQ(regPrimask)</code> <strong>启用中断，并返回</strong> <code>kStatus_HAL_GpioSuccess</code>。</p><h3 id="1-7-GPIOX-INT1-IRQHandler-和-GPIOX-INT0-IRQHandler"><a href="#1-7-GPIOX-INT1-IRQHandler-和-GPIOX-INT0-IRQHandler" class="headerlink" title="1.7 GPIOX_INT1_IRQHandler() 和 GPIOX_INT0_IRQHandler()"></a>1.7 GPIOX_INT1_IRQHandler() 和 GPIOX_INT0_IRQHandler()</h3><p>这些是设备上每个GPIO端口的中断处理程序函数。</p><p>它们是为了没有专门为每个GPIO端口提供中断处理程序的平台而实现的，这由 <code>FSL_FEATURE_PORT_HAS_NO_INTERRUPT</code> 宏指示。</p><p>对于每个GPIO端口，定义了两个中断处理程序，<code>GPIOX_INT0_IRQHandler()</code>和<code>GPIOX_INT1_IRQHandler()</code>。</p><ul><li><code>GPIOX_INT0_IRQHandler()</code>函数是端口的<strong>实际中断处理程序</strong>，并调用<code>HAL_GpioInterruptHandle()</code>函数来处理中断。</li><li><code>GPIOX_INT1_IRQHandler()</code>函数是<strong>中断优先级配置的占位符</strong>，它只调用<code>GPIOX_INT0_IRQHandler()</code>函数。</li></ul><p><code>SDK_ISR_EXIT_BARRIER</code>宏用于<strong>在退出中断处理程序之前添加障碍，以确保在从中断返回之前完成所有存储器访问</strong>。</p><h3 id="1-8-PORTX-IRQHandler"><a href="#1-8-PORTX-IRQHandler" class="headerlink" title="1.8 PORTX_IRQHandler()"></a>1.8 PORTX_IRQHandler()</h3><p>这是一系列针对 GPIO 端口的中断处理函数。</p><p>根据所使用的特定微控制器，这些功能将以前缀 GPIO 或 PORT 命名。 如果微控制器具有 GPIO 的“无中断”<code>FSL_FEATURE_PORT_HAS_NO_INTERRUPT</code>功能，则中断处理程序将使用 GPIO 前缀并具有类似 <code>GPIOA_INT0_IRQHandler()</code> 的名称。否则，中断处理程序将使用 PORT 前缀并具有类似于 <code>PORTA_IRQHandler() </code>的名称。 </p><p>每个中断处理函数负责处理特定 GPIO 端口的中断。例如，<code>GPIOA_INT0_IRQHandler() </code>处理端口 A、引脚 0 的中断。 在每个中断处理函数中，<code>HAL_GpioInterruptHandle() </code><strong>以端口号作为参数被调用</strong>。此函数负责查找触发中断的引脚并调用任何已注册的回调。 **<u>==<code>SDK_ISR_EXIT_BARRIER</code> 宏用于标记中断处理函数的结束。这是一种防止编译器在从中断返回后生成代码的方法，这可能会导致系统堆栈或中断处理出现问题==</u>**。</p><h3 id="1-9-函数-void-HAL-GpioPreInit-void"><a href="#1-9-函数-void-HAL-GpioPreInit-void" class="headerlink" title="1.9 函数 void HAL_GpioPreInit(void)"></a>1.9 函数 void HAL_GpioPreInit(void)</h3><p>函数 <code>HAL_GpioPreInit()</code> 将全局指针 <code>s_GpioHead</code> 初始化为 <code>NULL</code>，用作包含每个已配置 GPIO 引脚的 GPIO 状态信息的链表的头部。</p><p>此函数通常在 GPIO 驱动程序初始化期间调用，**<u>在添加或配置任何 GPIO 引脚之前</u>**。</p><h3 id="1-10-函数-hal-gpio-status-t-HAL-GpioInit-hal-gpio-handle-t-gpioHandle-hal-gpio-pin-config-t-pinConfig"><a href="#1-10-函数-hal-gpio-status-t-HAL-GpioInit-hal-gpio-handle-t-gpioHandle-hal-gpio-pin-config-t-pinConfig" class="headerlink" title="1.10 函数 hal_gpio_status_t HAL_GpioInit(hal_gpio_handle_t gpioHandle, hal_gpio_pin_config_t *pinConfig)"></a>1.10 函数 hal_gpio_status_t HAL_GpioInit(hal_gpio_handle_t gpioHandle, hal_gpio_pin_config_t *pinConfig)</h3><p>**<u>这是用提供的配置，初始化GPIO引脚的功能实现</u>**。</p><p><em><u><strong>该函数使用<code>gpioHandle</code>参数表示GPIO引脚的句柄和使用<code>pinConfig</code>参数表示引脚的配置的指针。</strong></u></em></p><p>该函数首先断言<code>gpioHandle</code>和<code>pinConfig</code>参数不为null，并且<code>gpioHandle</code>参数的大小至少与<code>hal_gpio_state_t</code>结构的大小一样。然后将<code>gpioHandle</code>参数转换为指向<code>hal_gpio_state_t</code>结构的指针<code>gpioState</code>，该结构包含有关GPIO引脚状态的信息。</p><ol><li><p>如果启用冲突检查<code>HAL_GPIO_CONFLICT_CHECK_ENABLE</code>，则该函数搜索GPIO引脚的链表，以确保指定端口和引脚没有冲突。如果发现冲突，则该函数返回<code>kStatus_HAL_GpioPinConflict</code>。</p></li><li><p>然后，该函数使用<code>HAL_GpioAddItem</code>函数将GPIO引脚添加到GPIO引脚的链表中，<u><strong>并使用<code>GPIO_PinInit</code>函数设置GPIO方向和其他配置选项</strong></u>。</p></li><li><p>最后，如果初始化成功，该函数返回<code>kStatus_HAL_GpioSuccess</code>。</p></li></ol><h3 id="1-11-函数-hal-gpio-status-t-HAL-GpioDeinit-hal-gpio-handle-t-gpioHandle"><a href="#1-11-函数-hal-gpio-status-t-HAL-GpioDeinit-hal-gpio-handle-t-gpioHandle" class="headerlink" title="1.11 函数 hal_gpio_status_t HAL_GpioDeinit(hal_gpio_handle_t gpioHandle)"></a>1.11 函数 hal_gpio_status_t HAL_GpioDeinit(hal_gpio_handle_t gpioHandle)</h3><p>此函数负责**==取消初始化 GPIO 引脚==**。</p><p>它接收 GPIO 引脚的句柄，该句柄是在使用 <code>HAL_GpioInit</code> 函数初始化引脚时获得的。 </p><ol><li>首先，该函数使用断言检查输入 <code>gpioHandle</code> 是否不为 <code>NULL</code>。 </li><li>接下来，它使用 <code>gpioHandle</code> 获取指向 <code>GPIO</code> 状态结构的指针。</li><li>然后，如果 GPIO 引脚配置为输入引脚，则该函数通过使用 <code>kHAL_GpioInterruptDisable</code> 参数调用 <code>HAL_GpioSetTriggerMode</code> 来**<u>==禁用其中断触发模式==</u>**。 </li><li>最后，函数使用<code>HAL_GpioRemoveItem</code>函数从链表<code>s_GpioHead</code>中移除<code>GPIO管脚状态</code>，返回<code>kStatus_HAL_GpioSuccess</code>表示操作成功。</li></ol><h3 id="1-12-函数-hal-gpio-status-t-HAL-GpioGetInput-hal-gpio-handle-t-gpioHandle-uint8-t-pinState"><a href="#1-12-函数-hal-gpio-status-t-HAL-GpioGetInput-hal-gpio-handle-t-gpioHandle-uint8-t-pinState" class="headerlink" title="1.12 函数 hal_gpio_status_t HAL_GpioGetInput(hal_gpio_handle_t gpioHandle, uint8_t *pinState)"></a>1.12 函数 hal_gpio_status_t HAL_GpioGetInput(hal_gpio_handle_t gpioHandle, uint8_t *pinState)</h3><p>**<u>==此函数获取配置为输入的 GPIO 引脚的当前状态==</u>**。</p><p>它需要一个 GPIO 引脚的句柄（表示为 <code>hal_gpio_handle_t</code> 类型）和一个指向变量的指针来<strong>存储引脚状态</strong>。 </p><p>在函数内部，它首先断言 gpioHandle 和 pinState 参数不为 NULL。**<u>==然后它将 gpioHandle 转换为 hal_gpio_state_t 类型并使用 <code>GPIO_PinRead</code> 函数读取引脚状态。 GPIO_PinRead函数返回一个uint32_t类型，转换为uint8_t类型存储在<code>pinState</code>变量中。==</u>**最后函数返回kStatus_HAL_GpioSuccess表示操作成功。</p><h3 id="1-13-函数-hal-gpio-status-t-HAL-GpioSetOutput-hal-gpio-handle-t-gpioHandle-uint8-t-pinState"><a href="#1-13-函数-hal-gpio-status-t-HAL-GpioSetOutput-hal-gpio-handle-t-gpioHandle-uint8-t-pinState" class="headerlink" title="1.13 函数 hal_gpio_status_t HAL_GpioSetOutput(hal_gpio_handle_t gpioHandle, uint8_t pinState)"></a>1.13 函数 hal_gpio_status_t HAL_GpioSetOutput(hal_gpio_handle_t gpioHandle, uint8_t pinState)</h3><p>**<u>此函数设置 GPIO 引脚的输出状态</u>**。</p><p>它将要配置的 GPIO 引脚的句柄和<strong>指定要设置的输出状态（高电平或低电平）的值作为输入</strong>。 </p><p>该函数首先检查 GPIO 句柄是否为 NULL。然后它将句柄转换为 hal_gpio_state_t 指针并使用它来获取 GPIO 端口和引脚号。</p><p>最后，它使用 <code>GPIO_PinWrite</code> 函数设置 GPIO 引脚的输出状态，**<u>该函数将 GPIO 端口、引脚号和输出值作为输入</u>**。 该函数返回一个状态代码以指示操作是否成功。</p><h3 id="1-14-函数-hal-gpio-status-t-HAL-GpioInstallCallback-hal-gpio-handle-t-gpioHandle，-hal-gpio-callback-t-callback-void-callbackParam"><a href="#1-14-函数-hal-gpio-status-t-HAL-GpioInstallCallback-hal-gpio-handle-t-gpioHandle，-hal-gpio-callback-t-callback-void-callbackParam" class="headerlink" title="1.14 函数 hal_gpio_status_t HAL_GpioInstallCallback(hal_gpio_handle_t gpioHandle， hal_gpio_callback_t callback, void *callbackParam)"></a>1.14 函数 hal_gpio_status_t HAL_GpioInstallCallback(hal_gpio_handle_t gpioHandle， hal_gpio_callback_t callback, void *callbackParam)</h3><p>**<u>==此函数将回调函数及其关联参数安装到给定句柄指定的 GPIO 引脚==</u>**。 </p><p>该函数接受三个参数： </p><ul><li><code>gpioHandle</code>：<u>将要安装其回调函数的 GPIO 引脚</u>的句柄。 </li><li><code>callback</code>：指向将要安装的回调函数的<u>函数指针</u>。 </li><li><code>callbackParam</code>：指向<u>将要传递给回调函数的参数</u>的空指针。</li></ul><p>该函数首先断言 gpioHandle 不为 NULL。然后它将句柄转换为 <code>hal_gpio_state_t</code> 指针，**<u>并将 hal_gpio_state_t 结构的 <code>callbackParam</code> 和 <code>callback</code> 字段分别设置为 callbackParam 和 callback 的值。</u>**</p><p>最后，该函数返回 kStatus_HAL_GpioSuccess。 </p><p>安装回调函数后，<u><em>当在 GPIO 引脚上触发中断时，GPIO 驱动程序可以调用它</em></u>。 </p><p>GPIO 驱动在回调函数被调用时会将 <code>callbackParam</code> 参数传给回调函数。</p><p><strong>应用程序可以使用此参数将上下文信息传递给回调函数</strong>。</p><h3 id="1-15-函数-hal-gpio-status-t-HAL-GpioGetTriggerMode-hal-gpio-handle-t-gpioHandle-hal-gpio-interrupt-trigger-t-gpioTrigger"><a href="#1-15-函数-hal-gpio-status-t-HAL-GpioGetTriggerMode-hal-gpio-handle-t-gpioHandle-hal-gpio-interrupt-trigger-t-gpioTrigger" class="headerlink" title="1.15 函数 hal_gpio_status_t HAL_GpioGetTriggerMode(hal_gpio_handle_t gpioHandle, hal_gpio_interrupt_trigger_t *gpioTrigger)"></a>1.15 函数 hal_gpio_status_t HAL_GpioGetTriggerMode(hal_gpio_handle_t gpioHandle, hal_gpio_interrupt_trigger_t *gpioTrigger)</h3><p>**<u>==该函数用于获取某个GPIO引脚的中断触发方式==</u>**。</p><p>该函数有两个参数：gpioHandle 和 gpioTrigger。 </p><ul><li>gpioHandle是GPIO引脚的句柄，用于标识GPIO引脚。</li><li>gpioTrigger 是一个<strong>指向 <code>hal_gpio_interrupt_trigger_t</code> 类型变量的指针，将用于返回 GPIO 引脚的中断触发模式</strong>。</li></ul><p>该函数首先检查 gpioHandle 参数是否有效。然后它将 gpioHandle 参数转换为指向 hal_gpio_state_t 结构的指针，该结构是 GPIO 驱动程序的内部状态结构。</p><p>**<u>==然后该函数检查 GPIO 引脚是否配置为输入引脚，如果不是，则返回错误==</u>**。 </p><p>最后，**<u>==该函数从 <code>hal_gpio_state_t</code> 结构中获取 GPIO 引脚的中断触发模式，并将其存储在 gpioTrigger 参数中==</u>**。</p><p>如果函数成功完成，它会返回 kStatus_HAL_GpioSuccess。</p><h3 id="1-16-函数-hal-gpio-status-t-HAL-GpioSetTriggerMode-hal-gpio-handle-t-gpioHandle-hal-gpio-interrupt-trigger-t-gpioTrigger"><a href="#1-16-函数-hal-gpio-status-t-HAL-GpioSetTriggerMode-hal-gpio-handle-t-gpioHandle-hal-gpio-interrupt-trigger-t-gpioTrigger" class="headerlink" title="1.16 函数 hal_gpio_status_t HAL_GpioSetTriggerMode(hal_gpio_handle_t gpioHandle, hal_gpio_interrupt_trigger_t gpioTrigger)"></a>1.16 函数 hal_gpio_status_t HAL_GpioSetTriggerMode(hal_gpio_handle_t gpioHandle, hal_gpio_interrupt_trigger_t gpioTrigger)</h3><p>此函数设置 GPIO 引脚的中断触发模式。</p><p>它接受 GPIO 引脚的句柄，以及所需的中断触发模式。</p><ol><li>该函数首先检查引脚的方向是否未设置为输出，**<u><em>因为中断触发只能用于输入引脚</em></u>**。</li><li>然后它将给定的触发模式映射到硬件平台的相应中断配置值。**<u>它设置 GPIO 引脚的触发模式，并在 NVIC（嵌套向量中断控制器）中启用相应的中断</u>**，优先级为 <code>HAL_GPIO_ISR_PRIORITY</code>（可能在代码库的其他地方定义）。</li><li>最后，它返回一个状态代码，指示操作是成功还是遇到错误。</li></ol><h3 id="1-17-函数-hal-gpio-status-t-HAL-GpioWakeUpSetting-hal-gpio-handle-t-gpioHandle-uint8-t-enable"><a href="#1-17-函数-hal-gpio-status-t-HAL-GpioWakeUpSetting-hal-gpio-handle-t-gpioHandle-uint8-t-enable" class="headerlink" title="1.17 函数 hal_gpio_status_t HAL_GpioWakeUpSetting(hal_gpio_handle_t gpioHandle, uint8_t enable)"></a>1.17 函数 hal_gpio_status_t HAL_GpioWakeUpSetting(hal_gpio_handle_t gpioHandle, uint8_t enable)</h3><p><strong><u>==该函数是 GPIO 驱动程序的一部分，用于启用/禁用 GPIO 引脚的唤醒功能。==</u></strong></p><p>当设备处于低功耗模式时，如果特定 GPIO 引脚上的唤醒功能已启用，则它可以被该引脚上的信号唤醒。 </p><p>该函数有两个参数，一个 GPIO 句柄和一个启用标志。 </p><blockquote><p>GPIO 句柄用于标识要配置的特定 GPIO 引脚，而启用标志用于指定是启用还是禁用唤醒功能。 </p></blockquote><ol><li>该函数首先断言 GPIO 句柄不为 NULL。</li><li>**<u>然后检查GPIO引脚方向是否输出。如果输出方向，则返回错误</u>**。</li><li>然后它检查启用标志是否为 0，这意味着禁用唤醒功能。如果启用标志为 0，则返回错误。否则，它返回成功。</li></ol><p>总的来说，该函数用于配置GPIO引脚的唤醒功能，确保输入参数有效。</p><h3 id="1-18-函数-hal-gpio-status-t-HAL-GpioEnterLowpower-hal-gpio-handle-t-gpioHandle"><a href="#1-18-函数-hal-gpio-status-t-HAL-GpioEnterLowpower-hal-gpio-handle-t-gpioHandle" class="headerlink" title="1.18 函数 hal_gpio_status_t HAL_GpioEnterLowpower(hal_gpio_handle_t gpioHandle)"></a>1.18 函数 hal_gpio_status_t HAL_GpioEnterLowpower(hal_gpio_handle_t gpioHandle)</h3><p><code>HAL_GpioEnterLowpower</code> 的实现似乎是一个placeholder占位符函数，它返回<code>kStatus_HAL_GpioSuccess</code>而不执行任何实际操作。</p><p><strong><u>==此函数很可能旨在由 HAL 库的用户实现，以提供特定于其应用程序的低功耗功能。==</u></strong></p><h3 id="1-19-函数-hal-gpio-status-t-HAL-GpioExitLowpower-hal-gpio-handle-t-gpioHandle"><a href="#1-19-函数-hal-gpio-status-t-HAL-GpioExitLowpower-hal-gpio-handle-t-gpioHandle" class="headerlink" title="1.19 函数 hal_gpio_status_t HAL_GpioExitLowpower(hal_gpio_handle_t gpioHandle)"></a>1.19 函数 hal_gpio_status_t HAL_GpioExitLowpower(hal_gpio_handle_t gpioHandle)</h3><p>**<u>==此函数负责在退出低功耗模式后将 GPIO 引脚恢复为之前的配置==</u>**。</p><p>它以一个 GPIO 句柄作为输入并返回一个状态代码，指示操作是否成功。 </p><ul><li>该函数首先断言 GPIO 句柄有效。</li><li>然后它从句柄中检索 GPIO 状态，并使用引脚方向（输入或输出）和默认值 0 初始化一个新的 GPIO 引脚配置对象。 <ul><li>如果之前将引脚配置为输出，则新配置对象中的引脚方向将设置为输出。</li></ul></li><li>然后，该函数使用 <code>GPIO_PinInit</code> 函数使用新配置初始化 GPIO 引脚。 <ul><li>如果该引脚之前被配置为输入，则该函数调用 <code>HAL_GpioSetTriggerMode</code> 函数来**<u>恢复进入低功耗模式之前设置的中断触发模式</u>**。</li></ul></li><li>最后，函数返回一个状态码，表示操作成功。</li></ul><h2 id="2-fsl-adapter-gpio-h"><a href="#2-fsl-adapter-gpio-h" class="headerlink" title="2.  fsl_adapter_gpio.h"></a>2.  fsl_adapter_gpio.h</h2><h3 id="2-1-引言"><a href="#2-1-引言" class="headerlink" title="2.1. 引言"></a>2.1. 引言</h3><p>这是用于 GPIO（通用输入/输出）接口的 HAL（硬件抽象层）头文件的开头。它从许可证和标题保护开始。 </p><ul><li>header包括 <code>fsl_common.h</code>，它是在不同 SDK（软件开发工具包）组件之间共享的通用实用函数、结构和宏的集合。</li><li>此外，如果定义了 <code>SDK_OS_FREE_RTOS</code>，它会包含 <code>FreeRTOS.h</code>，这是 FreeRTOS 操作系统的头文件。 </li><li>header guard 定义为 <code>HAL_GPIO_H</code> 以防止多次包含同一头文件。</li></ul><p>头文件为 GPIO 适配器提供定义和结构，它是位于供应商 (NXP) 提供的低级 GPIO 驱动程序之上的抽象层。 该文件提供了以下定义： </p><ul><li>GPIO适配器版本 </li><li>GPIO 冲突检查使能 </li><li>GPIO适配器句柄大小 </li><li>GPIO句柄定义宏 </li><li>GPIO 适配器 ISR 优先级 </li><li>GPIO 句柄类型 (hal_gpio_handle_t) </li><li>GPIO回调函数类型(hal_gpio_callback_t) </li><li>GPIO 中断触发类型 (hal_gpio_interrupt_trigger_t) </li><li>GPIO 状态代码 (hal_gpio_status_t) </li><li>GPIO 方向类型 (hal_gpio_direction_t) </li><li>GPIO 引脚配置结构 (hal_gpio_pin_config_t)</li></ul><p>这个头文件定义了 GPIO 适配器，它是一个抽象 GPIO 接口的硬件特定细节的驱动程序。驱动程序提供 API 来配置和控制设备的 GPIO 引脚，例如**<u>设置引脚的方向、读取或写入其值以及在引脚上启用中断</u>**。 该文件以一些标准 C 语言定义开头，包括 GPIO 适配器句柄、回调函数、中断触发器、状态和方向的类型定义。这些类型在整个 GPIO 适配器驱动程序 API 中使用，以提供清晰一致的接口。 </p><p>该文件还定义了一些宏，包括 GPIO 适配器驱动程序的版本号、GPIO 适配器句柄的大小以及启用或禁用 GPIO 冲突检查的标志。 最后，该文件包括 <code>fsl_common.h</code> 头文件，它提供了在 Freescale/NXP SDK 软件中使用的通用宏和定义，以及 <code>FreeRTOS.h</code> 头文件，它为正在使用的 FreeRTOS 操作系统提供 API。</p><p>这是 GPIO（通用输入/输出）适配器的头文件，用于配置和控制MCU上的 GPIO 引脚。 该文件定义了几种类型，包括 <code>hal_gpio_handle_t</code>、<code>hal_gpio_callback_t</code>、<code>hal_gpio_interrupt_trigger_t</code>、<code>hal_gpio_status_t</code>、<code>hal_gpio_direction_t </code>和 <code>hal_gpio_pin_config_t</code>。 </p><ul><li><code>hal_gpio_handle_t</code>是指向GPIO适配器句柄的指针，</li><li><code>hal_gpio_callback_t</code>是用于回调的函数指针，</li><li><code>hal_gpio_interrupt_trigger_t</code>定义了中断触发器，</li><li><code>hal_gpio_status_t</code>定义了GPIO适配器的状态，</li><li><code>hal_gpio_direction_t</code>定义了GPIO引脚的方向，</li><li><code>hal_gpio_pin_config_t</code>是一个保存配置的结构GPIO 引脚的设置。</li></ul><p>头文件还包含宏，例如 </p><ul><li><code>FSL_GPIO_ADAPTER_VERSION</code> 指示驱动程序的版本，<code>HAL_GPIO_CONFLICT_CHECK_ENABLE</code> 启用/禁用 GPIO 冲突检查，以及</li><li><code>HAL_GPIO_HANDLE_SIZE </code>定义 GPIO 适配器句柄的大小。 </li><li>此外，头文件定义了一个宏 <code>GPIO_HANDLE_DEFINE</code> 来定义一个 4 字节对齐的 GPIO 句柄</li><li>和一个宏 <code>HAL_GPIO_ISR_PRIORITY</code> 来定义 GPIO ISR（中断服务程序）的优先级。</li></ul><h3 id="2-2-预先初始化引脚-void-HAL-GpioPreInit-void"><a href="#2-2-预先初始化引脚-void-HAL-GpioPreInit-void" class="headerlink" title="2.2 预先初始化引脚 void HAL_GpioPreInit(void)"></a>2.2 预先初始化引脚 void HAL_GpioPreInit(void)</h3><p>此函数初始化位于内存的 <code>.bss</code> 部分中的静态变量。这通常由 IDE 自动完成，但如果在自动清理 <code>.bss</code> 部分之前使用 GPIO 适配器，则可以使用此功能。 用户通常不需要调用此 API。代码注释中提供了一个示例来演示如何使用它。</p><ul><li>首先，调用 HAL_GpioPreInit() 函数，</li><li>然后使用 GPIO_HANDLE_DEFINE 宏定义 GPIO 句柄。</li><li>然后，使用所需的 GPIO 引脚配置定义并初始化 hal_gpio_pin_config_t 结构。</li><li>最后，调用 HAL_GpioInit() 函数以使用先前定义的 GPIO 句柄以指定配置初始化 GPIO 引脚。</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HAL_GpioPreInit();</span><br><span class="line">GPIO_HANDLE_DEFINE(g_GpioHandle);</span><br><span class="line"><span class="type">hal_gpio_pin_config_t</span> config;</span><br><span class="line">    config.direction = kHAL_GpioDirectionOut;</span><br><span class="line">    config.port = <span class="number">0</span>;</span><br><span class="line">    config.pin = <span class="number">0</span>;</span><br><span class="line">    config.level = <span class="number">0</span>;</span><br><span class="line">HAL_GpioInit((<span class="type">hal_gpio_handle_t</span>)g_GpioHandle, &amp;config);</span><br></pre></td></tr></tbody></table></figure><h3 id="2-3-初始化-hal-gpio-status-t-HAL-GpioInit-hal-gpio-handle-t-gpioHandle-hal-gpio-pin-config-t-pinConfig"><a href="#2-3-初始化-hal-gpio-status-t-HAL-GpioInit-hal-gpio-handle-t-gpioHandle-hal-gpio-pin-config-t-pinConfig" class="headerlink" title="2.3 初始化 hal_gpio_status_t HAL_GpioInit(hal_gpio_handle_t gpioHandle, hal_gpio_pin_config_t *pinConfig);"></a>2.3 初始化 hal_gpio_status_t HAL_GpioInit(hal_gpio_handle_t gpioHandle, hal_gpio_pin_config_t *pinConfig);</h3><p>这是 GPIO（通用输入/输出）模块中的一个函数，它使用**<u>==用户定义的设置初始化 GPIO 实例==</u>**。该函数有两个参数： </p><ul><li>gpioHandle：指向调用者分配的大小为<code>HAL_GPIO_HANDLE_SIZE</code>的内存空间的指针。句柄应该是 4 字节对齐的。用户可以通过两种方式定义句柄：<ul><li>使用 <code>GPIO_HANDLE_DEFINE(gpioHandle) </code></li><li>或 <code>uint32_t gpioHandle[((HAL_GPIO_HANDLE_SIZE + sizeof(uint32_t) - 1U) / sizeof(uint32_t))]</code></li></ul></li><li><code>pinConfig</code>：指向 <code>hal_gpio_pin_config_t</code> 类型的用户定义配置结构的指针，**<u>该结构保存 GPIO 的配置。该结构有四个字段</u>**： <ul><li>direction：GPIO的方向，输出可以设置为<code>kHAL_GpioDirectionOut</code>，输入可以设置为<code>kHAL_GpioDirectionIn</code>。 </li><li>port：GPIO 端口号。 </li><li>pin：GPIO 引脚号。 </li><li>level：**<u>GPIO的初始值，可设置为0或1</u>**。</li></ul></li><li>该函数返回以下状态代码之一： <ul><li>kStatus_HAL_GpioError：初始化 GPIO 时发生错误。 </li><li>kStatus_HAL_GpioPinConflict：pinConfig 传递的pin 和port 对已经初始化，所以conflict。</li><li>kStatus_HAL_GpioSuccess：GPIO 初始化成功。</li></ul></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GPIO_HANDLE_DEFINE(g_GpioHandle);</span><br><span class="line"><span class="type">hal_gpio_pin_config_t</span> config;</span><br><span class="line">config.direction = kHAL_GpioDirectionOut;</span><br><span class="line">config.port = <span class="number">0</span>;</span><br><span class="line">config.pin = <span class="number">0</span>;</span><br><span class="line">config.level = <span class="number">0</span>;</span><br><span class="line">HAL_GpioInit((<span class="type">hal_gpio_handle_t</span>)g_GpioHandle, &amp;config);</span><br></pre></td></tr></tbody></table></figure><h3 id="2-4-取消初始化-HAL-GpioDeinit-hal-gpio-handle-t-gpioHandle"><a href="#2-4-取消初始化-HAL-GpioDeinit-hal-gpio-handle-t-gpioHandle" class="headerlink" title="2.4 取消初始化 HAL_GpioDeinit(hal_gpio_handle_t gpioHandle)"></a>2.4 取消初始化 HAL_GpioDeinit(hal_gpio_handle_t gpioHandle)</h3><p><code>HAL_GpioDeinit</code> 函数用于取消初始化 GPIO 实例。**<u>==它禁用触发模式==</u>**。 </p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">hal_gpio_status_t</span> <span class="title function_">HAL_GpioDeinit</span><span class="params">(<span class="type">hal_gpio_handle_t</span> gpioHandle)</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>gpioHandle：GPIO句柄指针。句柄应该是 4 字节对齐的，因为某些设备不支持未对齐的访问。</li></ul><p>如果 GPIO 去初始化成功，该函数返回 kStatus_HAL_GpioSuccess。</p><h3 id="2-5-获取输入引脚状态-HAL-GpioGetInput"><a href="#2-5-获取输入引脚状态-HAL-GpioGetInput" class="headerlink" title="2.5 获取输入引脚状态 HAL_GpioGetInput()"></a>2.5 获取输入引脚状态 HAL_GpioGetInput()</h3><p>此函数用于获取输入 GPIO 引脚的当前状态。通过 pinState 指针参数读取并返回引脚状态。 这是一个示例用法：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GPIO_HANDLE_DEFINE(g_GpioHandle);</span><br><span class="line"><span class="type">uint8_t</span> pinState;</span><br><span class="line">HAL_GpioInit((<span class="type">hal_gpio_handle_t</span>)g_GpioHandle, &amp;config);</span><br><span class="line">HAL_GpioGetInput((<span class="type">hal_gpio_handle_t</span>)g_GpioHandle, &amp;pinState);</span><br></pre></td></tr></tbody></table></figure><p><strong>==<u>在此示例中，已使用 <code>HAL_GpioInit() </code>初始化 GPIO 引脚，然后使用 <code>HAL_GpioGetInput() </code>读取引脚的当前状态。引脚的当前状态通过 <code>pinState</code> 指针参数返回。</u>==</strong></p><h3 id="2-6-设置输出电平HAL-GpioSetOutput"><a href="#2-6-设置输出电平HAL-GpioSetOutput" class="headerlink" title="2.6 设置输出电平HAL_GpioSetOutput"></a>2.6 设置输出电平HAL_GpioSetOutput</h3><p>这是 <code>HAL_GpioSetOutput</code> 函数的函数定义。此函数**<u>==将 GPIO 引脚的电压电平设置为指定值==</u>**。下面简单解释一下参数和返回值： </p><ul><li>gpioHandle：这是一个指向GPIO句柄对象的指针，表示设备上的一个特定的GPIO引脚。句柄应该是 4 字节对齐的，以确保正确的内存访问。 </li><li>pinState：这是一个 8 位无符号整数，表示 GPIO 引脚的所需电压电平。值为 0 表示低电压电平，而值为 1 表示高电压电平。 </li><li>返回值：该函数返回一个hal_gpio_status_t类型的值，代表操作成功或失败。如果操作成功，函数返回 kStatus_HAL_GpioSuccess。</li></ul><h3 id="2-7-获取Pin中断触发模式-HAL-GpioGetTriggerMode"><a href="#2-7-获取Pin中断触发模式-HAL-GpioGetTriggerMode" class="headerlink" title="2.7 获取Pin中断触发模式 HAL_GpioGetTriggerMode"></a>2.7 获取Pin中断触发模式 HAL_GpioGetTriggerMode</h3><p>函数 <code>HAL_GpioGetTriggerMode</code> **<u>==获取引脚中断触发模式==</u>**。</p><p>触发模式由枚举类型<code>hal_gpio_interrupt_trigger_t</code>表示，可以是以下值之一: </p><ul><li>kHAL_GpioInterruptTriggerLowLevel：低电平触发中断 </li><li>kHAL_GpioInterruptTriggerHighLevel：高电平触发中断 </li><li>kHAL_GpioInterruptTriggerRisingEdge：上升沿触发中断 </li><li>kHAL_GpioInterruptTriggerFallingEdge：下降沿触发中断 </li><li>kHAL_GpioInterruptTriggerEitherEdge：在任一边沿触发中断</li></ul><p>**<u>==如果引脚配置为输出，函数返回 kStatus_HAL_GpioError==</u>**。 </p><p>该函数有两个参数： </p><ul><li>gpioHandle：GPIO句柄指针。 </li><li>gpioTrigger：保存管脚触发模式值的指针。</li></ul><p>该函数返回以下状态代码之一： </p><ul><li>kStatus_HAL_GpioSuccess：引脚触发模式已成功检索。 </li><li>kStatus_HAL_GpioError：引脚配置为输出。</li></ul><h3 id="2-8-设置触发模式-HAL-GpioSetTriggerMode"><a href="#2-8-设置触发模式-HAL-GpioSetTriggerMode" class="headerlink" title="2.8 设置触发模式 HAL_GpioSetTriggerMode"></a>2.8 设置触发模式 HAL_GpioSetTriggerMode</h3><p>HAL_Gpio* 函数是硬件抽象层 (HAL) 库的一部分，用于与微控制器上的 GPIO（通用输入/输出）引脚进行交互。 GPIO 引脚可用于多种用途，例如控制 LED 或读取按钮按下情况。 </p><ul><li>HAL_GpioPreInit() 函数用于初始化位于 .bss 部分的静态变量。该变量将用于存储 GPIO 引脚的配置信息。通常不需要此功能，仅在某些情况下使用，例如在 .bss 部分被 IDE 自动清理之前使用 GPIO 适配器时。 </li><li>HAL_GpioInit() 函数使用 GPIO 句柄和用户配置结构初始化 GPIO 实例。用户可以配置配置结构来设置引脚方向（输入或输出）、端口号、引脚号和初始引脚电平。 gpioHandle参数是一个指向调用者分配的内存空间的指针，用于存储GPIO实例的信息。 </li><li>HAL_GpioDeinit() 函数通过禁用触发模式来取消初始化 GPIO 实例。当不再需要 GPIO 引脚时，应调用此函数。 </li><li>HAL_GpioGetInput() 函数获取输入 GPIO 引脚的电压电平。电压电平在 pinState 参数中返回。 </li><li>HAL_GpioSetOutput() 函数设置输出 GPIO 引脚的电压电平。所需的电压电平在 pinState 参数中传递。 </li><li>HAL_GpioGetTriggerMode() 函数获取 GPIO 引脚的中断触发模式。触发模式决定了是什么导致在引脚上产生中断，例如上升沿或下降沿。触发模式在 gpioTrigger 参数中返回。 </li><li>HAL_GpioSetTriggerMode() 函数设置 GPIO 引脚的中断触发模式。所需的触发模式在 gpioTrigger 参数中传递。</li></ul><h3 id="2-9-HAL-GpioInstallCallback"><a href="#2-9-HAL-GpioInstallCallback" class="headerlink" title="2.9 HAL_GpioInstallCallback()"></a>2.9 HAL_GpioInstallCallback()</h3><p>该函数用于**<u>为GPIO模块安装一个回调函数及其对应的参数</u>**。</p><p>当引脚状态中断发生时，驱动会通过调用已安装的回调函数通知上层。 GPIO管脚状态可以通过回调函数内部调用函数<code>HAL_GpioGetInput()</code>获取。 该函数采用三个参数： </p><ul><li>gpioHandle：GPIO句柄指针。 </li><li>callback：要安装的回调函数。 </li><li>callbackParam：回调函数的参数。</li></ul><p>该函数返回一个状态代码，指示回调是否已成功安装。如果成功，返回值为 kStatus_HAL_GpioSuccess。</p><h3 id="2-10-HAL-GpioWakeUpSetting"><a href="#2-10-HAL-GpioWakeUpSetting" class="headerlink" title="2.10 HAL_GpioWakeUpSetting()"></a>2.10 HAL_GpioWakeUpSetting()</h3><p><code>HAL_GpioWakeUpSetting</code> 函数**<u>==启用或禁用 GPIO 唤醒功能==</u>**。</p><p>此功能允许系统**<u>通过 GPIO 引脚状态的变化从低功耗模式唤醒</u>**。 </p><p>该函数采用 gpioHandle 参数，该参数是指向 GPIO 句柄的指针。句柄应该是 4 字节对齐的，因为某些设备不支持未对齐的访问。 </p><p>enable 参数是一个布尔值，指示是启用还是禁用唤醒功能。值 1 启用该功能，而值 0 禁用它。 </p><p>该函数返回一个 hal_gpio_status_t 状态码，其中 kStatus_HAL_GpioSuccess 表示成功，kStatus_HAL_GpioError 表示发生错误。</p><h3 id="2-11-HAL-GpioEnterLowpower"><a href="#2-11-HAL-GpioEnterLowpower" class="headerlink" title="2.11 HAL_GpioEnterLowpower()"></a>2.11 HAL_GpioEnterLowpower()</h3><p>根据提供的函数定义，函数 HAL_GpioEnterLowpower() 用于准备进入低功耗。但是，函数定义中并未指定为低功耗准备所采取的确切步骤。该**<u>==函数很可能会执行必要的步骤将 GPIO 模块置于低功耗状态==</u>**，例如禁用未使用的引脚或将时钟频率设置为较低的值。</p><p>在定义此函数的 HAL 库的文档或源代码中可能会提供更多信息。</p><h3 id="2-12-HAL-GpioExitLowpower"><a href="#2-12-HAL-GpioExitLowpower" class="headerlink" title="2.12 HAL_GpioExitLowpower()"></a>2.12 HAL_GpioExitLowpower()</h3><p>这两个函数 HAL_GpioEnterLowpower 和 HAL_GpioExitLowpower 似乎是用于管理低功耗的更大系统的一部分。 GPIO 模块用于控制系统的唤醒行为，这些函数可能分别用于准备 GPIO 模块进入低功耗模式和从低功耗模式恢复。 </p><p>HAL_GpioEnterLowpower 可以执行诸如禁用 GPIO 中断、将 GPIO 引脚设置为低功耗状态或降低 GPIO 模块的时钟频率以节省电量等操作。 </p><p>HAL_GpioExitLowpower 可能会执行 HAL_GpioEnterLowpower 的反向操作，例如恢复 GPIO 中断，将 GPIO 引脚恢复到之前的状态，或者提高 GPIO 模块的时钟频率以恢复正常操作。 </p><p>总体而言，这些功能似乎是用于管理功耗和唤醒行为的更大系统的一部分，而不是独立的 GPIO 功能。</p>]]></content>
    
    
    <summary type="html">解读NXP的GPIO Adapter代码（.c &amp; .h）</summary>
    
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/categories/NXP/"/>
    
    <category term="嵌入式基础" scheme="https://dustofstars.github.io/categories/NXP/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="NXP" scheme="https://dustofstars.github.io/tags/NXP/"/>
    
    <category term="GPIO" scheme="https://dustofstars.github.io/tags/GPIO/"/>
    
  </entry>
  
</feed>
